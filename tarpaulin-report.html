<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <style>html, body {
  margin: 0;
  padding: 0;
}

.app {
  margin: 10px;
  padding: 0;
}

.files-list {
  margin: 10px 0 0;
  width: 100%;
  border-collapse: collapse;
}
.files-list__head {
  border: 1px solid #999;
}
.files-list__head > tr > th {
  padding: 10px;
  border: 1px solid #999;
  text-align: left;
  font-weight: normal;
  background: #ddd;
}
.files-list__body {
}
.files-list__file {
  cursor: pointer;
}
.files-list__file:hover {
  background: #ccf;
}
.files-list__file > td {
  padding: 10px;
  border: 1px solid #999;
}
.files-list__file > td:first-child::before {
  content: '\01F4C4';
  margin-right: 1em;
}
.files-list__file_low {
  background: #fcc;
}
.files-list__file_medium {
  background: #ffc;
}
.files-list__file_high {
  background: #cfc;
}
.files-list__file_folder > td:first-child::before {
  content: '\01F4C1';
  margin-right: 1em;
}

.file-header {
  border: 1px solid #999;
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.file-header__back {
  margin: 10px;
  cursor: pointer;
  flex-shrink: 0;
  flex-grow: 0;
  text-decoration: underline;
  color: #338;
}

.file-header__name {
  margin: 10px;
  flex-shrink: 2;
  flex-grow: 2;
}

.file-header__stat {
  margin: 10px;
  flex-shrink: 0;
  flex-grow: 0;
}

.file-content {
  margin: 10px 0 0;
  border: 1px solid #999;
  padding: 10px;
}

.code-line {
  margin: 0;
  padding: 0.3em;
  height: 1em;
}
.code-line_covered {
  background: #cfc;
}
.code-line_uncovered {
  background: #fcc;
}
</style>
</head>
<body>
    <div id="root"></div>
    <script>
        var data = {"files":[{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","reql-macros","src","func","mod.rs"],"content":"#[cfg(test)]\nmod tests;\n\nuse proc_macro2::{TokenStream, TokenTree};\nuse quote::quote;\nuse std::iter::FromIterator;\nuse syn::Ident;\n\n#[derive(Debug)]\npub(super) struct Func {\n    mv: Option\u003cIdent\u003e,\n    args: Vec\u003cIdent\u003e,\n    body: TokenStream,\n}\n\nimpl Func {\n    pub(super) fn new(input: TokenStream) -\u003e Self {\n        let mut iter = input.into_iter();\n        let mv = iter.next().map(first).unwrap();\n        if mv.is_some() {\n            iter.next().filter(is_pipe).unwrap();\n        }\n        let mut args = Vec::new();\n        while let Some(token) = iter.next() {\n            if is_pipe(\u0026token) {\n                break;\n            }\n            args.push(ident(token));\n            let token = iter.next().unwrap();\n            if is_pipe(\u0026token) {\n                break;\n            }\n            assert_comma(\u0026token);\n        }\n        let body = TokenStream::from_iter(iter);\n        Self { mv, args, body }\n    }\n\n    pub(super) fn process(self) -\u003e TokenStream {\n        let Self { mv, args, body } = self;\n        let mut header = quote!(#mv |);\n        let mut params = TokenStream::new();\n        let func_args = args.len();\n        for (i, arg) in args.into_iter().enumerate() {\n            let var = quote!(Command::var(*ids.get(#i).unwrap()));\n            if i == func_args - 1 {\n                header.extend(quote!(#arg: Command));\n                params.extend(quote!(#var));\n            } else {\n                header.extend(quote!(#arg: Command, ));\n                params.extend(quote!(#var, ));\n            }\n        }\n        header.extend(quote!(|));\n        let closure = quote!(#header #body);\n        quote!({\n            let closure = #closure;\n            let mut ids = Vec::with_capacity(#func_args);\n            for _ in 0..#func_args {\n                let id = var_counter();\n                ids.push(id);\n            }\n            let func = closure(#params);\n            Func::new(ids, func)\n        })\n    }\n}\n\nfn first(token: TokenTree) -\u003e Option\u003cIdent\u003e {\n    if is_pipe(\u0026token) {\n        return None;\n    }\n    match token {\n        TokenTree::Ident(ident) if ident == \"move\" =\u003e Some(ident),\n        _ =\u003e panic!(\"invalid closure\"),\n    }\n}\n\nfn ident(token: TokenTree) -\u003e Ident {\n    match token {\n        TokenTree::Ident(ident) =\u003e ident,\n        _ =\u003e panic!(\"invalid closure\"),\n    }\n}\n\nfn is_pipe(token: \u0026TokenTree) -\u003e bool {\n    matches!(token, TokenTree::Punct(punct) if punct.as_char() == '|')\n}\n\nfn assert_comma(token: \u0026TokenTree) {\n    match token {\n        TokenTree::Punct(punct) if punct.as_char() == ',' =\u003e {}\n        _ =\u003e panic!(\"invalid closure\"),\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","reql-macros","src","func","tests.rs"],"content":"use super::*;\n\n#[test]\nfn with_move() {\n    Func::new(quote!(move |doc| {\n        doc.get_field(\"author\").bracket(\"name\")\n    }))\n    .process();\n}\n\n#[test]\nfn with_no_arg() {\n    Func::new(quote!(|| r.expr(\"Hello world!\"))).process();\n}\n\n#[test]\nfn with_one_arg() {\n    Func::new(quote!(|doc| { doc.get_field(\"author\").bracket(\"name\") })).process();\n}\n\n#[test]\nfn with_multiple_args() {\n    Func::new(quote!(|with, multiple, args| r.expr(with, multiple, args))).process();\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","reql-macros","src","geometry.rs"],"content":"use quote::quote;\nuse syn::{parse_macro_input, DeriveInput};\n\npub(super) fn parse(input: proc_macro::TokenStream) -\u003e proc_macro::TokenStream {\n    let DeriveInput { ident, .. } = parse_macro_input!(input);\n\n    let output = quote! {\n        impl Geometry for #ident {}\n    };\n\n    output.into()\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","reql-macros","src","lib.rs"],"content":"use func::Func;\nuse proc_macro::TokenStream;\n\nmod geometry;\nmod func;\nmod options;\n\n#[proc_macro]\npub fn func(input: TokenStream) -\u003e TokenStream {\n    Func::new(input.into()).process().into()\n}\n\n#[proc_macro_derive(CommandOptions)]\npub fn command_opts(input: TokenStream) -\u003e TokenStream {\n    options::parse(input)\n}\n\n#[proc_macro_derive(Geometry)]\npub fn make_document(input: TokenStream) -\u003e TokenStream {\n    geometry::parse(input)\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","reql-macros","src","options.rs"],"content":"use proc_macro2::TokenStream;\nuse quote::{quote, ToTokens};\nuse syn::{parse_macro_input, Data, DeriveInput, Fields, GenericArgument, PathArguments, Type};\n\npub(super) fn parse(input: proc_macro::TokenStream) -\u003e proc_macro::TokenStream {\n    let input = parse_macro_input!(input as DeriveInput);\n\n    let mut methods = TokenStream::new();\n\n    match input.data {\n        Data::Struct(data) =\u003e match data.fields {\n            Fields::Named(fields) =\u003e {\n                for field in fields.named {\n                    let name = field.ident;\n                    let mut generics = TokenStream::new();\n                    let mut where_clause = TokenStream::new();\n                    let mut value = quote!(#name);\n                    let mut param = param(\u0026field.ty);\n\n                    if param.is_cow || param.is_db {\n                        generics = quote!(\u003cT\u003e);\n                        where_clause = quote!(where T: crate::cmd::StaticString);\n                        param.ty = quote!(T);\n                        value = quote!(#name.static_string());\n                    }\n\n                    if param.is_db {\n                        value = quote!(Db(#value))\n                    }\n\n                    if param.is_option {\n                        value = quote!(Some(#value))\n                    }\n\n                    let ty = param.ty;\n\n                    methods.extend(quote! {\n                        pub fn #name #generics(mut self, #name: #ty) -\u003e Self #where_clause {\n                            self.#name = #value;\n                            self\n                        }\n                    });\n                }\n            }\n            _ =\u003e unimplemented!(),\n        },\n        Data::Enum(_) | Data::Union(_) =\u003e unimplemented!(),\n    }\n\n    let name = input.ident;\n    let generics = input.generics;\n\n    let options = quote! {\n        impl #generics #name #generics {\n            pub fn new() -\u003e Self {\n                Default::default()\n            }\n\n            #methods\n        }\n    };\n\n    options.into()\n}\n\nstruct Param {\n    ty: TokenStream,\n    is_option: bool,\n    is_cow: bool,\n    is_db: bool,\n}\n\nfn param(typ: \u0026Type) -\u003e Param {\n    if let Type::Path(typ) = typ {\n        if let Some(typ) = typ.path.segments.first() {\n            let mut param = Param {\n                ty: typ.to_token_stream(),\n                is_option: typ.ident == \"Option\",\n                is_cow: typ.ident == \"Cow\",\n                is_db: false,\n            };\n            if !param.is_option {\n                return param;\n            } else if let PathArguments::AngleBracketed(path) = \u0026typ.arguments {\n                if let Some(typ) = path.args.first() {\n                    param.ty = typ.to_token_stream();\n                    if let GenericArgument::Type(Type::Path(typ)) = typ {\n                        if let Some(typ) = typ.path.segments.first() {\n                            param.is_cow = typ.ident == \"Cow\";\n                            param.is_db = typ.ident == \"Db\";\n                        }\n                    }\n                    return param;\n                }\n            }\n        }\n    }\n    unimplemented!()\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","arguments","any_param.rs"],"content":"use serde::Serialize;\n\nuse crate::Command;\n\n#[derive(Debug, Clone)]\npub struct AnyParam(Command);\n\nimpl AnyParam {\n    pub fn new(arg: impl Serialize) -\u003e Self {\n        Self(Command::from_json(arg))\n    }\n}\n\nimpl From\u003cAnyParam\u003e for Command {\n    fn from(param: AnyParam) -\u003e Self {\n        param.0\n    }\n}\n","traces":[{"line":15,"address":[2169840],"length":1,"stats":{"Line":0},"fn_name":"from"},{"line":16,"address":[2169848],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":2},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","arguments","mod.rs"],"content":"use std::{borrow::Cow, collections::HashMap};\n\nuse reql_macros::CommandOptions;\nuse serde::{Deserialize, Serialize};\n\npub use any_param::AnyParam;\npub use return_changes::ReturnChanges;\n\nmod any_param;\nmod return_changes;\n\n#[derive(Debug, Clone, Copy, Eq, PartialEq, Ord, PartialOrd, Hash)]\npub struct Args\u003cT\u003e(pub T);\n\n#[derive(Debug, Clone, Copy, Serialize, Default, PartialEq, PartialOrd, CommandOptions)]\npub struct Permission {\n    /// allows reading the data in tables.\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub read: Option\u003cbool\u003e,\n    /// allows modifying data, including inserting, replacing/updating, and deleting.\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub write: Option\u003cbool\u003e,\n    /// allows a user to open HTTP connections via the [http](crate::r::http)\n    /// command. This permission can only be granted in global scope.\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub connect: Option\u003cbool\u003e,\n    /// allows users to create/drop\n    /// [secondary indexes](https://rethinkdb.com/docs/secondary-indexes/python/)\n    /// on a table and changing the cluster configuration;\n    /// to create and drop tables, if granted on a database;\n    /// and to create and drop databases, if granted globally.\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub config: Option\u003cbool\u003e,\n}\n\n#[derive(Debug, Clone, Copy, Serialize, Deserialize, Eq, PartialEq, Ord, PartialOrd, Hash)]\n#[serde(rename_all = \"lowercase\")]\npub enum Status {\n    Open,\n    Closed,\n}\n\n#[derive(Debug, Clone, Copy, Serialize, Deserialize, Eq, PartialEq, Ord, PartialOrd, Hash)]\n#[serde(rename_all = \"lowercase\")]\npub enum Durability {\n    Hard,\n    Soft,\n}\n\n#[derive(Debug, Clone, Copy, Serialize, Deserialize, Eq, PartialEq, Ord, PartialOrd, Hash)]\n#[serde(rename_all = \"lowercase\")]\npub enum ReadMode {\n    /// returns values that are in memory\n    /// (but not necessarily written to disk)\n    /// on the primary replica.\n    /// This is the default.\n    Single,\n    /// will only return values that are safely committed on disk on a majority of replicas.\n    /// This requires sending a message to every replica on each read,\n    /// so it is the slowest but most consistent.\n    Majority,\n    /// will return values that are in memory on an arbitrarily-selected replica.\n    /// This is the fastest but least consistent.\n    Outdated,\n}\n\n#[derive(Debug, Clone, Copy, Serialize, Deserialize, Eq, PartialEq, Ord, PartialOrd, Hash)]\n#[serde(rename_all = \"lowercase\")]\npub enum Format {\n    Native,\n    Raw,\n}\n\n#[derive(Debug, Clone, Copy, Serialize, Deserialize, Eq, PartialEq, Ord, PartialOrd, Hash)]\n#[serde(rename_all = \"lowercase\")]\npub enum Conflict {\n    Error,\n    Replace,\n    Update,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]\n#[non_exhaustive]\npub enum Replicas {\n    Int(usize),\n    Map {\n        replicas: HashMap\u003cCow\u003c'static, str\u003e, usize\u003e,\n        primary_replica_tag: Cow\u003c'static, str\u003e,\n    },\n}\n\n#[derive(Debug, Clone, Copy, Serialize, Deserialize, Eq, PartialEq, Ord, PartialOrd, Hash)]\n#[serde(rename_all = \"snake_case\")]\npub enum EmergencyRepair {\n    UnsafeRollback,\n    UnsafeRollbackOrErase,\n}\n\n#[derive(Debug, Clone, Copy, Serialize, PartialEq, PartialOrd)]\n#[non_exhaustive]\n#[serde(rename_all = \"lowercase\")]\npub enum IdentifierFormat {\n    Name,\n    Uuid,\n}\n\n#[derive(Debug, Clone, Copy, Serialize, Deserialize, Eq, PartialEq, Ord, PartialOrd, Hash)]\n#[serde(rename_all = \"snake_case\")]\npub enum WaitFor {\n    ReadyForOutdatedReads,\n    ReadyForReads,\n    ReadyForWrites,\n    AllReplicasReady,\n}\n\n#[derive(Debug, Clone, Copy, Serialize, Deserialize, Eq, PartialEq, Ord, PartialOrd, Hash)]\npub enum Unit {\n    #[serde(rename = \"m\")]\n    Meter,\n    #[serde(rename = \"km\")]\n    Kilometer,\n    #[serde(rename = \"mi\")]\n    InternationalMile,\n    #[serde(rename = \"nm\")]\n    NauticalMile,\n    #[serde(rename = \"ft\")]\n    InternationalFoot,\n}\n\n#[derive(Debug, Clone, Copy, Serialize, Deserialize, PartialEq, PartialOrd)]\n#[serde(untagged)]\n#[non_exhaustive]\npub enum Interleave {\n    Bool(bool),\n    FieldName(\u0026'static str),\n    // Function\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","arguments","return_changes.rs"],"content":"use serde::{Deserialize, Serialize, Serializer};\n\n#[derive(Debug, Clone, Copy, Deserialize, PartialEq, PartialOrd)]\n#[non_exhaustive]\npub enum ReturnChanges {\n    Bool(bool),\n    Always,\n}\n\nimpl Serialize for ReturnChanges {\n    fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    where\n        S: Serializer,\n    {\n        match self {\n            Self::Bool(boolean) =\u003e boolean.serialize(serializer),\n            Self::Always =\u003e \"always\".serialize(serializer),\n        }\n    }\n}\n","traces":[{"line":11,"address":[5156112],"length":1,"stats":{"Line":1},"fn_name":"serialize\u003cserde_json::value::ser::Serializer\u003e"},{"line":15,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":16,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":3,"coverable":4},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","add.rs"],"content":"use std::ops::Add;\n\nuse ql2::term::TermType;\nuse serde::Serialize;\n\nuse crate::Command;\n\nimpl\u003cT: AddArg\u003e Add\u003cT\u003e for Command {\n    type Output = Self;\n\n    fn add(self, arg: T) -\u003e Self {\n        Command::new(TermType::Add)\n            .with_arg(arg.into_add_opts())\n            .with_parent(self)\n    }\n}\n\npub trait AddArg {\n    fn into_add_opts(self) -\u003e Command;\n}\n\nimpl\u003cT: Serialize\u003e AddArg for T {\n    fn into_add_opts(self) -\u003e Command {\n        Command::from_json(self)\n    }\n}\n\nimpl AddArg for Command {\n    fn into_add_opts(self) -\u003e Command {\n        self\n    }\n}\n\n// TODO write test\n","traces":[{"line":11,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":12,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":13,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":14,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[2169872],"length":1,"stats":{"Line":1},"fn_name":"into_add_opts"},{"line":30,"address":[2169880],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":6,"coverable":8},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","and.rs"],"content":"use ql2::term::TermType;\n\nuse crate::{arguments::Args, Command};\n\nuse super::CmdOpts;\n\npub(crate) fn new(args: impl AndArg) -\u003e Command {\n    args.into_and_opts().add_to_cmd(Command::new(TermType::And))\n}\n\npub trait AndArg {\n    fn into_and_opts(self) -\u003e CmdOpts;\n}\n\nimpl AndArg for bool {\n    fn into_and_opts(self) -\u003e CmdOpts {\n        CmdOpts::Single(Command::from_json(self))\n    }\n}\n\nimpl AndArg for Command {\n    fn into_and_opts(self) -\u003e CmdOpts {\n        CmdOpts::Single(self)\n    }\n}\n\nimpl\u003cT\u003e AndArg for Args\u003cT\u003e\nwhere\n    T: IntoIterator\u003cItem = bool\u003e,\n{\n    fn into_and_opts(self) -\u003e CmdOpts {\n        let commands = self.0.into_iter().map(Command::from_json).collect();\n\n        CmdOpts::Many(commands)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::Converter;\n    use crate::{args, r, Result};\n\n    #[tokio::test]\n    async fn test_and_ops() -\u003e Result\u003c()\u003e {\n        let conn = r.connection().connect().await?;\n        let data_obtained: bool = r\n            .and(args!([true, true, true]))\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(data_obtained);\n\n        Ok(())\n    }\n}\n","traces":[{"line":7,"address":[5156453,5156208,5156480],"length":1,"stats":{"Line":1},"fn_name":"new\u003creql_rust::arguments::Args\u003c[bool; 3]\u003e\u003e"},{"line":8,"address":[5156261,5156473],"length":1,"stats":{"Line":1},"fn_name":null},{"line":16,"address":[2194592],"length":1,"stats":{"Line":0},"fn_name":"into_and_opts"},{"line":17,"address":[2194624],"length":1,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[2169904],"length":1,"stats":{"Line":0},"fn_name":"into_and_opts"},{"line":23,"address":[2169920],"length":1,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":44,"address":[4767269,4766903,4766864,4767317],"length":1,"stats":{"Line":6},"fn_name":"test_and_ops"},{"line":45,"address":[5205770,5206106,5205420,5205315,5205349,5205581],"length":1,"stats":{"Line":4},"fn_name":null},{"line":46,"address":[5206465,5206536,5206354,5206940,5206997,5206067,5206721,5207034,5207224],"length":1,"stats":{"Line":6},"fn_name":null},{"line":47,"address":[5206013],"length":1,"stats":{"Line":1},"fn_name":null},{"line":48,"address":[5206377,5206495,5205364,5206334,5206664],"length":1,"stats":{"Line":4},"fn_name":null},{"line":49,"address":[5206844],"length":1,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[5207336,5207113],"length":1,"stats":{"Line":1},"fn_name":null},{"line":55,"address":[4767000,4766940,4767280,4766895],"length":1,"stats":{"Line":5},"fn_name":null}],"covered":12,"coverable":17},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","append.rs"],"content":"use ql2::term::TermType;\nuse serde::Serialize;\n\nuse crate::Command;\n\npub(crate) fn new(args: impl AppendArg) -\u003e Command {\n    Command::new(TermType::Append).with_arg(args.into_append_opts())\n}\n\npub trait AppendArg {\n    fn into_append_opts(self) -\u003e Command;\n}\n\nimpl\u003cT\u003e AppendArg for T\nwhere\n    T: Serialize,\n{\n    fn into_append_opts(self) -\u003e Command {\n        Command::from_json(self)\n    }\n}\n\nimpl AppendArg for Command {\n    fn into_append_opts(self) -\u003e Command {\n        self\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::Converter;\n    use crate::{r, Result};\n\n    #[tokio::test]\n    async fn test_append_ops() -\u003e Result\u003c()\u003e {\n        let conn = r.connection().connect().await?;\n        let response: [u8; 6] = r\n            .expr([10, 20, 30, 40, 50])\n            .append(100)\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(response == [10, 20, 30, 40, 50, 100]);\n\n        Ok(())\n    }\n}\n","traces":[{"line":6,"address":[5679797,5679536],"length":1,"stats":{"Line":1},"fn_name":"new\u003ci32\u003e"},{"line":7,"address":[5679564,5679787,5679663],"length":1,"stats":{"Line":2},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":24,"address":[2169984],"length":1,"stats":{"Line":0},"fn_name":"into_append_opts"},{"line":25,"address":[2169992],"length":1,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[2829885,2829737,2829728,2830020,2830319,2829760,2829817],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":36,"address":[2830141,2829875,2829909,2829980,2830330,2830654],"length":1,"stats":{"Line":4},"fn_name":null},{"line":37,"address":[2830644,2831610,2831516,2831573,2831112,2831041,2831297,2831843,2830898,2830930],"length":1,"stats":{"Line":7},"fn_name":null},{"line":38,"address":[2830573],"length":1,"stats":{"Line":1},"fn_name":null},{"line":40,"address":[2831071,2829924,2830910,2830953,2831240],"length":1,"stats":{"Line":4},"fn_name":null},{"line":41,"address":[2831420],"length":1,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[2831950,2831987,2831718],"length":1,"stats":{"Line":2},"fn_name":null},{"line":47,"address":[2831961],"length":1,"stats":{"Line":5},"fn_name":null}],"covered":11,"coverable":14},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","args.rs"],"content":"use ql2::term::TermType;\nuse serde::Serialize;\n\nuse crate::Command;\n\npub(crate) fn new\u003cT, S\u003e(values: T) -\u003e Command\nwhere\n    S: Serialize,\n    T: AsRef\u003c[S]\u003e + Serialize,\n{\n    let args = Command::from_json(values);\n\n    Command::new(TermType::Args).with_arg(args)\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::{prelude::Converter, r, Result};\n\n    #[tokio::test]\n    async fn test_args_ops() -\u003e Result\u003c()\u003e {\n        let conn = r.connection().connect().await?;\n        let data = vec![1, 2, 3];\n        let response: Vec\u003cu8\u003e = r.args(\u0026data).run(\u0026conn).await?.unwrap().parse()?;\n\n        assert!(response == data);\n\n        Ok(())\n    }\n}\n","traces":[{"line":6,"address":[1599061,1598832,1599034],"length":1,"stats":{"Line":1},"fn_name":"new\u003c\u0026alloc::vec::Vec\u003cu8, alloc::alloc::Global\u003e, u8\u003e"},{"line":11,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":13,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":21,"address":[2796855,2797221,2796816,2797269],"length":1,"stats":{"Line":6},"fn_name":"test_args_ops"},{"line":22,"address":[5513683,5514406,5513949,5514138,5513717,5513788],"length":1,"stats":{"Line":4},"fn_name":null},{"line":23,"address":[5514391,5514653],"length":1,"stats":{"Line":2},"fn_name":null},{"line":24,"address":[5514685,5513732,5514736,5515440,5515588],"length":1,"stats":{"Line":3},"fn_name":null},{"line":26,"address":[5515558,5515833,5515870],"length":1,"stats":{"Line":2},"fn_name":null},{"line":28,"address":[2797232,2796847,2796892,2796952],"length":1,"stats":{"Line":5},"fn_name":null}],"covered":9,"coverable":9},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","asc.rs"],"content":"use ql2::term::TermType;\nuse serde::Serialize;\n\nuse crate::prelude::Func;\nuse crate::Command;\n\npub(crate) fn new(args: impl AscArg) -\u003e Command {\n    Command::new(TermType::Asc).with_arg(args.into_asc_opts())\n}\n\npub trait AscArg {\n    fn into_asc_opts(self) -\u003e Command;\n}\n\nimpl\u003cT\u003e AscArg for T\nwhere\n    T: Into\u003cT\u003e + Serialize,\n{\n    fn into_asc_opts(self) -\u003e Command {\n        Command::from_json(self)\n    }\n}\n\nimpl AscArg for Func {\n    fn into_asc_opts(self) -\u003e Command {\n        self.0\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::*;\n    use crate::spec::*;\n    use crate::{args, r, Result};\n\n    #[tokio::test]\n    async fn test_asc_ops() -\u003e Result\u003c()\u003e {\n        let (conn, table, table_name) = set_up(true).await?;\n        let response: Vec\u003cPost\u003e = table\n            .order_by(args!(r.expr(\"view\"), r.asc(\"title\")))\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(response.len() \u003e 1);\n\n        tear_down(conn, \u0026table_name).await\n    }\n}\n","traces":[{"line":7,"address":[5679872,5680154],"length":1,"stats":{"Line":1},"fn_name":"new\u003c\u0026str\u003e"},{"line":8,"address":[5680020,5679915,5680144],"length":1,"stats":{"Line":2},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":25,"address":[2740384],"length":1,"stats":{"Line":0},"fn_name":"into_asc_opts"},{"line":26,"address":[2740392],"length":1,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[1849040,1849079,1849445,1849493],"length":1,"stats":{"Line":6},"fn_name":"test_asc_ops"},{"line":38,"address":[3946275,3946847,3946348,3946669,3947289,3946501],"length":1,"stats":{"Line":4},"fn_name":null},{"line":39,"address":[3948014,3947708,3948485,3948209,3948529,3948760,3947771,3948428,3947937,3947237],"length":1,"stats":{"Line":7},"fn_name":null},{"line":40,"address":[3947495,3947259,3947747,3947778,3947796],"length":1,"stats":{"Line":2},"fn_name":null},{"line":41,"address":[3946369,3947970,3946452,3947846,3948142],"length":1,"stats":{"Line":5},"fn_name":null},{"line":42,"address":[3948332],"length":1,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[3948958,3949019,3948649],"length":1,"stats":{"Line":2},"fn_name":null},{"line":48,"address":[1849456,1849071,1849176,1849116],"length":1,"stats":{"Line":7},"fn_name":null}],"covered":11,"coverable":14},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","avg.rs"],"content":"use ql2::term::TermType;\n\nuse crate::prelude::Func;\nuse crate::Command;\n\npub(crate) fn new(args: impl AvgArg) -\u003e Command {\n    let mut command = Command::new(TermType::Avg);\n\n    if let Some(arg) = args.into_avg_opts() {\n        command = command.with_arg(arg)\n    }\n\n    command\n}\n\npub trait AvgArg {\n    fn into_avg_opts(self) -\u003e Option\u003cCommand\u003e;\n}\n\nimpl AvgArg for () {\n    fn into_avg_opts(self) -\u003e Option\u003cCommand\u003e {\n        None\n    }\n}\n\nimpl AvgArg for \u0026str {\n    fn into_avg_opts(self) -\u003e Option\u003cCommand\u003e {\n        let arg = Command::from_json(self);\n\n        Some(arg)\n    }\n}\n\nimpl AvgArg for Func {\n    fn into_avg_opts(self) -\u003e Option\u003cCommand\u003e {\n        Some(self.0)\n    }\n}\n\nimpl AvgArg for Command {\n    fn into_avg_opts(self) -\u003e Option\u003cCommand\u003e {\n        Some(self)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::Converter;\n    use crate::spec::{set_up, tear_down, Post};\n    use crate::Result;\n\n    #[tokio::test]\n    async fn test_avg_data() -\u003e Result\u003c()\u003e {\n        let data: Vec\u003cu8\u003e = Post::get_many_data().iter().map(|post| post.view).collect();\n        let avg = data.iter().sum::\u003cu8\u003e() as f32 / data.len() as f32;\n        let (conn, table, table_name) = set_up(true).await?;\n        let data_obtained: f32 = table.avg(\"view\").run(\u0026conn).await?.unwrap().parse()?;\n\n        assert!(data_obtained == avg);\n\n        tear_down(conn, table_name.as_str()).await\n    }\n}\n","traces":[{"line":6,"address":[1691840,1692405],"length":1,"stats":{"Line":1},"fn_name":"new\u003c\u0026str\u003e"},{"line":7,"address":[1691886,1691988],"length":1,"stats":{"Line":2},"fn_name":null},{"line":9,"address":[1691996,1692329,1692054],"length":1,"stats":{"Line":3},"fn_name":null},{"line":10,"address":[1692161,1692303],"length":1,"stats":{"Line":2},"fn_name":null},{"line":13,"address":[1692354],"length":1,"stats":{"Line":1},"fn_name":null},{"line":21,"address":[2441376],"length":1,"stats":{"Line":0},"fn_name":"into_avg_opts"},{"line":22,"address":[2839652],"length":1,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[2441392],"length":1,"stats":{"Line":1},"fn_name":"into_avg_opts"},{"line":28,"address":[2441425],"length":1,"stats":{"Line":1},"fn_name":null},{"line":30,"address":[2441436],"length":1,"stats":{"Line":1},"fn_name":null},{"line":35,"address":[2740416],"length":1,"stats":{"Line":0},"fn_name":"into_avg_opts"},{"line":36,"address":[2740432],"length":1,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[2170016],"length":1,"stats":{"Line":0},"fn_name":"into_avg_opts"},{"line":42,"address":[2170032],"length":1,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[1587273,1587683,1587457,1587984,1587365,1587296,1587264],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":54,"address":[1587427,1591104,1591117,1587800],"length":1,"stats":{"Line":4},"fn_name":"{closure#0}"},{"line":55,"address":[1588047],"length":1,"stats":{"Line":1},"fn_name":null},{"line":56,"address":[1588322,1587487,1587640,1588939],"length":1,"stats":{"Line":3},"fn_name":null},{"line":57,"address":[1589151,1588885,1589990,1587591,1589880,1587508],"length":1,"stats":{"Line":5},"fn_name":null},{"line":59,"address":[1590345,1589963],"length":1,"stats":{"Line":1},"fn_name":null},{"line":61,"address":[1590567,1590301,1590627,1590688,1590822,1590443,1587526],"length":1,"stats":{"Line":7},"fn_name":null}],"covered":15,"coverable":21},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","between.rs"],"content":"use std::borrow::Cow;\n\nuse ql2::term::TermType;\nuse reql_macros::CommandOptions;\nuse serde::Serialize;\n\nuse crate::arguments::{Args, Status};\nuse crate::Command;\n\nuse super::CmdOpts;\n\npub(crate) fn new(args: impl BetweenArg) -\u003e Command {\n    let (min_key, max_key, opts) = args.into_between_opts();\n    let min_key: Option\u003cCommand\u003e = min_key.into();\n    let max_key: Option\u003cCommand\u003e = max_key.into();\n\n    Command::new(TermType::Between)\n        .with_arg(min_key.unwrap())\n        .with_arg(max_key.unwrap())\n        .with_opts(opts)\n}\n\npub trait BetweenArg {\n    fn into_between_opts(self) -\u003e (CmdOpts, CmdOpts, BetweenOption);\n}\n\nimpl BetweenArg for Args\u003c(Command, Command)\u003e {\n    fn into_between_opts(self) -\u003e (CmdOpts, CmdOpts, BetweenOption) {\n        (\n            CmdOpts::Single(self.0 .0),\n            CmdOpts::Single(self.0 .1),\n            Default::default(),\n        )\n    }\n}\n\nimpl BetweenArg for Args\u003c(Command, Command, BetweenOption)\u003e {\n    fn into_between_opts(self) -\u003e (CmdOpts, CmdOpts, BetweenOption) {\n        (\n            CmdOpts::Single(self.0 .0),\n            CmdOpts::Single(self.0 .1),\n            self.0 .2,\n        )\n    }\n}\n\n///  If `index` is set to the name of a secondary index,\n/// `between` will return all documents where that index’s\n/// value is in the specified range (it uses the primary key by default).\n/// `left_bound` or `right_bound` may be set to `Status::Open` or `Status::Closed`\n/// to indicate whether or not to include that endpoint of the range\n/// (by default, `left_bound` is closed and `right_bound` is open).\n#[derive(\n    Debug, Clone, Serialize, Default, Eq, PartialEq, Ord, PartialOrd, Hash, CommandOptions,\n)]\npub struct BetweenOption {\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub index: Option\u003cCow\u003c'static, str\u003e\u003e,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub left_bound: Option\u003cStatus\u003e,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub right_bound: Option\u003cStatus\u003e,\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::arguments::Status;\n    use crate::prelude::*;\n    use crate::spec::{set_up, tear_down, Post};\n    use crate::{args, r, Result};\n\n    use super::BetweenOption;\n\n    #[tokio::test]\n    async fn test_get_data_between() -\u003e Result\u003c()\u003e {\n        let data = Post::get_many_data();\n        let (conn, table, table_name) = set_up(true).await?;\n        let data_get: Vec\u003cPost\u003e = table\n            .between(args!(r.expr(2), r.expr(4)))\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(data_get.len() == 2);\n        assert!(data_get.first() == data.get(2));\n        assert!(data_get.last() == data.get(1));\n\n        tear_down(conn, table_name.as_str()).await\n    }\n\n    #[tokio::test]\n    async fn test_get_data_between_by_minval() -\u003e Result\u003c()\u003e {\n        let data = Post::get_many_data();\n        let (conn, table, table_name) = set_up(true).await?;\n        let data_get: Vec\u003cPost\u003e = table\n            .between(args!(r::min_val(), r.expr(4)))\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(data_get.len() == 3);\n        assert!(data_get.first() == data.get(2));\n        assert!(data_get.last() == data.first());\n\n        tear_down(conn, table_name.as_str()).await\n    }\n\n    #[tokio::test]\n    async fn test_get_data_between_by_maxval() -\u003e Result\u003c()\u003e {\n        let data = Post::get_many_data();\n        let (conn, table, table_name) = set_up(true).await?;\n        let data_get: Vec\u003cPost\u003e = table\n            .between(args!(r.expr(2), r::max_val()))\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(data_get.len() == 4);\n        assert!(data_get.first() == data.get(3));\n        assert!(data_get.last() == data.get(1));\n\n        tear_down(conn, table_name.as_str()).await\n    }\n\n    #[tokio::test]\n    async fn test_get_data_between_with_opts() -\u003e Result\u003c()\u003e {\n        let data = Post::get_many_data();\n        let (conn, table, table_name) = set_up(true).await?;\n        let between_option = BetweenOption::default().right_bound(Status::Closed);\n        let data_get: Vec\u003cPost\u003e = table\n            .between(args!(r.expr(2), r.expr(4), between_option))\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(data_get.len() == 3);\n        assert!(data_get.first() == data.get(3));\n        assert!(data_get.last() == data.get(1));\n\n        tear_down(conn, table_name.as_str()).await\n    }\n\n    #[tokio::test]\n    async fn test_get_data_between_by_minval_and_max_val_with_opts() -\u003e Result\u003c()\u003e {\n        let data = Post::get_many_data();\n        let (conn, table, table_name) = set_up(true).await?;\n        let between_option = BetweenOption::default()\n            .right_bound(Status::Closed)\n            .left_bound(Status::Closed)\n            .index(\"title\");\n        let data_get: Vec\u003cPost\u003e = table\n            .between(args!(r::min_val(), r::max_val(), between_option))\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(data_get.len() == data.len());\n        assert!(data_get.first() == data.get(3));\n        assert!(data_get.last() == data.first());\n\n        tear_down(conn, table_name.as_str()).await\n    }\n}\n","traces":[{"line":12,"address":[5529747,5528944,5530931,5530128,5531275,5530091],"length":1,"stats":{"Line":2},"fn_name":"new\u003creql_rust::arguments::Args\u003c(reql_rust::proto::Command, reql_rust::proto::Command)\u003e\u003e"},{"line":13,"address":[5530145,5528961],"length":1,"stats":{"Line":2},"fn_name":null},{"line":14,"address":[5529297,5530397,5530481,5529213],"length":1,"stats":{"Line":4},"fn_name":null},{"line":15,"address":[5530489,5529406,5529305,5530590],"length":1,"stats":{"Line":4},"fn_name":null},{"line":17,"address":[5530669,5529414,5529604,5529799,5530598,5530788,5529485,5531107,5530983,5529923],"length":1,"stats":{"Line":10},"fn_name":null},{"line":18,"address":[5530827,5530677,5530921,5529737,5529643,5529493],"length":1,"stats":{"Line":4},"fn_name":null},{"line":19,"address":[5529659,5530942,5531122,5529938,5531027,5529758,5529843,5530843],"length":1,"stats":{"Line":4},"fn_name":null},{"line":20,"address":[5531035,5529851],"length":1,"stats":{"Line":2},"fn_name":null},{"line":28,"address":[7628816,7629148,7629125],"length":1,"stats":{"Line":1},"fn_name":"into_between_opts"},{"line":30,"address":[2648841],"length":1,"stats":{"Line":1},"fn_name":null},{"line":31,"address":[2648889],"length":1,"stats":{"Line":1},"fn_name":null},{"line":32,"address":[2648956],"length":1,"stats":{"Line":1},"fn_name":null},{"line":38,"address":[2649152],"length":1,"stats":{"Line":1},"fn_name":"into_between_opts"},{"line":40,"address":[2649174],"length":1,"stats":{"Line":1},"fn_name":null},{"line":41,"address":[2649233],"length":1,"stats":{"Line":1},"fn_name":null},{"line":42,"address":[2649305],"length":1,"stats":{"Line":1},"fn_name":null},{"line":75,"address":[2610448,2610853,2610487,2610901],"length":1,"stats":{"Line":6},"fn_name":"test_get_data_between"},{"line":76,"address":[3145683],"length":1,"stats":{"Line":1},"fn_name":null},{"line":77,"address":[3146296,3146750,3146061,3145896,3146121,3145743],"length":1,"stats":{"Line":4},"fn_name":null},{"line":78,"address":[3147987,3148221,3146705,3147472,3147943,3147156,3147389,3147886,3147223,3147667],"length":1,"stats":{"Line":7},"fn_name":null},{"line":79,"address":[3146740,3147248,3147230,3147195,3146923],"length":1,"stats":{"Line":2},"fn_name":null},{"line":80,"address":[3147298,3147600,3147203,3145847,3145764,3147428],"length":1,"stats":{"Line":6},"fn_name":null},{"line":81,"address":[3147790],"length":1,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[3148107,3148480,3148528],"length":1,"stats":{"Line":2},"fn_name":null},{"line":86,"address":[3148576,3148501,3148762],"length":1,"stats":{"Line":2},"fn_name":null},{"line":87,"address":[3148981,3148741,3148805],"length":1,"stats":{"Line":2},"fn_name":null},{"line":89,"address":[2610864,2610524,2610479,2610584],"length":1,"stats":{"Line":7},"fn_name":null},{"line":93,"address":[2610983,2611349,2611397,2610944],"length":1,"stats":{"Line":6},"fn_name":"test_get_data_between_by_minval"},{"line":94,"address":[3149955],"length":1,"stats":{"Line":1},"fn_name":null},{"line":95,"address":[3150015,3150393,3150168,3150568,3151017,3150333],"length":1,"stats":{"Line":4},"fn_name":null},{"line":96,"address":[3152153,3151739,3151423,3151934,3150977,3152254,3152210,3151656,3152488,3151490],"length":1,"stats":{"Line":7},"fn_name":null},{"line":97,"address":[3151007,3151462,3151497,3151190,3151515],"length":1,"stats":{"Line":2},"fn_name":null},{"line":98,"address":[3151695,3150036,3151867,3150119,3151565,3151470],"length":1,"stats":{"Line":6},"fn_name":null},{"line":99,"address":[3152057],"length":1,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[3152795,3152374,3152747],"length":1,"stats":{"Line":2},"fn_name":null},{"line":104,"address":[3153029,3152768,3152843],"length":1,"stats":{"Line":2},"fn_name":null},{"line":105,"address":[3153243,3153072,3153008],"length":1,"stats":{"Line":2},"fn_name":null},{"line":107,"address":[2610975,2611020,2611360,2611080],"length":1,"stats":{"Line":7},"fn_name":null},{"line":111,"address":[2611893,2611845,2611440,2611479],"length":1,"stats":{"Line":6},"fn_name":"test_get_data_between_by_maxval"},{"line":112,"address":[3154211],"length":1,"stats":{"Line":1},"fn_name":null},{"line":113,"address":[3154649,3154271,3154424,3154824,3155278,3154589],"length":1,"stats":{"Line":4},"fn_name":null},{"line":114,"address":[3156744,3155995,3155746,3155679,3156510,3156409,3156466,3156190,3155233,3155912],"length":1,"stats":{"Line":7},"fn_name":null},{"line":115,"address":[3155753,3155771,3155268,3155718,3155451],"length":1,"stats":{"Line":2},"fn_name":null},{"line":116,"address":[3154375,3156123,3154292,3155726,3155821,3155951],"length":1,"stats":{"Line":6},"fn_name":null},{"line":117,"address":[3156313],"length":1,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[3157003,3156630,3157051],"length":1,"stats":{"Line":2},"fn_name":null},{"line":122,"address":[3157285,3157099,3157024],"length":1,"stats":{"Line":2},"fn_name":null},{"line":123,"address":[3157264,3157328,3157504],"length":1,"stats":{"Line":2},"fn_name":null},{"line":125,"address":[2611576,2611516,2611471,2611856],"length":1,"stats":{"Line":7},"fn_name":null},{"line":129,"address":[2612389,2612341,2611936,2611975],"length":1,"stats":{"Line":6},"fn_name":"test_get_data_between_with_opts"},{"line":130,"address":[3158467],"length":1,"stats":{"Line":1},"fn_name":null},{"line":131,"address":[3158684,3158909,3159084,3158849,3158531,3159471],"length":1,"stats":{"Line":4},"fn_name":null},{"line":132,"address":[3159696,3159461],"length":1,"stats":{"Line":2},"fn_name":null},{"line":133,"address":[3160661,3160880,3160383,3160466,3159747,3160217,3160150,3160937,3160985,3161219],"length":1,"stats":{"Line":7},"fn_name":null},{"line":134,"address":[3160242,3160189,3159802,3160224],"length":1,"stats":{"Line":2},"fn_name":null},{"line":135,"address":[3160594,3158552,3160197,3160292,3160422,3158635],"length":1,"stats":{"Line":6},"fn_name":null},{"line":136,"address":[3160784],"length":1,"stats":{"Line":0},"fn_name":null},{"line":140,"address":[3161105,3161478,3161526],"length":1,"stats":{"Line":2},"fn_name":null},{"line":141,"address":[3161499,3161574,3161766],"length":1,"stats":{"Line":2},"fn_name":null},{"line":142,"address":[3161815,3161991,3161739],"length":1,"stats":{"Line":2},"fn_name":null},{"line":144,"address":[2612352,2612072,2611967,2612012],"length":1,"stats":{"Line":7},"fn_name":null},{"line":148,"address":[2612432,2612471,2612885,2612837],"length":1,"stats":{"Line":6},"fn_name":"test_get_data_between_by_minval_and_max_val_with_opts"},{"line":149,"address":[3162995],"length":1,"stats":{"Line":1},"fn_name":null},{"line":150,"address":[3163059,3163999,3163212,3163377,3163437,3163612],"length":1,"stats":{"Line":4},"fn_name":null},{"line":151,"address":[3163989,3164232,3164271],"length":1,"stats":{"Line":3},"fn_name":null},{"line":152,"address":[3164224],"length":1,"stats":{"Line":1},"fn_name":null},{"line":153,"address":[3164263],"length":1,"stats":{"Line":1},"fn_name":null},{"line":155,"address":[3165529,3164975,3165253,3165811,3165058,3164349,3164809,3165577,3165472,3164742],"length":1,"stats":{"Line":7},"fn_name":null},{"line":156,"address":[3164399,3164781,3164816,3164834],"length":1,"stats":{"Line":2},"fn_name":null},{"line":157,"address":[3164884,3163163,3165014,3163080,3164789,3165186],"length":1,"stats":{"Line":6},"fn_name":null},{"line":158,"address":[3165376],"length":1,"stats":{"Line":0},"fn_name":null},{"line":162,"address":[3165697,3166070,3166148],"length":1,"stats":{"Line":2},"fn_name":null},{"line":163,"address":[3166385,3166121,3166196],"length":1,"stats":{"Line":2},"fn_name":null},{"line":164,"address":[3166602,3166361,3166431],"length":1,"stats":{"Line":2},"fn_name":null},{"line":166,"address":[2612848,2612508,2612568,2612463],"length":1,"stats":{"Line":7},"fn_name":null}],"covered":70,"coverable":75},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","binary.rs"],"content":"use crate::types::Binary;\n\npub(crate) fn new(bytes: \u0026[u8]) -\u003e Binary {\n    Binary::new(bytes)\n}\n\n#[cfg(test)]\nmod tests {\n    use serde::{Deserialize, Serialize};\n\n    use crate::prelude::Converter;\n    use crate::spec::{set_up, tear_down};\n    use crate::types::Binary;\n    use crate::{r, Result};\n\n    #[derive(Debug, Serialize, Deserialize)]\n    struct User {\n        id: u8,\n        name: String,\n        avatar: Binary,\n    }\n\n    #[tokio::test]\n    async fn test_binary_ops() -\u003e Result\u003c()\u003e {\n        let avatar_img = std::fs::read(\"logo.png\")?;\n        let user = User {\n            id: 1,\n            name: \"John Doe\".to_string(),\n            avatar: r.binary(\u0026avatar_img),\n        };\n\n        let (conn, table, table_name) = set_up(false).await?;\n        table.clone().insert(\u0026user).run(\u0026conn).await?;\n        let response: User = table.get(1).run(\u0026conn).await?.unwrap().parse()?;\n\n        assert!(response.id == user.id);\n        assert!(response.name == user.name);\n        assert!(!response.avatar.data.is_empty());\n\n        tear_down(conn, \u0026table_name).await\n    }\n}\n","traces":[{"line":3,"address":[2468864],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":4,"address":[2468885],"length":1,"stats":{"Line":1},"fn_name":null},{"line":24,"address":[4930273,4930869,4929861,4929971,4929760,4929769,4929792],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":25,"address":[4929926,4930401,4930520],"length":1,"stats":{"Line":2},"fn_name":null},{"line":28,"address":[4930490],"length":1,"stats":{"Line":1},"fn_name":null},{"line":29,"address":[4930785,4930693],"length":1,"stats":{"Line":2},"fn_name":null},{"line":32,"address":[4930001,4930940,4931500,4930230,4930862],"length":1,"stats":{"Line":4},"fn_name":null},{"line":33,"address":[4930022,4931490,4931712,4930179],"length":1,"stats":{"Line":4},"fn_name":null},{"line":34,"address":[4932472,4930128,4932596,4930043,4933316,4933463],"length":1,"stats":{"Line":5},"fn_name":null},{"line":36,"address":[4933436,4933837],"length":1,"stats":{"Line":1},"fn_name":null},{"line":37,"address":[4933952,4933920,4933812],"length":1,"stats":{"Line":2},"fn_name":null},{"line":38,"address":[4934046,4933934,4933986],"length":1,"stats":{"Line":2},"fn_name":null},{"line":40,"address":[4934002,4934532,4934101,4934225,4934396,4930061,4934284],"length":1,"stats":{"Line":7},"fn_name":null}],"covered":13,"coverable":13},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","bit_and.rs"],"content":"use std::ops::BitAnd;\n\nuse ql2::term::TermType;\n\nuse crate::Command;\n\nimpl\u003cT: BitAndArg\u003e BitAnd\u003cT\u003e for Command {\n    type Output = Self;\n\n    fn bitand(self, arg: T) -\u003e Self {\n        Command::new(TermType::BitAnd)\n            .with_arg(arg.into_bit_and_opts())\n            .with_parent(self)\n    }\n}\n\npub trait BitAndArg {\n    fn into_bit_and_opts(self) -\u003e Command;\n}\n\nimpl BitAndArg for i32 {\n    fn into_bit_and_opts(self) -\u003e Command {\n        Command::from_json(self)\n    }\n}\n\nimpl BitAndArg for Command {\n    fn into_bit_and_opts(self) -\u003e Command {\n        self\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::Converter;\n    use crate::{r, Result};\n\n    #[tokio::test]\n    async fn test_bit_and_ops() -\u003e Result\u003c()\u003e {\n        let conn = r.connection().connect().await?;\n        let response: u8 = r.expr(5).bit_and(3).run(\u0026conn).await?.unwrap().parse()?;\n\n        assert!(response == 1);\n\n        Ok(())\n    }\n\n    #[tokio::test]\n    async fn test_bit_and_ops_with_command() -\u003e Result\u003c()\u003e {\n        let conn = r.connection().connect().await?;\n        let response: u8 = r\n            .bit_and(r.expr(5), r.expr(3))\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(response == 1);\n\n        Ok(())\n    }\n\n    #[tokio::test]\n    async fn test_bit_and_ops_with_syntax() -\u003e Result\u003c()\u003e {\n        let conn = r.connection().connect().await?;\n        let response: u8 = (r.expr(5) \u0026 r.expr(3)).run(\u0026conn).await?.unwrap().parse()?;\n\n        assert!(response == 1);\n\n        Ok(())\n    }\n}\n","traces":[{"line":10,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":11,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":12,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":13,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":22,"address":[2154944],"length":1,"stats":{"Line":1},"fn_name":"into_bit_and_opts"},{"line":23,"address":[2154960],"length":1,"stats":{"Line":1},"fn_name":null},{"line":28,"address":[2170080],"length":1,"stats":{"Line":1},"fn_name":"into_bit_and_opts"},{"line":29,"address":[2170088],"length":1,"stats":{"Line":1},"fn_name":null},{"line":39,"address":[5099031,5099397,5099445,5098992],"length":1,"stats":{"Line":6},"fn_name":"test_bit_and_ops"},{"line":40,"address":[4031245,4030979,4031434,4031700,4031013,4031084],"length":1,"stats":{"Line":4},"fn_name":null},{"line":41,"address":[4032656,4032745,4031028,4031944,4031690],"length":1,"stats":{"Line":4},"fn_name":null},{"line":43,"address":[4032725,4032953],"length":1,"stats":{"Line":1},"fn_name":null},{"line":45,"address":[4032927],"length":1,"stats":{"Line":5},"fn_name":null},{"line":49,"address":[4033017,4033097,4033173,4033008,4033040,4033607,4033308],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":50,"address":[4033197,4033618,4033429,4033147,4033884,4033268],"length":1,"stats":{"Line":4},"fn_name":null},{"line":51,"address":[4034877,4034934,4034402,4034971,4035156,4034249,4034473,4034177,4034658],"length":1,"stats":{"Line":6},"fn_name":null},{"line":52,"address":[4033874,4034080,4034115,4034264,4034221],"length":1,"stats":{"Line":3},"fn_name":null},{"line":53,"address":[4034317,4034432,4034601,4033212,4034229],"length":1,"stats":{"Line":5},"fn_name":null},{"line":54,"address":[4034781],"length":1,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[4035040,4035268],"length":1,"stats":{"Line":1},"fn_name":null},{"line":60,"address":[4035242],"length":1,"stats":{"Line":5},"fn_name":null},{"line":64,"address":[4035328,4035493,4035360,4035628,4035417,4035927,4035337],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":65,"address":[4035749,4036204,4035588,4035938,4035517,4035467],"length":1,"stats":{"Line":4},"fn_name":null},{"line":66,"address":[4036194,4036435,4037380,4036637,4037291,4035532,4036400],"length":1,"stats":{"Line":5},"fn_name":null},{"line":68,"address":[4037360,4037588],"length":1,"stats":{"Line":1},"fn_name":null},{"line":70,"address":[4037562],"length":1,"stats":{"Line":5},"fn_name":null}],"covered":25,"coverable":26},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","bit_not.rs"],"content":"use ql2::term::TermType;\n\nuse crate::Command;\n\npub(crate) fn new() -\u003e Command {\n    Command::new(TermType::BitNot)\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::Converter;\n    use crate::{r, Result};\n\n    #[tokio::test]\n    async fn test_bit_not_ops() -\u003e Result\u003c()\u003e {\n        let conn = r.connection().connect().await?;\n        let response: i32 = r.expr(7).bit_not().run(\u0026conn).await?.unwrap().parse()?;\n\n        assert!(response == -8);\n\n        Ok(())\n    }\n\n    #[tokio::test]\n    async fn test_bit_not_ops_with_command() -\u003e Result\u003c()\u003e {\n        let conn = r.connection().connect().await?;\n        let response: i32 = r.bit_not(r.expr(7)).run(\u0026conn).await?.unwrap().parse()?;\n\n        assert!(response == -8);\n\n        Ok(())\n    }\n}\n","traces":[{"line":5,"address":[2435360],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":6,"address":[2435372],"length":1,"stats":{"Line":1},"fn_name":null},{"line":15,"address":[1945061,1944608,1945013,1944647],"length":1,"stats":{"Line":6},"fn_name":"test_bit_not_ops"},{"line":16,"address":[5207805,5207644,5207573,5208260,5207539,5207994],"length":1,"stats":{"Line":4},"fn_name":null},{"line":17,"address":[5208250,5209301,5207588,5208499,5209211],"length":1,"stats":{"Line":4},"fn_name":null},{"line":19,"address":[5209280,5209509],"length":1,"stats":{"Line":1},"fn_name":null},{"line":21,"address":[1944684,1944639,1945024,1944744],"length":1,"stats":{"Line":5},"fn_name":null},{"line":25,"address":[1945557,1945509,1945104,1945143],"length":1,"stats":{"Line":6},"fn_name":"test_bit_not_ops_with_command"},{"line":26,"address":[5209820,5210170,5210436,5209749,5209715,5209981],"length":1,"stats":{"Line":4},"fn_name":null},{"line":27,"address":[5211477,5209764,5211387,5210675,5210426],"length":1,"stats":{"Line":4},"fn_name":null},{"line":29,"address":[5211685,5211456],"length":1,"stats":{"Line":1},"fn_name":null},{"line":31,"address":[1945135,1945520,1945180,1945240],"length":1,"stats":{"Line":5},"fn_name":null}],"covered":12,"coverable":12},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","bit_or.rs"],"content":"use std::ops::BitOr;\n\nuse ql2::term::TermType;\n\nuse crate::Command;\n\nimpl\u003cT: BitOrArg\u003e BitOr\u003cT\u003e for Command {\n    type Output = Self;\n\n    fn bitor(self, arg: T) -\u003e Self {\n        Command::new(TermType::BitOr)\n            .with_arg(arg.into_bit_or_opts())\n            .with_parent(self)\n    }\n}\n\npub trait BitOrArg {\n    fn into_bit_or_opts(self) -\u003e Command;\n}\n\nimpl BitOrArg for i32 {\n    fn into_bit_or_opts(self) -\u003e Command {\n        Command::from_json(self)\n    }\n}\n\nimpl BitOrArg for Command {\n    fn into_bit_or_opts(self) -\u003e Command {\n        self\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::Converter;\n    use crate::{r, Result};\n\n    #[tokio::test]\n    async fn test_bit_or_ops() -\u003e Result\u003c()\u003e {\n        let conn = r.connection().connect().await?;\n        let response: u8 = r.expr(5).bit_or(3).run(\u0026conn).await?.unwrap().parse()?;\n\n        assert!(response == 7);\n\n        Ok(())\n    }\n\n    #[tokio::test]\n    async fn test_bit_or_ops_with_command() -\u003e Result\u003c()\u003e {\n        let conn = r.connection().connect().await?;\n        let response: u8 = r\n            .bit_or(r.expr(5), r.expr(3))\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(response == 7);\n\n        Ok(())\n    }\n\n    #[tokio::test]\n    async fn test_bit_or_ops_with_syntax() -\u003e Result\u003c()\u003e {\n        let conn = r.connection().connect().await?;\n        let response: u8 = (r.expr(5) | r.expr(3)).run(\u0026conn).await?.unwrap().parse()?;\n\n        assert!(response == 7);\n\n        Ok(())\n    }\n}\n","traces":[{"line":10,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":11,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":12,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":13,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":22,"address":[2154976],"length":1,"stats":{"Line":1},"fn_name":"into_bit_or_opts"},{"line":23,"address":[2154992],"length":1,"stats":{"Line":1},"fn_name":null},{"line":28,"address":[2170112],"length":1,"stats":{"Line":1},"fn_name":"into_bit_or_opts"},{"line":29,"address":[2170120],"length":1,"stats":{"Line":1},"fn_name":null},{"line":39,"address":[3026183,3026597,3026144,3026549],"length":1,"stats":{"Line":6},"fn_name":"test_bit_or_ops"},{"line":40,"address":[2517933,2518388,2517772,2517701,2518122,2517667],"length":1,"stats":{"Line":4},"fn_name":null},{"line":41,"address":[2519433,2518378,2518632,2517716,2519344],"length":1,"stats":{"Line":4},"fn_name":null},{"line":43,"address":[2519641,2519413],"length":1,"stats":{"Line":1},"fn_name":null},{"line":45,"address":[3026560,3026175,3026220,3026280],"length":1,"stats":{"Line":5},"fn_name":null},{"line":49,"address":[3026640,3026679,3027045,3027093],"length":1,"stats":{"Line":6},"fn_name":"test_bit_or_ops_with_command"},{"line":50,"address":[2519885,2520117,2520572,2519956,2519835,2520306],"length":1,"stats":{"Line":4},"fn_name":null},{"line":51,"address":[2521844,2521622,2520937,2520865,2521346,2521161,2521659,2521090,2521565],"length":1,"stats":{"Line":6},"fn_name":null},{"line":52,"address":[2520803,2520952,2520768,2520909,2520562],"length":1,"stats":{"Line":3},"fn_name":null},{"line":53,"address":[2521005,2519900,2521120,2520917,2521289],"length":1,"stats":{"Line":5},"fn_name":null},{"line":54,"address":[2521469],"length":1,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[2521728,2521956],"length":1,"stats":{"Line":1},"fn_name":null},{"line":60,"address":[2521930],"length":1,"stats":{"Line":5},"fn_name":null},{"line":64,"address":[2522016,2522025,2522316,2522048,2522181,2522105,2522615],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":65,"address":[2522626,2522155,2522437,2522205,2522276,2522892],"length":1,"stats":{"Line":4},"fn_name":null},{"line":66,"address":[2524068,2522882,2523088,2523123,2522220,2523979,2523325],"length":1,"stats":{"Line":5},"fn_name":null},{"line":68,"address":[2524276,2524048],"length":1,"stats":{"Line":1},"fn_name":null},{"line":70,"address":[2524250],"length":1,"stats":{"Line":5},"fn_name":null}],"covered":25,"coverable":26},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","bit_sal.rs"],"content":"use ql2::term::TermType;\n\nuse crate::Command;\n\npub(crate) fn new(args: impl BitSalArg) -\u003e Command {\n    Command::new(TermType::BitSal).with_arg(args.into_bit_sal_opts())\n}\n\npub trait BitSalArg {\n    fn into_bit_sal_opts(self) -\u003e Command;\n}\n\nimpl BitSalArg for i32 {\n    fn into_bit_sal_opts(self) -\u003e Command {\n        Command::from_json(self)\n    }\n}\n\nimpl BitSalArg for Command {\n    fn into_bit_sal_opts(self) -\u003e Command {\n        self\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::Converter;\n    use crate::{r, Result};\n\n    #[tokio::test]\n    async fn test_bit_sal_ops() -\u003e Result\u003c()\u003e {\n        let conn = r.connection().connect().await?;\n        let response: u8 = r.expr(5).bit_sal(4).run(\u0026conn).await?.unwrap().parse()?;\n\n        assert!(response == 80);\n\n        Ok(())\n    }\n\n    #[tokio::test]\n    async fn test_bit_sal_ops_with_command() -\u003e Result\u003c()\u003e {\n        let conn = r.connection().connect().await?;\n        let response: u8 = r\n            .bit_sal(r.expr(5), r.expr(4))\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(response == 80);\n\n        Ok(())\n    }\n}\n","traces":[{"line":5,"address":[3393829,3394158,3393568,3393872],"length":1,"stats":{"Line":2},"fn_name":"new\u003ci32\u003e"},{"line":6,"address":[3393596,3394148,3393695,3393894,3393994,3393819],"length":1,"stats":{"Line":4},"fn_name":null},{"line":14,"address":[2155008],"length":1,"stats":{"Line":1},"fn_name":"into_bit_sal_opts"},{"line":15,"address":[2155024],"length":1,"stats":{"Line":1},"fn_name":null},{"line":20,"address":[2170144],"length":1,"stats":{"Line":1},"fn_name":"into_bit_sal_opts"},{"line":21,"address":[2170152],"length":1,"stats":{"Line":1},"fn_name":null},{"line":31,"address":[2939687,2940053,2940101,2939648],"length":1,"stats":{"Line":6},"fn_name":"test_bit_sal_ops"},{"line":32,"address":[3014708,3014442,3014021,3014092,3013987,3014253],"length":1,"stats":{"Line":4},"fn_name":null},{"line":33,"address":[3014952,3015753,3014698,3015664,3014036],"length":1,"stats":{"Line":4},"fn_name":null},{"line":35,"address":[3015961,3015733],"length":1,"stats":{"Line":1},"fn_name":null},{"line":37,"address":[2940064,2939724,2939679,2939784],"length":1,"stats":{"Line":5},"fn_name":null},{"line":41,"address":[2940597,2940549,2940183,2940144],"length":1,"stats":{"Line":6},"fn_name":"test_bit_sal_ops_with_command"},{"line":42,"address":[3016276,3016626,3016892,3016437,3016205,3016155],"length":1,"stats":{"Line":4},"fn_name":null},{"line":43,"address":[3017666,3018164,3017942,3017481,3017410,3017185,3017885,3017257,3017979],"length":1,"stats":{"Line":6},"fn_name":null},{"line":44,"address":[3017123,3017088,3017272,3016882,3017229],"length":1,"stats":{"Line":3},"fn_name":null},{"line":45,"address":[3017440,3017325,3016220,3017237,3017609],"length":1,"stats":{"Line":5},"fn_name":null},{"line":46,"address":[3017789],"length":1,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[3018276,3018048],"length":1,"stats":{"Line":1},"fn_name":null},{"line":52,"address":[2940175,2940220,2940280,2940560],"length":1,"stats":{"Line":5},"fn_name":null}],"covered":18,"coverable":19},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","bit_sar.rs"],"content":"use ql2::term::TermType;\n\nuse crate::Command;\n\npub(crate) fn new(args: impl BitSarArg) -\u003e Command {\n    Command::new(TermType::BitSar).with_arg(args.into_bit_sar_opts())\n}\n\npub trait BitSarArg {\n    fn into_bit_sar_opts(self) -\u003e Command;\n}\n\nimpl BitSarArg for i32 {\n    fn into_bit_sar_opts(self) -\u003e Command {\n        Command::from_json(self)\n    }\n}\n\nimpl BitSarArg for Command {\n    fn into_bit_sar_opts(self) -\u003e Command {\n        self\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::Converter;\n    use crate::{r, Result};\n\n    #[tokio::test]\n    async fn test_bit_sar_ops() -\u003e Result\u003c()\u003e {\n        let conn = r.connection().connect().await?;\n        let response: u8 = r.expr(32).bit_sar(3).run(\u0026conn).await?.unwrap().parse()?;\n\n        assert!(response == 4);\n\n        Ok(())\n    }\n\n    #[tokio::test]\n    async fn test_bit_sar_ops_with_command() -\u003e Result\u003c()\u003e {\n        let conn = r.connection().connect().await?;\n        let response: u8 = r\n            .bit_sar(r.expr(32), r.expr(3))\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(response == 4);\n\n        Ok(())\n    }\n}\n","traces":[{"line":5,"address":[3394512,3394469,3394798,3394208],"length":1,"stats":{"Line":2},"fn_name":"new\u003ci32\u003e"},{"line":6,"address":[3394335,3394634,3394534,3394236,3394459,3394788],"length":1,"stats":{"Line":4},"fn_name":null},{"line":14,"address":[2155040],"length":1,"stats":{"Line":1},"fn_name":"into_bit_sar_opts"},{"line":15,"address":[2155056],"length":1,"stats":{"Line":1},"fn_name":null},{"line":20,"address":[2170176],"length":1,"stats":{"Line":1},"fn_name":"into_bit_sar_opts"},{"line":21,"address":[2170184],"length":1,"stats":{"Line":1},"fn_name":null},{"line":31,"address":[1945639,1945600,1946005,1946053],"length":1,"stats":{"Line":6},"fn_name":"test_bit_sar_ops"},{"line":32,"address":[3018588,3018483,3018517,3018749,3018938,3019204],"length":1,"stats":{"Line":4},"fn_name":null},{"line":33,"address":[3019448,3020249,3018532,3020160,3019194],"length":1,"stats":{"Line":4},"fn_name":null},{"line":35,"address":[3020229,3020457],"length":1,"stats":{"Line":1},"fn_name":null},{"line":37,"address":[1945736,1945676,1946016,1945631],"length":1,"stats":{"Line":5},"fn_name":null},{"line":41,"address":[1946501,1946135,1946549,1946096],"length":1,"stats":{"Line":6},"fn_name":"test_bit_sar_ops_with_command"},{"line":42,"address":[3020651,3020772,3021388,3020701,3020933,3021122],"length":1,"stats":{"Line":4},"fn_name":null},{"line":43,"address":[3022162,3021977,3021681,3021906,3022438,3022381,3021753,3022475,3022660],"length":1,"stats":{"Line":6},"fn_name":null},{"line":44,"address":[3021725,3021378,3021584,3021619,3021768],"length":1,"stats":{"Line":3},"fn_name":null},{"line":45,"address":[3021733,3020716,3021936,3021821,3022105],"length":1,"stats":{"Line":5},"fn_name":null},{"line":46,"address":[3022285],"length":1,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[3022772,3022544],"length":1,"stats":{"Line":1},"fn_name":null},{"line":52,"address":[1946232,1946512,1946172,1946127],"length":1,"stats":{"Line":5},"fn_name":null}],"covered":18,"coverable":19},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","bit_xor.rs"],"content":"use std::ops::BitXor;\n\nuse ql2::term::TermType;\n\nuse crate::Command;\n\nimpl\u003cT: BitXorArg\u003e BitXor\u003cT\u003e for Command {\n    type Output = Self;\n\n    fn bitxor(self, arg: T) -\u003e Self {\n        Command::new(TermType::BitXor)\n            .with_arg(arg.into_bit_xor_opts())\n            .with_parent(self)\n    }\n}\n\npub trait BitXorArg {\n    fn into_bit_xor_opts(self) -\u003e Command;\n}\n\nimpl BitXorArg for i32 {\n    fn into_bit_xor_opts(self) -\u003e Command {\n        Command::from_json(self)\n    }\n}\n\nimpl BitXorArg for Command {\n    fn into_bit_xor_opts(self) -\u003e Command {\n        self\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::Converter;\n    use crate::{r, Result};\n\n    #[tokio::test]\n    async fn test_bit_xor_ops() -\u003e Result\u003c()\u003e {\n        let conn = r.connection().connect().await?;\n        let response: u8 = r.expr(6).bit_xor(4).run(\u0026conn).await?.unwrap().parse()?;\n\n        assert!(response == 2);\n\n        Ok(())\n    }\n\n    #[tokio::test]\n    async fn test_bit_xor_ops_with_command() -\u003e Result\u003c()\u003e {\n        let conn = r.connection().connect().await?;\n        let response: u8 = r\n            .bit_xor(r.expr(6), r.expr(4))\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(response == 2);\n\n        Ok(())\n    }\n\n    #[tokio::test]\n    async fn test_bit_xor_ops_with_syntax() -\u003e Result\u003c()\u003e {\n        let conn = r.connection().connect().await?;\n        let response: u8 = (r.expr(6) ^ r.expr(4)).run(\u0026conn).await?.unwrap().parse()?;\n\n        assert!(response == 2);\n\n        Ok(())\n    }\n}\n","traces":[{"line":10,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":11,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":12,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":13,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":22,"address":[2155072],"length":1,"stats":{"Line":1},"fn_name":"into_bit_xor_opts"},{"line":23,"address":[2155088],"length":1,"stats":{"Line":1},"fn_name":null},{"line":28,"address":[2170208],"length":1,"stats":{"Line":1},"fn_name":"into_bit_xor_opts"},{"line":29,"address":[2170216],"length":1,"stats":{"Line":1},"fn_name":null},{"line":39,"address":[5100519,5100480,5100933,5100885],"length":1,"stats":{"Line":6},"fn_name":"test_bit_xor_ops"},{"line":40,"address":[1709500,1709395,1709661,1710116,1709850,1709429],"length":1,"stats":{"Line":4},"fn_name":null},{"line":41,"address":[1710360,1711161,1711072,1710106,1709444],"length":1,"stats":{"Line":4},"fn_name":null},{"line":43,"address":[1711369,1711141],"length":1,"stats":{"Line":1},"fn_name":null},{"line":45,"address":[1711343],"length":1,"stats":{"Line":5},"fn_name":null},{"line":49,"address":[1712023,1711513,1711456,1711433,1711589,1711724,1711424],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":50,"address":[1711563,1712034,1711613,1711845,1712300,1711684],"length":1,"stats":{"Line":4},"fn_name":null},{"line":51,"address":[1713387,1713572,1713293,1713350,1712593,1712818,1712889,1713074,1712665],"length":1,"stats":{"Line":6},"fn_name":null},{"line":52,"address":[1712637,1712496,1712290,1712680,1712531],"length":1,"stats":{"Line":3},"fn_name":null},{"line":53,"address":[1712733,1711628,1712848,1712645,1713017],"length":1,"stats":{"Line":5},"fn_name":null},{"line":54,"address":[1713197],"length":1,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[1713684,1713456],"length":1,"stats":{"Line":1},"fn_name":null},{"line":60,"address":[1713658],"length":1,"stats":{"Line":5},"fn_name":null},{"line":64,"address":[1714044,1713753,1713744,1713909,1713833,1714343,1713776],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":65,"address":[1713933,1713883,1714004,1714620,1714354,1714165],"length":1,"stats":{"Line":4},"fn_name":null},{"line":66,"address":[1715796,1714851,1714816,1713948,1715707,1715053,1714610],"length":1,"stats":{"Line":5},"fn_name":null},{"line":68,"address":[1715776,1716004],"length":1,"stats":{"Line":1},"fn_name":null},{"line":70,"address":[1715978],"length":1,"stats":{"Line":5},"fn_name":null}],"covered":25,"coverable":26},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","bracket.rs"],"content":"use ql2::term::TermType;\nuse serde::Serialize;\n\nuse crate::Command;\n\npub(crate) fn new(attr: impl Serialize) -\u003e Command {\n    let arg = Command::from_json(attr);\n\n    Command::new(TermType::Bracket).with_arg(arg)\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::Converter;\n    use crate::spec::{set_up, tear_down, Post};\n    use crate::Result;\n\n    #[tokio::test]\n    async fn test_bracket_data() -\u003e Result\u003c()\u003e {\n        let data = Post::get_one_data();\n        let (conn, table, table_name) = set_up(true).await?;\n        let data_obtained: String = table\n            .get(1)\n            .bracket(\"title\")\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(data_obtained == data.title);\n\n        tear_down(conn, \u0026table_name).await\n    }\n}\n","traces":[{"line":6,"address":[1599072,1599284,1599311],"length":1,"stats":{"Line":1},"fn_name":"new\u003c\u0026str\u003e"},{"line":7,"address":[1599105],"length":1,"stats":{"Line":1},"fn_name":null},{"line":9,"address":[1599131,1599198],"length":1,"stats":{"Line":2},"fn_name":null},{"line":19,"address":[2501477,2501111,2501525,2501072],"length":1,"stats":{"Line":6},"fn_name":"test_bracket_data"},{"line":20,"address":[4661459],"length":1,"stats":{"Line":1},"fn_name":null},{"line":21,"address":[4661511,4661664,4661889,4662502,4661829,4662064],"length":1,"stats":{"Line":4},"fn_name":null},{"line":22,"address":[4662882,4662702,4662765,4662449,4663430,4662959,4663704,4663154,4663474,4663373],"length":1,"stats":{"Line":7},"fn_name":null},{"line":25,"address":[4661615,4661532,4662745,4662915,4662788,4663087],"length":1,"stats":{"Line":6},"fn_name":null},{"line":26,"address":[4663277],"length":1,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[4663594,4663963,4664018],"length":1,"stats":{"Line":2},"fn_name":null},{"line":32,"address":[2501103,2501208,2501148,2501488],"length":1,"stats":{"Line":7},"fn_name":null}],"covered":10,"coverable":11},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","branch.rs"],"content":"use ql2::term::TermType;\n\nuse crate::{arguments::Args, Command};\n\nuse super::CmdOpts;\n\npub(crate) fn new(args: impl BranchArg) -\u003e Command {\n    let (test, true_action, false_action) = args.into_branch_opts();\n    let mut command = Command::new(TermType::Branch);\n\n    if let Some(arg) = test {\n        command = command.with_arg(arg)\n    }\n\n    true_action.add_to_cmd(command).with_arg(false_action)\n}\n\npub trait BranchArg {\n    fn into_branch_opts(self) -\u003e (Option\u003cCommand\u003e, CmdOpts, Command);\n}\n\nimpl BranchArg for Args\u003c(Command, Command)\u003e {\n    fn into_branch_opts(self) -\u003e (Option\u003cCommand\u003e, CmdOpts, Command) {\n        (None, CmdOpts::Single(self.0 .0), self.0 .1)\n    }\n}\n\nimpl\u003cconst N: usize\u003e BranchArg for Args\u003c(Command, [(Command, Command); N], Command)\u003e {\n    fn into_branch_opts(self) -\u003e (Option\u003cCommand\u003e, CmdOpts, Command) {\n        let actions = self\n            .0\n             .1\n            .into_iter()\n            .flat_map(|(test, true_action)| [test, true_action])\n            .collect();\n        (Some(self.0 .0), CmdOpts::Many(actions), self.0 .2)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::Converter;\n    use crate::{args, r, Result};\n\n    #[tokio::test]\n    async fn test_branch_data() -\u003e Result\u003c()\u003e {\n        let x = 10;\n        let conn = r.connection().connect().await?;\n        let response: String = r\n            .branch(r.expr(x \u003e 5), args!(r.expr(\"big\"), r.expr(\"small\")))\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(response.eq(\"big\"));\n\n        Ok(())\n    }\n\n    #[tokio::test]\n    async fn test_branch_data_with_infix() -\u003e Result\u003c()\u003e {\n        let x = 10;\n        let conn = r.connection().connect().await?;\n        let response: String = r\n            .expr(x \u003e 5)\n            .branch(args!(r.expr(\"big\"), r.expr(\"small\")))\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(response.eq(\"big\"));\n\n        Ok(())\n    }\n}\n","traces":[{"line":7,"address":[4720416,4721140,4721208],"length":1,"stats":{"Line":1},"fn_name":"new\u003creql_rust::arguments::Args\u003c(reql_rust::proto::Command, reql_rust::proto::Command)\u003e\u003e"},{"line":8,"address":[4720433],"length":1,"stats":{"Line":1},"fn_name":null},{"line":9,"address":[4720613],"length":1,"stats":{"Line":1},"fn_name":null},{"line":11,"address":[4720687,4720991],"length":1,"stats":{"Line":1},"fn_name":null},{"line":12,"address":[4720802,4720965],"length":1,"stats":{"Line":0},"fn_name":null},{"line":15,"address":[4720859,4720996],"length":1,"stats":{"Line":2},"fn_name":null},{"line":23,"address":[2649424],"length":1,"stats":{"Line":1},"fn_name":"into_branch_opts"},{"line":24,"address":[2649446],"length":1,"stats":{"Line":1},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[1946631,1946592,1946997,1947045],"length":1,"stats":{"Line":6},"fn_name":"test_branch_data"},{"line":47,"address":[7979921],"length":1,"stats":{"Line":1},"fn_name":null},{"line":48,"address":[7917042],"length":1,"stats":{"Line":4},"fn_name":null},{"line":49,"address":[7981936,7981842,7982179,7981623,7981899,7981149,7981437,7981213,7981366],"length":1,"stats":{"Line":6},"fn_name":null},{"line":50,"address":[7980643,7981228,7980904,7980869,7981185],"length":1,"stats":{"Line":3},"fn_name":null},{"line":51,"address":[7981193,7981396,7979992,7981281,7981565],"length":1,"stats":{"Line":5},"fn_name":null},{"line":52,"address":[7981746],"length":1,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[7982049,7982305,7982342],"length":1,"stats":{"Line":2},"fn_name":null},{"line":58,"address":[7982311],"length":1,"stats":{"Line":5},"fn_name":null},{"line":62,"address":[1947088,1947541,1947493,1947127],"length":1,"stats":{"Line":6},"fn_name":"test_branch_data_with_infix"},{"line":63,"address":[7982577],"length":1,"stats":{"Line":1},"fn_name":null},{"line":64,"address":[7792402],"length":1,"stats":{"Line":4},"fn_name":null},{"line":65,"address":[7984835,7984592,7984279,7984022,7984555,7984498,7983869,7983307,7983805,7984093],"length":1,"stats":{"Line":7},"fn_name":null},{"line":66,"address":[7983560,7983299],"length":1,"stats":{"Line":2},"fn_name":null},{"line":67,"address":[7983841,7983568,7983525,7983884],"length":1,"stats":{"Line":2},"fn_name":null},{"line":68,"address":[7792266],"length":1,"stats":{"Line":5},"fn_name":null},{"line":69,"address":[7984402],"length":1,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[7984998,7984961,7984705],"length":1,"stats":{"Line":2},"fn_name":null},{"line":75,"address":[1947504,1947119,1947164,1947224],"length":1,"stats":{"Line":5},"fn_name":null}],"covered":24,"coverable":33},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","ceil.rs"],"content":"use ql2::term::TermType;\n\nuse crate::Command;\n\npub(crate) fn new(args: impl CeilArg) -\u003e Command {\n    let mut command = Command::new(TermType::Ceil);\n\n    if let Some(arg) = args.into_ceil_opts() {\n        command = command.with_arg(arg)\n    }\n\n    command\n}\n\npub trait CeilArg {\n    fn into_ceil_opts(self) -\u003e Option\u003cCommand\u003e;\n}\n\nimpl CeilArg for () {\n    fn into_ceil_opts(self) -\u003e Option\u003cCommand\u003e {\n        None\n    }\n}\n\nimpl CeilArg for Command {\n    fn into_ceil_opts(self) -\u003e Option\u003cCommand\u003e {\n        Some(self)\n    }\n}\n\nimpl CeilArg for f64 {\n    fn into_ceil_opts(self) -\u003e Option\u003cCommand\u003e {\n        Some(Command::from_json(self))\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::Converter;\n    use crate::{r, Result};\n\n    #[tokio::test]\n    async fn test_ceil_data() -\u003e Result\u003c()\u003e {\n        let conn = r.connection().connect().await?;\n        let data_obtained: u8 = r.ceil(12.345).run(\u0026conn).await?.unwrap().parse()?;\n        let data_obtained2: u8 = r.expr(12.345).ceil().run(\u0026conn).await?.unwrap().parse()?;\n        let data_obtained3: u8 = r.ceil(r.expr(12.345)).run(\u0026conn).await?.unwrap().parse()?;\n\n        assert!(\n            data_obtained == 13\n                \u0026\u0026 data_obtained == data_obtained2\n                \u0026\u0026 data_obtained == data_obtained3\n        );\n\n        Ok(())\n    }\n}\n","traces":[{"line":5,"address":[2755792,2756339],"length":1,"stats":{"Line":3},"fn_name":"new\u003c()\u003e"},{"line":6,"address":[2674164,2674260],"length":1,"stats":{"Line":6},"fn_name":null},{"line":8,"address":[3413885,3412381,3413283,3413010,3412952,3412439,3413522,3412714,3413612],"length":1,"stats":{"Line":8},"fn_name":null},{"line":9,"address":[2674581,2674436],"length":1,"stats":{"Line":4},"fn_name":null},{"line":12,"address":[2756280],"length":1,"stats":{"Line":3},"fn_name":null},{"line":20,"address":[2748432],"length":1,"stats":{"Line":1},"fn_name":"into_ceil_opts"},{"line":21,"address":[2748436],"length":1,"stats":{"Line":1},"fn_name":null},{"line":26,"address":[2170240],"length":1,"stats":{"Line":1},"fn_name":"into_ceil_opts"},{"line":27,"address":[2170256],"length":1,"stats":{"Line":1},"fn_name":null},{"line":32,"address":[2748448],"length":1,"stats":{"Line":1},"fn_name":"into_ceil_opts"},{"line":33,"address":[2748474],"length":1,"stats":{"Line":1},"fn_name":null},{"line":43,"address":[2614320,2614377,2614297,2614446,2614288,2614703,2615003],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":44,"address":[2615014,2614473,2614663,2614825,2614436,2615283],"length":1,"stats":{"Line":4},"fn_name":null},{"line":45,"address":[2614491,2615273,2616288,2615528,2614620,2616192],"length":1,"stats":{"Line":5},"fn_name":null},{"line":46,"address":[2614506,2614577,2616278,2616516,2617211,2617307],"length":1,"stats":{"Line":5},"fn_name":null},{"line":47,"address":[2618203,2617508,2618296,2614521,2617297],"length":1,"stats":{"Line":4},"fn_name":null},{"line":49,"address":[2618531,2618571],"length":1,"stats":{"Line":1},"fn_name":null},{"line":50,"address":[2618522,2618281,2618468],"length":1,"stats":{"Line":3},"fn_name":null},{"line":51,"address":[2618459],"length":1,"stats":{"Line":1},"fn_name":null},{"line":52,"address":[2618516],"length":1,"stats":{"Line":1},"fn_name":null},{"line":55,"address":[2618549],"length":1,"stats":{"Line":5},"fn_name":null}],"covered":21,"coverable":21},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","change_at.rs"],"content":"use ql2::term::TermType;\nuse serde::Serialize;\n\nuse crate::Command;\n\npub(crate) fn new(offset: isize, value: impl Serialize) -\u003e Command {\n    let arg_offset = Command::from_json(offset);\n    let arg_value = Command::from_json(value);\n\n    Command::new(TermType::ChangeAt)\n        .with_arg(arg_offset)\n        .with_arg(arg_value)\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::Converter;\n    use crate::{r, Result};\n\n    #[tokio::test]\n    async fn test_change_at_ops() -\u003e Result\u003c()\u003e {\n        let conn = r.connection().connect().await?;\n        let response: [String; 3] = r\n            .expr([\"Moussa\", \"Ali\", \"Fati\"])\n            .change_at(1, \"Alima\")\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(response == [\"Moussa\", \"Alima\", \"Fati\"]);\n\n        Ok(())\n    }\n}\n","traces":[{"line":6,"address":[2981195,2980720,2981221],"length":1,"stats":{"Line":1},"fn_name":"new\u003c\u0026str\u003e"},{"line":7,"address":[2980866,2980771],"length":1,"stats":{"Line":2},"fn_name":null},{"line":8,"address":[2980874,2980935],"length":1,"stats":{"Line":2},"fn_name":null},{"line":10,"address":[2980943,2981141,2981075],"length":1,"stats":{"Line":3},"fn_name":null},{"line":11,"address":[2981014],"length":1,"stats":{"Line":1},"fn_name":null},{"line":12,"address":[2981082],"length":1,"stats":{"Line":1},"fn_name":null},{"line":21,"address":[2797847,2797808,2798213,2798261],"length":1,"stats":{"Line":6},"fn_name":"test_change_at_ops"},{"line":22,"address":[3001677,3001445,3001866,3001411,3002219,3001516],"length":1,"stats":{"Line":4},"fn_name":null},{"line":23,"address":[3002875,3002690,3003188,3002442,3002209,3003151,3003525,3002619,3003094,3002508],"length":1,"stats":{"Line":7},"fn_name":null},{"line":24,"address":[3002112],"length":1,"stats":{"Line":1},"fn_name":null},{"line":26,"address":[3002531,3002649,3002818,3001460,3002488],"length":1,"stats":{"Line":5},"fn_name":null},{"line":27,"address":[3002998],"length":1,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[3003680,3003647,3003400],"length":1,"stats":{"Line":2},"fn_name":null},{"line":33,"address":[2797839,2797884,2797944,2798224],"length":1,"stats":{"Line":5},"fn_name":null}],"covered":13,"coverable":14},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","changes.rs"],"content":"use ql2::term::TermType;\nuse reql_macros::CommandOptions;\nuse serde::Serialize;\n\nuse crate::types::Squash;\nuse crate::Command;\n\npub(crate) fn new(args: impl ChangesArg) -\u003e Command {\n    Command::new(TermType::Changes)\n        .with_opts(args.into_changes_opts())\n        .mark_change_feed()\n}\n\npub trait ChangesArg {\n    fn into_changes_opts(self) -\u003e ChangesOption;\n}\n\nimpl ChangesArg for () {\n    fn into_changes_opts(self) -\u003e ChangesOption {\n        Default::default()\n    }\n}\n\nimpl ChangesArg for ChangesOption {\n    fn into_changes_opts(self) -\u003e ChangesOption {\n        self\n    }\n}\n\n#[derive(Debug, Clone, Serialize, Default, PartialEq, PartialOrd, CommandOptions)]\npub struct ChangesOption {\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub squash: Option\u003cSquash\u003e,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub changefeed_queue_size: Option\u003cu32\u003e,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub include_initial: Option\u003cbool\u003e,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub include_states: Option\u003cbool\u003e,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub include_offsets: Option\u003cbool\u003e,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub include_types: Option\u003cbool\u003e,\n}\n","traces":[{"line":19,"address":[2418704],"length":1,"stats":{"Line":0},"fn_name":"into_changes_opts"},{"line":20,"address":[2418716],"length":1,"stats":{"Line":0},"fn_name":null},{"line":25,"address":[2418736],"length":1,"stats":{"Line":0},"fn_name":"into_changes_opts"},{"line":26,"address":[2418739],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":4},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","circle.rs"],"content":"use ql2::term::TermType;\nuse reql_macros::CommandOptions;\nuse serde::Serialize;\n\nuse crate::arguments::{Args, Unit};\nuse crate::types::{GeoSystem, Point};\nuse crate::Command;\n\npub(crate) fn new(args: impl CircleArg) -\u003e Command {\n    let (arg_point, arg_radius, opts) = args.into_circle_opts();\n\n    Command::new(TermType::Circle)\n        .with_arg(arg_point)\n        .with_arg(arg_radius)\n        .with_opts(opts)\n}\n\npub trait CircleArg {\n    fn into_circle_opts(self) -\u003e (Command, Command, CircleOption);\n}\n\nimpl CircleArg for Args\u003c(Point, f64)\u003e {\n    fn into_circle_opts(self) -\u003e (Command, Command, CircleOption) {\n        (\n            Command::from_json(self.0 .0),\n            Command::from_json(self.0 .1),\n            Default::default(),\n        )\n    }\n}\n\nimpl CircleArg for Args\u003c(Command, f64)\u003e {\n    fn into_circle_opts(self) -\u003e (Command, Command, CircleOption) {\n        (self.0 .0, Command::from_json(self.0 .1), Default::default())\n    }\n}\n\nimpl CircleArg for Args\u003c(Point, f64, CircleOption)\u003e {\n    fn into_circle_opts(self) -\u003e (Command, Command, CircleOption) {\n        (\n            Command::from_json(self.0 .0),\n            Command::from_json(self.0 .1),\n            self.0 .2,\n        )\n    }\n}\n\nimpl CircleArg for Args\u003c(Command, f64, CircleOption)\u003e {\n    fn into_circle_opts(self) -\u003e (Command, Command, CircleOption) {\n        (self.0 .0, Command::from_json(self.0 .1), self.0 .2)\n    }\n}\n\n#[derive(\n    Debug, Clone, Serialize, Default, PartialEq, Eq, PartialOrd, Ord, Hash, CommandOptions,\n)]\npub struct CircleOption {\n    /// the number of vertices in the polygon or line. Defaults to 32.\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub num_vertices: Option\u003cusize\u003e,\n    /// the reference ellipsoid to use for geographic coordinates.\n    /// Possible values are `WGS84` (the default), a common standard\n    /// for Earth’s geometry, or `UnitSphere`, a perfect sphere of 1 meter radius.\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub geo_system: Option\u003cGeoSystem\u003e,\n    /// Unit for the radius distance.\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub unit: Option\u003cUnit\u003e,\n    /// if `true` (the default) the circle is filled, creating a polygon;\n    /// if `false` the circle is unfilled (creating a line).\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub fill: Option\u003cbool\u003e,\n}\n\n// TODO write test\n","traces":[{"line":9,"address":[2531581,2531040],"length":1,"stats":{"Line":1},"fn_name":"new\u003creql_rust::arguments::Args\u003c(reql_rust::cmd::point::Point, f64)\u003e\u003e"},{"line":10,"address":[2531057],"length":1,"stats":{"Line":1},"fn_name":null},{"line":12,"address":[2531389,2531254,2531518,2531458],"length":1,"stats":{"Line":4},"fn_name":null},{"line":13,"address":[2531328],"length":1,"stats":{"Line":1},"fn_name":null},{"line":14,"address":[2531396],"length":1,"stats":{"Line":1},"fn_name":null},{"line":15,"address":[2531470],"length":1,"stats":{"Line":1},"fn_name":null},{"line":23,"address":[7629664,7629964],"length":1,"stats":{"Line":1},"fn_name":"into_circle_opts"},{"line":25,"address":[2649669],"length":1,"stats":{"Line":1},"fn_name":null},{"line":26,"address":[7629742],"length":1,"stats":{"Line":1},"fn_name":null},{"line":27,"address":[2649800],"length":1,"stats":{"Line":1},"fn_name":null},{"line":33,"address":[2650000,2650283],"length":1,"stats":{"Line":0},"fn_name":"into_circle_opts"},{"line":34,"address":[2650039],"length":1,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[2650320,2650617],"length":1,"stats":{"Line":0},"fn_name":"into_circle_opts"},{"line":41,"address":[2650341],"length":1,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[2650399],"length":1,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[2650473],"length":1,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[2650656,2650933],"length":1,"stats":{"Line":0},"fn_name":"into_circle_opts"},{"line":50,"address":[2650695],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":10,"coverable":18},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","coerce_to.rs"],"content":"use ql2::term::TermType;\nuse serde::Serialize;\n\nuse crate::Command;\n\npub(crate) fn new(value: impl Serialize) -\u003e Command {\n    Command::new(TermType::CoerceTo).with_arg(Command::from_json(value))\n}\n\n#[cfg(test)]\nmod tests {\n    use serde_json::json;\n\n    use crate::prelude::Converter;\n    use crate::spec::Post;\n    use crate::{r, Result};\n\n    #[tokio::test]\n    async fn test_coerce_to_ops() -\u003e Result\u003c()\u003e {\n        let data = Post::get_one_data();\n        let conn = r.connection().connect().await?;\n        let response: Post = r\n            .expr(json!([\n                [\"id\", 1],\n                [\"title\", \"title1\"],\n                [\"content\", \"content1\"],\n                [\"view\", 0]\n            ]))\n            .coerce_to(\"object\")\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        let response2: char = r\n            .expr(1)\n            .coerce_to(\"string\")\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(response == data);\n        assert!(response2 == '1');\n\n        Ok(())\n    }\n}\n","traces":[{"line":6,"address":[3395130,3394848],"length":1,"stats":{"Line":1},"fn_name":"new\u003c\u0026str\u003e"},{"line":7,"address":[3394891,3394996,3395120],"length":1,"stats":{"Line":2},"fn_name":null},{"line":19,"address":[4951616,4952021,4952069,4951655],"length":1,"stats":{"Line":6},"fn_name":"test_coerce_to_ops"},{"line":20,"address":[5533443],"length":1,"stats":{"Line":1},"fn_name":null},{"line":21,"address":[5533858,5534349,5533638,5533798,5533483,5534062],"length":1,"stats":{"Line":4},"fn_name":null},{"line":22,"address":[5537816,5536767,5536954,5537502,5537525,5537445,5537031,5536837,5537226],"length":1,"stats":{"Line":6},"fn_name":null},{"line":23,"address":[5534575,5534331],"length":1,"stats":{"Line":2},"fn_name":null},{"line":30,"address":[5537159,5533504,5536817,5533589,5536987,5536860],"length":1,"stats":{"Line":6},"fn_name":null},{"line":31,"address":[5537349],"length":1,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[5538404,5538680,5538132,5538012,5537949,5538209,5538623,5538918,5538720,5537710],"length":1,"stats":{"Line":7},"fn_name":null},{"line":38,"address":[5538165,5537992,5538035,5533522,5538337],"length":1,"stats":{"Line":5},"fn_name":null},{"line":39,"address":[5538527],"length":1,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[5538801,5539104,5539128],"length":1,"stats":{"Line":2},"fn_name":null},{"line":44,"address":[5539114,5539191],"length":1,"stats":{"Line":1},"fn_name":null},{"line":46,"address":[4951752,4952032,4951692,4951647],"length":1,"stats":{"Line":5},"fn_name":null}],"covered":13,"coverable":15},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","concat_map.rs"],"content":"use ql2::term::TermType;\n\nuse crate::prelude::Func;\nuse crate::Command;\n\npub(crate) fn new(func: Func) -\u003e Command {\n    Command::new(TermType::ConcatMap).with_arg(func.0)\n}\n\n// FIX Bug\n// #[cfg(test)]\n// mod tests {\n//     use crate::prelude::*;\n//     use crate::{r, Result};\n\n//     #[tokio::test]\n//     async fn test_concat_map_data() -\u003e Result\u003c()\u003e {\n//         let conn = r.connection().connect().await?;\n//         let data_obtained: Vec\u003cu8\u003e = r\n//             .expr([1, 2, 3])\n//             .concat_map(func!(|x| vec![r.expr(1), x * 2]))\n//             .run(\u0026conn)\n//             .await?\n//             .unwrap()\n//             .parse()?;\n\n//         assert!(data_obtained == vec![1, 2, 2, 4, 3, 6]);\n\n//         Ok(())\n//     }\n// }\n","traces":[{"line":6,"address":[2685136,2685321,2685352],"length":1,"stats":{"Line":0},"fn_name":"new"},{"line":7,"address":[2685247,2685158],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":2},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","config.rs"],"content":"use ql2::term::TermType;\n\nuse crate::Command;\n\npub(crate) fn new() -\u003e Command {\n    Command::new(TermType::Config)\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::Converter;\n    use crate::spec::{set_up, tear_down};\n    use crate::types::ConfigResponse;\n    use crate::Result;\n\n    #[tokio::test]\n    async fn test_get_config_info() -\u003e Result\u003c()\u003e {\n        let (conn, table, table_name) = set_up(false).await?;\n        let response: ConfigResponse = table.config().run(\u0026conn).await?.unwrap().parse()?;\n\n        assert!(response.name == table_name);\n\n        tear_down(conn, table_name.as_str()).await\n    }\n}\n","traces":[{"line":5,"address":[2435408],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":6,"address":[2435420],"length":1,"stats":{"Line":1},"fn_name":null},{"line":17,"address":[1786688,1786697,1786720,1786789,1786883,1787111,1787403],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":18,"address":[1787846,1786913,1787068,1787414,1786851,1787236],"length":1,"stats":{"Line":4},"fn_name":null},{"line":19,"address":[1787798,1788103,1788812,1787019,1786934,1788968],"length":1,"stats":{"Line":5},"fn_name":null},{"line":21,"address":[1789315,1788943,1789261],"length":1,"stats":{"Line":2},"fn_name":null},{"line":23,"address":[1789775,1789508,1789384,1786952,1789275,1789564,1789642],"length":1,"stats":{"Line":7},"fn_name":null}],"covered":7,"coverable":7},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","connect.rs"],"content":"#![allow(clippy::unused_io_amount)]\n\n//! Create a new connection to the database server\n\nuse std::borrow::Cow;\nuse std::fs::File;\nuse std::io::Read;\nuse std::sync::atomic::{AtomicBool, AtomicU64};\nuse std::sync::Arc;\nuse std::time::Duration;\n\nuse async_native_tls::{Certificate, TlsConnector};\nuse async_net::TcpStream;\nuse dashmap::DashMap;\nuse futures::channel::oneshot;\nuse futures::lock::Mutex;\nuse tokio::task;\nuse tokio::time;\n\nuse super::{StaticString, TcpStreamConnection};\nuse crate::constants::{\n    DEFAULT_RETHINKDB_DBNAME, DEFAULT_RETHINKDB_HOSTNAME, DEFAULT_RETHINKDB_PASSWORD,\n    DEFAULT_RETHINKDB_PORT, DEFAULT_RETHINKDB_USER,\n};\nuse crate::{InnerSession, Result, Session};\n\n#[derive(Debug)]\n#[non_exhaustive]\npub struct ConnectionCommand {\n    /// Host of the RethinkDB instance. The default value is `localhost`.\n    host: Cow\u003c'static, str\u003e,\n\n    /// The driver port, by default `28015`.\n    port: u16,\n\n    /// The database used if not explicitly specified in a query, by default `test`.\n    db: Cow\u003c'static, str\u003e,\n\n    /// The user account to connect as (default `admin`).\n    user: Cow\u003c'static, str\u003e,\n\n    /// The password for the user account to connect as (default `\"\"`, empty).\n    password: Cow\u003c'static, str\u003e,\n\n    timeout: Option\u003cDuration\u003e,\n\n    tls_connector: Option\u003cTlsConnector\u003e,\n}\n\n#[derive(Debug, Clone)]\n#[non_exhaustive]\npub struct SslContext\u003c'a\u003e {\n    pub ca_certs: \u0026'a str,\n    pub auth_key: Option\u003c\u0026'a str\u003e,\n}\n\nimpl ConnectionCommand {\n    /// This method connect to database\n    pub async fn connect(self) -\u003e Result\u003cSession\u003e {\n        if let Some(timeout) = self.timeout {\n            let (sender, reciever) = oneshot::channel();\n\n            task::spawn(async move { sender.send(self.create_session().await) });\n\n            let session = time::timeout(timeout, reciever)\n                .await\n                .unwrap_or_else(|_| {\n                    panic!(\n                        \"It took {} seconds to open the connection\",\n                        timeout.as_secs_f32()\n                    )\n                })\n                .expect(\"The connection has been closed\");\n\n            session\n        } else {\n            self.create_session().await\n        }\n    }\n\n    /// This method set database host\n    pub fn host(mut self, host: \u0026'static str) -\u003e Self {\n        self.host = host.static_string();\n        self\n    }\n\n    /// This method set database port\n    pub fn port(mut self, port: u16) -\u003e Self {\n        self.port = port;\n        self\n    }\n\n    /// This method set database name\n    pub fn dbname(mut self, dbname: \u0026'static str) -\u003e Self {\n        self.db = Cow::from(dbname);\n        self\n    }\n\n    /// This method set database user\n    pub fn user(mut self, user: \u0026'static str, password: \u0026'static str) -\u003e Self {\n        self.user = user.static_string();\n        self.password = password.static_string();\n        self\n    }\n\n    /// Timeout period in seconds for the connection to be opened\n    pub fn timeout(mut self, timeout: Duration) -\u003e Self {\n        self.timeout = Some(timeout);\n        self\n    }\n\n    /// This method set ssl connection\n    pub fn ssl_context(mut self, ssl_context: SslContext) -\u003e Self {\n        let mut file = File::open(ssl_context.ca_certs).unwrap();\n        let mut certificate = Vec::new();\n\n        file.read_to_end(\u0026mut certificate).unwrap();\n\n        let certificate = if let Ok(cert) = Certificate::from_pem(\u0026certificate) {\n            cert\n        } else {\n            Certificate::from_der(\u0026certificate).unwrap()\n        };\n\n        self.tls_connector = Some(TlsConnector::new().add_root_certificate(certificate));\n\n        self\n    }\n\n    async fn create_session(self) -\u003e Result\u003cSession\u003e {\n        let stream = TcpStream::connect((self.host.as_ref(), self.port)).await?;\n        let mut stream = TcpStreamConnection {\n            tls_stream: if let Some(connector) = \u0026self.tls_connector {\n                let stream = connector\n                    .connect(self.host.as_ref(), stream.clone())\n                    .await?;\n                Some(stream)\n            } else {\n                None\n            },\n            stream,\n        };\n\n        if let Some(tcp_stream) = stream.tls_stream {\n            stream.tls_stream = Some(tools::handshake(tcp_stream, \u0026self).await?);\n        } else {\n            stream.stream = tools::handshake(stream.stream, \u0026self).await?;\n        }\n\n        let inner = InnerSession {\n            stream: Mutex::new(stream),\n            db: Mutex::new(self.db),\n            channels: DashMap::new(),\n            token: AtomicU64::new(0),\n            broken: AtomicBool::new(false),\n            change_feed: AtomicBool::new(false),\n        };\n\n        Ok(Session {\n            inner: Arc::new(inner),\n        })\n    }\n}\n\nimpl Default for ConnectionCommand {\n    fn default() -\u003e Self {\n        Self {\n            host: DEFAULT_RETHINKDB_HOSTNAME.static_string(),\n            port: DEFAULT_RETHINKDB_PORT,\n            db: DEFAULT_RETHINKDB_DBNAME.static_string(),\n            user: DEFAULT_RETHINKDB_USER.static_string(),\n            password: DEFAULT_RETHINKDB_PASSWORD.static_string(),\n            timeout: None,\n            tls_connector: None,\n        }\n    }\n}\n\nmod tools {\n    use futures::io::{AsyncReadExt, AsyncWriteExt};\n    use futures::{AsyncRead, AsyncWrite};\n    use ql2::version_dummy::Version;\n    use scram::client::{ScramClient, ServerFinal, ServerFirst};\n    use serde::{Deserialize, Serialize};\n    use tracing::trace;\n\n    use super::ConnectionCommand;\n    use crate::cmd::bytes_to_string;\n    use crate::constants::{\n        BUFFER_SIZE, DEFAULT_AUTHENTICATION_METHOD, NULL_BYTE, PROTOCOL_VERSION,\n    };\n    use crate::{err, Result};\n\n    // Performs the actual handshake\n    //\n    // This method optimises message exchange as suggested in the RethinkDB\n    // documentation by sending message 3 right after message 1, without waiting\n    // for message 2 first.\n    pub async fn handshake\u003cT\u003e(mut stream: T, opts: \u0026ConnectionCommand) -\u003e Result\u003cT\u003e\n    where\n        T: Unpin + AsyncWrite + AsyncReadExt + AsyncRead + AsyncReadExt,\n    {\n        trace!(\"sending supported version to RethinkDB\");\n\n        stream\n            .write_all(\u0026(Version::V10 as i32).to_le_bytes())\n            .await?; // message 1\n\n        let scram = ScramClient::new(opts.user.as_ref(), opts.password.as_ref(), None);\n        let (scram, msg) = client_first(scram)?;\n        trace!(\"sending client first message\");\n        stream.write_all(\u0026msg).await?; // message 3\n\n        let mut buf = [0u8; BUFFER_SIZE];\n\n        trace!(\"receiving message(s) from RethinkDB\");\n        stream.read(\u0026mut buf).await?; // message 2\n        let (len, resp) = bytes(\u0026buf, 0);\n        trace!(\"received server info; info: {}\", bytes_to_string(resp));\n        ServerInfo::validate(resp)?;\n\n        let offset = len + 1;\n        let resp = if offset \u003c BUFFER_SIZE \u0026\u0026 buf[offset] != NULL_BYTE {\n            bytes(\u0026buf, offset).1\n        } else {\n            trace!(\"reading auth response\");\n            stream.read(\u0026mut buf).await?; // message 4\n            bytes(\u0026buf, 0).1\n        };\n        trace!(\"received auth response\");\n        let info = AuthResponse::from_slice(resp)?;\n        let auth = match info.authentication {\n            Some(auth) =\u003e auth,\n            None =\u003e {\n                let msg = String::from(\"server did not send authentication info\");\n                return Err(err::ReqlDriverError::Other(msg).into());\n            }\n        };\n\n        let (scram, msg) = client_final(scram, \u0026auth)?;\n        trace!(\"sending client final message\");\n        stream.write_all(\u0026msg).await?; // message 5\n\n        trace!(\"reading server final message\");\n        stream.read(\u0026mut buf).await?; // message 6\n        let resp = bytes(\u0026buf, 0).1;\n        trace!(\"received server final message\");\n        server_final(scram, resp)?;\n\n        trace!(\"client connected successfully\");\n\n        Ok(stream)\n    }\n    fn bytes(buf: \u0026[u8], offset: usize) -\u003e (usize, \u0026[u8]) {\n        let len = (\u0026buf[offset..])\n            .iter()\n            .take_while(|x| **x != NULL_BYTE)\n            .count();\n        let max = offset + len;\n        (max, \u0026buf[offset..max])\n    }\n\n    // We are going to use \u0026str for `server_version` because it is safe to do so.\n    // Unfortunately, the other fields that are using String, are doing so because\n    // because they can potentially contain an escaped double quote which is not\n    // supported by serde in \u0026str.\n    #[derive(Serialize, Deserialize, Debug)]\n    struct ServerInfo\u003c'a\u003e {\n        success: bool,\n        min_protocol_version: usize,\n        max_protocol_version: usize,\n        server_version: \u0026'a str,\n    }\n\n    impl ServerInfo\u003c'_\u003e {\n        fn validate(resp: \u0026[u8]) -\u003e Result\u003c()\u003e {\n            let info = serde_json::from_slice::\u003cServerInfo\u003e(resp)?;\n            if !info.success {\n                return Err(err::ReqlRuntimeError::Internal(bytes_to_string(resp)).into());\n            }\n            #[allow(clippy::absurd_extreme_comparisons)]\n            if PROTOCOL_VERSION \u003c info.min_protocol_version\n                || info.max_protocol_version \u003c PROTOCOL_VERSION\n            {\n                let msg = format!(\n                    \"unsupported protocol version {version}, expected between {min} and {max}\",\n                    version = PROTOCOL_VERSION,\n                    min = info.min_protocol_version,\n                    max = info.max_protocol_version,\n                );\n                return Err(err::ReqlDriverError::Other(msg).into());\n            }\n            Ok(())\n        }\n    }\n\n    #[derive(Serialize, Deserialize, Debug)]\n    struct AuthRequest {\n        protocol_version: usize,\n        authentication_method: \u0026'static str,\n        authentication: String,\n    }\n\n    fn client_first(scram: ScramClient\u003c'_\u003e) -\u003e Result\u003c(ServerFirst\u003c'_\u003e, Vec\u003cu8\u003e)\u003e {\n        let (scram, client_first) = scram.client_first();\n        let ar = AuthRequest {\n            protocol_version: PROTOCOL_VERSION,\n            authentication_method: DEFAULT_AUTHENTICATION_METHOD,\n            authentication: client_first,\n        };\n        let mut msg = serde_json::to_vec(\u0026ar)?;\n        msg.push(NULL_BYTE);\n        Ok((scram, msg))\n    }\n\n    #[derive(Serialize, Deserialize, Debug)]\n    struct AuthConfirmation {\n        authentication: String,\n    }\n\n    fn client_final(scram: ServerFirst\u003c'_\u003e, auth: \u0026str) -\u003e Result\u003c(ServerFinal, Vec\u003cu8\u003e)\u003e {\n        let scram = scram\n            .handle_server_first(auth)\n            .map_err(|x| x.to_string())\n            .map_err(err::ReqlDriverError::Other)?;\n        let (scram, client_final) = scram.client_final();\n        let conf = AuthConfirmation {\n            authentication: client_final,\n        };\n        let mut msg = serde_json::to_vec(\u0026conf)?;\n        msg.push(NULL_BYTE);\n        Ok((scram, msg))\n    }\n\n    #[derive(Serialize, Deserialize, Debug)]\n    struct AuthResponse {\n        success: bool,\n        authentication: Option\u003cString\u003e,\n        error_code: Option\u003cusize\u003e,\n        error: Option\u003cString\u003e,\n    }\n\n    impl AuthResponse {\n        fn from_slice(resp: \u0026[u8]) -\u003e Result\u003cSelf\u003e {\n            let info = serde_json::from_slice::\u003cAuthResponse\u003e(resp)?;\n            if !info.success {\n                // If error code is between 10 and 20, this is an auth error\n                if let Some(10..=20) = info.error_code {\n                    if let Some(msg) = info.error {\n                        return Err(err::ReqlDriverError::Auth(msg).into());\n                    }\n                }\n                return Err(err::ReqlRuntimeError::Internal(bytes_to_string(resp)).into());\n            }\n            Ok(info)\n        }\n    }\n\n    fn server_final(scram: ServerFinal, resp: \u0026[u8]) -\u003e Result\u003c()\u003e {\n        let info = AuthResponse::from_slice(resp)?;\n        if let Some(auth) = info.authentication {\n            if let Err(error) = scram.handle_server_final(\u0026auth) {\n                return Err(err::ReqlDriverError::Other(error.to_string()).into());\n            }\n        }\n        Ok(())\n    }\n}\n\n#[cfg(test)]\nmod test {\n    use crate::{ReqlDriverError, ReqlError};\n\n    use super::ConnectionCommand;\n\n    #[tokio::test]\n    async fn test_default_connection() {\n        execute_test(ConnectionCommand::default()).await\n    }\n\n    #[tokio::test]\n    async fn test_custom_connection() {\n        let connection_command = ConnectionCommand::default()\n            .host(\"127.0.0.1\")\n            .port(28015)\n            .user(\"admin\", \"\")\n            .dbname(\"test\");\n\n        execute_test(connection_command).await\n    }\n\n    async fn execute_test(connection_command: ConnectionCommand) {\n        let db_expected = connection_command.db.clone();\n\n        match connection_command.connect().await {\n            Ok(session) =\u003e {\n                let db_obtained = \u0026session.inner.db.lock().await;\n                assert!(db_obtained.eq(\u0026db_expected));\n            }\n            Err(err) =\u003e {\n                if let ReqlError::Driver(err) = err {\n                    match err {\n                        ReqlDriverError::Io(err, msg) =\u003e {\n                            assert!(std::io::ErrorKind::ConnectionRefused.eq(\u0026err), \"{}\", msg)\n                        }\n                        ReqlDriverError::Auth(msg) =\u003e assert!(true, \"{}\", msg),\n                        _ =\u003e (),\n                    }\n                }\n            }\n        };\n    }\n}\n","traces":[{"line":59,"address":[1503880,1504242,1504687,1505674,1504038,1503680,1504465,1503749],"length":1,"stats":{"Line":29},"fn_name":"{async_fn#0}"},{"line":60,"address":[1505585,1504106,1503860],"length":1,"stats":{"Line":5},"fn_name":null},{"line":61,"address":[1504134,1504764],"length":1,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[1505872,1504794,1505921,1506130,1504933],"length":1,"stats":{"Line":0},"fn_name":"{async_block#0}"},{"line":65,"address":[1503995,1505464,1503910,1505014],"length":1,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[1505450,1505728],"length":1,"stats":{"Line":0},"fn_name":"{closure#1}"},{"line":68,"address":[1505761],"length":1,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[1505750],"length":1,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[1505537],"length":1,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[1504298,1503928,1504476,1504168],"length":1,"stats":{"Line":15},"fn_name":null},{"line":82,"address":[2437184,2437427],"length":1,"stats":{"Line":1},"fn_name":"host"},{"line":83,"address":[2437293,2437237],"length":1,"stats":{"Line":2},"fn_name":null},{"line":84,"address":[2437407],"length":1,"stats":{"Line":1},"fn_name":null},{"line":88,"address":[2437456],"length":1,"stats":{"Line":1},"fn_name":"port"},{"line":89,"address":[2437476],"length":1,"stats":{"Line":1},"fn_name":null},{"line":90,"address":[2437483],"length":1,"stats":{"Line":1},"fn_name":null},{"line":94,"address":[2437504,2437749],"length":1,"stats":{"Line":1},"fn_name":"dbname"},{"line":95,"address":[2437609,2437562],"length":1,"stats":{"Line":2},"fn_name":null},{"line":96,"address":[2437729],"length":1,"stats":{"Line":1},"fn_name":null},{"line":100,"address":[2438209,2437776],"length":1,"stats":{"Line":1},"fn_name":"user"},{"line":101,"address":[2437862,2437924],"length":1,"stats":{"Line":2},"fn_name":null},{"line":102,"address":[2438036],"length":1,"stats":{"Line":1},"fn_name":null},{"line":103,"address":[2438186],"length":1,"stats":{"Line":1},"fn_name":null},{"line":107,"address":[2438240],"length":1,"stats":{"Line":0},"fn_name":"timeout"},{"line":108,"address":[2438261],"length":1,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[2438315],"length":1,"stats":{"Line":0},"fn_name":null},{"line":113,"address":[2438916,2439589,2438336],"length":1,"stats":{"Line":0},"fn_name":"ssl_context"},{"line":114,"address":[2438470,2438358],"length":1,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[2438505],"length":1,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[2438559,2438623],"length":1,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[2438760,2438646,2438914],"length":1,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[2438744],"length":1,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[2438845,2438765],"length":1,"stats":{"Line":0},"fn_name":null},{"line":125,"address":[2439056,2439018],"length":1,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[2439360],"length":1,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[1503318,1498158,1498460,1499275,1498842,1503140,1497920,1497981,1498535,1502339],"length":1,"stats":{"Line":34},"fn_name":"{async_fn#0}"},{"line":131,"address":[1498602,1498188,1498128,1499193,1498417,1498853],"length":1,"stats":{"Line":32},"fn_name":null},{"line":133,"address":[1500209,1499134,1499312],"length":1,"stats":{"Line":11},"fn_name":null},{"line":144,"address":[1500424,1501932,1499524,1501076],"length":1,"stats":{"Line":22},"fn_name":null},{"line":145,"address":[1498315,1498230,1501391,1501937,1500461],"length":1,"stats":{"Line":0},"fn_name":null},{"line":147,"address":[1500494,1500634,1501081,1498248],"length":1,"stats":{"Line":24},"fn_name":null},{"line":151,"address":[1501270],"length":1,"stats":{"Line":11},"fn_name":null},{"line":152,"address":[1502470],"length":1,"stats":{"Line":11},"fn_name":null},{"line":153,"address":[1502582],"length":1,"stats":{"Line":11},"fn_name":null},{"line":154,"address":[1502634,1502692],"length":1,"stats":{"Line":22},"fn_name":null},{"line":155,"address":[1502718],"length":1,"stats":{"Line":11},"fn_name":null},{"line":156,"address":[1502756],"length":1,"stats":{"Line":11},"fn_name":null},{"line":159,"address":[1503076],"length":1,"stats":{"Line":11},"fn_name":null},{"line":160,"address":[1503044],"length":1,"stats":{"Line":11},"fn_name":null},{"line":166,"address":[2439712,2440221],"length":1,"stats":{"Line":4},"fn_name":"default"},{"line":168,"address":[2439729],"length":1,"stats":{"Line":5},"fn_name":null},{"line":170,"address":[2439752],"length":1,"stats":{"Line":4},"fn_name":null},{"line":171,"address":[2439821],"length":1,"stats":{"Line":5},"fn_name":null},{"line":172,"address":[2439887],"length":1,"stats":{"Line":4},"fn_name":null},{"line":199,"address":[1522064,1522286,1521968,1543262],"length":1,"stats":{"Line":22},"fn_name":"handshake\u003casync_native_tls::tls_stream::TlsStream\u003casync_net::tcp::TcpStream\u003e\u003e"},{"line":203,"address":[1544896,1544542,1523383,1523021,1523901,1523814,1544809,1544016,1544378,1544695,1523700,1523547],"length":1,"stats":{"Line":33},"fn_name":null},{"line":205,"address":[1524410,1545792,1524611,1524792,1545229,1524234,1545697,1545407,1545608,1524506,1545503,1524700],"length":1,"stats":{"Line":55},"fn_name":null},{"line":206,"address":[1522490,1543858,1524537,1545534,1522863,1524246,1543485,1524433,1545243,1545430,1524670,1545667],"length":1,"stats":{"Line":44},"fn_name":null},{"line":207,"address":[1524776,1524814,1545776,1545814],"length":1,"stats":{"Line":0},"fn_name":null},{"line":209,"address":[1545738,1545912,1524741,1524909],"length":1,"stats":{"Line":22},"fn_name":null},{"line":210,"address":[1546035,1525029,1546467,1525458],"length":1,"stats":{"Line":11},"fn_name":null},{"line":211,"address":[1547362,1526036,1546683,1547045,1525674,1526467,1547563,1526353,1526200,1547209,1547476,1526554],"length":1,"stats":{"Line":33},"fn_name":null},{"line":212,"address":[1522511,1543807,1526887,1547896,1522812,1527433,1548444,1543506],"length":1,"stats":{"Line":22},"fn_name":null},{"line":214,"address":[1527302,1548313],"length":1,"stats":{"Line":11},"fn_name":null},{"line":216,"address":[1528215,1528062,1548547,1528329,1549226,1528416,1527536,1527898,1548909,1549340,1549427,1549073],"length":1,"stats":{"Line":33},"fn_name":null},{"line":217,"address":[1522761,1550139,1543756,1543527,1522532,1549760,1528749,1529125],"length":1,"stats":{"Line":24},"fn_name":null},{"line":218,"address":[1529092,1550209,1529195,1550106],"length":1,"stats":{"Line":22},"fn_name":null},{"line":219,"address":[1530177,1530763,1530264,1529910,1551777,1529384,1550398,1551191,1551278,1550760,1550924,1551077,1530063,1529746],"length":1,"stats":{"Line":33},"fn_name":null},{"line":220,"address":[1530781,1530889,1551795,1551903],"length":1,"stats":{"Line":11},"fn_name":null},{"line":222,"address":[1552087,1530861,1551875,1552069,1531073,1531055],"length":1,"stats":{"Line":22},"fn_name":null},{"line":223,"address":[1531106,1533228,1531063,1552077,1552120,1554245],"length":1,"stats":{"Line":13},"fn_name":null},{"line":224,"address":[1552366,1531352],"length":1,"stats":{"Line":10},"fn_name":null},{"line":226,"address":[1553077,1532063,1532417,1553431,1532216,1553230,1531899,1532330,1552913,1553344,1552551,1531537],"length":1,"stats":{"Line":6},"fn_name":null},{"line":227,"address":[1533126,1532750,1522553,1543548,1522710,1554143,1543705,1553764],"length":1,"stats":{"Line":6},"fn_name":null},{"line":228,"address":[1554213,1533196,1533093,1554110],"length":1,"stats":{"Line":4},"fn_name":null},{"line":230,"address":[1534033,1533919,1554619,1555137,1554783,1554257,1533240,1554936,1533766,1533602,1534120,1555050],"length":1,"stats":{"Line":33},"fn_name":null},{"line":231,"address":[1534522,1555539,1534770,1534445,1555787,1555462],"length":1,"stats":{"Line":22},"fn_name":null},{"line":232,"address":[1534741,1534945,1555962,1555758],"length":1,"stats":{"Line":11},"fn_name":null},{"line":233,"address":[1556002,1534985],"length":1,"stats":{"Line":11},"fn_name":null},{"line":234,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":235,"address":[1534947,1555964],"length":1,"stats":{"Line":0},"fn_name":null},{"line":236,"address":[1542686,1563803],"length":1,"stats":{"Line":0},"fn_name":null},{"line":240,"address":[1535650,1535371,1535301,1556682,1556079,1535062,1556333,1556403],"length":1,"stats":{"Line":22},"fn_name":null},{"line":241,"address":[1536418,1535892,1536685,1536772,1536254,1536571,1557286,1557450,1557717,1557804,1556924,1557603],"length":1,"stats":{"Line":33},"fn_name":null},{"line":242,"address":[1537105,1543569,1522574,1558655,1558137,1537621,1522659,1543654],"length":1,"stats":{"Line":22},"fn_name":null},{"line":244,"address":[1558758,1559284,1559638,1559551,1538403,1559437,1537724,1538086,1538604,1538250,1538517,1559120],"length":1,"stats":{"Line":33},"fn_name":null},{"line":245,"address":[1539313,1560350,1522592,1559971,1543587,1538937],"length":1,"stats":{"Line":12},"fn_name":null},{"line":246,"address":[1560420,1539280,1539383,1560317],"length":1,"stats":{"Line":22},"fn_name":null},{"line":247,"address":[1540074,1540341,1560947,1561264,1561111,1561378,1561465,1540428,1539548,1539910,1540227,1560585],"length":1,"stats":{"Line":33},"fn_name":null},{"line":248,"address":[1540777,1562084,1561814,1541038],"length":1,"stats":{"Line":11},"fn_name":null},{"line":250,"address":[1541774,1541909,1563075,1541622,1542086,1562838,1562973,1563150,1542011,1562686,1562342,1541293],"length":1,"stats":{"Line":33},"fn_name":null},{"line":252,"address":[1542413,1563477],"length":1,"stats":{"Line":11},"fn_name":null},{"line":254,"address":[2016912],"length":1,"stats":{"Line":11},"fn_name":"bytes"},{"line":255,"address":[2016984],"length":1,"stats":{"Line":11},"fn_name":null},{"line":257,"address":[2751648,2751661],"length":1,"stats":{"Line":22},"fn_name":"{closure#0}"},{"line":259,"address":[2017104,2017204],"length":1,"stats":{"Line":11},"fn_name":null},{"line":260,"address":[2017259,2017147],"length":1,"stats":{"Line":22},"fn_name":null},{"line":276,"address":[2017280],"length":1,"stats":{"Line":11},"fn_name":"validate"},{"line":277,"address":[2017323,2017439],"length":1,"stats":{"Line":11},"fn_name":null},{"line":278,"address":[2017422],"length":1,"stats":{"Line":11},"fn_name":null},{"line":279,"address":[2017511],"length":1,"stats":{"Line":0},"fn_name":null},{"line":282,"address":[2017483,2017644],"length":1,"stats":{"Line":22},"fn_name":null},{"line":283,"address":[2017635],"length":1,"stats":{"Line":11},"fn_name":null},{"line":285,"address":[2017690],"length":1,"stats":{"Line":0},"fn_name":null},{"line":291,"address":[2017942],"length":1,"stats":{"Line":0},"fn_name":null},{"line":293,"address":[2017678],"length":1,"stats":{"Line":11},"fn_name":null},{"line":304,"address":[2018096,2019185,2019245],"length":1,"stats":{"Line":11},"fn_name":"client_first"},{"line":305,"address":[2018112],"length":1,"stats":{"Line":11},"fn_name":null},{"line":311,"address":[2018608,2018399,2018470],"length":1,"stats":{"Line":22},"fn_name":null},{"line":312,"address":[2018580],"length":1,"stats":{"Line":11},"fn_name":null},{"line":313,"address":[2018817],"length":1,"stats":{"Line":11},"fn_name":null},{"line":321,"address":[2020897,2019280,2020951],"length":1,"stats":{"Line":11},"fn_name":"client_final"},{"line":322,"address":[2019902,2019322],"length":1,"stats":{"Line":11},"fn_name":null},{"line":324,"address":[2751680,2751696],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":325,"address":[2019774],"length":1,"stats":{"Line":0},"fn_name":null},{"line":326,"address":[2019979,2019658],"length":1,"stats":{"Line":22},"fn_name":null},{"line":330,"address":[2020171,2020380,2020242],"length":1,"stats":{"Line":22},"fn_name":null},{"line":331,"address":[2020352],"length":1,"stats":{"Line":11},"fn_name":null},{"line":332,"address":[2020575],"length":1,"stats":{"Line":11},"fn_name":null},{"line":344,"address":[2021767,2020992,2021723],"length":1,"stats":{"Line":11},"fn_name":"from_slice"},{"line":345,"address":[2021034,2021170],"length":1,"stats":{"Line":11},"fn_name":null},{"line":346,"address":[2021149],"length":1,"stats":{"Line":11},"fn_name":null},{"line":348,"address":[2021345,2021294],"length":1,"stats":{"Line":0},"fn_name":null},{"line":349,"address":[2021353],"length":1,"stats":{"Line":0},"fn_name":null},{"line":350,"address":[2021410,2021555],"length":1,"stats":{"Line":0},"fn_name":null},{"line":353,"address":[2021608,2021323],"length":1,"stats":{"Line":0},"fn_name":null},{"line":355,"address":[2021211],"length":1,"stats":{"Line":11},"fn_name":null},{"line":359,"address":[2022781,2021952],"length":1,"stats":{"Line":11},"fn_name":"server_final"},{"line":360,"address":[2022016,2022168],"length":1,"stats":{"Line":11},"fn_name":null},{"line":361,"address":[2022270,2022140],"length":1,"stats":{"Line":22},"fn_name":null},{"line":362,"address":[2022304,2022486],"length":1,"stats":{"Line":22},"fn_name":null},{"line":363,"address":[2022575,2022872],"length":1,"stats":{"Line":0},"fn_name":null},{"line":366,"address":[2022393],"length":1,"stats":{"Line":11},"fn_name":null},{"line":377,"address":[2613073,2612933,2613141,2612960,2613007,2613431,2612928],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":378,"address":[2613266,2613094,2613442,2613063],"length":1,"stats":{"Line":7},"fn_name":null},{"line":382,"address":[2613665,2613733,2613599,2614194,2613520,2613552,2613525],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":383,"address":[2613655,2613842],"length":1,"stats":{"Line":2},"fn_name":null},{"line":389,"address":[2614205,2614014,2613686],"length":1,"stats":{"Line":6},"fn_name":null},{"line":392,"address":[2607979,2610350,2607813,2608137,2608560,2610397,2607760],"length":1,"stats":{"Line":5},"fn_name":"{async_fn#0}"},{"line":393,"address":[2607948],"length":1,"stats":{"Line":1},"fn_name":null},{"line":395,"address":[2608387,2608253,2608571,2608094,2608009],"length":1,"stats":{"Line":4},"fn_name":null},{"line":396,"address":[2608793],"length":1,"stats":{"Line":1},"fn_name":null},{"line":397,"address":[2609816,2608817,2608027],"length":1,"stats":{"Line":2},"fn_name":null},{"line":398,"address":[2610147,2610212,2610259],"length":1,"stats":{"Line":2},"fn_name":null},{"line":400,"address":[2608843],"length":1,"stats":{"Line":0},"fn_name":null},{"line":401,"address":[2608986,2609588,2608880],"length":1,"stats":{"Line":0},"fn_name":null},{"line":402,"address":[2608947],"length":1,"stats":{"Line":0},"fn_name":null},{"line":403,"address":[2609084],"length":1,"stats":{"Line":0},"fn_name":null},{"line":404,"address":[2609138,2609290,2609265],"length":1,"stats":{"Line":0},"fn_name":null},{"line":406,"address":[2609379,2609013],"length":1,"stats":{"Line":0},"fn_name":null},{"line":407,"address":[2609008],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":110,"coverable":151},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","contains.rs"],"content":"use ql2::term::TermType;\nuse serde::Serialize;\n\nuse crate::arguments::Args;\nuse crate::prelude::Func;\nuse crate::Command;\n\nuse super::CmdOpts;\n\npub(crate) fn new(args: impl ContainsArg) -\u003e Command {\n    args.into_contains_opts()\n        .add_to_cmd(Command::new(TermType::Contains))\n}\n\npub trait ContainsArg {\n    fn into_contains_opts(self) -\u003e CmdOpts;\n}\n\nimpl\u003cT\u003e ContainsArg for T\nwhere\n    T: Serialize,\n{\n    fn into_contains_opts(self) -\u003e CmdOpts {\n        CmdOpts::Single(Command::from_json(self))\n    }\n}\n\nimpl ContainsArg for Func {\n    fn into_contains_opts(self) -\u003e CmdOpts {\n        CmdOpts::Single(self.0)\n    }\n}\n\nimpl ContainsArg for Command {\n    fn into_contains_opts(self) -\u003e CmdOpts {\n        CmdOpts::Single(self)\n    }\n}\n\nimpl\u003cS, T\u003e ContainsArg for Args\u003cT\u003e\nwhere\n    S: Into\u003cCommand\u003e,\n    T: IntoIterator\u003cItem = S\u003e,\n{\n    fn into_contains_opts(self) -\u003e CmdOpts {\n        CmdOpts::Many(self.0.into_iter().map(|cmd| cmd.into()).collect())\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::Converter;\n    use crate::{r, Result};\n\n    #[tokio::test]\n    async fn test_contains_ops() -\u003e Result\u003c()\u003e {\n        let conn = r.connection().connect().await?;\n        let response: bool = r\n            .expr([\"red\", \"green\", \"blue\"])\n            .contains(\"green\")\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(response);\n\n        Ok(())\n    }\n}\n","traces":[{"line":10,"address":[5011024,5011204,5011231],"length":1,"stats":{"Line":1},"fn_name":"new\u003c\u0026str\u003e"},{"line":11,"address":[5011057,5011155],"length":1,"stats":{"Line":2},"fn_name":null},{"line":12,"address":[5011224,5011188,5011083],"length":1,"stats":{"Line":2},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":29,"address":[2740480],"length":1,"stats":{"Line":0},"fn_name":"into_contains_opts"},{"line":30,"address":[2740496],"length":1,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[2170304],"length":1,"stats":{"Line":0},"fn_name":"into_contains_opts"},{"line":36,"address":[2170320],"length":1,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[4759056,4759065,4759213,4759348,4759647,4759145,4759088],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":57,"address":[4760011,4759308,4759658,4759203,4759469,4759237],"length":1,"stats":{"Line":4},"fn_name":null},{"line":58,"address":[4760234,4760937,4760974,4760294,4760476,4760661,4760001,4761164,4760405,4760880],"length":1,"stats":{"Line":7},"fn_name":null},{"line":59,"address":[4759904],"length":1,"stats":{"Line":1},"fn_name":null},{"line":61,"address":[4760435,4760274,4760317,4760604,4759252],"length":1,"stats":{"Line":5},"fn_name":null},{"line":62,"address":[4760784],"length":1,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[4761276,4761053],"length":1,"stats":{"Line":1},"fn_name":null},{"line":68,"address":[2575160,2575440,2575100,2575055],"length":1,"stats":{"Line":5},"fn_name":null}],"covered":12,"coverable":19},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","count.rs"],"content":"use ql2::term::TermType;\nuse serde::Serialize;\n\nuse crate::arguments::Args;\nuse crate::prelude::Func;\nuse crate::Command;\n\npub(crate) fn new(args: impl CountArg) -\u003e Command {\n    let mut command = Command::new(TermType::Count);\n\n    if let Some(arg) = args.into_count_arg() {\n        command = command.with_arg(arg)\n    }\n\n    command\n}\n\npub trait CountArg {\n    fn into_count_arg(self) -\u003e Option\u003cCommand\u003e;\n}\n\nimpl CountArg for () {\n    fn into_count_arg(self) -\u003e Option\u003cCommand\u003e {\n        None\n    }\n}\n\nimpl CountArg for Command {\n    fn into_count_arg(self) -\u003e Option\u003cCommand\u003e {\n        Some(self)\n    }\n}\n\nimpl CountArg for Func {\n    fn into_count_arg(self) -\u003e Option\u003cCommand\u003e {\n        Some(self.0)\n    }\n}\n\nimpl\u003cT\u003e CountArg for Args\u003cT\u003e\nwhere\n    T: Serialize,\n{\n    fn into_count_arg(self) -\u003e Option\u003cCommand\u003e {\n        Some(Command::from_json(self.0))\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::Converter;\n    use crate::spec::{set_up, tear_down, Post};\n    use crate::Result;\n\n    #[tokio::test]\n    async fn test_count_data() -\u003e Result\u003c()\u003e {\n        let data = Post::get_many_data();\n        let (conn, table, table_name) = set_up(true).await?;\n        let data_obtained: usize = table.count(()).run(\u0026conn).await?.unwrap().parse()?;\n\n        assert!(data_obtained == data.len());\n\n        tear_down(conn, \u0026table_name).await\n    }\n}\n","traces":[{"line":8,"address":[1692448,1692975],"length":1,"stats":{"Line":1},"fn_name":"new\u003c()\u003e"},{"line":9,"address":[1692560,1692468],"length":1,"stats":{"Line":2},"fn_name":null},{"line":11,"address":[1692568,1692626,1692899],"length":1,"stats":{"Line":2},"fn_name":null},{"line":12,"address":[1692732,1692873],"length":1,"stats":{"Line":0},"fn_name":null},{"line":15,"address":[1692924],"length":1,"stats":{"Line":1},"fn_name":null},{"line":23,"address":[2468912],"length":1,"stats":{"Line":1},"fn_name":"into_count_arg"},{"line":24,"address":[5631588],"length":1,"stats":{"Line":1},"fn_name":null},{"line":29,"address":[2170384],"length":1,"stats":{"Line":0},"fn_name":"into_count_arg"},{"line":30,"address":[2170400],"length":1,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[2740560],"length":1,"stats":{"Line":0},"fn_name":"into_count_arg"},{"line":36,"address":[2740576],"length":1,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[2575559,2575925,2575520,2575973],"length":1,"stats":{"Line":6},"fn_name":"test_count_data"},{"line":57,"address":[5157651],"length":1,"stats":{"Line":1},"fn_name":null},{"line":58,"address":[5158021,5157856,5158081,5158256,5158689,5157703],"length":1,"stats":{"Line":4},"fn_name":null},{"line":59,"address":[5159626,5159727,5158641,5157807,5157724,5158897],"length":1,"stats":{"Line":5},"fn_name":null},{"line":61,"address":[5159712,5160065,5160126],"length":1,"stats":{"Line":2},"fn_name":null},{"line":63,"address":[2575551,2575596,2575656,2575936],"length":1,"stats":{"Line":7},"fn_name":null}],"covered":12,"coverable":19},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","date.rs"],"content":"use ql2::term::TermType;\n\nuse crate::Command;\n\npub(crate) fn new() -\u003e Command {\n    Command::new(TermType::Date)\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::Converter;\n    use crate::types::Time;\n    use crate::{r, Result};\n\n    #[tokio::test]\n    async fn test_date_ops() -\u003e Result\u003c()\u003e {\n        let conn = r.connection().connect().await?;\n\n        let datetime = r.now().date();\n        let date1 = datetime.clone().value();\n        let date2: Time = datetime.cmd().run(\u0026conn).await?.unwrap().parse()?;\n\n        assert!(date1 == date2);\n\n        Ok(())\n    }\n}\n","traces":[{"line":5,"address":[2307776],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":6,"address":[2307788],"length":1,"stats":{"Line":1},"fn_name":null},{"line":16,"address":[2576055,2576469,2576016,2576421],"length":1,"stats":{"Line":6},"fn_name":"test_date_ops"},{"line":17,"address":[7964490,7963879,7963806,7963760,7964229,7964040],"length":1,"stats":{"Line":4},"fn_name":null},{"line":19,"address":[7964480,7964736],"length":1,"stats":{"Line":2},"fn_name":null},{"line":20,"address":[7964764,7964827],"length":1,"stats":{"Line":2},"fn_name":null},{"line":21,"address":[7891529,7891603],"length":1,"stats":{"Line":4},"fn_name":null},{"line":23,"address":[7966079,7966112,7965806],"length":1,"stats":{"Line":2},"fn_name":null},{"line":25,"address":[2576432,2576047,2576152,2576092],"length":1,"stats":{"Line":5},"fn_name":null}],"covered":9,"coverable":9},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","day.rs"],"content":"use ql2::term::TermType;\n\nuse crate::Command;\n\npub(crate) fn new() -\u003e Command {\n    Command::new(TermType::Day)\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::Converter;\n    use crate::{r, Result};\n\n    #[tokio::test]\n    async fn test_day_ops() -\u003e Result\u003c()\u003e {\n        let conn = r.connection().connect().await?;\n\n        let day = r.now().day();\n        let day1 = day.clone().value();\n        let day2: u8 = day.cmd().run(\u0026conn).await?.unwrap().parse()?;\n\n        assert!(day1 == day2);\n\n        Ok(())\n    }\n}\n","traces":[{"line":5,"address":[2307824],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":6,"address":[2307836],"length":1,"stats":{"Line":1},"fn_name":null},{"line":15,"address":[4740752,4740886,4740809,4741322,4740720,4740729,4741023],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":16,"address":[4740983,4740864,4741594,4741333,4741144,4740910],"length":1,"stats":{"Line":4},"fn_name":null},{"line":18,"address":[4741840,4741584],"length":1,"stats":{"Line":2},"fn_name":null},{"line":19,"address":[4741931,4741868],"length":1,"stats":{"Line":2},"fn_name":null},{"line":20,"address":[4740925,4741975,4742870,4742775,4742062],"length":1,"stats":{"Line":3},"fn_name":null},{"line":22,"address":[4742849,4743063],"length":1,"stats":{"Line":1},"fn_name":null},{"line":24,"address":[4743033],"length":1,"stats":{"Line":5},"fn_name":null}],"covered":9,"coverable":9},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","day_of_week.rs"],"content":"use ql2::term::TermType;\n\nuse crate::Command;\n\npub(crate) fn new() -\u003e Command {\n    Command::new(TermType::DayOfWeek)\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::Converter;\n    use crate::{r, Result};\n\n    #[tokio::test]\n    async fn test_day_of_week_ops() -\u003e Result\u003c()\u003e {\n        let conn = r.connection().connect().await?;\n\n        let day_of_week = r.now().day_of_week();\n        let day_of_week1 = day_of_week.clone().value();\n        let day_of_week2: u8 = day_of_week.cmd().run(\u0026conn).await?.unwrap().parse()?;\n\n        assert!(day_of_week1 == day_of_week2);\n\n        Ok(())\n    }\n}\n","traces":[{"line":5,"address":[2028640],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":6,"address":[2028652],"length":1,"stats":{"Line":1},"fn_name":null},{"line":15,"address":[4547110,4547033,4546976,4547247,4546953,4547546,4546944],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":16,"address":[4547134,4547088,4547368,4547557,4547818,4547207],"length":1,"stats":{"Line":4},"fn_name":null},{"line":18,"address":[4548064,4547808],"length":1,"stats":{"Line":2},"fn_name":null},{"line":19,"address":[4548155,4548092],"length":1,"stats":{"Line":2},"fn_name":null},{"line":20,"address":[4547149,4548999,4548199,4549094,4548286],"length":1,"stats":{"Line":4},"fn_name":null},{"line":22,"address":[4549287,4549073],"length":1,"stats":{"Line":1},"fn_name":null},{"line":24,"address":[4549257],"length":1,"stats":{"Line":5},"fn_name":null}],"covered":9,"coverable":9},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","day_of_year.rs"],"content":"use ql2::term::TermType;\n\nuse crate::Command;\n\npub(crate) fn new() -\u003e Command {\n    Command::new(TermType::DayOfYear)\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::Converter;\n    use crate::{r, Result};\n\n    #[tokio::test]\n    async fn test_day_of_year_ops() -\u003e Result\u003c()\u003e {\n        let conn = r.connection().connect().await?;\n\n        let day_of_year = r.now().day_of_year();\n        let day_of_year1 = day_of_year.clone().value();\n        let day_of_year2: u16 = day_of_year.cmd().run(\u0026conn).await?.unwrap().parse()?;\n\n        assert!(day_of_year1 == day_of_year2);\n\n        Ok(())\n    }\n}\n","traces":[{"line":5,"address":[2155648],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":6,"address":[2155660],"length":1,"stats":{"Line":1},"fn_name":null},{"line":15,"address":[2576551,2576917,2576965,2576512],"length":1,"stats":{"Line":6},"fn_name":"test_day_of_year_ops"},{"line":16,"address":[5516112,5516158,5516231,5516842,5516581,5516392],"length":1,"stats":{"Line":4},"fn_name":null},{"line":18,"address":[5516832,5517088],"length":1,"stats":{"Line":2},"fn_name":null},{"line":19,"address":[5517179,5517116],"length":1,"stats":{"Line":2},"fn_name":null},{"line":20,"address":[5517313,5518026,5517226,5516173,5518126],"length":1,"stats":{"Line":4},"fn_name":null},{"line":22,"address":[5518104,5518319],"length":1,"stats":{"Line":1},"fn_name":null},{"line":24,"address":[2576543,2576588,2576648,2576928],"length":1,"stats":{"Line":5},"fn_name":null}],"covered":9,"coverable":9},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","db.rs"],"content":"use ql2::term::TermType;\n\nuse crate::Command;\n\npub(crate) fn new(db_name: impl Into\u003cString\u003e) -\u003e Command {\n    let arg = Command::from_json(db_name.into());\n\n    Command::new(TermType::Db).with_arg(arg)\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::{r, ReqlError, ReqlRuntimeError, Result};\n\n    #[tokio::test]\n    async fn test_select_db() -\u003e Result\u003c()\u003e {\n        let conn = r.connection().connect().await?;\n        let response = r.db(\"test\").run(\u0026conn).await.err().unwrap();\n\n        if let ReqlError::Runtime(err) = response {\n            if let ReqlRuntimeError::QueryLogic(msg) = err {\n                assert!(true, \"{}\", msg);\n                return Ok(());\n            }\n        }\n\n        assert!(false);\n        Ok(())\n    }\n}\n","traces":[{"line":5,"address":[2307872,2308113,2308144],"length":1,"stats":{"Line":3},"fn_name":"new\u003c\u0026str\u003e"},{"line":6,"address":[2307905],"length":1,"stats":{"Line":3},"fn_name":null},{"line":8,"address":[2308025,2307954],"length":1,"stats":{"Line":6},"fn_name":null},{"line":16,"address":[1952633,1952844,1953143,1952709,1952544,1952553,1952576],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":17,"address":[1952683,1952965,1952733,1953154,1952804,1953427],"length":1,"stats":{"Line":4},"fn_name":null},{"line":18,"address":[1952748,1953677,1953397],"length":1,"stats":{"Line":3},"fn_name":null},{"line":20,"address":[1954171,1954109],"length":1,"stats":{"Line":1},"fn_name":null},{"line":21,"address":[1954185,1954158],"length":1,"stats":{"Line":2},"fn_name":null},{"line":22,"address":[1954233,1954462],"length":1,"stats":{"Line":1},"fn_name":null},{"line":23,"address":[1954431],"length":1,"stats":{"Line":1},"fn_name":null},{"line":27,"address":[1954330,1954173],"length":1,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[1954305],"length":1,"stats":{"Line":4},"fn_name":null}],"covered":11,"coverable":12},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","db_create.rs"],"content":"use ql2::term::TermType;\n\nuse crate::Command;\n\npub(crate) fn new(db_name: impl Into\u003cString\u003e) -\u003e Command {\n    Command::new(TermType::DbCreate).with_arg(Command::from_json(db_name.into()))\n}\n\n#[cfg(test)]\nmod tests {\n    use uuid::Uuid;\n\n    use crate::prelude::*;\n    use crate::types::DbResponse;\n    use crate::{r, Result};\n\n    #[tokio::test]\n    async fn test_create_db() -\u003e Result\u003c()\u003e {\n        let dbname = Uuid::new_v4().to_string();\n        let conn = r.connection().connect().await?;\n        let db_created: DbResponse = r\n            .db_create(dbname.as_str())\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(db_created.dbs_created == Some(1));\n\n        r.db_drop(\u0026dbname).run(\u0026conn).await?;\n        Ok(())\n    }\n}\n","traces":[{"line":5,"address":[5011651,5011344],"length":1,"stats":{"Line":1},"fn_name":"new\u003c\u0026str\u003e"},{"line":6,"address":[5011641,5011386,5011490],"length":1,"stats":{"Line":2},"fn_name":null},{"line":18,"address":[1790144,1790121,1790201,1790112,1790463,1790265,1790833],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":19,"address":[1790246,1790579],"length":1,"stats":{"Line":2},"fn_name":null},{"line":20,"address":[1790292,1790844,1791108,1790594,1790655,1790423],"length":1,"stats":{"Line":4},"fn_name":null},{"line":21,"address":[1791327,1791946,1791541,1792026,1791359,1791470,1792376,1791727,1792003],"length":1,"stats":{"Line":6},"fn_name":null},{"line":22,"address":[1791088],"length":1,"stats":{"Line":1},"fn_name":null},{"line":23,"address":[1790307,1790380,1791339,1791382,1791500,1791669],"length":1,"stats":{"Line":6},"fn_name":null},{"line":24,"address":[1791850],"length":1,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[1792518,1792544,1792251],"length":1,"stats":{"Line":2},"fn_name":null},{"line":30,"address":[1792605,1792537,1790322],"length":1,"stats":{"Line":3},"fn_name":null},{"line":31,"address":[1793352],"length":1,"stats":{"Line":5},"fn_name":null}],"covered":11,"coverable":12},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","db_drop.rs"],"content":"use ql2::term::TermType;\n\nuse crate::Command;\n\npub(crate) fn new(db_name: impl Into\u003cString\u003e) -\u003e Command {\n    Command::new(TermType::DbDrop).with_arg(Command::from_json(db_name.into()))\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::*;\n    use crate::types::DbResponse;\n    use crate::{r, Result};\n\n    #[tokio::test]\n    async fn test_drop_db() -\u003e Result\u003c()\u003e {\n        let dbname = \"zuma\";\n        let conn = r.connection().connect().await?;\n        r.db_create(dbname).run(\u0026conn).await?;\n\n        let db_dropped: DbResponse = r.db_drop(dbname).run(\u0026conn).await?.unwrap().parse()?;\n\n        assert!(db_dropped.dbs_dropped == Some(1));\n        Ok(())\n    }\n}\n","traces":[{"line":5,"address":[2840401,2839776,2840083,2840112],"length":1,"stats":{"Line":2},"fn_name":"new\u003c\u0026str\u003e"},{"line":6,"address":[2840391,2840073,2840141,2840240,2839818,2839922],"length":1,"stats":{"Line":4},"fn_name":null},{"line":16,"address":[1849989,1849536,1849575,1849941],"length":1,"stats":{"Line":6},"fn_name":"test_drop_db"},{"line":17,"address":[7958561],"length":1,"stats":{"Line":1},"fn_name":null},{"line":18,"address":[7900097],"length":1,"stats":{"Line":4},"fn_name":null},{"line":19,"address":[7899987,7900038],"length":1,"stats":{"Line":4},"fn_name":null},{"line":21,"address":[7899935,7899884],"length":1,"stats":{"Line":4},"fn_name":null},{"line":23,"address":[7961547,7961279,7961514],"length":1,"stats":{"Line":2},"fn_name":null},{"line":24,"address":[1849612,1849952,1849672,1849567],"length":1,"stats":{"Line":5},"fn_name":null}],"covered":9,"coverable":9},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","db_list.rs"],"content":"use ql2::term::TermType;\n\nuse crate::Command;\n\npub(crate) fn new() -\u003e Command {\n    Command::new(TermType::DbList)\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::*;\n    use crate::{r, Result};\n\n    #[tokio::test]\n    async fn test_list_db() -\u003e Result\u003c()\u003e {\n        let conn = r.connection().connect().await?;\n        let db_list: Vec\u003cString\u003e = r.db_list().run(\u0026conn).await?.unwrap().parse()?;\n\n        assert!(db_list.len() \u003e 0);\n        Ok(())\n    }\n}\n","traces":[{"line":5,"address":[2702064],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":6,"address":[2702076],"length":1,"stats":{"Line":1},"fn_name":null},{"line":15,"address":[1865305,1865216,1865373,1865807,1865225,1865248,1865508],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":16,"address":[1865818,1865363,1866079,1865397,1865468,1865629],"length":1,"stats":{"Line":4},"fn_name":null},{"line":17,"address":[1867147,1865412,1867007,1866069,1866307],"length":1,"stats":{"Line":4},"fn_name":null},{"line":19,"address":[1867120,1867370,1867414],"length":1,"stats":{"Line":2},"fn_name":null},{"line":20,"address":[1867383],"length":1,"stats":{"Line":5},"fn_name":null}],"covered":7,"coverable":7},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","default.rs"],"content":"use ql2::term::TermType;\nuse serde::Serialize;\n\nuse crate::Command;\n\npub(crate) fn new(args: impl Serialize) -\u003e Command {\n    Command::new(TermType::Default).with_arg(Command::from_json(args))\n}\n\n#[cfg(test)]\nmod tests {\n    use std::collections::HashMap;\n\n    use serde::{Deserialize, Serialize};\n\n    use crate::prelude::*;\n    use crate::spec::{set_up, tear_down, Post};\n    use crate::{r, Result};\n\n    #[derive(Debug, Serialize, Deserialize, PartialEq, Eq)]\n    struct InnerPost {\n        title: String,\n        content: String,\n    }\n\n    #[tokio::test]\n    async fn test_default_ops() -\u003e Result\u003c()\u003e {\n        let data: Vec\u003cInnerPost\u003e = Post::get_many_data()\n            .into_iter()\n            .map(|post| InnerPost {\n                title: post.title,\n                content: if let Some(content) = post.content {\n                    content\n                } else {\n                    \"Anonymous\".to_owned()\n                },\n            })\n            .collect();\n        let (conn, table, table_name) = set_up(true).await?;\n        let response: Vec\u003cInnerPost\u003e = table\n            .order_by(r.expr(\"title\"))\n            .map(func!(|doc| {\n                let mut post = HashMap::new();\n                post.insert(\"title\", doc.clone().g(\"title\"));\n                post.insert(\"content\", doc.g(\"content\").default(\"Anonymous\"));\n                r.hash_map(post)\n            }))\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(response == data);\n\n        tear_down(conn, \u0026table_name).await\n    }\n}\n","traces":[{"line":6,"address":[3395472,3395168,3395429,3395754],"length":1,"stats":{"Line":2},"fn_name":"new\u003ci32\u003e"},{"line":7,"address":[3395515,3395196,3395419,3395744,3395620,3395295],"length":1,"stats":{"Line":4},"fn_name":null},{"line":27,"address":[4722325,4722373,4721959,4721920],"length":1,"stats":{"Line":6},"fn_name":"test_default_ops"},{"line":28,"address":[3420995,3421400],"length":1,"stats":{"Line":2},"fn_name":null},{"line":30,"address":[3425511,3425542,3425296],"length":1,"stats":{"Line":1},"fn_name":"{closure#0}"},{"line":31,"address":[3425323],"length":1,"stats":{"Line":1},"fn_name":null},{"line":32,"address":[3425359,3425448],"length":1,"stats":{"Line":2},"fn_name":null},{"line":33,"address":[3425418],"length":1,"stats":{"Line":1},"fn_name":null},{"line":35,"address":[3425509,3425450],"length":1,"stats":{"Line":2},"fn_name":null},{"line":39,"address":[7924584],"length":1,"stats":{"Line":4},"fn_name":null},{"line":40,"address":[3423846,3423196,3423903,3423432,3422113,3423062,3422372,3424177,3423355,3423627,3423947],"length":1,"stats":{"Line":8},"fn_name":null},{"line":41,"address":[3422411,3422465,3422338,3422135,3422447],"length":1,"stats":{"Line":2},"fn_name":null},{"line":42,"address":[3425680,3423101,3422440,3426202,3422520,3422485],"length":1,"stats":{"Line":3},"fn_name":"{closure#1}"},{"line":43,"address":[3425710],"length":1,"stats":{"Line":1},"fn_name":null},{"line":44,"address":[3425792,3425853],"length":1,"stats":{"Line":2},"fn_name":null},{"line":45,"address":[3425942],"length":1,"stats":{"Line":1},"fn_name":null},{"line":46,"address":[3426104],"length":1,"stats":{"Line":1},"fn_name":null},{"line":48,"address":[3423264,3423176,3423560,3421100,3421183,3423388],"length":1,"stats":{"Line":6},"fn_name":null},{"line":49,"address":[3423750],"length":1,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[3424432,3424487,3424067],"length":1,"stats":{"Line":2},"fn_name":null},{"line":55,"address":[3424446,3424560,3424684,3424740,3424820,3421118,3424950],"length":1,"stats":{"Line":7},"fn_name":null}],"covered":20,"coverable":21},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","delete.rs"],"content":"use ql2::term::TermType;\nuse reql_macros::CommandOptions;\nuse serde::Serialize;\n\nuse crate::arguments::{Durability, ReturnChanges};\nuse crate::Command;\n\npub(crate) fn new(args: impl DeleteArg) -\u003e Command {\n    Command::new(TermType::Delete).with_opts(args.into_delete_opts())\n}\n\npub trait DeleteArg {\n    fn into_delete_opts(self) -\u003e DeleteOption;\n}\n\nimpl DeleteArg for () {\n    fn into_delete_opts(self) -\u003e DeleteOption {\n        Default::default()\n    }\n}\nimpl DeleteArg for DeleteOption {\n    fn into_delete_opts(self) -\u003e DeleteOption {\n        self\n    }\n}\n\n#[derive(Debug, Clone, Copy, Serialize, Default, PartialEq, PartialOrd, CommandOptions)]\npub struct DeleteOption {\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub durability: Option\u003cDurability\u003e,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub return_changes: Option\u003cReturnChanges\u003e,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub non_atomic: Option\u003cbool\u003e,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub ignore_write_hook: Option\u003cbool\u003e,\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::arguments::ReturnChanges;\n    use crate::prelude::Converter;\n    use crate::spec::*;\n    use crate::types::MutationResponse;\n    use crate::Result;\n\n    use super::DeleteOption;\n\n    #[tokio::test]\n    async fn test_delete_docs() -\u003e Result\u003c()\u003e {\n        let (conn, table, table_name) = set_up(true).await?;\n        let response: MutationResponse =\n            table.get(5).delete(()).run(\u0026conn).await?.unwrap().parse()?;\n\n        assert!(response.deleted == 1);\n\n        tear_down(conn, \u0026table_name).await\n    }\n\n    #[tokio::test]\n    async fn test_delete_docs_with_opts() -\u003e Result\u003c()\u003e {\n        let data = Post::get_many_data().get(0).unwrap().to_owned();\n        let delete_option = DeleteOption::default().return_changes(ReturnChanges::Bool(true));\n        let (conn, table, table_name) = set_up(true).await?;\n        let response: MutationResponse = table\n            .get(1)\n            .delete(delete_option)\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(response.deleted == 1);\n\n        let old_val: Post = response\n            .changes\n            .unwrap()\n            .first()\n            .unwrap()\n            .to_owned()\n            .old_val\n            .unwrap()\n            .parse()?;\n\n        assert!(old_val == data);\n\n        tear_down(conn, \u0026table_name).await\n    }\n}\n","traces":[{"line":8,"address":[7666528,7667130,7666824,7666864],"length":1,"stats":{"Line":2},"fn_name":"new\u003creql_rust::cmd::delete::DeleteOption\u003e"},{"line":9,"address":[7667120,7666814,7666652,7666976,7666881,7666557],"length":1,"stats":{"Line":4},"fn_name":null},{"line":17,"address":[1874592],"length":1,"stats":{"Line":1},"fn_name":"into_delete_opts"},{"line":18,"address":[1874596],"length":1,"stats":{"Line":1},"fn_name":null},{"line":22,"address":[1874624],"length":1,"stats":{"Line":1},"fn_name":"into_delete_opts"},{"line":23,"address":[1874639],"length":1,"stats":{"Line":1},"fn_name":null},{"line":50,"address":[5172928,5172967,5173333,5173381],"length":1,"stats":{"Line":6},"fn_name":"test_delete_docs"},{"line":51,"address":[5177620,5177943,5178121,5177775,5178558,5177555],"length":1,"stats":{"Line":4},"fn_name":null},{"line":52,"address":[5177641,5178807,5178505,5179547,5179687,5177726],"length":1,"stats":{"Line":5},"fn_name":null},{"line":55,"address":[5179664,5179986],"length":1,"stats":{"Line":1},"fn_name":null},{"line":57,"address":[7917217],"length":1,"stats":{"Line":7},"fn_name":null},{"line":61,"address":[5180841,5181033,5180864,5180933,5181261,5181541,5180832],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":62,"address":[5181378,5180995],"length":1,"stats":{"Line":2},"fn_name":null},{"line":63,"address":[5181592],"length":1,"stats":{"Line":1},"fn_name":null},{"line":64,"address":[5181218,5181063,5181735,5182387],"length":1,"stats":{"Line":3},"fn_name":null},{"line":65,"address":[5182605,5183277,5183334,5182863,5183357,5182334,5183604,5182663,5182780,5183058],"length":1,"stats":{"Line":7},"fn_name":null},{"line":67,"address":[5182595],"length":1,"stats":{"Line":1},"fn_name":null},{"line":68,"address":[5182686,5182643,5181169,5182991,5182819,5181084],"length":1,"stats":{"Line":6},"fn_name":null},{"line":69,"address":[5183181],"length":1,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[5183482,5183810],"length":1,"stats":{"Line":1},"fn_name":null},{"line":75,"address":[5183901,5184149,5183742,5184451,5183971],"length":1,"stats":{"Line":4},"fn_name":null},{"line":85,"address":[5185043,5184960],"length":1,"stats":{"Line":1},"fn_name":null},{"line":87,"address":[5173455,5173840,5173560,5173500],"length":1,"stats":{"Line":7},"fn_name":null}],"covered":22,"coverable":23},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","delete_at.rs"],"content":"use ql2::term::TermType;\n\nuse crate::arguments::Args;\nuse crate::Command;\n\npub(crate) fn new(args: impl DeleteAtArg) -\u003e Command {\n    let (start_offset, end_offset) = args.into_delete_at_opts();\n    let mut command = Command::new(TermType::DeleteAt).with_arg(start_offset);\n\n    if let Some(end_offset) = end_offset {\n        command = command.with_arg(end_offset);\n    }\n\n    command\n}\n\npub trait DeleteAtArg {\n    fn into_delete_at_opts(self) -\u003e (Command, Option\u003cCommand\u003e);\n}\n\nimpl DeleteAtArg for isize {\n    fn into_delete_at_opts(self) -\u003e (Command, Option\u003cCommand\u003e) {\n        (Command::from_json(self), None)\n    }\n}\n\nimpl DeleteAtArg for Args\u003c(isize, isize)\u003e {\n    fn into_delete_at_opts(self) -\u003e (Command, Option\u003cCommand\u003e) {\n        (\n            Command::from_json(self.0 .0),\n            Some(Command::from_json(self.0 .1)),\n        )\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::Converter;\n    use crate::{args, r, Result};\n\n    const DATA: [char; 6] = ['a', 'b', 'c', 'd', 'e', 'f'];\n\n    #[tokio::test]\n    async fn test_delete_at_ops() -\u003e Result\u003c()\u003e {\n        let conn = r.connection().connect().await?;\n        let response: [char; 5] = r\n            .expr(\u0026DATA)\n            .delete_at(1)\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        let response2: [char; 5] = r\n            .expr(\u0026DATA)\n            .delete_at(-2)\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        let response3: [char; 4] = r\n            .expr(\u0026DATA)\n            .delete_at(args!(1, 3))\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(response == ['a', 'c', 'd', 'e', 'f']);\n        assert!(response2 == ['a', 'b', 'c', 'd', 'f']);\n        assert!(response3 == ['a', 'd', 'e', 'f']);\n\n        Ok(())\n    }\n}\n","traces":[{"line":6,"address":[5404959,5405046,5405088,5405689,5404352,5405776],"length":1,"stats":{"Line":2},"fn_name":"new\u003creql_rust::arguments::Args\u003c(isize, isize)\u003e\u003e"},{"line":7,"address":[5405113,5404385],"length":1,"stats":{"Line":2},"fn_name":null},{"line":8,"address":[5405320,5404592,5404495,5405223],"length":1,"stats":{"Line":4},"fn_name":null},{"line":10,"address":[5405650,5404660,5404920,5405388],"length":1,"stats":{"Line":3},"fn_name":null},{"line":11,"address":[5405624,5405509,5404894,5404780],"length":1,"stats":{"Line":2},"fn_name":null},{"line":14,"address":[5404841,5405571],"length":1,"stats":{"Line":2},"fn_name":null},{"line":22,"address":[2436528],"length":1,"stats":{"Line":1},"fn_name":"into_delete_at_opts"},{"line":23,"address":[2436552],"length":1,"stats":{"Line":1},"fn_name":null},{"line":28,"address":[2650960,2651160],"length":1,"stats":{"Line":1},"fn_name":"into_delete_at_opts"},{"line":30,"address":[2650998],"length":1,"stats":{"Line":1},"fn_name":null},{"line":31,"address":[2651071,2651014],"length":1,"stats":{"Line":2},"fn_name":null},{"line":44,"address":[2502560,2502965,2502599,2503013],"length":1,"stats":{"Line":6},"fn_name":"test_delete_at_ops"},{"line":45,"address":[5028884,5029111,5029462,5029273,5029730,5028921],"length":1,"stats":{"Line":4},"fn_name":null},{"line":46,"address":[5030185,5030590,5030371,5029705,5030896,5030114,5030647,5030670,5029975],"length":1,"stats":{"Line":6},"fn_name":null},{"line":49,"address":[7771085],"length":1,"stats":{"Line":5},"fn_name":null},{"line":50,"address":[5030494],"length":1,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[5031707,5031956,5031650,5030775,5031431,5031035,5031245,5031730,5031174],"length":1,"stats":{"Line":6},"fn_name":null},{"line":57,"address":[5028954,5029025,5031086,5031204,5031373],"length":1,"stats":{"Line":5},"fn_name":null},{"line":58,"address":[5031554],"length":1,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[5031835,5032805,5032529,5032101,5032343,5033034,5032272,5032828,5032748],"length":1,"stats":{"Line":6},"fn_name":null},{"line":64,"address":[5032045],"length":1,"stats":{"Line":1},"fn_name":null},{"line":65,"address":[5032302,5028969,5032471,5032184],"length":1,"stats":{"Line":4},"fn_name":null},{"line":66,"address":[5032652],"length":1,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[5032913,5033158,5033125],"length":1,"stats":{"Line":2},"fn_name":null},{"line":71,"address":[5033226,5033194,5033136],"length":1,"stats":{"Line":2},"fn_name":null},{"line":72,"address":[5033200,5033260,5033293],"length":1,"stats":{"Line":2},"fn_name":null},{"line":74,"address":[2502591,2502696,2502976,2502636],"length":1,"stats":{"Line":5},"fn_name":null}],"covered":24,"coverable":27},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","desc.rs"],"content":"use ql2::term::TermType;\nuse serde::Serialize;\n\nuse crate::prelude::Func;\nuse crate::Command;\n\npub(crate) fn new(args: impl DescArg) -\u003e Command {\n    Command::new(TermType::Desc).with_arg(args.into_desc_opts())\n}\n\npub trait DescArg {\n    fn into_desc_opts(self) -\u003e Command;\n}\n\nimpl\u003cT\u003e DescArg for T\nwhere\n    T: Into\u003cT\u003e + Serialize,\n{\n    fn into_desc_opts(self) -\u003e Command {\n        Command::from_json(self)\n    }\n}\n\nimpl DescArg for Func {\n    fn into_desc_opts(self) -\u003e Command {\n        self.0\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::*;\n    use crate::spec::*;\n    use crate::{args, r, Result};\n\n    #[tokio::test]\n    async fn test_desc_ops() -\u003e Result\u003c()\u003e {\n        let (conn, table, table_name) = set_up(true).await?;\n        let response: Vec\u003cPost\u003e = table\n            .order_by(args!(r.expr(\"view\"), r.desc(\"title\")))\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(response.len() \u003e 1);\n\n        tear_down(conn, \u0026table_name).await\n    }\n}\n","traces":[{"line":7,"address":[5680240,5680522],"length":1,"stats":{"Line":1},"fn_name":"new\u003c\u0026str\u003e"},{"line":8,"address":[5680512,5680283,5680388],"length":1,"stats":{"Line":2},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":25,"address":[2740624],"length":1,"stats":{"Line":0},"fn_name":"into_desc_opts"},{"line":26,"address":[2740632],"length":1,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[2798709,2798304,2798757,2798343],"length":1,"stats":{"Line":6},"fn_name":"test_desc_ops"},{"line":38,"address":[3950543,3950985,3950197,3949971,3950044,3950365],"length":1,"stats":{"Line":4},"fn_name":null},{"line":39,"address":[3951905,3951633,3952225,3952181,3952456,3950933,3952124,3951467,3951710,3951404],"length":1,"stats":{"Line":7},"fn_name":null},{"line":40,"address":[3950955,3951474,3951492,3951443,3951191],"length":1,"stats":{"Line":2},"fn_name":null},{"line":41,"address":[3950148,3951666,3951838,3950065,3951542],"length":1,"stats":{"Line":5},"fn_name":null},{"line":42,"address":[3952028],"length":1,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[3952654,3952715,3952345],"length":1,"stats":{"Line":2},"fn_name":null},{"line":48,"address":[2798335,2798380,2798440,2798720],"length":1,"stats":{"Line":7},"fn_name":null}],"covered":11,"coverable":14},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","difference.rs"],"content":"use ql2::term::TermType;\nuse serde::Serialize;\n\nuse crate::Command;\n\npub(crate) fn new(args: impl DifferenceArg) -\u003e Command {\n    Command::new(TermType::Difference).with_arg(args.into_difference_opts())\n}\n\npub trait DifferenceArg {\n    fn into_difference_opts(self) -\u003e Command;\n}\n\nimpl\u003cS, T\u003e DifferenceArg for T\nwhere\n    S: Serialize,\n    T: IntoIterator\u003cItem = S\u003e + Serialize,\n{\n    fn into_difference_opts(self) -\u003e Command {\n        Command::from_json(self)\n    }\n}\n\nimpl DifferenceArg for Command {\n    fn into_difference_opts(self) -\u003e Command {\n        self\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::Converter;\n    use crate::{r, Result};\n\n    #[tokio::test]\n    async fn test_difference_ops() -\u003e Result\u003c()\u003e {\n        let conn = r.connection().connect().await?;\n        let response: [u8; 4] = r\n            .expr([10, 20, 30, 40, 50])\n            .difference([30, 70])\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(response == [10, 20, 40, 50]);\n\n        Ok(())\n    }\n}\n","traces":[{"line":6,"address":[7624912,7625192],"length":1,"stats":{"Line":1},"fn_name":"new\u003c[i32; 2]\u003e"},{"line":7,"address":[7625182,7624943,7625038],"length":1,"stats":{"Line":2},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":25,"address":[2170448],"length":1,"stats":{"Line":0},"fn_name":"into_difference_opts"},{"line":26,"address":[2170456],"length":1,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[1850485,1850032,1850071,1850437],"length":1,"stats":{"Line":6},"fn_name":"test_difference_ops"},{"line":37,"address":[4762270,4761757,4761946,4761491,4761525,4761596],"length":1,"stats":{"Line":4},"fn_name":null},{"line":38,"address":[4763452,4762753,4762571,4763214,4763157,4762260,4762938,4763251,4762682,4762515],"length":1,"stats":{"Line":7},"fn_name":null},{"line":39,"address":[4762189],"length":1,"stats":{"Line":1},"fn_name":null},{"line":40,"address":[4762493],"length":1,"stats":{"Line":1},"fn_name":null},{"line":41,"address":[4762551,4762712,4761540,4762594,4762881],"length":1,"stats":{"Line":5},"fn_name":null},{"line":42,"address":[4763061],"length":1,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[4763327,4763596,4763559],"length":1,"stats":{"Line":2},"fn_name":null},{"line":48,"address":[1850108,1850168,1850063,1850448],"length":1,"stats":{"Line":5},"fn_name":null}],"covered":12,"coverable":15},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","distance.rs"],"content":"use ql2::term::TermType;\nuse reql_macros::CommandOptions;\nuse serde::Serialize;\n\nuse crate::arguments::{Args, Unit};\nuse crate::prelude::Geometry;\nuse crate::types::GeoSystem;\nuse crate::Command;\n\npub(crate) fn new(args: impl DistanceArg) -\u003e Command {\n    let (arg1, arg2, opts) = args.into_distance_opts();\n    let mut command = Command::new(TermType::Distance).with_arg(arg1);\n\n    if let Some(arg) = arg2 {\n        command = command.with_arg(arg)\n    }\n\n    command.with_opts(opts)\n}\n\npub trait DistanceArg {\n    fn into_distance_opts(self) -\u003e (Command, Option\u003cCommand\u003e, DistanceOption);\n}\n\nimpl\u003cT: Geometry\u003e DistanceArg for T {\n    fn into_distance_opts(self) -\u003e (Command, Option\u003cCommand\u003e, DistanceOption) {\n        (self.into(), None, Default::default())\n    }\n}\n\nimpl\u003cT: Geometry\u003e DistanceArg for Args\u003c(T, DistanceOption)\u003e {\n    fn into_distance_opts(self) -\u003e (Command, Option\u003cCommand\u003e, DistanceOption) {\n        (self.0 .0.into(), None, self.0 .1)\n    }\n}\n\n#[derive(\n    Debug, Clone, Copy, Serialize, Default, PartialEq, Eq, PartialOrd, Ord, CommandOptions,\n)]\npub struct DistanceOption {\n    /// the reference ellipsoid to use for geographic coordinates.\n    /// Possible values are `GeoSystem::WGS84` (the default),\n    /// a common standard for Earth’s geometry, or `GeoSystem::UnitSphere`,\n    /// a perfect sphere of 1 meter radius.\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub geo_system: Option\u003cGeoSystem\u003e,\n    /// Unit to return the distance in.\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub unit: Option\u003cUnit\u003e,\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::arguments::Unit;\n    use crate::prelude::*;\n    use crate::{args, r, Result};\n\n    use super::DistanceOption;\n\n    #[tokio::test]\n    async fn test_distance_data() -\u003e Result\u003c()\u003e {\n        let conn = r.connection().connect().await?;\n        let point1 = r.point(-122.423246, 37.779388);\n        let point2 = r.point(-117.220406, 32.719464);\n        let distance_option = DistanceOption::default().unit(Unit::Kilometer);\n\n        let response: f64 = r\n            .distance(point1.cmd(), args!(point2, distance_option))\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(response == 734.125249602186);\n\n        Ok(())\n    }\n}\n","traces":[{"line":10,"address":[4650544,4651271,4651358],"length":1,"stats":{"Line":1},"fn_name":"new\u003creql_rust::arguments::Args\u003c(reql_rust::cmd::point::Point, reql_rust::cmd::distance::DistanceOption)\u003e\u003e"},{"line":11,"address":[4650561],"length":1,"stats":{"Line":1},"fn_name":null},{"line":12,"address":[4650762,4650859],"length":1,"stats":{"Line":2},"fn_name":null},{"line":14,"address":[4651197,4650927],"length":1,"stats":{"Line":1},"fn_name":null},{"line":15,"address":[4651048,4651171],"length":1,"stats":{"Line":0},"fn_name":null},{"line":18,"address":[4651138],"length":1,"stats":{"Line":1},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":61,"address":[4768757,4768352,4768391,4768805],"length":1,"stats":{"Line":6},"fn_name":"test_distance_data"},{"line":62,"address":[5192717,5193183,5192485,5192556,5192451,5192906],"length":1,"stats":{"Line":4},"fn_name":null},{"line":63,"address":[5193173],"length":1,"stats":{"Line":1},"fn_name":null},{"line":64,"address":[5193444],"length":1,"stats":{"Line":1},"fn_name":null},{"line":65,"address":[5193451],"length":1,"stats":{"Line":1},"fn_name":null},{"line":67,"address":[5193983,5194168,5194444,5194387,5193801,5194688,5194481,5193769,5193912],"length":1,"stats":{"Line":6},"fn_name":null},{"line":68,"address":[5193545,5193635],"length":1,"stats":{"Line":2},"fn_name":null},{"line":69,"address":[5194111,5193824,5193942,5193781,5192500],"length":1,"stats":{"Line":5},"fn_name":null},{"line":70,"address":[5194291],"length":1,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[5194781,5194557],"length":1,"stats":{"Line":1},"fn_name":null},{"line":76,"address":[4768768,4768383,4768488,4768428],"length":1,"stats":{"Line":5},"fn_name":null}],"covered":17,"coverable":21},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","distinct.rs"],"content":"use std::borrow::Cow;\n\nuse ql2::term::TermType;\nuse reql_macros::CommandOptions;\nuse serde::Serialize;\n\nuse crate::Command;\n\npub(crate) fn new(args: impl DistinctArg) -\u003e Command {\n    let (args, opts) = args.into_distinct_opts();\n    let mut command = Command::new(TermType::Distinct);\n\n    if let Some(arg) = args {\n        command = command.with_arg(arg)\n    }\n\n    command.with_opts(opts)\n}\n\npub trait DistinctArg {\n    fn into_distinct_opts(self) -\u003e (Option\u003cCommand\u003e, DistinctOption);\n}\n\nimpl DistinctArg for () {\n    fn into_distinct_opts(self) -\u003e (Option\u003cCommand\u003e, DistinctOption) {\n        (None, Default::default())\n    }\n}\n\nimpl DistinctArg for DistinctOption {\n    fn into_distinct_opts(self) -\u003e (Option\u003cCommand\u003e, DistinctOption) {\n        (None, self)\n    }\n}\n\nimpl DistinctArg for Command {\n    fn into_distinct_opts(self) -\u003e (Option\u003cCommand\u003e, DistinctOption) {\n        (Some(self), Default::default())\n    }\n}\n\n#[derive(Debug, Clone, Serialize, Default, PartialEq, PartialOrd, CommandOptions)]\npub struct DistinctOption {\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub index: Option\u003cCow\u003c'static, str\u003e\u003e,\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::Converter;\n    use crate::spec::{set_up, tear_down, Post};\n    use crate::Result;\n\n    use super::DistinctOption;\n\n    #[tokio::test]\n    async fn test_distinct_data() -\u003e Result\u003c()\u003e {\n        let mut data = Post::get_many_data()\n            .into_iter()\n            .map(|post| post.title)\n            .collect::\u003cVec\u003cString\u003e\u003e();\n        data.pop();\n        let (conn, table, table_name) = set_up(true).await?;\n        let data_obtained: Vec\u003cString\u003e = table\n            .distinct(DistinctOption::default().index(\"title\"))\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(data_obtained == data);\n\n        tear_down(conn, \u0026table_name).await\n    }\n}\n","traces":[{"line":9,"address":[3414637,3414658,3414000],"length":1,"stats":{"Line":1},"fn_name":"new\u003creql_rust::cmd::distinct::DistinctOption\u003e"},{"line":10,"address":[3414017],"length":1,"stats":{"Line":1},"fn_name":null},{"line":11,"address":[3414176],"length":1,"stats":{"Line":1},"fn_name":null},{"line":13,"address":[3414548,3414250],"length":1,"stats":{"Line":1},"fn_name":null},{"line":14,"address":[3414522,3414365],"length":1,"stats":{"Line":0},"fn_name":null},{"line":17,"address":[3414455],"length":1,"stats":{"Line":1},"fn_name":null},{"line":25,"address":[2739456,2739636],"length":1,"stats":{"Line":0},"fn_name":"into_distinct_opts"},{"line":26,"address":[2821121],"length":1,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[2739664],"length":1,"stats":{"Line":1},"fn_name":"into_distinct_opts"},{"line":32,"address":[2739683],"length":1,"stats":{"Line":1},"fn_name":null},{"line":37,"address":[2170480,2170707],"length":1,"stats":{"Line":0},"fn_name":"into_distinct_opts"},{"line":38,"address":[2170531],"length":1,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[2798800,2798839,2799253,2799205],"length":1,"stats":{"Line":6},"fn_name":"test_distinct_data"},{"line":58,"address":[2984819,2985208],"length":1,"stats":{"Line":2},"fn_name":null},{"line":60,"address":[2988464,2988492],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":62,"address":[2985277,2985328],"length":1,"stats":{"Line":2},"fn_name":null},{"line":63,"address":[2985998,2984887,2985040,2985360,2985561],"length":1,"stats":{"Line":3},"fn_name":null},{"line":64,"address":[2986764,2986492,2987040,2986251,2986326,2985958,2987084,2987314,2986983,2986569],"length":1,"stats":{"Line":7},"fn_name":null},{"line":65,"address":[2986175,2986298,2986333,2986351,2985988],"length":1,"stats":{"Line":2},"fn_name":null},{"line":66,"address":[2986525,2986697,2986306,2984991,2984908,2986401],"length":1,"stats":{"Line":6},"fn_name":null},{"line":67,"address":[2986887],"length":1,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[2987628,2987573,2987204],"length":1,"stats":{"Line":2},"fn_name":null},{"line":73,"address":[2799216,2798936,2798876,2798831],"length":1,"stats":{"Line":7},"fn_name":null}],"covered":17,"coverable":23},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","div.rs"],"content":"use std::ops::Div;\n\nuse ql2::term::TermType;\nuse serde::Serialize;\n\nuse crate::Command;\n\nimpl\u003cT: DivArg\u003e Div\u003cT\u003e for Command {\n    type Output = Self;\n\n    fn div(self, arg: T) -\u003e Self {\n        Command::new(TermType::Div)\n            .with_arg(arg.into_div_opts())\n            .with_parent(self)\n    }\n}\n\npub trait DivArg {\n    fn into_div_opts(self) -\u003e Command;\n}\n\nimpl\u003cT: Serialize\u003e DivArg for T {\n    fn into_div_opts(self) -\u003e Command {\n        Command::from_json(self)\n    }\n}\n\nimpl DivArg for Command {\n    fn into_div_opts(self) -\u003e Command {\n        self\n    }\n}\n\n// TODO write test\n","traces":[{"line":11,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":12,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":13,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":14,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[2170736],"length":1,"stats":{"Line":0},"fn_name":"into_div_opts"},{"line":30,"address":[2170744],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":8},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","do_.rs"],"content":"use ql2::term::TermType;\n\nuse crate::arguments::Args;\nuse crate::prelude::Func;\nuse crate::Command;\n\nuse super::CmdOpts;\n\npub(crate) fn new(args: impl DoArg) -\u003e Command {\n    args.into_do_opts()\n        .add_to_cmd(Command::new(TermType::Funcall))\n}\n\npub trait DoArg {\n    fn into_do_opts(self) -\u003e CmdOpts;\n}\n\nimpl DoArg for Command {\n    fn into_do_opts(self) -\u003e CmdOpts {\n        CmdOpts::Single(self)\n    }\n}\n\nimpl DoArg for Func {\n    fn into_do_opts(self) -\u003e CmdOpts {\n        CmdOpts::Single(self.0)\n    }\n}\n\nimpl DoArg for Args\u003c(Command, Command)\u003e {\n    fn into_do_opts(self) -\u003e CmdOpts {\n        CmdOpts::Many(vec![self.0 .0, self.0 .1])\n    }\n}\n\nimpl DoArg for Args\u003c(Command, Func)\u003e {\n    fn into_do_opts(self) -\u003e CmdOpts {\n        let Func(func) = self.0 .1;\n\n        CmdOpts::Many(vec![self.0 .0, func])\n    }\n}\n\nimpl\u003cconst N: usize\u003e DoArg for Args\u003c([Command; N], Func)\u003e {\n    fn into_do_opts(self) -\u003e CmdOpts {\n        let Func(func) = self.0 .1;\n        let mut args = self.0 .0.to_vec();\n\n        args.push(func);\n        CmdOpts::Many(args)\n    }\n}\n\nimpl\u003cconst N: usize\u003e DoArg for Args\u003c([Command; N], Command)\u003e {\n    fn into_do_opts(self) -\u003e CmdOpts {\n        let mut args = self.0 .0.to_vec();\n\n        args.push(self.0 .1);\n        CmdOpts::Many(args)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use std::ops::Add;\n\n    use crate::prelude::*;\n    use crate::spec::*;\n    use crate::{r, Result};\n\n    #[tokio::test]\n    #[ignore = \"not work\"]\n    async fn test_do_opts() -\u003e Result\u003c()\u003e {\n        let (conn, table, table_name) = set_up(true).await?;\n        let response = table\n            .get(1)\n            .do_(func!(|post| post.g(\"view\").add(r.expr(5))))\n            .run(\u0026conn)\n            .await;\n\n        dbg!(\u0026response);\n\n        tear_down(conn, \u0026table_name).await\n    }\n}\n","traces":[{"line":9,"address":[5156684,5156711,5156496],"length":1,"stats":{"Line":0},"fn_name":"new\u003creql_rust::cmd::func::Func\u003e"},{"line":10,"address":[5156512,5156635],"length":1,"stats":{"Line":0},"fn_name":null},{"line":11,"address":[5156704,5156668,5156564],"length":1,"stats":{"Line":0},"fn_name":null},{"line":19,"address":[2252416],"length":1,"stats":{"Line":0},"fn_name":"into_do_opts"},{"line":20,"address":[4585776],"length":1,"stats":{"Line":0},"fn_name":null},{"line":25,"address":[2822304],"length":1,"stats":{"Line":0},"fn_name":"into_do_opts"},{"line":26,"address":[4544976],"length":1,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[2651566,2651200],"length":1,"stats":{"Line":0},"fn_name":"into_do_opts"},{"line":32,"address":[2732870,2732970],"length":1,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[2733670,2733264],"length":1,"stats":{"Line":0},"fn_name":"into_do_opts"},{"line":38,"address":[2651638],"length":1,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[2651706,2651764],"length":1,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":21},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","downcase.rs"],"content":"use ql2::term::TermType;\n\nuse crate::Command;\n\npub(crate) fn new() -\u003e Command {\n    Command::new(TermType::Downcase)\n}\n\n// TODO write test\n","traces":[{"line":5,"address":[2435456],"length":1,"stats":{"Line":0},"fn_name":"new"},{"line":6,"address":[2435468],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":2},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","during.rs"],"content":"use ql2::term::TermType;\nuse reql_macros::CommandOptions;\nuse serde::Serialize;\n\nuse crate::arguments::{Args, Status};\nuse crate::types::DateTime;\nuse crate::Command;\n\npub(crate) fn new(args: impl DuringArg) -\u003e Command {\n    let (arg1, arg2, opts) = args.into_during_opts();\n\n    Command::new(TermType::During)\n        .with_arg(arg1)\n        .with_arg(arg2)\n        .with_opts(opts)\n}\n\npub trait DuringArg {\n    fn into_during_opts(self) -\u003e (Command, Command, DuringOption);\n}\n\nimpl DuringArg for Args\u003c(DateTime, DateTime)\u003e {\n    fn into_during_opts(self) -\u003e (Command, Command, DuringOption) {\n        (self.0 .0.into(), self.0 .1.into(), Default::default())\n    }\n}\n\nimpl DuringArg for Args\u003c(DateTime, DateTime, DuringOption)\u003e {\n    fn into_during_opts(self) -\u003e (Command, Command, DuringOption) {\n        (self.0 .0.into(), self.0 .1.into(), self.0 .2)\n    }\n}\n\nimpl DuringArg for Args\u003c(DateTime, DateTime, Option\u003cDuringOption\u003e)\u003e {\n    fn into_during_opts(self) -\u003e (Command, Command, DuringOption) {\n        (\n            self.0 .0.into(),\n            self.0 .1.into(),\n            self.0 .2.unwrap_or_default(),\n        )\n    }\n}\n\nimpl DuringArg for Args\u003c(Command, Command)\u003e {\n    fn into_during_opts(self) -\u003e (Command, Command, DuringOption) {\n        (self.0 .0, self.0 .1, Default::default())\n    }\n}\n\nimpl DuringArg for Args\u003c(Command, Command, DuringOption)\u003e {\n    fn into_during_opts(self) -\u003e (Command, Command, DuringOption) {\n        (self.0 .0, self.0 .1, self.0 .2)\n    }\n}\n\n/// By default, this is inclusive of the start time and exclusive of the end time.\n/// Set left_bound and right_bound to explicitly include\n/// (closed) or exclude (open) that endpoint of the range.\n#[derive(Debug, Clone, Copy, Serialize, Default, PartialEq, PartialOrd, CommandOptions)]\npub struct DuringOption {\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub left_bound: Option\u003cStatus\u003e,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub right_bound: Option\u003cStatus\u003e,\n}\n\n#[cfg(test)]\nmod tests {\n    use time::macros::{date, offset};\n\n    use crate::prelude::Converter;\n    use crate::{args, r, Result};\n\n    #[tokio::test]\n    async fn test_during_ops() -\u003e Result\u003c()\u003e {\n        let conn = r.connection().connect().await?;\n        let start_date = r.time(args!(date!(2022 - 08 - 01), offset!(UTC)));\n        let end_date = r.time(args!(date!(2022 - 12 - 31), offset!(UTC)));\n\n        let datetime = r.epoch_time(1661990400)?;\n\n        let response = datetime\n            .clone()\n            .during(start_date.clone(), end_date.clone(), None);\n        let response2: bool = response.clone().cmd().run(\u0026conn).await?.unwrap().parse()?;\n        let response3: bool = datetime\n            .cmd()\n            .during(args!(start_date, end_date))\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(response2 == response3 \u0026\u0026 response2 == response.value());\n\n        Ok(())\n    }\n}\n","traces":[{"line":9,"address":[2482752,2483263],"length":1,"stats":{"Line":2},"fn_name":"new\u003creql_rust::arguments::Args\u003c(reql_rust::types::datetime::DateTime, reql_rust::types::datetime::DateTime, core::option::Option\u003creql_rust::cmd::during::DuringOption\u003e)\u003e\u003e"},{"line":10,"address":[2482769],"length":1,"stats":{"Line":2},"fn_name":null},{"line":12,"address":[4736137,4736068,4735595,4735389,4735933,4735524],"length":1,"stats":{"Line":6},"fn_name":null},{"line":13,"address":[2483020],"length":1,"stats":{"Line":2},"fn_name":null},{"line":14,"address":[4735531,4736075],"length":1,"stats":{"Line":2},"fn_name":null},{"line":23,"address":[2652064,2652446],"length":1,"stats":{"Line":1},"fn_name":"into_during_opts"},{"line":24,"address":[2652196,2652086],"length":1,"stats":{"Line":2},"fn_name":null},{"line":29,"address":[7632432,7632771],"length":1,"stats":{"Line":0},"fn_name":"into_during_opts"},{"line":30,"address":[2734166,2734276],"length":1,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[2652896,2653300],"length":1,"stats":{"Line":1},"fn_name":"into_during_opts"},{"line":37,"address":[7632838],"length":1,"stats":{"Line":1},"fn_name":null},{"line":38,"address":[7632944],"length":1,"stats":{"Line":1},"fn_name":null},{"line":39,"address":[2734785],"length":1,"stats":{"Line":1},"fn_name":null},{"line":45,"address":[2653360,2653589,2653616],"length":1,"stats":{"Line":0},"fn_name":"into_during_opts"},{"line":46,"address":[2653409,2653600],"length":1,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[2653632],"length":1,"stats":{"Line":0},"fn_name":"into_during_opts"},{"line":52,"address":[2653654],"length":1,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[1850528,1850567,1850981,1850933],"length":1,"stats":{"Line":6},"fn_name":"test_during_ops"},{"line":76,"address":[3402762,3402591,3402969,3403330,3402434,3402342],"length":1,"stats":{"Line":4},"fn_name":null},{"line":77,"address":[3403594,3403233],"length":1,"stats":{"Line":2},"fn_name":null},{"line":78,"address":[3403601,3403761],"length":1,"stats":{"Line":2},"fn_name":null},{"line":80,"address":[3404021,3403781,3403856],"length":1,"stats":{"Line":2},"fn_name":null},{"line":82,"address":[3404011,3404417],"length":1,"stats":{"Line":2},"fn_name":null},{"line":84,"address":[3404209,3404550,3404260,3404497],"length":1,"stats":{"Line":2},"fn_name":null},{"line":85,"address":[3404654,3405391,3404520,3402540,3405537,3402455],"length":1,"stats":{"Line":5},"fn_name":null},{"line":86,"address":[3406731,3406432,3406231,3406708,3406154,3405467,3406923,3406000,3406651],"length":1,"stats":{"Line":6},"fn_name":null},{"line":88,"address":[3405778],"length":1,"stats":{"Line":1},"fn_name":null},{"line":89,"address":[3402473,3406359,3406054,3406187],"length":1,"stats":{"Line":4},"fn_name":null},{"line":90,"address":[3406555],"length":1,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[3407330,3406808,3407155],"length":1,"stats":{"Line":1},"fn_name":null},{"line":96,"address":[1850664,1850559,1850604,1850944],"length":1,"stats":{"Line":5},"fn_name":null}],"covered":24,"coverable":31},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","epoch_time.rs"],"content":"use ql2::term::TermType;\n\nuse crate::Command;\n\npub(crate) fn epoch_time(timestamp: i64) -\u003e Command {\n    Command::new(TermType::EpochTime).with_arg(Command::from_json(timestamp))\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::Converter;\n    use crate::types::Time;\n    use crate::{r, Result};\n\n    #[tokio::test]\n    async fn test_time_ops() -\u003e Result\u003c()\u003e {\n        let conn = r.connection().connect().await?;\n\n        let date_time = r.epoch_time(531360000)?;\n        let time1 = date_time.clone().value();\n        let time2: Time = date_time.cmd().run(\u0026conn).await?.unwrap().parse()?;\n\n        assert!(time2 == time1);\n\n        Ok(())\n    }\n}\n","traces":[{"line":5,"address":[2042447,2042478,2042256],"length":1,"stats":{"Line":1},"fn_name":"epoch_time"},{"line":6,"address":[2042286,2042462],"length":1,"stats":{"Line":1},"fn_name":null},{"line":16,"address":[1851477,1851429,1851063,1851024],"length":1,"stats":{"Line":6},"fn_name":"test_time_ops"},{"line":17,"address":[5406720,5406766,5407000,5407189,5407455,5406839],"length":1,"stats":{"Line":4},"fn_name":null},{"line":19,"address":[5407712,5407841,5407445],"length":1,"stats":{"Line":2},"fn_name":null},{"line":20,"address":[5408066,5407831],"length":1,"stats":{"Line":2},"fn_name":null},{"line":21,"address":[5408180,5406781,5408093,5408892,5409074],"length":1,"stats":{"Line":4},"fn_name":null},{"line":23,"address":[5409045,5409295,5409328],"length":1,"stats":{"Line":2},"fn_name":null},{"line":25,"address":[1851100,1851055,1851160,1851440],"length":1,"stats":{"Line":5},"fn_name":null}],"covered":9,"coverable":9},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","eq.rs"],"content":"use ql2::term::TermType;\nuse serde::Serialize;\n\nuse crate::{arguments::Args, Command};\n\nuse super::CmdOpts;\n\npub(crate) fn new(args: impl EqArg) -\u003e Command {\n    args.into_eq_opts().add_to_cmd(Command::new(TermType::Eq))\n}\n\npub trait EqArg {\n    fn into_eq_opts(self) -\u003e CmdOpts;\n}\n\nimpl\u003cT\u003e EqArg for T\nwhere\n    T: Serialize,\n{\n    fn into_eq_opts(self) -\u003e CmdOpts {\n        CmdOpts::Single(Command::from_json(self))\n    }\n}\n\nimpl EqArg for Command {\n    fn into_eq_opts(self) -\u003e CmdOpts {\n        CmdOpts::Single(self)\n    }\n}\n\nimpl\u003cS, T\u003e EqArg for Args\u003cT\u003e\nwhere\n    S: Serialize,\n    T: IntoIterator\u003cItem = S\u003e,\n{\n    fn into_eq_opts(self) -\u003e CmdOpts {\n        let commands = self.0.into_iter().map(Command::from_json).collect();\n\n        CmdOpts::Many(commands)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::Converter;\n    use crate::spec::{set_up, tear_down};\n    use crate::{args, r, Result};\n\n    #[tokio::test]\n    async fn test_eq_data() -\u003e Result\u003c()\u003e {\n        let (conn, table, table_name) = set_up(true).await?;\n        let data_obtained: bool = table\n            .get(1)\n            .g(\"title\")\n            .eq(\"title1\")\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(data_obtained);\n\n        tear_down(conn, \u0026table_name).await\n    }\n\n    #[tokio::test]\n    async fn test_eq_data_r() -\u003e Result\u003c()\u003e {\n        let conn = r.connection().connect().await?;\n        let data_obtained: bool = r.eq(args!([5, 5, 5])).run(\u0026conn).await?.unwrap().parse()?;\n\n        assert!(data_obtained);\n\n        Ok(())\n    }\n}\n","traces":[{"line":8,"address":[5149191,5149436,5148976,5149216,5149636,5149409,5149164,5149456,5149663],"length":1,"stats":{"Line":3},"fn_name":"new\u003creql_rust::proto::Command\u003e"},{"line":9,"address":[5149429,5149656,5149489,5149184,5148992,5149233],"length":1,"stats":{"Line":3},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":26,"address":[2170848],"length":1,"stats":{"Line":1},"fn_name":"into_eq_opts"},{"line":27,"address":[2170864],"length":1,"stats":{"Line":1},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":50,"address":[1947989,1948037,1947623,1947584],"length":1,"stats":{"Line":6},"fn_name":"test_eq_data"},{"line":51,"address":[4706117,4706295,4705731,4705949,4705796,4706732],"length":1,"stats":{"Line":4},"fn_name":null},{"line":52,"address":[4706965,4707448,4707724,4707253,4707958,4706679,4707768,4707667,4707176],"length":1,"stats":{"Line":6},"fn_name":null},{"line":56,"address":[7876288],"length":1,"stats":{"Line":5},"fn_name":null},{"line":57,"address":[4707571],"length":1,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[4708161,4707847],"length":1,"stats":{"Line":1},"fn_name":null},{"line":63,"address":[1947615,1947720,1948000,1947660],"length":1,"stats":{"Line":7},"fn_name":null},{"line":67,"address":[1948080,1948119,1948533,1948485],"length":1,"stats":{"Line":6},"fn_name":"test_eq_data_r"},{"line":68,"address":[4709148,4709077,4709498,4709830,4709043,4709309],"length":1,"stats":{"Line":4},"fn_name":null},{"line":69,"address":[4710852,4710058,4709092,4709741,4710758],"length":1,"stats":{"Line":4},"fn_name":null},{"line":71,"address":[4710837,4711060],"length":1,"stats":{"Line":1},"fn_name":null},{"line":73,"address":[1948111,1948216,1948496,1948156],"length":1,"stats":{"Line":5},"fn_name":null}],"covered":20,"coverable":21},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","eq_join.rs"],"content":"use std::borrow::Cow;\n\nuse ql2::term::TermType;\nuse reql_macros::CommandOptions;\nuse serde::Serialize;\n\nuse crate::arguments::Args;\nuse crate::prelude::Func;\nuse crate::Command;\n\npub(crate) fn new(args: impl EqJoinArg) -\u003e Command {\n    let (arg, right_table, opts) = args.into_eq_join_opts();\n\n    Command::new(TermType::EqJoin)\n        .with_arg(arg)\n        .with_arg(right_table)\n        .with_opts(opts)\n}\n\npub trait EqJoinArg {\n    fn into_eq_join_opts(self) -\u003e (Command, Command, EqJoinOption);\n}\n\nimpl\u003cT\u003e EqJoinArg for Args\u003c(T, Command)\u003e\nwhere\n    T: Into\u003cString\u003e,\n{\n    fn into_eq_join_opts(self) -\u003e (Command, Command, EqJoinOption) {\n        (\n            Command::from_json(self.0 .0.into()),\n            self.0 .1,\n            Default::default(),\n        )\n    }\n}\n\nimpl EqJoinArg for Args\u003c(Func, Command)\u003e {\n    fn into_eq_join_opts(self) -\u003e (Command, Command, EqJoinOption) {\n        let Func(func) = self.0 .0;\n\n        (func, self.0 .1, Default::default())\n    }\n}\n\nimpl EqJoinArg for Args\u003c(Command, Command)\u003e {\n    fn into_eq_join_opts(self) -\u003e (Command, Command, EqJoinOption) {\n        (self.0 .0, self.0 .1, Default::default())\n    }\n}\n\nimpl\u003cT\u003e EqJoinArg for Args\u003c(T, Command, EqJoinOption)\u003e\nwhere\n    T: Into\u003cString\u003e,\n{\n    fn into_eq_join_opts(self) -\u003e (Command, Command, EqJoinOption) {\n        (Command::from_json(self.0 .0.into()), self.0 .1, self.0 .2)\n    }\n}\n\nimpl EqJoinArg for Args\u003c(Func, Command, EqJoinOption)\u003e {\n    fn into_eq_join_opts(self) -\u003e (Command, Command, EqJoinOption) {\n        let Func(func) = self.0 .0;\n\n        (func, self.0 .1, self.0 .2)\n    }\n}\n\nimpl EqJoinArg for Args\u003c(Command, Command, EqJoinOption)\u003e {\n    fn into_eq_join_opts(self) -\u003e (Command, Command, EqJoinOption) {\n        (self.0 .0, self.0 .1, self.0 .2)\n    }\n}\n\n#[derive(\n    Debug, Clone, Serialize, Default, Eq, PartialEq, Ord, PartialOrd, Hash, CommandOptions,\n)]\n#[non_exhaustive]\npub struct EqJoinOption {\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub index: Option\u003cCow\u003c'static, str\u003e\u003e,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub ordered: Option\u003cbool\u003e,\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::Converter;\n    use crate::spec::{Comment, Post};\n    use crate::types::JoinResponse;\n    use crate::{args, Result};\n\n    #[tokio::test]\n    pub async fn test_eq_join_ops() -\u003e Result\u003c()\u003e {\n        let data = JoinResponse {\n            left: Some(Comment {\n                id: 5,\n                text: \"comment4\".to_string(),\n                post_id: 1,\n            }),\n            right: Some(Post {\n                id: 1,\n                title: \"title1\".to_string(),\n                content: Some(\"content1\".to_string()),\n                view: 10,\n            }),\n        };\n        let (conn, comment_table, post_table, comment_tablename, post_tablename) =\n            Comment::own_set_up().await?;\n\n        let response: Vec\u003cJoinResponse\u003cComment, Post\u003e\u003e = comment_table\n            .eq_join(args!(\"post_id\", post_table))\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(response.len() \u003e 0);\n        assert_eq!(response.first(), Some(\u0026data));\n\n        Comment::own_tear_down(conn, comment_tablename, post_tablename).await\n    }\n}\n","traces":[{"line":11,"address":[5424512,5425088,5425126],"length":1,"stats":{"Line":1},"fn_name":"new\u003creql_rust::arguments::Args\u003c(\u0026str, reql_rust::proto::Command)\u003e\u003e"},{"line":12,"address":[5424529],"length":1,"stats":{"Line":1},"fn_name":null},{"line":14,"address":[5424729,5424864,5425017,5424933],"length":1,"stats":{"Line":4},"fn_name":null},{"line":15,"address":[5424803],"length":1,"stats":{"Line":1},"fn_name":null},{"line":16,"address":[5424871],"length":1,"stats":{"Line":1},"fn_name":null},{"line":17,"address":[5424945],"length":1,"stats":{"Line":1},"fn_name":null},{"line":28,"address":[1897106,1897080,1896768],"length":1,"stats":{"Line":1},"fn_name":"into_eq_join_opts\u003c\u0026str\u003e"},{"line":30,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":31,"address":[1896901],"length":1,"stats":{"Line":1},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":38,"address":[7634002,7633976,7633712],"length":1,"stats":{"Line":0},"fn_name":"into_eq_join_opts"},{"line":39,"address":[2653878],"length":1,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[7633995,7633791],"length":1,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[2654144,2654376,2654403],"length":1,"stats":{"Line":0},"fn_name":"into_eq_join_opts"},{"line":47,"address":[2736035,2735841],"length":1,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[7634304],"length":1,"stats":{"Line":0},"fn_name":"into_eq_join_opts"},{"line":62,"address":[2654453],"length":1,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[2654468],"length":1,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[2654656],"length":1,"stats":{"Line":0},"fn_name":"into_eq_join_opts"},{"line":70,"address":[2654678],"length":1,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[2509226,2508613,2508943,2508521,2508512,2508713,2508544],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":95,"address":[2509052],"length":1,"stats":{"Line":1},"fn_name":null},{"line":100,"address":[2509321],"length":1,"stats":{"Line":1},"fn_name":null},{"line":107,"address":[2510087],"length":1,"stats":{"Line":1},"fn_name":null},{"line":110,"address":[2511453,2510932,2511687,2510488,2510726,2510288,2510849,2511130,2511349,2511406],"length":1,"stats":{"Line":7},"fn_name":null},{"line":111,"address":[2510342],"length":1,"stats":{"Line":1},"fn_name":null},{"line":112,"address":[2510706,2508849,2510749,2511060,2508764,2510888],"length":1,"stats":{"Line":6},"fn_name":null},{"line":113,"address":[2511253],"length":1,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[2512021,2512069,2511573],"length":1,"stats":{"Line":2},"fn_name":null},{"line":118,"address":[2512042,2512117,2512387],"length":1,"stats":{"Line":2},"fn_name":null},{"line":120,"address":[2512652,2508782,2512782,2512276,2512573],"length":1,"stats":{"Line":7},"fn_name":null}],"covered":20,"coverable":33},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","error.rs"],"content":"use ql2::term::TermType;\n\nuse crate::Command;\n\npub(crate) fn new(message: impl Into\u003cString\u003e) -\u003e Command {\n    let arg = Command::from_json(message.into());\n\n    Command::new(TermType::Error).with_arg(arg)\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::{r, ReqlError, ReqlRuntimeError, Result};\n\n    #[tokio::test]\n    async fn test_error_ops() -\u003e Result\u003c()\u003e {\n        let msg = \"Error\";\n        let conn = r.connection().connect().await?;\n        let err = r.error(msg).run(\u0026conn).await.err().unwrap();\n\n        if let ReqlError::Runtime(err) = err {\n            if let ReqlRuntimeError::User(err) = err {\n                assert!(err == msg);\n\n                return Ok(());\n            }\n        }\n\n        assert!(false);\n\n        Ok(())\n    }\n}\n","traces":[{"line":5,"address":[5189200,5189432,5189459],"length":1,"stats":{"Line":1},"fn_name":"new\u003c\u0026str\u003e"},{"line":6,"address":[5189233],"length":1,"stats":{"Line":1},"fn_name":null},{"line":8,"address":[5189348,5189281],"length":1,"stats":{"Line":2},"fn_name":null},{"line":16,"address":[4952608,4953013,4953061,4952647],"length":1,"stats":{"Line":6},"fn_name":"test_error_ops"},{"line":17,"address":[5203089],"length":1,"stats":{"Line":1},"fn_name":null},{"line":18,"address":[5203579,5203123,5203157,5203228,5203390,5203848],"length":1,"stats":{"Line":4},"fn_name":null},{"line":19,"address":[5203172,5204099,5203823],"length":1,"stats":{"Line":3},"fn_name":null},{"line":21,"address":[5204532,5204594],"length":1,"stats":{"Line":1},"fn_name":null},{"line":22,"address":[5204581,5204613],"length":1,"stats":{"Line":2},"fn_name":null},{"line":23,"address":[5204895,5204932,5204653],"length":1,"stats":{"Line":2},"fn_name":null},{"line":25,"address":[5204901],"length":1,"stats":{"Line":1},"fn_name":null},{"line":29,"address":[5204749,5204596],"length":1,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[4952639,4952684,4953024,4952744],"length":1,"stats":{"Line":4},"fn_name":null}],"covered":12,"coverable":13},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","expr.rs"],"content":"use serde::Serialize;\n\nuse crate::Command;\n\npub(crate) fn new(value: impl Serialize) -\u003e Command {\n    Command::from_json(value)\n}\n\n#[cfg(test)]\nmod tests {\n    use serde::{Deserialize, Serialize};\n    use serde_json::json;\n\n    use crate::prelude::Converter;\n    use crate::{r, Result};\n\n    #[derive(Debug, Serialize, Deserialize, PartialEq, Eq)]\n    struct Dummy {\n        a: char,\n        b: [u8; 3],\n    }\n\n    #[tokio::test]\n    async fn test_expr_ops() -\u003e Result\u003c()\u003e {\n        let data = Dummy {\n            a: 'b',\n            b: [1, 2, 3],\n        };\n        let conn = r.connection().connect().await?;\n        let response: Dummy = r\n            .expr(json!({'a':'b'}))\n            .merge(r.expr(json!({'b':[1, 2, 3]})))\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(data == response);\n\n        Ok(())\n    }\n}\n","traces":[{"line":5,"address":[1529520],"length":1,"stats":{"Line":12},"fn_name":"new\u003c\u0026alloc::string::String\u003e"},{"line":6,"address":[1529537],"length":1,"stats":{"Line":12},"fn_name":null},{"line":24,"address":[3942585,3942720,3942384,3942361,3942352,3943020,3942441],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":27,"address":[3942515],"length":1,"stats":{"Line":1},"fn_name":null},{"line":29,"address":[3942575,3942842,3943293,3942680,3943031,3942609],"length":1,"stats":{"Line":4},"fn_name":null},{"line":30,"address":[3945925,3944927,3944999,3945722,3945409,3945223,3945628,3945152,3943916,3945685],"length":1,"stats":{"Line":7},"fn_name":null},{"line":31,"address":[3943577,3943283,3943784,3943923,3943538],"length":1,"stats":{"Line":4},"fn_name":null},{"line":32,"address":[3944039,3944788,3944419,3943939,3945014,3944971,3944282,3943490],"length":1,"stats":{"Line":3},"fn_name":null},{"line":33,"address":[3945182,3945351,3942624,3944979,3945067],"length":1,"stats":{"Line":5},"fn_name":null},{"line":34,"address":[3945532],"length":1,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[3946032,3946069,3945815],"length":1,"stats":{"Line":2},"fn_name":null},{"line":40,"address":[3946043],"length":1,"stats":{"Line":5},"fn_name":null}],"covered":11,"coverable":12},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","fill.rs"],"content":"use ql2::term::TermType;\n\nuse crate::Command;\n\npub(crate) fn new() -\u003e Command {\n    Command::new(TermType::Fill)\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::Converter;\n    use crate::types::{Point, Polygon};\n    use crate::{r, Result};\n\n    #[tokio::test]\n    async fn test_fill_ops() -\u003e Result\u003c()\u003e {\n        let conn = r.connection().connect().await?;\n        let rectangle = r.line(\u0026[\n            Point::new(-122.423246, 37.779388),\n            Point::new(-122.423246, 37.329898),\n            Point::new(-121.886420, 37.329898),\n            Point::new(-121.886420, 37.779388),\n        ]);\n        let data = Polygon::new(\u0026[\n            Point::new(-122.423246, 37.779388),\n            Point::new(-122.423246, 37.329898),\n            Point::new(-121.88642, 37.329898),\n            Point::new(-121.88642, 37.779388),\n            Point::new(-122.423246, 37.779388),\n        ]);\n\n        let response: Polygon = rectangle.fill().run(\u0026conn).await?.unwrap().parse()?;\n\n        assert!(response == data);\n\n        Ok(())\n    }\n}\n","traces":[{"line":5,"address":[2028688],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":6,"address":[2028700],"length":1,"stats":{"Line":1},"fn_name":null},{"line":16,"address":[2503461,2503095,2503509,2503056],"length":1,"stats":{"Line":6},"fn_name":"test_fill_ops"},{"line":17,"address":[5539408,5540152,5539454,5539525,5539875,5539686],"length":1,"stats":{"Line":4},"fn_name":null},{"line":18,"address":[5540486],"length":1,"stats":{"Line":1},"fn_name":null},{"line":19,"address":[5540142],"length":1,"stats":{"Line":1},"fn_name":null},{"line":20,"address":[5540417],"length":1,"stats":{"Line":1},"fn_name":null},{"line":21,"address":[5540448],"length":1,"stats":{"Line":1},"fn_name":null},{"line":22,"address":[5540479],"length":1,"stats":{"Line":1},"fn_name":null},{"line":24,"address":[5540853],"length":1,"stats":{"Line":1},"fn_name":null},{"line":25,"address":[5540675],"length":1,"stats":{"Line":1},"fn_name":null},{"line":26,"address":[5540748],"length":1,"stats":{"Line":1},"fn_name":null},{"line":27,"address":[5540779],"length":1,"stats":{"Line":1},"fn_name":null},{"line":28,"address":[5540810],"length":1,"stats":{"Line":1},"fn_name":null},{"line":29,"address":[5540841],"length":1,"stats":{"Line":1},"fn_name":null},{"line":32,"address":[5541042,5541133,5541977,5539469,5541833],"length":1,"stats":{"Line":3},"fn_name":null},{"line":34,"address":[5542218,5541951,5542251],"length":1,"stats":{"Line":2},"fn_name":null},{"line":36,"address":[2503192,2503132,2503472,2503087],"length":1,"stats":{"Line":5},"fn_name":null}],"covered":18,"coverable":18},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","filter.rs"],"content":"use ql2::term::TermType;\nuse serde::Serialize;\n\nuse crate::arguments::Args;\nuse crate::prelude::Func;\nuse crate::Command;\n\npub(crate) fn new(args: impl FilterArg) -\u003e Command {\n    let (arg, opts) = args.into_filter_opts();\n\n    Command::new(TermType::Filter).with_arg(arg).with_opts(opts)\n}\n\npub trait FilterArg {\n    fn into_filter_opts(self) -\u003e (Command, FilterOption);\n}\n\nimpl\u003cT\u003e FilterArg for T\nwhere\n    T: Serialize,\n{\n    fn into_filter_opts(self) -\u003e (Command, FilterOption) {\n        (Command::from_json(self), Default::default())\n    }\n}\n\nimpl FilterArg for Func {\n    fn into_filter_opts(self) -\u003e (Command, FilterOption) {\n        (self.0, Default::default())\n    }\n}\n\nimpl FilterArg for Command {\n    fn into_filter_opts(self) -\u003e (Command, FilterOption) {\n        (self, Default::default())\n    }\n}\n\nimpl\u003cT\u003e FilterArg for Args\u003c(T, FilterOption)\u003e\nwhere\n    T: Serialize,\n{\n    fn into_filter_opts(self) -\u003e (Command, FilterOption) {\n        (Command::from_json(self.0 .0), self.0 .1)\n    }\n}\n\nimpl FilterArg for Args\u003c(Func, FilterOption)\u003e {\n    fn into_filter_opts(self) -\u003e (Command, FilterOption) {\n        let Func(func) = self.0 .0;\n\n        (func, self.0 .1)\n    }\n}\n\nimpl FilterArg for Args\u003c(Command, FilterOption)\u003e {\n    fn into_filter_opts(self) -\u003e (Command, FilterOption) {\n        (self.0 .0, self.0 .1)\n    }\n}\n\n#[derive(Debug, Clone, Copy, Serialize, Default, Eq, PartialEq, Ord, PartialOrd, Hash)]\npub struct FilterOption {\n    /// - If `default` is set to `true`, documents with missing\n    /// fields will be returned rather than skipped.\n    /// - If `default` is set to `r.error()`, an `ReqlRuntimeError` will\n    /// be thrown when a document with a missing field is tested.\n    /// - If `default` is set to `false` (the default),\n    /// documents with missing fields will be skipped.\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub default: Option\u003cbool\u003e,\n}\n\nimpl FilterOption {\n    pub fn default_(mut self, default: bool) -\u003e Self {\n        self.default = Some(default);\n        self\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use serde_json::json;\n\n    use crate::prelude::*;\n    use crate::spec::{set_up, tear_down, Post};\n    use crate::{r, Result};\n\n    #[tokio::test]\n    async fn test_filter_data() -\u003e Result\u003c()\u003e {\n        let data = Post::get_many_data();\n        let (conn, table, table_name) = set_up(true).await?;\n        let data_filtered: Vec\u003cPost\u003e = table\n            .clone()\n            .filter(json!({\"view\": 2}))\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(data_filtered.len() == 2);\n        assert!(data_filtered.first() == data.get(3));\n        assert!(data_filtered.last() == data.get(1));\n\n        tear_down(conn, \u0026table_name).await\n    }\n\n    #[tokio::test]\n    async fn test_filter_data_with_func() -\u003e Result\u003c()\u003e {\n        let data = Post::get_many_data();\n        let (conn, table, table_name) = set_up(true).await?;\n        let data_filtered: Vec\u003cPost\u003e = table\n            .clone()\n            .filter(func!(|user| user.g(\"view\").eq(r.expr(2))))\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(data_filtered.len() == 2);\n        assert!(data_filtered.first() == data.get(3));\n        assert!(data_filtered.last() == data.get(1));\n\n        tear_down(conn, \u0026table_name).await\n    }\n}\n","traces":[{"line":8,"address":[7963264,7962880,7963596,7963243,7963216,7963569],"length":1,"stats":{"Line":2},"fn_name":"new\u003cserde_json::value::Value\u003e"},{"line":9,"address":[7962897,7963281],"length":1,"stats":{"Line":2},"fn_name":null},{"line":11,"address":[7963100,7963455,7963026,7963381],"length":1,"stats":{"Line":4},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":23,"address":[2333345],"length":1,"stats":{"Line":1},"fn_name":null},{"line":28,"address":[4545040,4545169],"length":1,"stats":{"Line":1},"fn_name":"into_filter_opts"},{"line":29,"address":[4545074],"length":1,"stats":{"Line":1},"fn_name":null},{"line":34,"address":[4585920,4586049],"length":1,"stats":{"Line":0},"fn_name":"into_filter_opts"},{"line":35,"address":[2170962],"length":1,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[2654848],"length":1,"stats":{"Line":0},"fn_name":"into_filter_opts"},{"line":50,"address":[2654870],"length":1,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[2736533],"length":1,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[7634848],"length":1,"stats":{"Line":0},"fn_name":"into_filter_opts"},{"line":58,"address":[2654997],"length":1,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[2764864],"length":1,"stats":{"Line":0},"fn_name":"default_"},{"line":76,"address":[2764886],"length":1,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[2764899],"length":1,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[2940640,2940679,2941045,2941093],"length":1,"stats":{"Line":6},"fn_name":"test_filter_data"},{"line":91,"address":[2804918],"length":1,"stats":{"Line":1},"fn_name":null},{"line":92,"address":[2805139,2804982,2805307,2805367,2805545,2805952],"length":1,"stats":{"Line":4},"fn_name":null},{"line":93,"address":[2807131,2807407,2805942,2806682,2806607,2807350,2806930,2806847,2807454,2807697],"length":1,"stats":{"Line":7},"fn_name":null},{"line":95,"address":[2806125,2806176,2806284,2806491,2806654,2806697],"length":1,"stats":{"Line":3},"fn_name":null},{"line":96,"address":[2805088,2806750,2806886,2806662,2805003,2807058],"length":1,"stats":{"Line":6},"fn_name":null},{"line":97,"address":[2807254],"length":1,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[2808020,2807583,2808068],"length":1,"stats":{"Line":2},"fn_name":null},{"line":102,"address":[2808272,2808041,2808113],"length":1,"stats":{"Line":2},"fn_name":null},{"line":103,"address":[2808248,2808494,2808315],"length":1,"stats":{"Line":2},"fn_name":null},{"line":105,"address":[7917796],"length":1,"stats":{"Line":7},"fn_name":null},{"line":109,"address":[2809360,2809461,2809790,2810142,2809392,2809560,2809369],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":110,"address":[2809526],"length":1,"stats":{"Line":1},"fn_name":null},{"line":111,"address":[2809590,2809975,2809747,2810153,2810560,2809915],"length":1,"stats":{"Line":4},"fn_name":null},{"line":112,"address":[2811567,2810550,2812235,2812292,2812582,2811815,2811433,2812339,2811732,2812016],"length":1,"stats":{"Line":7},"fn_name":null},{"line":114,"address":[2810789,2810733,2810831,2811472,2811582,2814272,2814310],"length":1,"stats":{"Line":4},"fn_name":"{closure#0}"},{"line":115,"address":[2811943,2809696,2811547,2811635,2811771,2809611],"length":1,"stats":{"Line":6},"fn_name":null},{"line":116,"address":[2812139],"length":1,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[2812468,2812956,2812905],"length":1,"stats":{"Line":2},"fn_name":null},{"line":121,"address":[2812926,2813004,2813187],"length":1,"stats":{"Line":2},"fn_name":null},{"line":122,"address":[2813163,2813230,2813409],"length":1,"stats":{"Line":2},"fn_name":null},{"line":124,"address":[2809629,2813365,2813625,2813442,2813726,2813862,2813566],"length":1,"stats":{"Line":7},"fn_name":null}],"covered":27,"coverable":41},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","floor.rs"],"content":"use ql2::term::TermType;\n\nuse crate::Command;\n\npub(crate) fn new(args: impl FloorArg) -\u003e Command {\n    let mut command = Command::new(TermType::Floor);\n\n    if let Some(arg) = args.into_floor_opts() {\n        command = command.with_arg(arg)\n    }\n\n    command\n}\n\npub trait FloorArg {\n    fn into_floor_opts(self) -\u003e Option\u003cCommand\u003e;\n}\n\nimpl FloorArg for () {\n    fn into_floor_opts(self) -\u003e Option\u003cCommand\u003e {\n        None\n    }\n}\n\nimpl FloorArg for Command {\n    fn into_floor_opts(self) -\u003e Option\u003cCommand\u003e {\n        Some(self)\n    }\n}\n\nimpl FloorArg for f64 {\n    fn into_floor_opts(self) -\u003e Option\u003cCommand\u003e {\n        Some(Command::from_json(self))\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::Converter;\n    use crate::{r, Result};\n\n    #[tokio::test]\n    async fn test_floor_data() -\u003e Result\u003c()\u003e {\n        let conn = r.connection().connect().await?;\n        let data_obtained: i8 = r.floor(-12.345).run(\u0026conn).await?.unwrap().parse()?;\n        let data_obtained2: i8 = r.expr(-12.345).floor().run(\u0026conn).await?.unwrap().parse()?;\n        let data_obtained3: i8 = r\n            .floor(r.expr(-12.345))\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(\n            data_obtained == -13\n                \u0026\u0026 data_obtained == data_obtained2\n                \u0026\u0026 data_obtained == data_obtained3\n        );\n\n        Ok(())\n    }\n}\n","traces":[{"line":5,"address":[2459235,2458688],"length":1,"stats":{"Line":3},"fn_name":"new\u003c()\u003e"},{"line":6,"address":[2377060,2377156],"length":1,"stats":{"Line":6},"fn_name":null},{"line":8,"address":[1574083,1574412,1575274,1573752,1573810,1574941,1574685,1574322,1574999],"length":1,"stats":{"Line":8},"fn_name":null},{"line":9,"address":[2377332,2377477],"length":1,"stats":{"Line":4},"fn_name":null},{"line":12,"address":[2459176],"length":1,"stats":{"Line":3},"fn_name":null},{"line":20,"address":[2518416],"length":1,"stats":{"Line":1},"fn_name":"into_floor_opts"},{"line":21,"address":[2518420],"length":1,"stats":{"Line":1},"fn_name":null},{"line":26,"address":[2171088],"length":1,"stats":{"Line":1},"fn_name":"into_floor_opts"},{"line":27,"address":[2171104],"length":1,"stats":{"Line":1},"fn_name":null},{"line":32,"address":[2518432],"length":1,"stats":{"Line":1},"fn_name":"into_floor_opts"},{"line":33,"address":[2518458],"length":1,"stats":{"Line":1},"fn_name":null},{"line":43,"address":[2619355,2618672,2618640,2618649,2618729,2618798,2619055],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":44,"address":[2619015,2619177,2618825,2618788,2619366,2619635],"length":1,"stats":{"Line":4},"fn_name":null},{"line":45,"address":[2618843,2619625,2619880,2620640,2618972,2620544],"length":1,"stats":{"Line":5},"fn_name":null},{"line":46,"address":[2618858,2618929,2620630,2620868,2621563,2621659],"length":1,"stats":{"Line":5},"fn_name":null},{"line":47,"address":[2621999,2622532,2621860,2622555,2622475,2622256,2622744,2622070],"length":1,"stats":{"Line":5},"fn_name":null},{"line":48,"address":[2621649],"length":1,"stats":{"Line":1},"fn_name":null},{"line":49,"address":[2622029,2622198,2618873,2621911],"length":1,"stats":{"Line":4},"fn_name":null},{"line":50,"address":[2622379],"length":1,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[2622923,2622883],"length":1,"stats":{"Line":1},"fn_name":null},{"line":55,"address":[2622874,2622820,2622633],"length":1,"stats":{"Line":3},"fn_name":null},{"line":56,"address":[2622811],"length":1,"stats":{"Line":1},"fn_name":null},{"line":57,"address":[2622868],"length":1,"stats":{"Line":1},"fn_name":null},{"line":60,"address":[2622901],"length":1,"stats":{"Line":5},"fn_name":null}],"covered":23,"coverable":24},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","fold.rs"],"content":"use ql2::term::TermType;\nuse serde::Serialize;\n\nuse crate::prelude::Func;\nuse crate::Command;\n\npub(crate) fn new\u003cT\u003e(base: T, func: Func) -\u003e Command\nwhere\n    T: Serialize,\n{\n    Command::new(TermType::Fold)\n        .with_arg(Command::from_json(base))\n        .with_arg(func.0)\n}\n\n// #[derive(Debug, Clone, Serialize, Default)]\n// #[non_exhaustive]\n// pub struct FoldOption {\n//     pub emit: Option\u003cCommand\u003e,\n//     pub final_emit: Option\u003cCommand\u003e,\n// }\n\n#[cfg(test)]\nmod tests {\n    use crate::args;\n    use crate::prelude::*;\n    use crate::spec::*;\n    use crate::{r, Result};\n\n    #[tokio::test]\n    async fn test_fold_ops() -\u003e Result\u003c()\u003e {\n        let posts = Post::get_many_data()\n            .into_iter()\n            .fold(String::new(), |acc, post| {\n                format!(\"{}{}{}\", acc, if acc == \"\" { \"\" } else { \", \" }, post.title)\n            });\n        let (conn, table, table_name) = set_up(true).await?;\n        let response: String = table\n            .order_by(r.expr(\"id\"))\n            .fold(\n                \"\",\n                func!(|acc, post| acc.clone()\n                    + r.branch(acc.eq(\"\"), args!(r.expr(\"\"), r.expr(\", \")))\n                    + post.g(\"title\")),\n            )\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(response == posts);\n\n        tear_down(conn, \u0026table_name).await\n    }\n}\n","traces":[{"line":7,"address":[2501053,2501005,2500640],"length":1,"stats":{"Line":1},"fn_name":"new\u003c\u0026str\u003e"},{"line":11,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":12,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":13,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":31,"address":[2421957,2422575,2421865,2421856,2421888,2422089,2422315],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":32,"address":[2422426,2422019,2422498],"length":1,"stats":{"Line":3},"fn_name":null},{"line":34,"address":[2426880,2427318,2427380,2422449],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":35,"address":[2427006,2426923],"length":1,"stats":{"Line":2},"fn_name":null},{"line":37,"address":[2422119,2422272,2422550,2423295,2422670],"length":1,"stats":{"Line":4},"fn_name":null},{"line":38,"address":[2425437,2425711,2424585,2423506,2425161,2425380,2423243,2424889,2425481,2424966,2424730],"length":1,"stats":{"Line":8},"fn_name":null},{"line":39,"address":[2423581,2423599,2423265,2423472,2423545],"length":1,"stats":{"Line":2},"fn_name":null},{"line":42,"address":[2423574,2427568,2424635,2424022,2424570,2423654,2423619,2427408,2427958,2428177,2428265,2427977,2427451],"length":1,"stats":{"Line":8},"fn_name":"{closure#1}"},{"line":43,"address":[2427576,2428021,2427969,2428125],"length":1,"stats":{"Line":2},"fn_name":null},{"line":44,"address":[2428210,2428285,2428052,2428135,2427522],"length":1,"stats":{"Line":2},"fn_name":null},{"line":46,"address":[2425094,2422223,2422140,2424922,2424710,2424798],"length":1,"stats":{"Line":6},"fn_name":null},{"line":47,"address":[2425284],"length":1,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[2426050,2425995,2425601],"length":1,"stats":{"Line":2},"fn_name":null},{"line":53,"address":[2426525,2426391,2426009,2422158,2426307,2426123,2426247],"length":1,"stats":{"Line":7},"fn_name":null}],"covered":17,"coverable":18},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","for_each.rs"],"content":"use ql2::term::TermType;\n\nuse crate::prelude::Func;\nuse crate::Command;\n\npub(crate) fn new(arg: Func) -\u003e Command {\n    Command::new(TermType::ForEach).with_arg(arg.0)\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::*;\n    use crate::spec::{set_up, tear_down};\n    use crate::types::MutationResponse;\n    use crate::Result;\n\n    #[tokio::test]\n    async fn test_for_each_opts() -\u003e Result\u003c()\u003e {\n        let (conn, table, table_name) = set_up(true).await?;\n        let response: MutationResponse = table\n            .clone()\n            .for_each(func!(|doc| table.get(doc.g(\"id\")).delete(())))\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(response.deleted == 5);\n\n        tear_down(conn, \u0026table_name).await\n    }\n}\n","traces":[{"line":6,"address":[2685592,2685376,2685561],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":7,"address":[2685487,2685398],"length":1,"stats":{"Line":2},"fn_name":null},{"line":18,"address":[1851559,1851925,1851973,1851520],"length":1,"stats":{"Line":6},"fn_name":"test_for_each_opts"},{"line":19,"address":[5414970,5415892,5415127,5414870,5415298,5415479],"length":1,"stats":{"Line":4},"fn_name":null},{"line":20,"address":[5417113,5417556,5417879,5418121,5415882,5417775,5416958,5417355,5417832,5417278],"length":1,"stats":{"Line":7},"fn_name":null},{"line":22,"address":[5416997,5419237,5416101,5419216,5416152,5417037,5416935,5417128],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":23,"address":[5415076,5417311,5417483,5414991,5417181],"length":1,"stats":{"Line":5},"fn_name":null},{"line":24,"address":[5417679],"length":1,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[5417999,5418336],"length":1,"stats":{"Line":1},"fn_name":null},{"line":30,"address":[1851656,1851936,1851551,1851596],"length":1,"stats":{"Line":7},"fn_name":null}],"covered":9,"coverable":10},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","func.rs"],"content":"use crate::Command;\nuse ql2::term::TermType;\n\n#[derive(Debug, Clone)]\npub struct Func(pub(crate) Command);\n\nimpl Func {\n    pub fn new\u003cT\u003e(ids: Vec\u003cu64\u003e, body: T) -\u003e Self\n    where\n        T: Into\u003cCommand\u003e,\n    {\n        Func(\n            Command::new(TermType::Func)\n                .with_arg(Command::from_json(ids))\n                .with_arg(body),\n        )\n    }\n}\n\nimpl From\u003cFunc\u003e for Command {\n    fn from(func: Func) -\u003e Self {\n        func.0\n    }\n}\n","traces":[{"line":8,"address":[5098954,5098512,5098886],"length":1,"stats":{"Line":1},"fn_name":"new\u003creql_rust::proto::Command\u003e"},{"line":13,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":14,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":15,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":21,"address":[2171152],"length":1,"stats":{"Line":0},"fn_name":"from"},{"line":22,"address":[2171160],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":4,"coverable":6},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","ge.rs"],"content":"use ql2::term::TermType;\nuse serde::Serialize;\n\nuse crate::arguments::Args;\nuse crate::Command;\n\nuse super::CmdOpts;\n\npub(crate) fn new(args: impl GeArg) -\u003e Command {\n    args.into_ge_opts().add_to_cmd(Command::new(TermType::Ge))\n}\n\npub trait GeArg {\n    fn into_ge_opts(self) -\u003e CmdOpts;\n}\n\nimpl\u003cT: Serialize\u003e GeArg for T {\n    fn into_ge_opts(self) -\u003e CmdOpts {\n        CmdOpts::Single(Command::from_json(self))\n    }\n}\n\nimpl GeArg for Command {\n    fn into_ge_opts(self) -\u003e CmdOpts {\n        CmdOpts::Single(self)\n    }\n}\n\nimpl\u003cS, T\u003e GeArg for Args\u003cT\u003e\nwhere\n    S: Serialize,\n    T: IntoIterator\u003cItem = S\u003e,\n{\n    fn into_ge_opts(self) -\u003e CmdOpts {\n        let commands = self.0.into_iter().map(Command::from_json).collect();\n\n        CmdOpts::Many(commands)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::Converter;\n    use crate::spec::{set_up, tear_down};\n    use crate::{args, r, Result};\n\n    #[tokio::test]\n    async fn test_ge_data() -\u003e Result\u003c()\u003e {\n        let (conn, table, table_name) = set_up(true).await?;\n        let data_obtained: bool = table\n            .get(1)\n            .g(\"view\")\n            .ge(10)\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(data_obtained);\n\n        tear_down(conn, \u0026table_name).await\n    }\n\n    #[tokio::test]\n    async fn test_ge_data_r() -\u003e Result\u003c()\u003e {\n        let conn = r.connection().connect().await?;\n        let data_obtained: bool = r.ge(args!([7, 6, 5])).run(\u0026conn).await?.unwrap().parse()?;\n\n        assert!(data_obtained);\n\n        Ok(())\n    }\n}\n","traces":[{"line":9,"address":[2449340,2448912,2449313,2449081,2449108,2449120],"length":1,"stats":{"Line":2},"fn_name":"new\u003ci32\u003e"},{"line":10,"address":[2449137,2448935,2449101,2449333],"length":1,"stats":{"Line":2},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":24,"address":[2171184],"length":1,"stats":{"Line":0},"fn_name":"into_ge_opts"},{"line":25,"address":[2171200],"length":1,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":48,"address":[2942085,2941632,2942037,2941671],"length":1,"stats":{"Line":6},"fn_name":"test_ge_data"},{"line":49,"address":[4556516,4556669,4556451,4556837,4557015,4557452],"length":1,"stats":{"Line":4},"fn_name":null},{"line":50,"address":[4557889,4557399,4558380,4558671,4558437,4557685,4557966,4558161,4558481],"length":1,"stats":{"Line":6},"fn_name":null},{"line":54,"address":[7876800],"length":1,"stats":{"Line":5},"fn_name":null},{"line":55,"address":[4558284],"length":1,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[4558560,4558874],"length":1,"stats":{"Line":1},"fn_name":null},{"line":61,"address":[2941708,2942048,2941768,2941663],"length":1,"stats":{"Line":7},"fn_name":null},{"line":65,"address":[2942128,2942167,2942533,2942581],"length":1,"stats":{"Line":6},"fn_name":"test_ge_data_r"},{"line":66,"address":[4560013,4559747,4560202,4560534,4559781,4559852],"length":1,"stats":{"Line":4},"fn_name":null},{"line":67,"address":[4560762,4559796,4561462,4560445,4561556],"length":1,"stats":{"Line":4},"fn_name":null},{"line":69,"address":[4561764,4561541],"length":1,"stats":{"Line":1},"fn_name":null},{"line":71,"address":[2942159,2942204,2942544,2942264],"length":1,"stats":{"Line":5},"fn_name":null}],"covered":18,"coverable":21},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","geojson.rs"],"content":"use ql2::term::TermType;\nuse serde::{Deserialize, Serialize};\n\nuse crate::prelude::Geometry;\nuse crate::types::{GeoJson, GeoType, ReqlType};\nuse crate::Command;\n\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, PartialOrd)]\npub struct ReqlGeoJson\u003cT\u003e {\n    #[serde(rename = \"$reql_type$\")]\n    pub reql_type: ReqlType,\n    pub coordinates: T,\n    #[serde(rename = \"type\")]\n    pub typ: GeoType,\n}\n\nimpl\u003cT: Serialize\u003e ReqlGeoJson\u003cT\u003e {\n    pub fn new(geojson: GeoJson\u003cT\u003e) -\u003e Self {\n        Self {\n            reql_type: ReqlType::Geometry,\n            typ: geojson.typ,\n            coordinates: geojson.coordinates,\n        }\n    }\n}\n\nimpl\u003cT: Serialize\u003e From\u003cReqlGeoJson\u003cT\u003e\u003e for Command {\n    fn from(geo: ReqlGeoJson\u003cT\u003e) -\u003e Self {\n        let geo: GeoJson\u003cT\u003e = geo.into();\n        let arg = Command::from_json(geo);\n\n        Command::new(TermType::Geojson).with_arg(arg)\n    }\n}\n\nimpl\u003cT: Serialize\u003e From\u003cReqlGeoJson\u003cT\u003e\u003e for GeoJson\u003cT\u003e {\n    fn from(geo: ReqlGeoJson\u003cT\u003e) -\u003e Self {\n        Self {\n            typ: geo.typ,\n            coordinates: geo.coordinates,\n        }\n    }\n}\n\nimpl\u003cT: Serialize\u003e Geometry for ReqlGeoJson\u003cT\u003e {\n    fn cmd(self) -\u003e Command {\n        self.into()\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use serde::{Deserialize, Serialize};\n\n    use crate::prelude::Converter;\n    use crate::spec::{set_up, tear_down};\n    use crate::types::{GeoJson, GeoType};\n    use crate::{r, Result};\n\n    use super::ReqlGeoJson;\n\n    #[derive(Debug, Serialize, Deserialize, PartialEq)]\n    struct User {\n        id: u8,\n        name: String,\n        location: ReqlGeoJson\u003c[f64; 2]\u003e,\n    }\n\n    #[tokio::test]\n    async fn test_geojson_data() -\u003e Result\u003c()\u003e {\n        let geo_json = GeoJson {\n            typ: GeoType::Point,\n            coordinates: [-122.423246, 37.779388],\n        };\n        let user = User {\n            id: 1,\n            name: \"Yaoundé\".to_string(),\n            location: r.geojson(geo_json),\n        };\n        let (conn, table, table_name) = set_up(false).await?;\n        table.clone().insert(\u0026user).run(\u0026conn).await?;\n        let response: User = table.get(1).run(\u0026conn).await?.unwrap().parse()?;\n\n        assert!(response == user);\n\n        tear_down(conn, \u0026table_name).await\n    }\n}\n","traces":[{"line":18,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[4786507,4786791,4786021,4785920,4786205,4785952,4785929],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":73,"address":[4786119],"length":1,"stats":{"Line":1},"fn_name":null},{"line":77,"address":[4786175],"length":1,"stats":{"Line":1},"fn_name":null},{"line":78,"address":[4786619],"length":1,"stats":{"Line":1},"fn_name":null},{"line":80,"address":[4786464,4786235,4786784,4786858,4787439],"length":1,"stats":{"Line":4},"fn_name":null},{"line":81,"address":[4787663,4786413,4787429,4786256],"length":1,"stats":{"Line":4},"fn_name":null},{"line":82,"address":[4788533,4789461,4788409,4786277,4786362,4789253],"length":1,"stats":{"Line":5},"fn_name":null},{"line":84,"address":[4789447,4789943,4789885],"length":1,"stats":{"Line":2},"fn_name":null},{"line":86,"address":[2784815,2784920,2784860,2785200],"length":1,"stats":{"Line":7},"fn_name":null}],"covered":12,"coverable":21},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","get.rs"],"content":"use ql2::term::TermType;\nuse serde::Serialize;\n\nuse crate::Command;\n\npub(crate) fn new(args: impl GetArg) -\u003e Command {\n    Command::new(TermType::Get).with_arg(args.into_get_opts())\n}\n\npub trait GetArg {\n    fn into_get_opts(self) -\u003e Command;\n}\n\nimpl GetArg for Command {\n    fn into_get_opts(self) -\u003e Command {\n        self\n    }\n}\n\nimpl\u003cT\u003e GetArg for T\nwhere\n    T: Serialize,\n{\n    fn into_get_opts(self) -\u003e Command {\n        Command::from_json(self)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::Converter;\n    use crate::spec::{set_up, tear_down, Post};\n    use crate::Result;\n\n    #[tokio::test]\n    async fn test_get_data() -\u003e Result\u003c()\u003e {\n        let expected_post = Post::get_many_data().get(3).unwrap().to_owned();\n        let (conn, table, table_name) = set_up(true).await?;\n        let data_inserted: Option\u003cPost\u003e = table\n            .get(expected_post.id)\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(data_inserted == Some(expected_post));\n\n        tear_down(conn, table_name.as_str()).await\n    }\n}\n","traces":[{"line":6,"address":[7668382,7668057,7668096,7667488,7667168,7667450,7667792,7667749],"length":1,"stats":{"Line":4},"fn_name":"new\u003c\u0026str\u003e"},{"line":7,"address":[7667211,7667822,7667316,7667921,7667516,7668047,7668118,7667739,7668218,7667615,7668372,7667440],"length":1,"stats":{"Line":8},"fn_name":null},{"line":15,"address":[2171264],"length":1,"stats":{"Line":1},"fn_name":"into_get_opts"},{"line":16,"address":[2171272],"length":1,"stats":{"Line":1},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":36,"address":[2800245,2800197,2799831,2799792],"length":1,"stats":{"Line":6},"fn_name":"test_get_data"},{"line":37,"address":[7329876,7329507],"length":1,"stats":{"Line":2},"fn_name":null},{"line":38,"address":[7329571,7329726,7330115,7330707],"length":1,"stats":{"Line":3},"fn_name":null},{"line":39,"address":[7331129,7331324,7332062,7330935,7330654,7331600,7331543,7331052,7331644],"length":1,"stats":{"Line":6},"fn_name":null},{"line":41,"address":[7330958,7329677,7329592,7331085,7331257,7330915],"length":1,"stats":{"Line":6},"fn_name":null},{"line":42,"address":[7331447],"length":1,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[7332449,7331829,7332391,7332289],"length":1,"stats":{"Line":2},"fn_name":null},{"line":48,"address":[2799868,2799928,2799823,2800208],"length":1,"stats":{"Line":7},"fn_name":null}],"covered":13,"coverable":14},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","get_all.rs"],"content":"use std::borrow::Cow;\n\nuse ql2::term::TermType;\nuse reql_macros::CommandOptions;\nuse serde::Serialize;\n\nuse crate::{arguments::Args, Command};\n\nuse super::CmdOpts;\n\npub(crate) fn new(args: impl GetAllArg) -\u003e Command {\n    let (args, opts) = args.into_get_all_opts();\n\n    args.add_to_cmd(Command::new(TermType::GetAll))\n        .with_opts(opts)\n}\n\npub trait GetAllArg {\n    fn into_get_all_opts(self) -\u003e (CmdOpts, GetAllOption);\n}\n\nimpl\u003cS, T\u003e GetAllArg for T\nwhere\n    S: Serialize,\n    T: IntoIterator\u003cItem = S\u003e,\n{\n    fn into_get_all_opts(self) -\u003e (CmdOpts, GetAllOption) {\n        let keys = self\n            .into_iter()\n            .map(|key| Command::from_json(key))\n            .collect();\n\n        (CmdOpts::Many(keys), Default::default())\n    }\n}\n\nimpl GetAllArg for Command {\n    fn into_get_all_opts(self) -\u003e (CmdOpts, GetAllOption) {\n        (CmdOpts::Single(self), Default::default())\n    }\n}\n\nimpl\u003cS, T\u003e GetAllArg for Args\u003c(T, GetAllOption)\u003e\nwhere\n    S: Serialize,\n    T: IntoIterator\u003cItem = S\u003e,\n{\n    fn into_get_all_opts(self) -\u003e (CmdOpts, GetAllOption) {\n        let keys = self\n            .0\n             .0\n            .into_iter()\n            .map(|key| Command::from_json(key))\n            .collect();\n\n        (CmdOpts::Many(keys), self.0 .1)\n    }\n}\n\nimpl GetAllArg for Args\u003c(Command, GetAllOption)\u003e {\n    fn into_get_all_opts(self) -\u003e (CmdOpts, GetAllOption) {\n        (CmdOpts::Single(self.0 .0), self.0 .1)\n    }\n}\n\n#[derive(Debug, Clone, Serialize, Default, PartialEq, PartialOrd, CommandOptions)]\npub struct GetAllOption {\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub index: Option\u003cCow\u003c'static, str\u003e\u003e,\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::args;\n    use crate::prelude::*;\n    use crate::spec::{set_up, tear_down, Post};\n    use crate::Result;\n\n    use super::GetAllOption;\n\n    #[tokio::test]\n    async fn test_get_all() -\u003e Result\u003c()\u003e {\n        let data = Post::get_many_data();\n        let (conn, table, table_name) = set_up(true).await?;\n\n        table.clone().sync().run(\u0026conn).await?;\n\n        let data_get: Vec\u003cPost\u003e = table\n            .get_all(args!([\"title4\"], GetAllOption::default().index(\"title\")))\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(data_get.len() == 2);\n        assert!(data_get.first() == data.get(3));\n        assert!(data_get.last() == data.last());\n\n        tear_down(conn, \u0026table_name).await\n    }\n}\n","traces":[{"line":11,"address":[2948144,2948660,2948571],"length":1,"stats":{"Line":1},"fn_name":"new\u003creql_rust::arguments::Args\u003c([\u0026str; 1], reql_rust::cmd::get_all::GetAllOption)\u003e\u003e"},{"line":12,"address":[2948161],"length":1,"stats":{"Line":1},"fn_name":null},{"line":14,"address":[2948329,2948564,2948537],"length":1,"stats":{"Line":2},"fn_name":null},{"line":15,"address":[2948481],"length":1,"stats":{"Line":1},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[4586523,4586288],"length":1,"stats":{"Line":0},"fn_name":"into_get_all_opts"},{"line":39,"address":[2252996],"length":1,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":61,"address":[2655088],"length":1,"stats":{"Line":0},"fn_name":"into_get_all_opts"},{"line":62,"address":[2655110],"length":1,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[4954135,4954549,4954096,4954501],"length":1,"stats":{"Line":6},"fn_name":"test_get_all"},{"line":83,"address":[4743286],"length":1,"stats":{"Line":1},"fn_name":null},{"line":84,"address":[4743984,4743746,4744398,4743349,4743806,4743578],"length":1,"stats":{"Line":4},"fn_name":null},{"line":86,"address":[4743527,4744388,4743370,4744614],"length":1,"stats":{"Line":4},"fn_name":null},{"line":88,"address":[4746717,4746451,4745719,4746175,4745891,4746474,4745644,4746394,4745360,4745974],"length":1,"stats":{"Line":7},"fn_name":null},{"line":89,"address":[4745401,4745691,4745744,4745472,4745726],"length":1,"stats":{"Line":2},"fn_name":null},{"line":90,"address":[4743476,4746102,4745794,4745699,4745930,4743391],"length":1,"stats":{"Line":6},"fn_name":null},{"line":91,"address":[4746298],"length":1,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[4746603,4747049,4747100],"length":1,"stats":{"Line":2},"fn_name":null},{"line":96,"address":[4747148,4747343,4747070],"length":1,"stats":{"Line":2},"fn_name":null},{"line":97,"address":[4747392,4747599,4747313],"length":1,"stats":{"Line":2},"fn_name":null},{"line":99,"address":[4747552,4747781,4747840,4747929,4748065,4743409,4747654],"length":1,"stats":{"Line":7},"fn_name":null}],"covered":19,"coverable":30},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","get_field.rs"],"content":"use ql2::term::TermType;\n\nuse crate::Command;\n\npub(crate) fn new(attr: impl Into\u003cString\u003e) -\u003e Command {\n    let arg = Command::from_json(attr.into());\n\n    Command::new(TermType::GetField).with_arg(arg)\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::Converter;\n    use crate::spec::{set_up, tear_down, Post};\n    use crate::Result;\n\n    #[tokio::test]\n    async fn test_get_fields_ops() -\u003e Result\u003c()\u003e {\n        let data = Post::get_one_data();\n        let (conn, table, table_name) = set_up(true).await?;\n        let data_obtained: String = table.get(1).g(\"title\").run(\u0026conn).await?.unwrap().parse()?;\n\n        assert!(data_obtained == data.title);\n\n        tear_down(conn, \u0026table_name).await\n    }\n}\n","traces":[{"line":5,"address":[4891104,4891336,4891363],"length":1,"stats":{"Line":1},"fn_name":"new\u003c\u0026str\u003e"},{"line":6,"address":[4891137],"length":1,"stats":{"Line":1},"fn_name":null},{"line":8,"address":[4891185,4891252],"length":1,"stats":{"Line":2},"fn_name":null},{"line":18,"address":[1852421,1852055,1852469,1852016],"length":1,"stats":{"Line":6},"fn_name":"test_get_fields_ops"},{"line":19,"address":[2584131],"length":1,"stats":{"Line":1},"fn_name":null},{"line":20,"address":[2584183,2584336,2584501,2585174,2584561,2584736],"length":1,"stats":{"Line":4},"fn_name":null},{"line":21,"address":[2586146,2586280,2584287,2584204,2585121,2585374],"length":1,"stats":{"Line":5},"fn_name":null},{"line":23,"address":[2586635,2586266,2586690],"length":1,"stats":{"Line":2},"fn_name":null},{"line":25,"address":[1852092,1852152,1852047,1852432],"length":1,"stats":{"Line":7},"fn_name":null}],"covered":9,"coverable":9},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","get_intersecting.rs"],"content":"use std::borrow::Cow;\n\nuse ql2::term::TermType;\nuse reql_macros::CommandOptions;\nuse serde::Serialize;\n\nuse crate::prelude::Geometry;\nuse crate::Command;\n\npub(crate) fn new(args: impl GetIntersectingArg, index: \u0026'static str) -\u003e Command {\n    let opts = GetIntersectingOption::default().index(index);\n\n    Command::new(TermType::GetIntersecting)\n        .with_arg(args.into_get_intersecting_opts())\n        .with_opts(opts)\n}\n\npub trait GetIntersectingArg {\n    fn into_get_intersecting_opts(self) -\u003e Command;\n}\n\nimpl GetIntersectingArg for Command {\n    fn into_get_intersecting_opts(self) -\u003e Command {\n        self\n    }\n}\n\nimpl\u003cT\u003e GetIntersectingArg for T\nwhere\n    T: Geometry,\n{\n    fn into_get_intersecting_opts(self) -\u003e Command {\n        self.cmd()\n    }\n}\n\n#[derive(Debug, Clone, Serialize, Default, CommandOptions)]\npub struct GetIntersectingOption {\n    pub index: Option\u003cCow\u003c'static, str\u003e\u003e,\n}\n\n#[cfg(test)]\nmod tests {\n    use serde::{Deserialize, Serialize};\n    use uuid::Uuid;\n\n    use crate::cmd::index_create::IndexCreateOption;\n    use crate::cmd::point::Point;\n    use crate::cmd::polygon::Polygon;\n    use crate::prelude::Converter;\n    use crate::{args, r, Result};\n\n    #[derive(Debug, Serialize, Deserialize, PartialEq)]\n    struct Park {\n        id: u8,\n        area: Point,\n    }\n\n    impl Park {\n        fn new(id: u8, area: Point) -\u003e Self {\n            Self { id, area }\n        }\n    }\n\n    #[tokio::test]\n    async fn test_get_intersecting_ops() -\u003e Result\u003c()\u003e {\n        let data = vec![\n            Park::new(1, r.point(-0.1, 5.3)),\n            Park::new(2, r.point(-117.220406, 32.719464)),\n            Park::new(2, r.point(-120.6, 58.9)),\n            Park::new(3, r.point(-11.220, 25.764)),\n        ];\n        let table_name = Uuid::new_v4().to_string();\n        let conn = r.connection().connect().await?;\n        let table = r.table(table_name.as_str());\n        let circle: Polygon = r\n            .circle(args!(r.point(-117.220406, 32.719464), 10.))\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n        r.table_create(table_name.as_str()).run(\u0026conn).await?;\n        table\n            .clone()\n            .index_create(args!(\"area\", IndexCreateOption::default().geo(true)))\n            .run(\u0026conn)\n            .await?;\n        table.clone().index_wait(()).run(\u0026conn).await?;\n        table.clone().insert(\u0026data).run(\u0026conn).await?;\n\n        let response: Vec\u003cPark\u003e = table\n            .get_intersecting(circle, \"area\")\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(response.len() == 1);\n\n        r.table_drop(table_name.as_str()).run(\u0026conn).await?;\n        Ok(())\n    }\n}\n","traces":[{"line":10,"address":[5042160,5042668,5042621],"length":1,"stats":{"Line":1},"fn_name":"new\u003creql_rust::cmd::polygon::Polygon\u003e"},{"line":11,"address":[5042208,5042313],"length":1,"stats":{"Line":2},"fn_name":null},{"line":13,"address":[5042328,5042404,5042596,5042500],"length":1,"stats":{"Line":4},"fn_name":null},{"line":14,"address":[5042611,5042412,5042541],"length":1,"stats":{"Line":2},"fn_name":null},{"line":15,"address":[5042549],"length":1,"stats":{"Line":1},"fn_name":null},{"line":23,"address":[2171568],"length":1,"stats":{"Line":0},"fn_name":"into_get_intersecting_opts"},{"line":24,"address":[2171576],"length":1,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":60,"address":[8051456],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":66,"address":[1754104,1755218,1754694,1753897,1753888,1753989,1753920],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":67,"address":[1755111,1754861,1754054],"length":1,"stats":{"Line":2},"fn_name":null},{"line":68,"address":[1754911,1754846],"length":1,"stats":{"Line":2},"fn_name":null},{"line":69,"address":[1754942],"length":1,"stats":{"Line":1},"fn_name":null},{"line":70,"address":[1755001],"length":1,"stats":{"Line":1},"fn_name":null},{"line":71,"address":[1755060],"length":1,"stats":{"Line":1},"fn_name":null},{"line":73,"address":[1755296,1755229],"length":1,"stats":{"Line":2},"fn_name":null},{"line":74,"address":[7805903],"length":1,"stats":{"Line":4},"fn_name":null},{"line":75,"address":[1756138,1755852],"length":1,"stats":{"Line":2},"fn_name":null},{"line":76,"address":[1756355,1757313,1756561,1756478,1756981,1757061,1756320,1757038,1756762],"length":1,"stats":{"Line":6},"fn_name":null},{"line":77,"address":[1756222,1756188],"length":1,"stats":{"Line":2},"fn_name":null},{"line":78,"address":[7805658],"length":1,"stats":{"Line":6},"fn_name":null},{"line":79,"address":[1756885],"length":1,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[1757187,1754549,1754176,1757492],"length":1,"stats":{"Line":4},"fn_name":null},{"line":83,"address":[1759039,1758515,1759247,1758235,1758590,1758755,1758838],"length":1,"stats":{"Line":6},"fn_name":null},{"line":85,"address":[1758605,1758280,1758323,1758562],"length":1,"stats":{"Line":2},"fn_name":null},{"line":86,"address":[1754197,1758570,1758966,1754498,1758658,1758794],"length":1,"stats":{"Line":6},"fn_name":null},{"line":87,"address":[1759277,1759129],"length":1,"stats":{"Line":1},"fn_name":null},{"line":88,"address":[1754218,1754447,1759379,1759317],"length":1,"stats":{"Line":4},"fn_name":null},{"line":89,"address":[1760169,1754396,1760099,1754239],"length":1,"stats":{"Line":4},"fn_name":null},{"line":91,"address":[1760889,1761197,1761280,1761481,1761700,1761757,1761780,1760983,1761074,1762023],"length":1,"stats":{"Line":7},"fn_name":null},{"line":92,"address":[1760946],"length":1,"stats":{"Line":1},"fn_name":null},{"line":93,"address":[1761236,1761097,1761408,1754345,1754260,1761054],"length":1,"stats":{"Line":6},"fn_name":null},{"line":94,"address":[1761604],"length":1,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[1761909,1762188,1762140],"length":1,"stats":{"Line":2},"fn_name":null},{"line":100,"address":[1762161,1762271,1754278],"length":1,"stats":{"Line":3},"fn_name":null},{"line":101,"address":[1763197],"length":1,"stats":{"Line":5},"fn_name":null}],"covered":33,"coverable":37},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","get_nearest.rs"],"content":"use std::borrow::Cow;\n\nuse ql2::term::TermType;\nuse reql_macros::CommandOptions;\nuse serde::Serialize;\n\nuse crate::arguments::{Args, Unit};\nuse crate::prelude::Geometry;\nuse crate::types::GeoSystem;\nuse crate::Command;\n\npub(crate) fn new(args: impl GetNearestArg) -\u003e Command {\n    let (arg, opts) = args.into_get_nearest_opts();\n\n    Command::new(TermType::GetNearest)\n        .with_arg(arg)\n        .with_opts(opts)\n}\n\npub trait GetNearestArg {\n    fn into_get_nearest_opts(self) -\u003e (Command, GetNearestOption);\n}\n\nimpl\u003cT: Geometry\u003e GetNearestArg for Args\u003c(T, \u0026str)\u003e {\n    fn into_get_nearest_opts(self) -\u003e (Command, GetNearestOption) {\n        let index_name = GetNearestOption::default().index(self.0 .1.to_owned());\n\n        (self.0 .0.into(), index_name)\n    }\n}\n\nimpl GetNearestArg for Args\u003c(Command, \u0026str)\u003e {\n    fn into_get_nearest_opts(self) -\u003e (Command, GetNearestOption) {\n        let index_name = GetNearestOption::default().index(self.0 .1.to_owned());\n\n        (self.0 .0, index_name)\n    }\n}\n\nimpl\u003cT: Geometry\u003e GetNearestArg for Args\u003c(T, \u0026str, GetNearestOption)\u003e {\n    fn into_get_nearest_opts(self) -\u003e (Command, GetNearestOption) {\n        let index_name = self.0 .2.index(self.0 .1.to_owned());\n\n        (self.0 .0.into(), index_name)\n    }\n}\n\nimpl GetNearestArg for Args\u003c(Command, \u0026str, GetNearestOption)\u003e {\n    fn into_get_nearest_opts(self) -\u003e (Command, GetNearestOption) {\n        let index_name = self.0 .2.index(self.0 .1.to_owned());\n\n        (self.0 .0, index_name)\n    }\n}\n\n#[derive(Debug, Clone, Serialize, Default, CommandOptions)]\npub struct GetNearestOption {\n    pub index: Cow\u003c'static, str\u003e,\n    /// the maximum number of results to return (default 100).\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub max_results: Option\u003cusize\u003e,\n    /// Unit for the distance.\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub unit: Option\u003cUnit\u003e,\n    /// distance from an object to the specified point (default 100 km).\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub max_dist: Option\u003cusize\u003e,\n    /// the reference ellipsoid to use for geographic coordinates.\n    /// Possible values are `GeoSystem::WGS84` (the default),\n    /// a common standard for Earth’s geometry, or `GeoSystem::UnitSphere`,\n    /// a perfect sphere of 1 meter radius.\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub geo_system: Option\u003cGeoSystem\u003e,\n}\n\n#[cfg(test)]\nmod tests {\n    use serde::{Deserialize, Serialize};\n    use uuid::Uuid;\n\n    use crate::cmd::index_create::IndexCreateOption;\n    use crate::cmd::point::Point;\n    use crate::prelude::Converter;\n    use crate::types::ClosestDocumentResponse;\n    use crate::{args, r, Result};\n\n    #[derive(Debug, Serialize, Deserialize, PartialEq)]\n    struct Park {\n        id: u8,\n        area: Point,\n    }\n\n    impl Park {\n        fn new(id: u8, area: Point) -\u003e Self {\n            Self { id, area }\n        }\n    }\n\n    #[tokio::test]\n    async fn test_get_nearest_ops() -\u003e Result\u003c()\u003e {\n        let data = vec![\n            Park::new(1, r.point(-121.886420, 37.329898)),\n            Park::new(2, r.point(-117.220406, 32.719464)),\n            Park::new(3, r.point(-122.422876, 37.777128)),\n            Park::new(4, r.point(-122.423246, 37.779388)),\n        ];\n        let table_name = Uuid::new_v4().to_string();\n        let conn = r.connection().connect().await?;\n        let table = r.table(table_name.as_str());\n        r.table_create(table_name.as_str()).run(\u0026conn).await?;\n        table\n            .clone()\n            .index_create(args!(\"area\", IndexCreateOption::default().geo(true)))\n            .run(\u0026conn)\n            .await?;\n        table.clone().index_wait(()).run(\u0026conn).await?;\n        table.clone().insert(\u0026data).run(\u0026conn).await?;\n\n        let secret_base = r.point(-122.422876, 37.777128);\n        let response: Vec\u003cClosestDocumentResponse\u003cPark\u003e\u003e = table\n            .get_nearest(args!(secret_base, \"area\"))\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(response.len() \u003e 0);\n\n        r.table_drop(table_name.as_str()).run(\u0026conn).await?;\n        Ok(())\n    }\n}\n","traces":[{"line":12,"address":[7366080,7366587],"length":1,"stats":{"Line":1},"fn_name":"new\u003creql_rust::arguments::Args\u003c(reql_rust::cmd::point::Point, \u0026str)\u003e\u003e"},{"line":13,"address":[7366097],"length":1,"stats":{"Line":1},"fn_name":null},{"line":15,"address":[7366275,7366524,7366408],"length":1,"stats":{"Line":3},"fn_name":null},{"line":16,"address":[7366349],"length":1,"stats":{"Line":1},"fn_name":null},{"line":17,"address":[7366420],"length":1,"stats":{"Line":1},"fn_name":null},{"line":25,"address":[1898165,1897744,1898028],"length":1,"stats":{"Line":1},"fn_name":"into_get_nearest_opts\u003creql_rust::cmd::point::Point\u003e"},{"line":26,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":28,"address":[1897959,1898076],"length":1,"stats":{"Line":2},"fn_name":null},{"line":33,"address":[2736976,2737311],"length":1,"stats":{"Line":0},"fn_name":"into_get_nearest_opts"},{"line":34,"address":[2655349,2655644,2655413],"length":1,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[2737185],"length":1,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[2656062,2655696],"length":1,"stats":{"Line":0},"fn_name":"into_get_nearest_opts"},{"line":50,"address":[2656046,2655720],"length":1,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[2655924],"length":1,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[8051536],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":100,"address":[5000439,4999712,5000963,4999721,4999813,4999921,4999744],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":101,"address":[5000856,5000606,4999878],"length":1,"stats":{"Line":2},"fn_name":null},{"line":102,"address":[5000656,5000591],"length":1,"stats":{"Line":2},"fn_name":null},{"line":103,"address":[5000687],"length":1,"stats":{"Line":1},"fn_name":null},{"line":104,"address":[5000746],"length":1,"stats":{"Line":1},"fn_name":null},{"line":105,"address":[5000805],"length":1,"stats":{"Line":1},"fn_name":null},{"line":107,"address":[5000974,5001041],"length":1,"stats":{"Line":2},"fn_name":null},{"line":108,"address":[7786159],"length":1,"stats":{"Line":4},"fn_name":null},{"line":109,"address":[5001871,5001597],"length":1,"stats":{"Line":2},"fn_name":null},{"line":110,"address":[7785914,7785971],"length":1,"stats":{"Line":4},"fn_name":null},{"line":111,"address":[5003682,5003273,5003031,5002700,5002956,5003196,5003474],"length":1,"stats":{"Line":6},"fn_name":null},{"line":113,"address":[5002788,5003046,5003003,5002745],"length":1,"stats":{"Line":2},"fn_name":null},{"line":114,"address":[5000294,4999993,5003229,5003401,5003099,5003011],"length":1,"stats":{"Line":6},"fn_name":null},{"line":115,"address":[5003712,5003564],"length":1,"stats":{"Line":1},"fn_name":null},{"line":116,"address":[5003752,5000014,5000243,5003814],"length":1,"stats":{"Line":4},"fn_name":null},{"line":117,"address":[5004528,5000035,5004598,5000192],"length":1,"stats":{"Line":4},"fn_name":null},{"line":119,"address":[5005328],"length":1,"stats":{"Line":1},"fn_name":null},{"line":120,"address":[5005628,5005368,5005751,5005828,5006328,5006305,5005566,5006568,5006248,5006029],"length":1,"stats":{"Line":7},"fn_name":null},{"line":121,"address":[5005411],"length":1,"stats":{"Line":1},"fn_name":null},{"line":122,"address":[5005956,5000141,5005651,5005608,5005784,5000056],"length":1,"stats":{"Line":6},"fn_name":null},{"line":123,"address":[5006152],"length":1,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[5006457,5006682,5006724],"length":1,"stats":{"Line":2},"fn_name":null},{"line":129,"address":[5000074,5006703,5006798],"length":1,"stats":{"Line":3},"fn_name":null},{"line":130,"address":[5007649],"length":1,"stats":{"Line":5},"fn_name":null}],"covered":32,"coverable":42},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","get_write_hook.rs"],"content":"use ql2::term::TermType;\n\nuse crate::Command;\n\npub(crate) fn new() -\u003e Command {\n    Command::new(TermType::GetWriteHook)\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::*;\n    use crate::spec::{set_up, tear_down};\n    use crate::types::GetWriteHookResponse;\n    use crate::Result;\n\n    #[tokio::test]\n    async fn test_get_write_hook_ops() -\u003e Result\u003c()\u003e {\n        let (conn, table, table_name) = set_up(false).await?;\n        table\n            .clone()\n            .set_write_hook(func!(|_, _, new_val| new_val))\n            .run(\u0026conn)\n            .await?;\n\n        let response: GetWriteHookResponse =\n            table.get_write_hook().run(\u0026conn).await?.unwrap().parse()?;\n\n        assert!(!response.query.is_empty());\n\n        tear_down(conn, \u0026table_name).await\n    }\n}\n","traces":[{"line":5,"address":[2435504],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":6,"address":[2435516],"length":1,"stats":{"Line":1},"fn_name":null},{"line":17,"address":[2503552,2503957,2503591,2504005],"length":1,"stats":{"Line":6},"fn_name":"test_get_write_hook_ops"},{"line":18,"address":[5718297,5717206,5717703,5717532,5717303,5717884],"length":1,"stats":{"Line":4},"fn_name":null},{"line":19,"address":[5720176,5718287,5720099,5719804,5720585,5719934,5720377],"length":1,"stats":{"Line":6},"fn_name":null},{"line":21,"address":[5719789,5718506,5719949,5718562,5722976,5723027,5718604,5719302,5719843,5718972],"length":1,"stats":{"Line":5},"fn_name":"{closure#0}"},{"line":22,"address":[5720132,5720304,5717481,5717324,5720002],"length":1,"stats":{"Line":5},"fn_name":null},{"line":23,"address":[5720467,5720615],"length":1,"stats":{"Line":1},"fn_name":null},{"line":25,"address":[5717430,5720681,5721516,5717345,5720816,5721731],"length":1,"stats":{"Line":5},"fn_name":null},{"line":28,"address":[5721707,5722173,5722099],"length":1,"stats":{"Line":2},"fn_name":null},{"line":30,"address":[2503688,2503583,2503968,2503628],"length":1,"stats":{"Line":7},"fn_name":null}],"covered":11,"coverable":11},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","grant.rs"],"content":"use ql2::term::TermType;\n\nuse crate::arguments::Permission;\nuse crate::Command;\n\npub(crate) fn new(username: \u0026str, permission: Permission) -\u003e Command {\n    Command::new(TermType::Grant)\n        .with_arg(Command::from_json(username))\n        .with_arg(Command::from_json(permission))\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::arguments::Permission;\n    use crate::prelude::Converter;\n    use crate::spec::{set_up, tear_down};\n    use crate::types::{ConfigChange, GrantChangeValue, GrantResponse};\n    use crate::Result;\n\n    #[tokio::test]\n    async fn test_grant_permission() -\u003e Result\u003c()\u003e {\n        let (conn, table, table_name) = set_up(false).await?;\n        let expected = GrantResponse {\n            granted: 1,\n            permissions_changes: vec![ConfigChange {\n                old_val: None,\n                new_val: Some(GrantChangeValue {\n                    write: Some(true),\n                    read: Some(true),\n                    config: None,\n                    connect: None,\n                }),\n            }],\n        };\n        let permissions = Permission::default().read(true).write(true);\n        // TODO Replace current user when test user should be created\n        let response: GrantResponse = table\n            .grant(\"bob\", permissions)\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(response == expected);\n\n        tear_down(conn, \u0026table_name).await\n    }\n}\n","traces":[{"line":6,"address":[2685885,2685919,2685616],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":7,"address":[2685670,2685969,2685792],"length":1,"stats":{"Line":3},"fn_name":null},{"line":8,"address":[2685735,2685832,2685900],"length":1,"stats":{"Line":2},"fn_name":null},{"line":9,"address":[2686022,2685930,2685848,2686006],"length":1,"stats":{"Line":2},"fn_name":null},{"line":21,"address":[1593317,1593411,1593929,1593637,1593225,1593216,1593248],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":22,"address":[1593379,1593762,1593940,1593594,1593441,1594324],"length":1,"stats":{"Line":4},"fn_name":null},{"line":25,"address":[1594306,1594696],"length":1,"stats":{"Line":2},"fn_name":null},{"line":35,"address":[1594791,1594850],"length":1,"stats":{"Line":2},"fn_name":null},{"line":37,"address":[1595236,1594975,1595119,1595727,1595033,1595313,1595508,1595824,1595784,1596058],"length":1,"stats":{"Line":7},"fn_name":null},{"line":38,"address":[1595019],"length":1,"stats":{"Line":1},"fn_name":null},{"line":39,"address":[1595269,1593462,1593545,1595142,1595441],"length":1,"stats":{"Line":5},"fn_name":null},{"line":40,"address":[1595631],"length":1,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[1596312,1596258,1595944],"length":1,"stats":{"Line":2},"fn_name":null},{"line":46,"address":[1593480,1596272,1596561,1596655,1596785,1596381,1596505],"length":1,"stats":{"Line":7},"fn_name":null}],"covered":13,"coverable":14},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","group.rs"],"content":"use std::borrow::Cow;\n\nuse ql2::term::TermType;\nuse reql_macros::CommandOptions;\nuse serde::Serialize;\n\nuse crate::arguments::Args;\nuse crate::prelude::Func;\nuse crate::Command;\n\nuse super::CmdOpts;\n\npub(crate) fn new(args: impl GroupArg) -\u003e Command {\n    let (args, opts) = args.into_group_opts();\n\n    args.add_to_cmd(Command::new(TermType::Group))\n        .with_opts(opts)\n}\n\npub trait GroupArg {\n    fn into_group_opts(self) -\u003e (CmdOpts, GroupOption);\n}\n\nimpl GroupArg for \u0026str {\n    fn into_group_opts(self) -\u003e (CmdOpts, GroupOption) {\n        let arg = Command::from_json(self);\n\n        (CmdOpts::Single(arg), Default::default())\n    }\n}\n\nimpl\u003cconst N: usize\u003e GroupArg for [\u0026str; N] {\n    fn into_group_opts(self) -\u003e (CmdOpts, GroupOption) {\n        let args = self.into_iter().map(Command::from_json).collect();\n\n        (CmdOpts::Many(args), Default::default())\n    }\n}\n\nimpl GroupArg for Func {\n    fn into_group_opts(self) -\u003e (CmdOpts, GroupOption) {\n        (CmdOpts::Single(self.0), Default::default())\n    }\n}\n\nimpl\u003cconst N: usize\u003e GroupArg for [Func; N] {\n    fn into_group_opts(self) -\u003e (CmdOpts, GroupOption) {\n        let args = self.into_iter().map(|func| func.0).collect();\n\n        (CmdOpts::Many(args), Default::default())\n    }\n}\n\nimpl GroupArg for Args\u003c(\u0026str, GroupOption)\u003e {\n    fn into_group_opts(self) -\u003e (CmdOpts, GroupOption) {\n        let arg = Command::from_json(self.0 .0);\n\n        (CmdOpts::Single(arg), self.0 .1)\n    }\n}\n\nimpl\u003cconst N: usize\u003e GroupArg for Args\u003c([\u0026str; N], GroupOption)\u003e {\n    fn into_group_opts(self) -\u003e (CmdOpts, GroupOption) {\n        let args = self.0 .0.into_iter().map(Command::from_json).collect();\n\n        (CmdOpts::Many(args), self.0 .1)\n    }\n}\n\nimpl GroupArg for Args\u003c(Func, GroupOption)\u003e {\n    fn into_group_opts(self) -\u003e (CmdOpts, GroupOption) {\n        let Func(func) = self.0 .0;\n\n        (CmdOpts::Single(func), self.0 .1)\n    }\n}\n\nimpl\u003cconst N: usize\u003e GroupArg for Args\u003c([Func; N], GroupOption)\u003e {\n    fn into_group_opts(self) -\u003e (CmdOpts, GroupOption) {\n        let funcs = self.0 .0.into_iter().map(|func| func.0).collect();\n\n        (CmdOpts::Many(funcs), self.0 .1)\n    }\n}\n\n#[derive(Debug, Clone, Serialize, Default, PartialEq, PartialOrd, CommandOptions)]\npub struct GroupOption {\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub index: Option\u003cCow\u003c'static, str\u003e\u003e,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub multi: Option\u003cbool\u003e,\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::Converter;\n    use crate::spec::{set_up, tear_down, Post};\n    use crate::types::GroupedStream;\n    use crate::Result;\n\n    #[tokio::test]\n    async fn test_group_data() -\u003e Result\u003c()\u003e {\n        let (conn, table, table_name) = set_up(true).await?;\n        let data_obtained: GroupedStream\u003cString, Post\u003e =\n            table.group(\"title\").run(\u0026conn).await?.unwrap().parse()?;\n\n        let data_obtained = data_obtained.collect();\n\n        assert!(data_obtained.len() == 4);\n\n        tear_down(conn, \u0026table_name).await\n    }\n}\n","traces":[{"line":13,"address":[1970752,1971201,1971290],"length":1,"stats":{"Line":1},"fn_name":"new\u003c\u0026str\u003e"},{"line":14,"address":[1970785],"length":1,"stats":{"Line":1},"fn_name":null},{"line":16,"address":[1971167,1971194,1970943],"length":1,"stats":{"Line":2},"fn_name":null},{"line":17,"address":[1971095],"length":1,"stats":{"Line":1},"fn_name":null},{"line":25,"address":[4736272,4736512],"length":1,"stats":{"Line":1},"fn_name":"into_group_opts"},{"line":26,"address":[4736305],"length":1,"stats":{"Line":1},"fn_name":null},{"line":28,"address":[2787620],"length":1,"stats":{"Line":1},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[2822544,2822742],"length":1,"stats":{"Line":0},"fn_name":"into_group_opts"},{"line":42,"address":[2740947],"length":1,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[7636175,7635936],"length":1,"stats":{"Line":0},"fn_name":"into_group_opts"},{"line":56,"address":[7635961],"length":1,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[7636017],"length":1,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[2738032],"length":1,"stats":{"Line":0},"fn_name":"into_group_opts"},{"line":72,"address":[2656406],"length":1,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[2656421],"length":1,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[4884213,4883760,4883799,4884165],"length":1,"stats":{"Line":6},"fn_name":"test_group_data"},{"line":103,"address":[7731173,7730947,7731519,7731341,7731963,7731020],"length":1,"stats":{"Line":4},"fn_name":null},{"line":104,"address":[7733131,7732937,7732220,7731041,7731903,7731124],"length":1,"stats":{"Line":5},"fn_name":null},{"line":107,"address":[7733069],"length":1,"stats":{"Line":1},"fn_name":null},{"line":109,"address":[7733433,7733495,7733556],"length":1,"stats":{"Line":2},"fn_name":null},{"line":111,"address":[4883791,4883836,4884176,4883896],"length":1,"stats":{"Line":7},"fn_name":null}],"covered":13,"coverable":33},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","gt.rs"],"content":"use ql2::term::TermType;\nuse serde::Serialize;\n\nuse crate::arguments::Args;\nuse crate::Command;\n\nuse super::CmdOpts;\n\npub(crate) fn new(args: impl GtArg) -\u003e Command {\n    args.into_gt_opts().add_to_cmd(Command::new(TermType::Gt))\n}\n\npub trait GtArg {\n    fn into_gt_opts(self) -\u003e CmdOpts;\n}\n\nimpl\u003cT: Serialize\u003e GtArg for T {\n    fn into_gt_opts(self) -\u003e CmdOpts {\n        CmdOpts::Single(Command::from_json(self))\n    }\n}\n\nimpl GtArg for Command {\n    fn into_gt_opts(self) -\u003e CmdOpts {\n        CmdOpts::Single(self)\n    }\n}\n\nimpl\u003cS, T\u003e GtArg for Args\u003cT\u003e\nwhere\n    S: Serialize,\n    T: IntoIterator\u003cItem = S\u003e,\n{\n    fn into_gt_opts(self) -\u003e CmdOpts {\n        let commands = self.0.into_iter().map(Command::from_json).collect();\n\n        CmdOpts::Many(commands)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::Converter;\n    use crate::spec::{set_up, tear_down};\n    use crate::{args, r, Result};\n\n    #[tokio::test]\n    async fn test_gt_data() -\u003e Result\u003c()\u003e {\n        let (conn, table, table_name) = set_up(true).await?;\n        let data_obtained: bool = table\n            .get(1)\n            .g(\"view\")\n            .gt(5)\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(data_obtained);\n\n        tear_down(conn, \u0026table_name).await\n    }\n\n    #[tokio::test]\n    async fn test_gt_data_r() -\u003e Result\u003c()\u003e {\n        let conn = r.connection().connect().await?;\n        let data_obtained: bool = r.gt(args!([7, 6, 5])).run(\u0026conn).await?.unwrap().parse()?;\n\n        assert!(data_obtained);\n\n        Ok(())\n    }\n}\n","traces":[{"line":9,"address":[2449892,2449649,2449865,2449456,2449696,2449676],"length":1,"stats":{"Line":2},"fn_name":"new\u003creql_rust::arguments::Args\u003c[i32; 3]\u003e\u003e"},{"line":10,"address":[2449885,2449669,2449719,2449473],"length":1,"stats":{"Line":2},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":24,"address":[2171600],"length":1,"stats":{"Line":0},"fn_name":"into_gt_opts"},{"line":25,"address":[2171616],"length":1,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":48,"address":[1948615,1948576,1948981,1949029],"length":1,"stats":{"Line":6},"fn_name":"test_gt_data"},{"line":49,"address":[2564485,2564317,2564099,2564164,2564663,2565100],"length":1,"stats":{"Line":4},"fn_name":null},{"line":50,"address":[2565537,2565333,2565809,2566085,2565614,2566028,2566319,2565047,2566129],"length":1,"stats":{"Line":6},"fn_name":null},{"line":54,"address":[7877312],"length":1,"stats":{"Line":5},"fn_name":null},{"line":55,"address":[2565932],"length":1,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[2566208,2566522],"length":1,"stats":{"Line":1},"fn_name":null},{"line":61,"address":[1948652,1948992,1948712,1948607],"length":1,"stats":{"Line":7},"fn_name":null},{"line":65,"address":[1949072,1949111,1949477,1949525],"length":1,"stats":{"Line":6},"fn_name":"test_gt_data_r"},{"line":66,"address":[2567429,2567850,2568182,2567500,2567395,2567661],"length":1,"stats":{"Line":4},"fn_name":null},{"line":67,"address":[2568410,2569110,2569204,2567444,2568093],"length":1,"stats":{"Line":4},"fn_name":null},{"line":69,"address":[2569412,2569189],"length":1,"stats":{"Line":1},"fn_name":null},{"line":71,"address":[1949103,1949148,1949208,1949488],"length":1,"stats":{"Line":5},"fn_name":null}],"covered":18,"coverable":21},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","has_fields.rs"],"content":"use ql2::term::TermType;\nuse serde::Serialize;\n\nuse crate::Command;\n\npub(crate) fn new(selector: impl Serialize) -\u003e Command {\n    let arg = Command::from_json(selector);\n\n    Command::new(TermType::HasFields).with_arg(arg)\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::Converter;\n    use crate::spec::{set_up, tear_down};\n    use crate::Result;\n\n    #[tokio::test]\n    async fn test_has_fields() -\u003e Result\u003c()\u003e {\n        let (conn, table, table_name) = set_up(true).await?;\n        let data_obtained: bool = table\n            .get(1)\n            .has_fields(\"title\")\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(data_obtained);\n\n        tear_down(conn, \u0026table_name).await\n    }\n}\n","traces":[{"line":6,"address":[1599328,1599567,1599540],"length":1,"stats":{"Line":1},"fn_name":"new\u003c\u0026str\u003e"},{"line":7,"address":[1599361],"length":1,"stats":{"Line":1},"fn_name":null},{"line":9,"address":[1599454,1599387],"length":1,"stats":{"Line":2},"fn_name":null},{"line":19,"address":[3933264,3933462,3933273,3933296,3933688,3933365,3933980],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":20,"address":[3933645,3933427,3933492,3933991,3934428,3933813],"length":1,"stats":{"Line":4},"fn_name":null},{"line":21,"address":[3934661,3935328,3934914,3934837,3935429,3935619,3935109,3934375,3935385],"length":1,"stats":{"Line":6},"fn_name":null},{"line":24,"address":[3935042,3934870,3934743,3933513,3933596],"length":1,"stats":{"Line":5},"fn_name":null},{"line":25,"address":[3935232],"length":1,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[3935508,3935822],"length":1,"stats":{"Line":1},"fn_name":null},{"line":31,"address":[3933531,3936286,3935916,3936040,3936100,3935779,3936152],"length":1,"stats":{"Line":7},"fn_name":null}],"covered":9,"coverable":10},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","hash_map.rs"],"content":"use std::collections::HashMap;\n\nuse ql2::term::TermType;\n\nuse crate::Command;\n\npub(crate) fn new\u003cT\u003e(args: HashMap\u003cT, Command\u003e) -\u003e Command\nwhere\n    T: Into\u003cString\u003e,\n{\n    args.into_iter()\n        .flat_map(|(key, value)| [Command::from_json(key.into()), value])\n        .fold(Command::new(TermType::Object), |command, arg| {\n            command.with_arg(arg)\n        })\n}\n","traces":[{"line":7,"address":[2840643,2840670,2840432],"length":1,"stats":{"Line":1},"fn_name":"new\u003c\u0026str\u003e"},{"line":11,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":12,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":13,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":14,"address":[],"length":0,"stats":{"Line":1},"fn_name":null}],"covered":5,"coverable":5},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","hours.rs"],"content":"use ql2::term::TermType;\n\nuse crate::Command;\n\npub(crate) fn new() -\u003e Command {\n    Command::new(TermType::Hours)\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::Converter;\n    use crate::{r, Result};\n\n    #[tokio::test]\n    async fn test_hours_ops() -\u003e Result\u003c()\u003e {\n        let conn = r.connection().connect().await?;\n\n        let hours = r.now().hours();\n        let hours1 = hours.clone().value();\n        let hours2: u8 = hours.cmd().run(\u0026conn).await?.unwrap().parse()?;\n\n        assert!(hours1 == hours2);\n\n        Ok(())\n    }\n}\n","traces":[{"line":5,"address":[2702112],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":6,"address":[2702124],"length":1,"stats":{"Line":1},"fn_name":null},{"line":15,"address":[1852551,1852917,1852512,1852965],"length":1,"stats":{"Line":6},"fn_name":"test_hours_ops"},{"line":16,"address":[4550426,4549976,4550165,4549696,4549742,4549815],"length":1,"stats":{"Line":4},"fn_name":null},{"line":18,"address":[4550672,4550416],"length":1,"stats":{"Line":2},"fn_name":null},{"line":19,"address":[4550700,4550763],"length":1,"stats":{"Line":2},"fn_name":null},{"line":20,"address":[4550807,4551607,4550894,4549757,4551702],"length":1,"stats":{"Line":4},"fn_name":null},{"line":22,"address":[4551895,4551681],"length":1,"stats":{"Line":1},"fn_name":null},{"line":24,"address":[1852543,1852648,1852928,1852588],"length":1,"stats":{"Line":5},"fn_name":null}],"covered":9,"coverable":9},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","http.rs"],"content":"use ql2::term::TermType;\nuse serde::Serialize;\n\nuse crate::arguments::Args;\nuse crate::Command;\n\npub(crate) fn new\u003cT\u003e(args: impl HttpArg\u003cT\u003e) -\u003e Command\nwhere\n    T: Serialize,\n{\n    let (arg, opts) = args.into_http_opts();\n    let mut command = Command::new(TermType::Http).with_arg(arg);\n\n    if let Some(opts) = opts {\n        command = command.with_opts(opts);\n    }\n\n    command\n}\n\npub trait HttpArg\u003cT: Serialize\u003e {\n    fn into_http_opts(self) -\u003e (Command, Option\u003cT\u003e);\n}\n\nimpl\u003cT\u003e HttpArg\u003cT\u003e for T\nwhere\n    T: Into\u003cString\u003e + Serialize,\n{\n    fn into_http_opts(self) -\u003e (Command, Option\u003cT\u003e) {\n        (Command::from_json(self.into()), None)\n    }\n}\n\nimpl\u003cS, T\u003e HttpArg\u003cT\u003e for Args\u003c(S, T)\u003e\nwhere\n    S: Into\u003cString\u003e,\n    T: Serialize,\n{\n    fn into_http_opts(self) -\u003e (Command, Option\u003cT\u003e) {\n        (Command::from_json(self.0 .0.into()), Some(self.0 .1))\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use serde_json::json;\n\n    use crate::{args, r, Result};\n\n    #[tokio::test]\n    async fn test_http_ops() -\u003e Result\u003c()\u003e {\n        let conn = r.connection().connect().await?;\n        let response = r.http(\"http://httpbin.org/get\").run(\u0026conn).await?;\n\n        assert!(response.is_some());\n\n        Ok(())\n    }\n\n    #[tokio::test]\n    async fn test_http_ops_with_params() -\u003e Result\u003c()\u003e {\n        let conn = r.connection().connect().await?;\n        let response = r\n            .http(args!(\n                \"http://httpbin.org/get\",\n                json!({\n                    \"params\": {\n                        \"user\": 1\n                    }\n                })\n            ))\n            .run(\u0026conn)\n            .await?;\n\n        assert!(response.is_some());\n\n        Ok(())\n    }\n}\n","traces":[{"line":7,"address":[7669280,7668560,7669885,7669858,7669162,7669253],"length":1,"stats":{"Line":2},"fn_name":"new\u003cserde_json::value::Value, reql_rust::arguments::Args\u003c(\u0026str, serde_json::value::Value)\u003e\u003e"},{"line":11,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":12,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":14,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":15,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":51,"address":[1950021,1949607,1949973,1949568],"length":1,"stats":{"Line":6},"fn_name":"test_http_ops"},{"line":52,"address":[7715114,7715387,7714764,7714693,7714659,7714925],"length":1,"stats":{"Line":4},"fn_name":null},{"line":53,"address":[7715629,7715357,7714708,7716128],"length":1,"stats":{"Line":3},"fn_name":null},{"line":55,"address":[7716385,7716114,7716348],"length":1,"stats":{"Line":2},"fn_name":null},{"line":57,"address":[7716354],"length":1,"stats":{"Line":5},"fn_name":null},{"line":61,"address":[1950517,1950064,1950469,1950103],"length":1,"stats":{"Line":6},"fn_name":"test_http_ops_with_params"},{"line":62,"address":[7716587,7716645,7716877,7717066,7717327,7716716],"length":1,"stats":{"Line":4},"fn_name":null},{"line":63,"address":[7718626,7719019,7718811,7718555,7718444,7718412],"length":1,"stats":{"Line":5},"fn_name":null},{"line":64,"address":[7718289],"length":1,"stats":{"Line":1},"fn_name":null},{"line":66,"address":[7717754,7717317,7717630,7717961,7717564],"length":1,"stats":{"Line":4},"fn_name":null},{"line":72,"address":[7718754,7718424,7718467,7716660,7718585],"length":1,"stats":{"Line":5},"fn_name":null},{"line":73,"address":[7718923,7719049],"length":1,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[7719143,7719180,7718909],"length":1,"stats":{"Line":2},"fn_name":null},{"line":77,"address":[1950200,1950480,1950140,1950095],"length":1,"stats":{"Line":5},"fn_name":null}],"covered":23,"coverable":24},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","in_timezone.rs"],"content":"use ql2::term::TermType;\nuse time::UtcOffset;\n\nuse crate::types::timezone_to_string;\nuse crate::Command;\n\npub(crate) fn new(timezone: UtcOffset) -\u003e Command {\n    Command::new(TermType::InTimezone).with_arg(Command::from_json(timezone_to_string(timezone)))\n}\n\n#[cfg(test)]\nmod tests {\n    use time::macros::offset;\n\n    use crate::prelude::Converter;\n    use crate::types::Time;\n    use crate::{r, Result};\n\n    #[tokio::test]\n    async fn test_in_timezone_ops() -\u003e Result\u003c()\u003e {\n        let conn = r.connection().connect().await?;\n\n        let date_time = r.now().in_timezone(offset!(-08:00));\n        let time1 = date_time.clone().value();\n        let time2: Time = date_time.cmd().run(\u0026conn).await?.unwrap().parse()?;\n\n        assert!(time1.is_valid());\n        assert!(time2.is_valid());\n\n        Ok(())\n    }\n}\n","traces":[{"line":7,"address":[2776005,2776036,2775728],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":8,"address":[2776020,2775781],"length":1,"stats":{"Line":1},"fn_name":null},{"line":20,"address":[1694265,1694778,1694479,1694185,1694176,1694208,1694342],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":21,"address":[1694789,1695050,1694366,1694439,1694600,1694320],"length":1,"stats":{"Line":4},"fn_name":null},{"line":23,"address":[1695040,1695296],"length":1,"stats":{"Line":2},"fn_name":null},{"line":24,"address":[1695373,1695439],"length":1,"stats":{"Line":2},"fn_name":null},{"line":25,"address":[1696436,1695466,1696265,1694381,1695553],"length":1,"stats":{"Line":4},"fn_name":null},{"line":27,"address":[1696680,1696705,1696415],"length":1,"stats":{"Line":2},"fn_name":null},{"line":28,"address":[1696694,1696741,1696774],"length":1,"stats":{"Line":2},"fn_name":null},{"line":30,"address":[1696747],"length":1,"stats":{"Line":5},"fn_name":null}],"covered":10,"coverable":10},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","includes.rs"],"content":"use ql2::term::TermType;\n\nuse crate::{prelude::Geometry, Command};\n\nuse super::CmdOpts;\n\npub(crate) fn new(geometry: impl IncludesArg) -\u003e Command {\n    geometry\n        .into_includes_opts()\n        .add_to_cmd(Command::new(TermType::Includes))\n}\n\npub trait IncludesArg {\n    fn into_includes_opts(self) -\u003e CmdOpts;\n}\n\nimpl\u003cT: Geometry\u003e IncludesArg for T {\n    fn into_includes_opts(self) -\u003e CmdOpts {\n        CmdOpts::Single(self.into())\n    }\n}\n\nimpl IncludesArg for Command {\n    fn into_includes_opts(self) -\u003e CmdOpts {\n        CmdOpts::Single(self)\n    }\n}\n\nimpl\u003cT: Geometry\u003e IncludesArg for Vec\u003cT\u003e {\n    fn into_includes_opts(self) -\u003e CmdOpts {\n        CmdOpts::Many(self.into_iter().map(|geo| geo.cmd()).collect())\n    }\n}\n\nimpl IncludesArg for Vec\u003cCommand\u003e {\n    fn into_includes_opts(self) -\u003e CmdOpts {\n        CmdOpts::Many(self)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::Converter;\n    use crate::{args, r, Result};\n\n    #[tokio::test]\n    async fn test_includes_geo() -\u003e Result\u003c()\u003e {\n        let conn = r.connection().connect().await?;\n        let point1 = r.point(-117.220406, 32.719464);\n        let point2 = r.point(-117.206201, 32.725186);\n\n        let response: bool = r\n            .circle(args!(point1, 2000.))\n            .includes(point2)\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(response);\n\n        Ok(())\n    }\n}\n","traces":[{"line":7,"address":[5156941,5156968,5156736],"length":1,"stats":{"Line":1},"fn_name":"new\u003creql_rust::cmd::point::Point\u003e"},{"line":8,"address":[5156752,5156892],"length":1,"stats":{"Line":2},"fn_name":null},{"line":10,"address":[5156925,5156961,5156821],"length":1,"stats":{"Line":2},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":24,"address":[2171680],"length":1,"stats":{"Line":0},"fn_name":"into_includes_opts"},{"line":25,"address":[2171696],"length":1,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[3395792],"length":1,"stats":{"Line":0},"fn_name":"into_includes_opts"},{"line":37,"address":[3395799],"length":1,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[2825085,2825220,2824960,2825017,2825519,2824928,2824937],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":48,"address":[2825109,2825341,2825530,2825807,2825180,2825075],"length":1,"stats":{"Line":4},"fn_name":null},{"line":49,"address":[2825797],"length":1,"stats":{"Line":1},"fn_name":null},{"line":50,"address":[2826068],"length":1,"stats":{"Line":1},"fn_name":null},{"line":52,"address":[2826913,2826970,2827197,2826694,2826205,2826295,2826509,2826327,2826438,2827007],"length":1,"stats":{"Line":7},"fn_name":null},{"line":53,"address":[2826075],"length":1,"stats":{"Line":1},"fn_name":null},{"line":54,"address":[2826239],"length":1,"stats":{"Line":1},"fn_name":null},{"line":55,"address":[2825124,2826307,2826468,2826350,2826637],"length":1,"stats":{"Line":5},"fn_name":null},{"line":56,"address":[2826817],"length":1,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[2827290,2827086],"length":1,"stats":{"Line":1},"fn_name":null},{"line":62,"address":[2577039,2577144,2577424,2577084],"length":1,"stats":{"Line":5},"fn_name":null}],"covered":15,"coverable":22},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","index_create.rs"],"content":"use ql2::term::TermType;\nuse reql_macros::CommandOptions;\nuse serde::Serialize;\n\nuse crate::arguments::Args;\nuse crate::prelude::Func;\nuse crate::Command;\n\npub(crate) fn new(args: impl IndexCreateArg) -\u003e Command {\n    let (arg, func, opts) = args.into_table_create_opts();\n    let mut command = Command::new(TermType::IndexCreate).with_arg(arg);\n\n    if let Some(Func(func)) = func {\n        command = command.with_arg(func);\n    }\n\n    command.with_opts(opts)\n}\n\npub trait IndexCreateArg {\n    fn into_table_create_opts(self) -\u003e (Command, Option\u003cFunc\u003e, IndexCreateOption);\n}\n\nimpl\u003cT\u003e IndexCreateArg for T\nwhere\n    T: Into\u003cString\u003e,\n{\n    fn into_table_create_opts(self) -\u003e (Command, Option\u003cFunc\u003e, IndexCreateOption) {\n        (Command::from_json(self.into()), None, Default::default())\n    }\n}\n\nimpl\u003cT\u003e IndexCreateArg for Args\u003c(T, Func)\u003e\nwhere\n    T: Into\u003cString\u003e,\n{\n    fn into_table_create_opts(self) -\u003e (Command, Option\u003cFunc\u003e, IndexCreateOption) {\n        (\n            Command::from_json(self.0 .0.into()),\n            Some(self.0 .1),\n            Default::default(),\n        )\n    }\n}\n\nimpl\u003cT\u003e IndexCreateArg for Args\u003c(T, IndexCreateOption)\u003e\nwhere\n    T: Into\u003cString\u003e,\n{\n    fn into_table_create_opts(self) -\u003e (Command, Option\u003cFunc\u003e, IndexCreateOption) {\n        (Command::from_json(self.0 .0.into()), None, self.0 .1)\n    }\n}\n\nimpl\u003cT\u003e IndexCreateArg for Args\u003c(T, Func, IndexCreateOption)\u003e\nwhere\n    T: Into\u003cString\u003e,\n{\n    fn into_table_create_opts(self) -\u003e (Command, Option\u003cFunc\u003e, IndexCreateOption) {\n        (\n            Command::from_json(self.0 .0.into()),\n            Some(self.0 .1),\n            self.0 .2,\n        )\n    }\n}\n\n#[derive(Debug, Clone, Copy, Serialize, Default, PartialEq, PartialOrd, CommandOptions)]\npub struct IndexCreateOption {\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub multi: Option\u003cbool\u003e,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub geo: Option\u003cbool\u003e,\n}\n\n#[cfg(test)]\nmod tests {\n    use uuid::Uuid;\n\n    use crate::prelude::*;\n    use crate::types::IndexResponse;\n    use crate::{args, r, Command, Result, Session};\n\n    use super::IndexCreateOption;\n\n    #[tokio::test]\n    async fn test_create_index() -\u003e Result\u003c()\u003e {\n        let table_name = Uuid::new_v4().to_string();\n        let conn = r.connection().connect().await?;\n        let index_created = r.table(table_name.as_str()).index_create(\"author\");\n\n        setup(\u0026table_name, index_created, \u0026conn).await\n    }\n\n    #[tokio::test]\n    async fn test_create_index_with_options() -\u003e Result\u003c()\u003e {\n        let table_name = Uuid::new_v4().to_string();\n        let conn = r.connection().connect().await?;\n        let index_option = IndexCreateOption::default().multi(true);\n        let index_created = r\n            .table(table_name.as_str())\n            .index_create(args!(\"author\", index_option));\n\n        setup(\u0026table_name, index_created, \u0026conn).await\n    }\n\n    /* #[tokio::test]\n    async fn test_create_index_with_func() -\u003e Result\u003c()\u003e {\n        let table_name = Uuid::new_v4().to_string();\n        let conn = r.connection().connect().await?;\n        let index_created = r\n            .table(table_name.as_str())\n            .index_create((\"author\", func!(|row| row.bracket(\"author\").bracket(\"name\"))));\n\n        setup(\u0026table_name, index_created, \u0026conn).await\n    }\n\n    #[tokio::test]\n    async fn test_create_index_with_func_and_options() -\u003e Result\u003c()\u003e {\n        let table_name = Uuid::new_v4().to_string();\n        let conn = r.connection().connect().await?;\n        let index_option = IndexCreateOption::default().multi(true);\n        let index_created = r.table(table_name.as_str()).index_create((\n            \"author\",\n            func!(|row| row.bracket(\"author\").bracket(\"name\")),\n            index_option,\n        ));\n\n        setup(\u0026table_name, index_created, \u0026conn).await\n    } */\n\n    async fn setup(table_name: \u0026str, index_created: Command, conn: \u0026Session) -\u003e Result\u003c()\u003e {\n        r.table_create(table_name).run(conn).await?;\n\n        let index_created: IndexResponse = index_created.run(conn).await?.unwrap().parse()?;\n\n        assert!(index_created.created \u003e Some(0));\n\n        r.table_drop(table_name).run(conn).await?;\n        Ok(())\n    }\n}\n","traces":[{"line":9,"address":[3025056,3025831,3025744,3024937,3024224,3025024],"length":1,"stats":{"Line":2},"fn_name":"new\u003creql_rust::arguments::Args\u003c(\u0026str, reql_rust::cmd::index_create::IndexCreateOption)\u003e\u003e"},{"line":10,"address":[3024241,3025089],"length":1,"stats":{"Line":2},"fn_name":null},{"line":11,"address":[3025235,3025332,3024430,3024527],"length":1,"stats":{"Line":4},"fn_name":null},{"line":13,"address":[3025400,3025670,3024863,3024595],"length":1,"stats":{"Line":2},"fn_name":null},{"line":14,"address":[3024837,3025521,3024716,3025644],"length":1,"stats":{"Line":0},"fn_name":null},{"line":17,"address":[3024805,3025611],"length":1,"stats":{"Line":2},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[2818025,2817872,2817881,2817961,2818160,2818530,2817904],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":88,"address":[2818276,2818006],"length":1,"stats":{"Line":2},"fn_name":null},{"line":89,"address":[2818049,2818120,2818291,2818352,2818541,2818805],"length":1,"stats":{"Line":4},"fn_name":null},{"line":90,"address":[2818785,2819075],"length":1,"stats":{"Line":2},"fn_name":null},{"line":92,"address":[1581727,1581772,1582112,1581832],"length":1,"stats":{"Line":8},"fn_name":null},{"line":96,"address":[2820506,2819776,2819953,2820109,2819785,2819808,2819877],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":97,"address":[2820234,2819931],"length":1,"stats":{"Line":2},"fn_name":null},{"line":98,"address":[7806977],"length":1,"stats":{"Line":4},"fn_name":null},{"line":99,"address":[2821081,2820776],"length":1,"stats":{"Line":2},"fn_name":null},{"line":100,"address":[2821332,2821214],"length":1,"stats":{"Line":2},"fn_name":null},{"line":101,"address":[2821167],"length":1,"stats":{"Line":1},"fn_name":null},{"line":102,"address":[2821235],"length":1,"stats":{"Line":1},"fn_name":null},{"line":104,"address":[1582268,1582608,1582223,1582328],"length":1,"stats":{"Line":8},"fn_name":null},{"line":132,"address":[1581408,1581465],"length":1,"stats":{"Line":5},"fn_name":"setup"},{"line":133,"address":[2814706,2814765,2815245,2815030,2814898],"length":1,"stats":{"Line":4},"fn_name":null},{"line":135,"address":[2816709,2814853,2815736,2814780,2815872,2816528],"length":1,"stats":{"Line":5},"fn_name":null},{"line":137,"address":[2816936,2816688,2816896],"length":1,"stats":{"Line":2},"fn_name":null},{"line":139,"address":[2816907,2817000,2814795],"length":1,"stats":{"Line":3},"fn_name":null},{"line":140,"address":[2817818],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":28,"coverable":37},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","index_drop.rs"],"content":"use crate::Command;\nuse ql2::term::TermType;\n\npub(crate) fn new(index_name: impl Into\u003cString\u003e) -\u003e Command {\n    Command::new(TermType::IndexDrop).with_arg(Command::from_json(index_name.into()))\n}\n\n#[cfg(test)]\nmod tests {\n    use uuid::Uuid;\n\n    use crate::prelude::*;\n    use crate::types::IndexResponse;\n    use crate::{r, Result};\n\n    #[tokio::test]\n    async fn test_drop_db() -\u003e Result\u003c()\u003e {\n        let table_name = Uuid::new_v4().to_string();\n        let index_name = \"author\";\n        let conn = r.connection().connect().await?;\n        let table = r.table(table_name.as_str());\n\n        r.table_create(table_name.as_str()).run(\u0026conn).await?;\n        table.clone().index_create(index_name).run(\u0026conn).await?;\n\n        let index_dropped: IndexResponse = table\n            .index_drop(index_name)\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(index_dropped.dropped \u003e Some(0));\n\n        r.table_drop(table_name.as_str()).run(\u0026conn).await?;\n        Ok(())\n    }\n}\n","traces":[{"line":4,"address":[5011680,5011987],"length":1,"stats":{"Line":1},"fn_name":"new\u003c\u0026str\u003e"},{"line":5,"address":[5011977,5011722,5011826],"length":1,"stats":{"Line":2},"fn_name":null},{"line":17,"address":[1954821,1954729,1954720,1954752,1955289,1954915,1955722],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":18,"address":[1954886,1955417],"length":1,"stats":{"Line":2},"fn_name":null},{"line":19,"address":[1955432],"length":1,"stats":{"Line":1},"fn_name":null},{"line":20,"address":[1955246,1955459,1954945,1955733,1955526,1956024],"length":1,"stats":{"Line":4},"fn_name":null},{"line":21,"address":[1955998,1956276],"length":1,"stats":{"Line":2},"fn_name":null},{"line":23,"address":[7918925,7918868],"length":1,"stats":{"Line":4},"fn_name":null},{"line":24,"address":[1957113,1954987,1955144,1957190],"length":1,"stats":{"Line":4},"fn_name":null},{"line":26,"address":[1958677,1958734,1958257,1957928,1958057,1958458,1959034,1958180,1958757,1957995],"length":1,"stats":{"Line":7},"fn_name":null},{"line":27,"address":[1957979],"length":1,"stats":{"Line":1},"fn_name":null},{"line":28,"address":[1955008,1958037,1958385,1955093,1958213,1958080],"length":1,"stats":{"Line":6},"fn_name":null},{"line":29,"address":[1958581],"length":1,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[1959125,1958917,1959156],"length":1,"stats":{"Line":2},"fn_name":null},{"line":35,"address":[1959139,1955026,1959233],"length":1,"stats":{"Line":3},"fn_name":null},{"line":36,"address":[1960049],"length":1,"stats":{"Line":5},"fn_name":null}],"covered":15,"coverable":16},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","index_list.rs"],"content":"use ql2::term::TermType;\n\nuse crate::Command;\n\npub(crate) fn new() -\u003e Command {\n    Command::new(TermType::IndexList)\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::*;\n    use crate::spec::{set_up, tear_down};\n    use crate::Result;\n\n    #[tokio::test]\n    async fn test_list_index() -\u003e Result\u003c()\u003e {\n        let (conn, table, table_name) = set_up(false).await?;\n        table.clone().index_create(\"author\").run(\u0026conn).await?;\n        let index_list: Vec\u003cString\u003e = table\n            .clone()\n            .index_list()\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(index_list.len() \u003e 0);\n\n        tear_down(conn, \u0026table_name).await\n    }\n}\n","traces":[{"line":5,"address":[2028736],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":6,"address":[2028748],"length":1,"stats":{"Line":1},"fn_name":null},{"line":16,"address":[4954631,4955045,4954997,4954592],"length":1,"stats":{"Line":6},"fn_name":"test_list_index"},{"line":17,"address":[4985726,4986771,4986013,4985784,4986184,4986365],"length":1,"stats":{"Line":4},"fn_name":null},{"line":18,"address":[4985962,4987007,4985805,4986761],"length":1,"stats":{"Line":4},"fn_name":null},{"line":19,"address":[4987777,4988303,4988602,4987865,4988522,4988846,4988019,4988579,4988102],"length":1,"stats":{"Line":6},"fn_name":null},{"line":22,"address":[4985826,4985911,4988230,4987919,4988058],"length":1,"stats":{"Line":5},"fn_name":null},{"line":23,"address":[4988426],"length":1,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[4989146,4989082,4988731],"length":1,"stats":{"Line":2},"fn_name":null},{"line":29,"address":[4954623,4954668,4954728,4955008],"length":1,"stats":{"Line":7},"fn_name":null}],"covered":9,"coverable":10},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","index_rename.rs"],"content":"use ql2::term::TermType;\nuse reql_macros::CommandOptions;\nuse serde::Serialize;\n\nuse crate::arguments::Args;\nuse crate::Command;\n\npub(crate) fn new(args: impl IndexRenameArg) -\u003e Command {\n    let (old_index_arg, new_index_arg, opts) = args.into_index_rename_opts();\n\n    Command::new(TermType::IndexRename)\n        .with_arg(old_index_arg)\n        .with_arg(new_index_arg)\n        .with_opts(opts)\n}\n\npub trait IndexRenameArg {\n    fn into_index_rename_opts(self) -\u003e (Command, Command, IndexRenameOption);\n}\n\nimpl\u003cO, N\u003e IndexRenameArg for Args\u003c(O, N)\u003e\nwhere\n    O: Into\u003cString\u003e,\n    N: Into\u003cString\u003e,\n{\n    fn into_index_rename_opts(self) -\u003e (Command, Command, IndexRenameOption) {\n        (\n            Command::from_json(self.0 .0.into()),\n            Command::from_json(self.0 .1.into()),\n            Default::default(),\n        )\n    }\n}\n\nimpl\u003cO, N\u003e IndexRenameArg for Args\u003c(O, N, IndexRenameOption)\u003e\nwhere\n    O: Into\u003cString\u003e,\n    N: Into\u003cString\u003e,\n{\n    fn into_index_rename_opts(self) -\u003e (Command, Command, IndexRenameOption) {\n        (\n            Command::from_json(self.0 .0.into()),\n            Command::from_json(self.0 .1.into()),\n            self.0 .2,\n        )\n    }\n}\n\n#[derive(Debug, Default, Clone, Copy, PartialEq, Serialize, CommandOptions)]\npub struct IndexRenameOption {\n    pub overwrite: Option\u003cbool\u003e,\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::*;\n    use crate::spec::{set_up, tear_down};\n    use crate::types::IndexResponse;\n    use crate::{args, Result};\n\n    use super::IndexRenameOption;\n\n    #[tokio::test]\n    async fn test_rename_index() -\u003e Result\u003c()\u003e {\n        let (conn, table, table_name) = set_up(false).await?;\n        table.clone().index_create(\"author\").run(\u0026conn).await?;\n        let index_renamed: IndexResponse = table\n            .clone()\n            .index_rename(args!(\"author\", \"author_name\"))\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(index_renamed.renamed \u003e Some(0));\n\n        tear_down(conn, \u0026table_name).await\n    }\n\n    #[tokio::test]\n    async fn test_rename_index_with_overwrite() -\u003e Result\u003c()\u003e {\n        let (conn, table, table_name) = set_up(false).await?;\n        table.clone().index_create(\"author\").run(\u0026conn).await?;\n        table.clone().index_create(\"author_name\").run(\u0026conn).await?;\n\n        let index_renamed: IndexResponse = table\n            .clone()\n            .index_rename(args!(\n                \"author\",\n                \"author_name\",\n                IndexRenameOption::default().overwrite(true)\n            ))\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(index_renamed.renamed \u003e Some(0));\n\n        tear_down(conn, \u0026table_name).await\n    }\n}\n","traces":[{"line":8,"address":[1600416,1600910,1599904,1600371],"length":1,"stats":{"Line":2},"fn_name":"new\u003creql_rust::arguments::Args\u003c(\u0026str, \u0026str, reql_rust::cmd::index_rename::IndexRenameOption)\u003e\u003e"},{"line":9,"address":[1599921,1600433],"length":1,"stats":{"Line":2},"fn_name":null},{"line":11,"address":[1600210,1600616,1600820,1600751,1600075,1600281],"length":1,"stats":{"Line":6},"fn_name":null},{"line":12,"address":[1600149,1600690],"length":1,"stats":{"Line":2},"fn_name":null},{"line":13,"address":[1600217,1600758],"length":1,"stats":{"Line":2},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":64,"address":[5174416,5174869,5174455,5174821],"length":1,"stats":{"Line":6},"fn_name":"test_rename_index"},{"line":65,"address":[4725843,4724856,4724798,4725085,4725256,4725437],"length":1,"stats":{"Line":4},"fn_name":null},{"line":66,"address":[7778598,7778544],"length":1,"stats":{"Line":4},"fn_name":null},{"line":67,"address":[4727745,4727031,4727185,4728045,4726849,4727688,4727768,4727268,4727469],"length":1,"stats":{"Line":6},"fn_name":null},{"line":69,"address":[4726921],"length":1,"stats":{"Line":1},"fn_name":null},{"line":70,"address":[4727396,4727085,4724983,4727224,4724898],"length":1,"stats":{"Line":5},"fn_name":null},{"line":71,"address":[4727592],"length":1,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[4728311,4727928,4728254],"length":1,"stats":{"Line":2},"fn_name":null},{"line":77,"address":[4724916,4728343,4728467,4728530,4728590,4728730,4728268],"length":1,"stats":{"Line":7},"fn_name":null},{"line":81,"address":[4729125,4729056,4729592,4729890,4729033,4729218,4729024],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":82,"address":[4729248,4729182,4729549,4730307,4729901,4729720],"length":1,"stats":{"Line":4},"fn_name":null},{"line":83,"address":[4730297,4729498,4729269,4730543],"length":1,"stats":{"Line":4},"fn_name":null},{"line":84,"address":[4731385,4729447,4731313,4729290],"length":1,"stats":{"Line":4},"fn_name":null},{"line":86,"address":[4733103,4733460,4733183,4733160,4732683,4732370,4732441,4732884,4732123,4732606],"length":1,"stats":{"Line":7},"fn_name":null},{"line":88,"address":[4732261],"length":1,"stats":{"Line":1},"fn_name":null},{"line":91,"address":[4732238,4732185],"length":1,"stats":{"Line":2},"fn_name":null},{"line":93,"address":[4732509,4732639,4732811,4729396,4729311],"length":1,"stats":{"Line":5},"fn_name":null},{"line":94,"address":[4733007],"length":1,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[4733726,4733669,4733343],"length":1,"stats":{"Line":2},"fn_name":null},{"line":100,"address":[4733882,4734145,4733945,4733683,4734005,4733758,4729329],"length":1,"stats":{"Line":7},"fn_name":null}],"covered":31,"coverable":33},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","index_status.rs"],"content":"use crate::Command;\nuse ql2::term::TermType;\n\nuse super::CmdOpts;\n\npub(crate) fn new(args: impl IndexStatusArg) -\u003e Command {\n    let mut command = Command::new(TermType::IndexStatus);\n    let args = args.into_index_status_opts();\n\n    if let Some(args) = args {\n        command = args.add_to_cmd(command)\n    }\n\n    command\n}\n\npub trait IndexStatusArg {\n    fn into_index_status_opts(self) -\u003e Option\u003cCmdOpts\u003e;\n}\n\nimpl IndexStatusArg for () {\n    fn into_index_status_opts(self) -\u003e Option\u003cCmdOpts\u003e {\n        None\n    }\n}\n\nimpl IndexStatusArg for \u0026str {\n    fn into_index_status_opts(self) -\u003e Option\u003cCmdOpts\u003e {\n        let arg = Command::from_json(self);\n\n        Some(CmdOpts::Single(arg))\n    }\n}\n\nimpl\u003cconst N: usize\u003e IndexStatusArg for [\u0026str; N] {\n    fn into_index_status_opts(self) -\u003e Option\u003cCmdOpts\u003e {\n        let args = self.into_iter().map(Command::from_json).collect();\n\n        Some(CmdOpts::Many(args))\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::spec::{set_up, tear_down};\n    use crate::types::IndexStatusResponse;\n    use crate::Result;\n    use crate::{prelude::*, Command, Session};\n\n    #[tokio::test]\n    async fn test_get_index_status() -\u003e Result\u003c()\u003e {\n        let (conn, table, table_name) = set_up(false).await?;\n        generate_index(\u0026conn, \u0026table).await?;\n\n        let index_status: Vec\u003cIndexStatusResponse\u003e = table\n            .clone()\n            .index_status(())\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(index_status.len() == 3);\n\n        tear_down(conn, \u0026table_name).await\n    }\n\n    #[tokio::test]\n    async fn test_get_index_status_with_param() -\u003e Result\u003c()\u003e {\n        let (conn, table, table_name) = set_up(false).await?;\n        generate_index(\u0026conn, \u0026table).await?;\n\n        let index_status: Vec\u003cIndexStatusResponse\u003e = table\n            .clone()\n            .index_status(\"author\")\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(index_status.len() == 1);\n        assert!(index_status.first().unwrap().index == \"author\");\n\n        tear_down(conn, \u0026table_name).await\n    }\n\n    #[tokio::test]\n    async fn test_get_index_status_with_params() -\u003e Result\u003c()\u003e {\n        let (conn, table, table_name) = set_up(false).await?;\n        generate_index(\u0026conn, \u0026table).await?;\n\n        let index_status: Vec\u003cIndexStatusResponse\u003e = table\n            .clone()\n            .index_status([\"age\", \"name\"])\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(index_status.len() == 2);\n        assert!(index_status.first().unwrap().index == \"age\");\n        assert!(index_status.last().unwrap().index == \"name\");\n\n        tear_down(conn, \u0026table_name).await\n    }\n\n    async fn generate_index(conn: \u0026Session, table: \u0026Command) -\u003e Result\u003c()\u003e {\n        table.clone().index_create(\"author\").run(conn).await?;\n        table.clone().index_create(\"name\").run(conn).await?;\n        table.clone().index_create(\"age\").run(conn).await?;\n\n        Ok(())\n    }\n}\n","traces":[{"line":6,"address":[5813920,5814563,5813312,5815162,5813952,5814592],"length":1,"stats":{"Line":3},"fn_name":"new\u003c\u0026str\u003e"},{"line":7,"address":[5814609,5814082,5813355,5814712,5813468,5813974],"length":1,"stats":{"Line":6},"fn_name":null},{"line":8,"address":[5814090,5813476,5814720,5813537,5814182,5814781],"length":1,"stats":{"Line":6},"fn_name":null},{"line":10,"address":[5814492,5814789,5815091,5813545,5813849,5814190],"length":1,"stats":{"Line":5},"fn_name":null},{"line":11,"address":[5815060,5813663,5814306,5814905,5814461,5813818],"length":1,"stats":{"Line":4},"fn_name":null},{"line":14,"address":[5813733,5814376,5814975],"length":1,"stats":{"Line":3},"fn_name":null},{"line":22,"address":[2445248],"length":1,"stats":{"Line":1},"fn_name":"into_index_status_opts"},{"line":23,"address":[2526900],"length":1,"stats":{"Line":1},"fn_name":null},{"line":28,"address":[2445264],"length":1,"stats":{"Line":1},"fn_name":"into_index_status_opts"},{"line":29,"address":[2445297],"length":1,"stats":{"Line":1},"fn_name":null},{"line":31,"address":[2445308],"length":1,"stats":{"Line":1},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":51,"address":[5225365,5225413,5224960,5224999],"length":1,"stats":{"Line":6},"fn_name":"test_get_index_status"},{"line":52,"address":[3052312,3053299,3052712,3052254,3052893,3052541],"length":1,"stats":{"Line":4},"fn_name":null},{"line":53,"address":[3053289,3052490,3053575,3053987,3052333],"length":1,"stats":{"Line":4},"fn_name":null},{"line":55,"address":[3053965,3055191,3054951,3054368,3054451,3054871,3054928,3054652,3054214],"length":1,"stats":{"Line":6},"fn_name":null},{"line":58,"address":[3054407,3054268,3052354,3054579,3052439],"length":1,"stats":{"Line":5},"fn_name":null},{"line":59,"address":[3054775],"length":1,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[3055423,3055487,3055080],"length":1,"stats":{"Line":2},"fn_name":null},{"line":65,"address":[3052372,3055643,3055924,3055702,3055788,3055519,3055444],"length":1,"stats":{"Line":7},"fn_name":null},{"line":69,"address":[3056389,3056297,3056320,3056474,3057074,3056776,3056288],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":70,"address":[3056446,3056504,3056733,3057085,3056904,3057491],"length":1,"stats":{"Line":4},"fn_name":null},{"line":71,"address":[3056525,3056682,3057767,3057481,3058179],"length":1,"stats":{"Line":4},"fn_name":null},{"line":73,"address":[3058572,3058390,3058655,3058856,3059395,3058157,3059155,3059132,3059075],"length":1,"stats":{"Line":6},"fn_name":null},{"line":76,"address":[3056546,3058472,3058611,3058783,3056631],"length":1,"stats":{"Line":5},"fn_name":null},{"line":77,"address":[3058979],"length":1,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[3059672,3059627,3059284],"length":1,"stats":{"Line":2},"fn_name":null},{"line":82,"address":[3059714,3059838,3059648],"length":1,"stats":{"Line":2},"fn_name":null},{"line":84,"address":[5225532,5225872,5225592,5225487],"length":1,"stats":{"Line":7},"fn_name":null},{"line":88,"address":[5226405,5225991,5225952,5226357],"length":1,"stats":{"Line":6},"fn_name":"test_get_index_status_with_params"},{"line":89,"address":[3061843,3061085,3060798,3060856,3061437,3061256],"length":1,"stats":{"Line":4},"fn_name":null},{"line":90,"address":[3060877,3062531,3061034,3061833,3062119],"length":1,"stats":{"Line":4},"fn_name":null},{"line":92,"address":[3063057,3063477,3063557,3062509,3063258,3062974,3062820,3063797,3063534],"length":1,"stats":{"Line":6},"fn_name":null},{"line":94,"address":[3062742],"length":1,"stats":{"Line":1},"fn_name":null},{"line":95,"address":[3060983,3063013,3060898,3062874,3063185],"length":1,"stats":{"Line":5},"fn_name":null},{"line":96,"address":[3063381],"length":1,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[3064029,3064074,3063686],"length":1,"stats":{"Line":2},"fn_name":null},{"line":101,"address":[3064050,3064221,3064116],"length":1,"stats":{"Line":2},"fn_name":null},{"line":102,"address":[3064264,3064197,3064388],"length":1,"stats":{"Line":2},"fn_name":null},{"line":104,"address":[3064690,3064345,3060916,3064604,3064545,3064421,3064826],"length":1,"stats":{"Line":7},"fn_name":null},{"line":107,"address":[3049392,3052085,3050038,3049716,3049435,3050577,3049522],"length":1,"stats":{"Line":5},"fn_name":"{async_fn#0}"},{"line":108,"address":[3049678,3050049,3049549,3049803,3049500],"length":1,"stats":{"Line":4},"fn_name":null},{"line":109,"address":[3050620,3049635,3050553,3049564],"length":1,"stats":{"Line":4},"fn_name":null},{"line":110,"address":[3049579,3051372,3051326],"length":1,"stats":{"Line":3},"fn_name":null},{"line":112,"address":[3052073],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":44,"coverable":47},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","index_wait.rs"],"content":"use crate::Command;\nuse ql2::term::TermType;\n\nuse super::CmdOpts;\n\npub(crate) fn new(args: impl IndexWaitArg) -\u003e Command {\n    let mut command = Command::new(TermType::IndexWait);\n\n    if let Some(args) = args.into_index_wait_opts() {\n        command = args.add_to_cmd(command)\n    }\n\n    command\n}\n\npub trait IndexWaitArg {\n    fn into_index_wait_opts(self) -\u003e Option\u003cCmdOpts\u003e;\n}\n\nimpl IndexWaitArg for () {\n    fn into_index_wait_opts(self) -\u003e Option\u003cCmdOpts\u003e {\n        None\n    }\n}\n\nimpl IndexWaitArg for \u0026str {\n    fn into_index_wait_opts(self) -\u003e Option\u003cCmdOpts\u003e {\n        let arg = Command::from_json(self);\n\n        Some(CmdOpts::Single(arg))\n    }\n}\n\nimpl\u003cconst N: usize\u003e IndexWaitArg for [\u0026str; N] {\n    fn into_index_wait_opts(self) -\u003e Option\u003cCmdOpts\u003e {\n        let args = self.into_iter().map(Command::from_json).collect();\n\n        Some(CmdOpts::Many(args))\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::spec::{set_up, tear_down};\n    use crate::types::IndexStatusResponse;\n    use crate::Result;\n    use crate::{prelude::*, Command, Session};\n\n    #[tokio::test]\n    async fn test_get_index_waited() -\u003e Result\u003c()\u003e {\n        let (conn, table, table_name) = set_up(false).await?;\n        generate_data(\u0026conn, \u0026table).await?;\n\n        let indexes_waited: Vec\u003cIndexStatusResponse\u003e = table\n            .clone()\n            .index_wait(())\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(indexes_waited.len() == 3);\n        indexes_waited\n            .iter()\n            .for_each(|index_waited| assert!(index_waited.ready));\n\n        tear_down(conn, \u0026table_name).await\n    }\n\n    #[tokio::test]\n    async fn test_get_index_status_with_param() -\u003e Result\u003c()\u003e {\n        let (conn, table, table_name) = set_up(false).await?;\n        generate_data(\u0026conn, \u0026table).await?;\n\n        let index_waited = table\n            .clone()\n            .index_wait(\"author\")\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse::\u003cVec\u003cIndexStatusResponse\u003e\u003e()?;\n\n        let index_waited = index_waited.first().unwrap();\n\n        assert!(index_waited.index == \"author\");\n        assert!(index_waited.ready);\n\n        tear_down(conn, \u0026table_name).await\n    }\n\n    #[tokio::test]\n    async fn test_get_index_status_with_params() -\u003e Result\u003c()\u003e {\n        let (conn, table, table_name) = set_up(false).await?;\n        generate_data(\u0026conn, \u0026table).await?;\n\n        let indexes_waited: Vec\u003cIndexStatusResponse\u003e = table\n            .clone()\n            .index_wait([\"age\", \"name\"])\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(indexes_waited.len() == 2);\n        indexes_waited\n            .iter()\n            .for_each(|index_waited| assert!(index_waited.ready));\n\n        tear_down(conn, \u0026table_name).await\n    }\n\n    async fn generate_data(conn: \u0026Session, table: \u0026Command) -\u003e Result\u003c()\u003e {\n        table.clone().index_create(\"author\").run(conn).await?;\n        table.clone().index_create(\"name\").run(conn).await?;\n        table.clone().index_create(\"age\").run(conn).await?;\n        Ok(())\n    }\n}\n","traces":[{"line":6,"address":[2781968,2783690,2782528,2783120,2783091,2782497],"length":1,"stats":{"Line":3},"fn_name":"new\u003c()\u003e"},{"line":7,"address":[2782676,2782080,2781988,2782574,2783242,2783145],"length":1,"stats":{"Line":6},"fn_name":null},{"line":9,"address":[2782146,2782421,2782684,2783614,2783339,2782742,2783250,2782088,2783015],"length":1,"stats":{"Line":8},"fn_name":null},{"line":10,"address":[2782860,2782989,2782395,2783459,2783588,2782266],"length":1,"stats":{"Line":4},"fn_name":null},{"line":13,"address":[2782446,2783040,2783639],"length":1,"stats":{"Line":3},"fn_name":null},{"line":21,"address":[2445424],"length":1,"stats":{"Line":1},"fn_name":"into_index_wait_opts"},{"line":22,"address":[5172276],"length":1,"stats":{"Line":1},"fn_name":null},{"line":27,"address":[2445440],"length":1,"stats":{"Line":1},"fn_name":"into_index_wait_opts"},{"line":28,"address":[2445473],"length":1,"stats":{"Line":1},"fn_name":null},{"line":30,"address":[2445484],"length":1,"stats":{"Line":1},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":50,"address":[4910649,4910640,4910741,4910672,4910826,4911128,4911426],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":51,"address":[4910798,4911437,4911256,4911843,4911085,4910856],"length":1,"stats":{"Line":4},"fn_name":null},{"line":52,"address":[4911833,4911034,4912531,4912119,4910877],"length":1,"stats":{"Line":4},"fn_name":null},{"line":54,"address":[4912995,4912912,4913495,4912758,4912509,4913196,4913735,4913415,4913472],"length":1,"stats":{"Line":6},"fn_name":null},{"line":57,"address":[4910983,4912951,4912812,4913123,4910898],"length":1,"stats":{"Line":5},"fn_name":null},{"line":58,"address":[4913319],"length":1,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[4913624,4914012,4913967],"length":1,"stats":{"Line":2},"fn_name":null},{"line":63,"address":[4913988,4914054],"length":1,"stats":{"Line":2},"fn_name":null},{"line":65,"address":[4914896,4914910],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":67,"address":[4914263,4910916,4914096,4914322,4914408,4914544],"length":1,"stats":{"Line":7},"fn_name":null},{"line":71,"address":[4914969,4915746,4914960,4914992,4915448,4915146,4915061],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":72,"address":[4915757,4915118,4915576,4915405,4915176,4916163],"length":1,"stats":{"Line":4},"fn_name":null},{"line":73,"address":[4916153,4915354,4915197,4916439,4916851],"length":1,"stats":{"Line":4},"fn_name":null},{"line":75,"address":[4917327,4917827,4917804,4917528,4917062,4916829,4917747,4918072,4917244],"length":1,"stats":{"Line":6},"fn_name":null},{"line":78,"address":[4915218,4917283,4917455,4917144,4915303],"length":1,"stats":{"Line":5},"fn_name":null},{"line":79,"address":[4917651],"length":1,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[4917956,4918309],"length":1,"stats":{"Line":2},"fn_name":null},{"line":85,"address":[4918406,4918358],"length":1,"stats":{"Line":1},"fn_name":null},{"line":86,"address":[4918395,4918489],"length":1,"stats":{"Line":1},"fn_name":null},{"line":88,"address":[4918519,4915236,4918702,4918788,4918924,4918643,4918446],"length":1,"stats":{"Line":7},"fn_name":null},{"line":92,"address":[4919768,4919289,4919312,4919466,4919280,4919381,4920066],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":93,"address":[4919896,4919496,4919725,4919438,4920077,4920483],"length":1,"stats":{"Line":4},"fn_name":null},{"line":94,"address":[4919674,4920473,4920759,4921171,4919517],"length":1,"stats":{"Line":4},"fn_name":null},{"line":96,"address":[4921614,4922117,4921460,4921898,4921149,4921697,4922197,4922437,4922174],"length":1,"stats":{"Line":6},"fn_name":null},{"line":98,"address":[4921382],"length":1,"stats":{"Line":1},"fn_name":null},{"line":99,"address":[4921653,4919538,4921825,4919623,4921514],"length":1,"stats":{"Line":5},"fn_name":null},{"line":100,"address":[4922021],"length":1,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[4922669,4922326,4922714],"length":1,"stats":{"Line":2},"fn_name":null},{"line":105,"address":[4922756,4922690],"length":1,"stats":{"Line":2},"fn_name":null},{"line":107,"address":[4923614,4923600],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":109,"address":[4923110,4923246,4922965,4923024,4919556,4922798],"length":1,"stats":{"Line":7},"fn_name":null},{"line":112,"address":[4908066,4908260,4908582,4909121,4910629,4907936,4907979],"length":1,"stats":{"Line":5},"fn_name":"{async_fn#0}"},{"line":113,"address":[4908347,4908593,4908044,4908222,4908093],"length":1,"stats":{"Line":4},"fn_name":null},{"line":114,"address":[4908179,4909097,4908108,4909164],"length":1,"stats":{"Line":4},"fn_name":null},{"line":115,"address":[4909870,4908123,4909916],"length":1,"stats":{"Line":3},"fn_name":null},{"line":116,"address":[4910617],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":46,"coverable":49},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","info.rs"],"content":"use ql2::term::TermType;\n\nuse crate::Command;\n\npub(crate) fn new() -\u003e Command {\n    Command::new(TermType::Info)\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::Converter;\n    use crate::spec::{set_up, tear_down};\n    use crate::types::{InfoResponse, TypeOf};\n    use crate::Result;\n\n    #[tokio::test]\n    async fn test_info_table() -\u003e Result\u003c()\u003e {\n        let (conn, table, table_name) = set_up(false).await?;\n        let data_obtained: InfoResponse = table.info().run(\u0026conn).await?.unwrap().parse()?;\n\n        assert!(data_obtained.typ == TypeOf::Table);\n\n        tear_down(conn, \u0026table_name).await\n    }\n}\n","traces":[{"line":5,"address":[2702160],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":6,"address":[2702172],"length":1,"stats":{"Line":1},"fn_name":null},{"line":17,"address":[4955541,4955127,4955088,4955493],"length":1,"stats":{"Line":6},"fn_name":"test_info_table"},{"line":18,"address":[5161073,5161228,5161011,5161396,5161574,5162006],"length":1,"stats":{"Line":4},"fn_name":null},{"line":19,"address":[5161958,5161094,5162263,5162972,5163131,5161179],"length":1,"stats":{"Line":5},"fn_name":null},{"line":21,"address":[5163103,5163478,5163424],"length":1,"stats":{"Line":2},"fn_name":null},{"line":23,"address":[4955119,4955224,4955504,4955164],"length":1,"stats":{"Line":7},"fn_name":null}],"covered":7,"coverable":7},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","inner_join.rs"],"content":"use ql2::term::TermType;\n\nuse crate::prelude::Func;\nuse crate::Command;\n\npub(crate) fn new(other_table: Command, func: Func) -\u003e Command {\n    let Func(func) = func;\n\n    Command::new(TermType::InnerJoin)\n        .with_arg(other_table)\n        .with_arg(func)\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::*;\n    use crate::spec::{Comment, Post};\n    use crate::types::JoinResponse;\n    use crate::Result;\n\n    #[tokio::test]\n    pub async fn test_inner_join_ops() -\u003e Result\u003c()\u003e {\n        let data = JoinResponse {\n            left: Some(Comment {\n                id: 4,\n                text: \"comment4\".to_string(),\n                post_id: 2,\n            }),\n            right: Some(Post {\n                id: 2,\n                title: \"title2\".to_string(),\n                content: Some(\"content2\".to_string()),\n                view: 2,\n            }),\n        };\n        let (conn, comment_table, post_table, comment_tablename, post_tablename) =\n            Comment::own_set_up().await?;\n\n        let response: Vec\u003cJoinResponse\u003cComment, Post\u003e\u003e = comment_table\n            .inner_join(\n                post_table,\n                func!(|comment, post| comment.g(\"post_id\").eq(post.g(\"id\"))),\n            )\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(response.len() \u003e 0);\n        assert_eq!(response.first(), Some(\u0026data));\n\n        Comment::own_tear_down(conn, comment_tablename, post_tablename).await\n    }\n}\n","traces":[{"line":6,"address":[2375888,2376240],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":7,"address":[2375923],"length":1,"stats":{"Line":1},"fn_name":null},{"line":9,"address":[2375974,2376097,2376172],"length":1,"stats":{"Line":3},"fn_name":null},{"line":10,"address":[2376057],"length":1,"stats":{"Line":1},"fn_name":null},{"line":11,"address":[2376124],"length":1,"stats":{"Line":1},"fn_name":null},{"line":22,"address":[2545120,2545353,2545152,2545583,2545221,2545866,2545129],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":24,"address":[2545692],"length":1,"stats":{"Line":1},"fn_name":null},{"line":29,"address":[2545961],"length":1,"stats":{"Line":1},"fn_name":null},{"line":36,"address":[7779409],"length":1,"stats":{"Line":4},"fn_name":null},{"line":39,"address":[2549366,2548611,2549028,2549132,2548166,2548809,2549085,2548321,2546928,2548528],"length":1,"stats":{"Line":7},"fn_name":null},{"line":41,"address":[2546982],"length":1,"stats":{"Line":1},"fn_name":null},{"line":42,"address":[2547200,2547017,2547603,2548151,2547235,2548221,2550752,2550795],"length":1,"stats":{"Line":5},"fn_name":"{closure#0}"},{"line":44,"address":[2548567,2545404,2545489,2548301,2548431,2548739],"length":1,"stats":{"Line":6},"fn_name":null},{"line":45,"address":[2548932],"length":1,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[2549700,2549252,2549748],"length":1,"stats":{"Line":2},"fn_name":null},{"line":50,"address":[2549721,2550072,2549796],"length":1,"stats":{"Line":2},"fn_name":null},{"line":52,"address":[2550337,2549958,2550467,2545422,2550258],"length":1,"stats":{"Line":7},"fn_name":null}],"covered":16,"coverable":17},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","insert.rs"],"content":"use ql2::term::TermType;\nuse reql_macros::CommandOptions;\nuse serde::Serialize;\n\nuse crate::arguments::{Args, Conflict, Durability, ReturnChanges};\nuse crate::Command;\n\npub(crate) fn new(args: impl InsertArg) -\u003e Command {\n    let (arg, opts) = args.into_insert_opts();\n\n    Command::new(TermType::Insert).with_arg(arg).with_opts(opts)\n}\n\npub trait InsertArg {\n    fn into_insert_opts(self) -\u003e (Command, InsertOption);\n}\n\nimpl\u003cT\u003e InsertArg for T\nwhere\n    T: Serialize,\n{\n    fn into_insert_opts(self) -\u003e (Command, InsertOption) {\n        (Command::from_json(self), Default::default())\n    }\n}\n\nimpl InsertArg for Command {\n    fn into_insert_opts(self) -\u003e (Command, InsertOption) {\n        (self, Default::default())\n    }\n}\n\nimpl\u003cT\u003e InsertArg for Args\u003c(T, InsertOption)\u003e\nwhere\n    T: Serialize,\n{\n    fn into_insert_opts(self) -\u003e (Command, InsertOption) {\n        (Command::from_json(self.0 .0), self.0 .1)\n    }\n}\n\nimpl InsertArg for Args\u003c(Command, InsertOption)\u003e {\n    fn into_insert_opts(self) -\u003e (Command, InsertOption) {\n        (self.0 .0, self.0 .1)\n    }\n}\n\n// TODO finish this struct\n#[derive(Debug, Clone, Copy, Serialize, Default, PartialEq, PartialOrd, CommandOptions)]\n#[non_exhaustive]\npub struct InsertOption {\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub durability: Option\u003cDurability\u003e,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub return_changes: Option\u003cReturnChanges\u003e,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub conflict: Option\u003cConflict\u003e,\n    // #[serde(skip_serializing_if = \"Option::is_none\")]\n    // pub conflict_func: Command,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub ignore_write_hook: Option\u003cbool\u003e,\n}\n\n#[cfg(test)]\nmod tests {\n    use uuid::Uuid;\n\n    use crate::arguments::ReturnChanges;\n    use crate::prelude::*;\n    use crate::spec::{set_up, tear_down, Post};\n    use crate::types::MutationResponse;\n    use crate::{args, r, Result};\n\n    use super::InsertOption;\n\n    #[tokio::test]\n    async fn test_insert_data() -\u003e Result\u003c()\u003e {\n        let data = Post::get_one_data();\n        let (conn, table, table_name) = set_up(false).await?;\n        let data_inserted: MutationResponse = table\n            .clone()\n            .insert(\u0026data)\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(data_inserted.inserted == 1);\n\n        tear_down(conn, \u0026table_name).await\n    }\n\n    #[tokio::test]\n    async fn test_insert_many_data() -\u003e Result\u003c()\u003e {\n        let data = Post::get_many_data();\n        let (conn, table, table_name) = set_up(false).await?;\n        let data_inserted: MutationResponse = table\n            .clone()\n            .insert(\u0026data)\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(data_inserted.inserted == data.len());\n\n        tear_down(conn, \u0026table_name).await\n    }\n\n    #[tokio::test]\n    async fn test_insert_data_by_copy() -\u003e Result\u003c()\u003e {\n        let data = Post::get_many_data();\n        let table_name2 = Uuid::new_v4().to_string();\n        let (conn, table, table_name) = set_up(false).await?;\n\n        r.table_create(table_name2.as_str()).run(\u0026conn).await?;\n        table.clone().insert(\u0026data).run(\u0026conn).await?;\n\n        let data_inserted: MutationResponse = r\n            .table(table_name2.as_str())\n            .insert(table.clone())\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(data_inserted.inserted == data.len());\n\n        r.table_drop(table_name2.as_str()).run(\u0026conn).await?;\n        tear_down(conn, \u0026table_name).await\n    }\n\n    #[tokio::test]\n    async fn test_insert_data_with_opts() -\u003e Result\u003c()\u003e {\n        let data = Post::get_one_data();\n        let (conn, table, table_name) = set_up(false).await?;\n        let insert_options = InsertOption::default().return_changes(ReturnChanges::Bool(true));\n        let data_inserted: MutationResponse = table\n            .clone()\n            .insert(args!(\u0026data, insert_options))\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!((\u0026data_inserted).inserted == 1);\n        let expected_data: Post = data_inserted\n            .changes\n            .unwrap()\n            .first()\n            .unwrap()\n            .clone()\n            .new_val\n            .unwrap()\n            .parse()?;\n        assert!(expected_data == data);\n\n        tear_down(conn, \u0026table_name).await\n    }\n}\n","traces":[{"line":8,"address":[5216192,5217248,5219325,5219728,5217632,5215856,5217237,5217580,5219344,5218304,5215065,5215104,5216825,5218292,5214729,5214768,5214756,5218628,5218601,5218640,5217968,5216516,5215092,5215830,5215477,5218265,5218937,5218964,5216864,5215450,5214432,5217956,5217929,5216153,5216489,5215803,5216852,5218976,5215488,5219676,5217210,5219703,5220025,5217607,5219298,5216528,5220052,5216180],"length":1,"stats":{"Line":16},"fn_name":"new\u003c\u0026reql_rust::cmd::geojson::tests::User\u003e"},{"line":9,"address":[5214457,5216553,5217265,5214793,5219753,5215881,5217657,5216881,5218993,5215121,5218329,5218665,5219361,5215505,5216217,5217993],"length":1,"stats":{"Line":16},"fn_name":null},{"line":11,"address":[5219897,5218473,5219168,5219548,5217801,5215675,5215320,5215601,5216361,5219823,5216287,5217727,5218809,5219474,5216697,5218735,5217080,5217378,5214527,5214601,5218137,5219094,5215246,5217006,5216025,5217452,5214863,5215951,5216623,5218399,5218063,5214937],"length":1,"stats":{"Line":32},"fn_name":null},{"line":22,"address":[5224064,5224220],"length":1,"stats":{"Line":13},"fn_name":"into_insert_opts\u003c\u0026reql_rust::cmd::to_geojson::tests::User\u003e"},{"line":23,"address":[4780585],"length":1,"stats":{"Line":13},"fn_name":null},{"line":28,"address":[2253569,2253408],"length":1,"stats":{"Line":1},"fn_name":"into_insert_opts"},{"line":29,"address":[2171794],"length":1,"stats":{"Line":1},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":43,"address":[2656592],"length":1,"stats":{"Line":0},"fn_name":"into_insert_opts"},{"line":44,"address":[2656613],"length":1,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[2486773,2486368,2486407,2486821],"length":1,"stats":{"Line":6},"fn_name":"test_insert_data"},{"line":78,"address":[3030086],"length":1,"stats":{"Line":1},"fn_name":null},{"line":79,"address":[3030134,3030456,3030291,3030516,3030694,3031101],"length":1,"stats":{"Line":4},"fn_name":null},{"line":80,"address":[3031360,3032043,3032332,3031986,3031325,3031483,3032090,3031091,3031767,3031566],"length":1,"stats":{"Line":7},"fn_name":null},{"line":83,"address":[3030240,3030155,3031340,3031522,3031694,3031383],"length":1,"stats":{"Line":6},"fn_name":null},{"line":84,"address":[3031890],"length":1,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[3032210,3032658],"length":1,"stats":{"Line":1},"fn_name":null},{"line":90,"address":[2486399,2486444,2486504,2486784],"length":1,"stats":{"Line":7},"fn_name":null},{"line":94,"address":[2487317,2487269,2486903,2486864],"length":1,"stats":{"Line":6},"fn_name":"test_insert_many_data"},{"line":95,"address":[3033734],"length":1,"stats":{"Line":1},"fn_name":null},{"line":96,"address":[3034164,3033782,3033939,3034104,3034749,3034342],"length":1,"stats":{"Line":4},"fn_name":null},{"line":97,"address":[3034739,3034973,3035634,3036001,3035131,3035008,3035415,3035691,3035738,3035214],"length":1,"stats":{"Line":7},"fn_name":null},{"line":100,"address":[3034988,3033803,3033888,3035170,3035031,3035342],"length":1,"stats":{"Line":6},"fn_name":null},{"line":101,"address":[3035538],"length":1,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[3035872,3036332,3036396],"length":1,"stats":{"Line":2},"fn_name":null},{"line":107,"address":[2487000,2487280,2486940,2486895],"length":1,"stats":{"Line":7},"fn_name":null},{"line":111,"address":[2487765,2487360,2487399,2487813],"length":1,"stats":{"Line":6},"fn_name":"test_insert_data_by_copy"},{"line":112,"address":[3037430],"length":1,"stats":{"Line":1},"fn_name":null},{"line":113,"address":[3038014,3038078],"length":1,"stats":{"Line":2},"fn_name":null},{"line":114,"address":[3038175,3038756,3037859,3037486,3038353,3038107],"length":1,"stats":{"Line":4},"fn_name":null},{"line":116,"address":[3037507,3038988,3038726,3037808],"length":1,"stats":{"Line":4},"fn_name":null},{"line":117,"address":[3037528,3037757,3039830,3039734],"length":1,"stats":{"Line":4},"fn_name":null},{"line":119,"address":[3041535,3040636,3040712,3040952,3041035,3041512,3041819,3041455,3041236,3040787],"length":1,"stats":{"Line":7},"fn_name":null},{"line":120,"address":[3040550,3040651],"length":1,"stats":{"Line":2},"fn_name":null},{"line":121,"address":[3040659,3040802,3040577,3040759],"length":1,"stats":{"Line":2},"fn_name":null},{"line":122,"address":[3037706,3041163,3037549,3040855,3040767,3040991],"length":1,"stats":{"Line":6},"fn_name":null},{"line":123,"address":[3041359],"length":1,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[3041690,3041944,3041991],"length":1,"stats":{"Line":2},"fn_name":null},{"line":129,"address":[3037655,3041964,3042074,3037570],"length":1,"stats":{"Line":4},"fn_name":null},{"line":130,"address":[2487391,2487776,2487496,2487436],"length":1,"stats":{"Line":7},"fn_name":null},{"line":134,"address":[2488261,2487856,2488309,2487895],"length":1,"stats":{"Line":6},"fn_name":"test_insert_data_with_opts"},{"line":135,"address":[3044166],"length":1,"stats":{"Line":1},"fn_name":null},{"line":136,"address":[3044379,3044782,3045172,3044544,3044222,3044604],"length":1,"stats":{"Line":4},"fn_name":null},{"line":137,"address":[3045403,3045155],"length":1,"stats":{"Line":2},"fn_name":null},{"line":138,"address":[3045497,3045662,3046069,3046288,3045868,3045627,3045785,3046345,3046618,3046368],"length":1,"stats":{"Line":7},"fn_name":null},{"line":140,"address":[3045551],"length":1,"stats":{"Line":1},"fn_name":null},{"line":141,"address":[3045685,3045824,3045996,3044243,3044328,3045642],"length":1,"stats":{"Line":6},"fn_name":null},{"line":142,"address":[3046192],"length":1,"stats":{"Line":0},"fn_name":null},{"line":146,"address":[3046496,3046806],"length":1,"stats":{"Line":1},"fn_name":null},{"line":147,"address":[3047447,3047145,3046967,3046738,3046897],"length":1,"stats":{"Line":4},"fn_name":null},{"line":156,"address":[3048014,3048100],"length":1,"stats":{"Line":1},"fn_name":null},{"line":158,"address":[2487887,2488272,2487932,2487992],"length":1,"stats":{"Line":7},"fn_name":null}],"covered":47,"coverable":53},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","insert_at.rs"],"content":"use ql2::term::TermType;\nuse serde::Serialize;\n\nuse crate::Command;\n\npub(crate) fn new(offset: isize, value: impl Serialize) -\u003e Command {\n    let arg_offset = Command::from_json(offset);\n    let arg_value = Command::from_json(value);\n\n    Command::new(TermType::InsertAt)\n        .with_arg(arg_offset)\n        .with_arg(arg_value)\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::Converter;\n    use crate::{r, Result};\n\n    #[tokio::test]\n    async fn test_insert_at_ops() -\u003e Result\u003c()\u003e {\n        let conn = r.connection().connect().await?;\n        let response: [String; 4] = r\n            .expr([\"Moussa\", \"Ali\", \"Fati\"])\n            .insert_at(1, \"Alima\")\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(response == [\"Moussa\", \"Alima\", \"Ali\", \"Fati\"]);\n\n        Ok(())\n    }\n}\n","traces":[{"line":6,"address":[1600960,1601435,1601461],"length":1,"stats":{"Line":1},"fn_name":"new\u003c\u0026str\u003e"},{"line":7,"address":[1601106,1601011],"length":1,"stats":{"Line":2},"fn_name":null},{"line":8,"address":[1601114,1601175],"length":1,"stats":{"Line":2},"fn_name":null},{"line":10,"address":[1601381,1601183,1601315],"length":1,"stats":{"Line":3},"fn_name":null},{"line":11,"address":[1601254],"length":1,"stats":{"Line":1},"fn_name":null},{"line":12,"address":[1601322],"length":1,"stats":{"Line":1},"fn_name":null},{"line":21,"address":[2504544,2504583,2504949,2504997],"length":1,"stats":{"Line":6},"fn_name":"test_insert_at_ops"},{"line":22,"address":[5033475,5033580,5033741,5034283,5033930,5033509],"length":1,"stats":{"Line":4},"fn_name":null},{"line":23,"address":[5035158,5034506,5035252,5034754,5034939,5034683,5035215,5035621,5034273,5034572],"length":1,"stats":{"Line":7},"fn_name":null},{"line":24,"address":[5034176],"length":1,"stats":{"Line":1},"fn_name":null},{"line":26,"address":[5034595,5034713,5034882,5033524,5034552],"length":1,"stats":{"Line":5},"fn_name":null},{"line":27,"address":[5035062],"length":1,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[5035743,5035496,5035776],"length":1,"stats":{"Line":2},"fn_name":null},{"line":33,"address":[2504960,2504575,2504680,2504620],"length":1,"stats":{"Line":5},"fn_name":null}],"covered":13,"coverable":14},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","intersects.rs"],"content":"use ql2::term::TermType;\n\nuse crate::prelude::Geometry;\nuse crate::Command;\n\nuse super::CmdOpts;\n\npub(crate) fn new(geometry: impl IntersectsArg) -\u003e Command {\n    let (arg1, arg) = geometry.into_intersects_opts();\n    let mut command = Command::new(TermType::Intersects);\n\n    if let Some(arg) = arg1 {\n        command = arg.add_to_cmd(command);\n    }\n\n    command.with_arg(arg)\n}\n\npub trait IntersectsArg {\n    fn into_intersects_opts(self) -\u003e (Option\u003cCmdOpts\u003e, Command);\n}\n\nimpl IntersectsArg for Command {\n    fn into_intersects_opts(self) -\u003e (Option\u003cCmdOpts\u003e, Command) {\n        (None, self)\n    }\n}\n\nimpl\u003cT\u003e IntersectsArg for T\nwhere\n    T: Geometry,\n{\n    fn into_intersects_opts(self) -\u003e (Option\u003cCmdOpts\u003e, Command) {\n        (None, self.into())\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::Converter;\n    use crate::{args, r, Result};\n\n    #[tokio::test]\n    async fn test_intersects_geo() -\u003e Result\u003c()\u003e {\n        let conn = r.connection().connect().await?;\n        let point1 = r.point(-117.220406, 32.719464);\n        let point2 = r.point(-117.206201, 32.725186);\n\n        let response: bool = r\n            .circle(args!(point1, 2000.))\n            .intersects(point2)\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(response);\n\n        Ok(())\n    }\n}\n","traces":[{"line":8,"address":[3396509,3396530,3395872],"length":1,"stats":{"Line":1},"fn_name":"new\u003creql_rust::cmd::point::Point\u003e"},{"line":9,"address":[3395889],"length":1,"stats":{"Line":1},"fn_name":null},{"line":10,"address":[3396037],"length":1,"stats":{"Line":1},"fn_name":null},{"line":12,"address":[3396111,3396417],"length":1,"stats":{"Line":1},"fn_name":null},{"line":13,"address":[3396223,3396391],"length":1,"stats":{"Line":0},"fn_name":null},{"line":16,"address":[3396326],"length":1,"stats":{"Line":1},"fn_name":null},{"line":24,"address":[2171952],"length":1,"stats":{"Line":0},"fn_name":"into_intersects_opts"},{"line":25,"address":[2171968],"length":1,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":44,"address":[2827485,2827919,2827328,2827417,2827620,2827360,2827337],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":45,"address":[2827475,2828207,2827580,2827741,2827930,2827509],"length":1,"stats":{"Line":4},"fn_name":null},{"line":46,"address":[2828197],"length":1,"stats":{"Line":1},"fn_name":null},{"line":47,"address":[2828468],"length":1,"stats":{"Line":1},"fn_name":null},{"line":49,"address":[2829370,2828695,2828838,2829094,2829407,2829313,2828727,2828605,2828909,2829597],"length":1,"stats":{"Line":7},"fn_name":null},{"line":50,"address":[2828475],"length":1,"stats":{"Line":1},"fn_name":null},{"line":51,"address":[2828639],"length":1,"stats":{"Line":1},"fn_name":null},{"line":52,"address":[2827524,2828750,2828868,2829037,2828707],"length":1,"stats":{"Line":5},"fn_name":null},{"line":53,"address":[2829217],"length":1,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[2829486,2829690],"length":1,"stats":{"Line":1},"fn_name":null},{"line":59,"address":[2577580,2577920,2577535,2577640],"length":1,"stats":{"Line":5},"fn_name":null}],"covered":17,"coverable":21},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","is_empty.rs"],"content":"use ql2::term::TermType;\n\nuse crate::Command;\n\npub(crate) fn new() -\u003e Command {\n    Command::new(TermType::IsEmpty)\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::Converter;\n    use crate::spec::{set_up, tear_down};\n    use crate::Result;\n\n    #[tokio::test]\n    async fn test_is_empty() -\u003e Result\u003c()\u003e {\n        let (conn, table, table_name) = set_up(true).await?;\n        let data_obtained: bool = table.is_empty().run(\u0026conn).await?.unwrap().parse()?;\n\n        assert!(!data_obtained);\n\n        tear_down(conn, \u0026table_name).await\n    }\n}\n","traces":[{"line":5,"address":[2435552],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":6,"address":[2435564],"length":1,"stats":{"Line":1},"fn_name":null},{"line":16,"address":[1853461,1853047,1853413,1853008],"length":1,"stats":{"Line":6},"fn_name":"test_is_empty"},{"line":17,"address":[3937719,3936788,3937287,3936723,3936941,3937109],"length":1,"stats":{"Line":4},"fn_name":null},{"line":18,"address":[3938685,3938781,3936809,3937671,3936892,3937976],"length":1,"stats":{"Line":5},"fn_name":null},{"line":20,"address":[3938764,3939080],"length":1,"stats":{"Line":1},"fn_name":null},{"line":22,"address":[1853424,1853039,1853084,1853144],"length":1,"stats":{"Line":7},"fn_name":null}],"covered":7,"coverable":7},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","iso8601.rs"],"content":"use ql2::term::TermType;\nuse time::{format_description, UtcOffset};\n\nuse crate::{arguments::Args, constants::TIMEZONE_FORMAT, Command};\n\npub(crate) fn new(iso_datetime: \u0026str) -\u003e Command {\n    Command::new(TermType::Iso8601).with_arg(Command::from_json(iso_datetime))\n}\n\npub trait Iso8601 {\n    fn into_iso8601_opts(self) -\u003e crate::Result\u003cString\u003e;\n}\n\nimpl\u003cT\u003e Iso8601 for T\nwhere\n    T: Into\u003cString\u003e,\n{\n    fn into_iso8601_opts(self) -\u003e crate::Result\u003cString\u003e {\n        Ok(self.into())\n    }\n}\n\nimpl\u003cT\u003e Iso8601 for Args\u003c(T, UtcOffset)\u003e\nwhere\n    T: Into\u003cString\u003e,\n{\n    fn into_iso8601_opts(self) -\u003e crate::Result\u003cString\u003e {\n        let timezone_format = format_description::parse(TIMEZONE_FORMAT)?;\n        let timezone = self.0 .1.format(\u0026timezone_format)?;\n\n        Ok(format!(\"{}{}\", self.0 .0.into(), timezone))\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use time::macros::offset;\n\n    use crate::prelude::Converter;\n    use crate::types::Time;\n    use crate::{args, r, Result};\n\n    #[tokio::test]\n    async fn test_iso8601_ops() -\u003e Result\u003c()\u003e {\n        let conn = r.connection().connect().await?;\n\n        let date_time = r.iso8601(\"1986-11-03T08:30:00-07:00\")?;\n        let time1 = date_time.clone().value();\n        let time2: Time = date_time.cmd().run(\u0026conn).await?.unwrap().parse()?;\n\n        assert!(time2 == time1);\n\n        Ok(())\n    }\n\n    #[tokio::test]\n    async fn test_iso8601_ops_with_default_timezone() -\u003e Result\u003c()\u003e {\n        let conn = r.connection().connect().await?;\n\n        let date_time = r.iso8601(args!(\"1986-11-03T08:30:00\", offset!(+01:00)))?;\n        let time1 = date_time.clone().value();\n        let time2: Time = date_time.cmd().run(\u0026conn).await?.unwrap().parse()?;\n\n        assert!(time2 == time1);\n\n        Ok(())\n    }\n}\n","traces":[{"line":6,"address":[2675056,2675265,2675296],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":7,"address":[2675280,2675099],"length":1,"stats":{"Line":1},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":44,"address":[5175408,5175447,5175861,5175813],"length":1,"stats":{"Line":6},"fn_name":"test_iso8601_ops"},{"line":45,"address":[5102854,5102392,5102231,5102112,5102158,5102581],"length":1,"stats":{"Line":4},"fn_name":null},{"line":47,"address":[5102824,5103111,5103240],"length":1,"stats":{"Line":2},"fn_name":null},{"line":48,"address":[5103465,5103230],"length":1,"stats":{"Line":2},"fn_name":null},{"line":49,"address":[7926259,7926185],"length":1,"stats":{"Line":4},"fn_name":null},{"line":51,"address":[5104727,5104694,5104444],"length":1,"stats":{"Line":2},"fn_name":null},{"line":53,"address":[5175484,5175544,5175824,5175439],"length":1,"stats":{"Line":5},"fn_name":null},{"line":57,"address":[5104937,5105151,5105450,5104857,5105014,5104848,5104880],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":58,"address":[5105461,5105111,5105038,5105272,5104992,5105850],"length":1,"stats":{"Line":4},"fn_name":null},{"line":60,"address":[5106107,5105707,5106236],"length":1,"stats":{"Line":2},"fn_name":null},{"line":61,"address":[5106461,5106226],"length":1,"stats":{"Line":2},"fn_name":null},{"line":62,"address":[5107287,5107469,5106575,5106488,5105053],"length":1,"stats":{"Line":4},"fn_name":null},{"line":64,"address":[5107723,5107440,5107690],"length":1,"stats":{"Line":2},"fn_name":null},{"line":66,"address":[5107696],"length":1,"stats":{"Line":5},"fn_name":null}],"covered":22,"coverable":22},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","js.rs"],"content":"use ql2::term::TermType;\nuse reql_macros::CommandOptions;\nuse serde::Serialize;\n\nuse crate::arguments::Args;\nuse crate::Command;\n\npub(crate) fn new(args: impl JsArg) -\u003e Command {\n    let (arg, opts) = args.into_js_opts();\n\n    Command::new(TermType::Javascript)\n        .with_arg(arg)\n        .with_opts(opts)\n}\n\npub trait JsArg {\n    fn into_js_opts(self) -\u003e (Command, JsOption);\n}\n\nimpl\u003cT\u003e JsArg for T\nwhere\n    T: Into\u003cString\u003e,\n{\n    fn into_js_opts(self) -\u003e (Command, JsOption) {\n        (Command::from_json(self.into()), Default::default())\n    }\n}\n\nimpl\u003cT\u003e JsArg for Args\u003c(T, JsOption)\u003e\nwhere\n    T: Into\u003cString\u003e,\n{\n    fn into_js_opts(self) -\u003e (Command, JsOption) {\n        (Command::from_json(self.0 .0.into()), self.0 .1)\n    }\n}\n\n#[derive(Debug, Clone, Serialize, Default, PartialEq, PartialOrd, CommandOptions)]\npub struct JsOption {\n    /// `timeout` is the number of seconds before r.js times out.\n    /// The default value is 5 seconds.\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub timeout: Option\u003cf64\u003e,\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::Converter;\n    use crate::{r, Result};\n\n    #[tokio::test]\n    async fn test_js_ops() -\u003e Result\u003c()\u003e {\n        let conn = r.connection().connect().await?;\n        let response: String = r.js(\"'str1' + 'str2'\").run(\u0026conn).await?.unwrap().parse()?;\n\n        assert!(response.eq(\"str1str2\"));\n\n        Ok(())\n    }\n}\n","traces":[{"line":8,"address":[4643856,4644184,4644211],"length":1,"stats":{"Line":1},"fn_name":"new\u003c\u0026str\u003e"},{"line":9,"address":[4643889],"length":1,"stats":{"Line":1},"fn_name":null},{"line":11,"address":[4643990,4644125],"length":1,"stats":{"Line":2},"fn_name":null},{"line":12,"address":[4644064],"length":1,"stats":{"Line":1},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[2578039,2578405,2578000,2578453],"length":1,"stats":{"Line":6},"fn_name":"test_js_ops"},{"line":53,"address":[2792387,2792421,2792492,2792653,2792842,2793115],"length":1,"stats":{"Line":4},"fn_name":null},{"line":54,"address":[2792436,2794190,2794043,2793085,2793343],"length":1,"stats":{"Line":4},"fn_name":null},{"line":56,"address":[2794156,2794412,2794449],"length":1,"stats":{"Line":2},"fn_name":null},{"line":58,"address":[2578031,2578416,2578136,2578076],"length":1,"stats":{"Line":5},"fn_name":null}],"covered":11,"coverable":13},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","json.rs"],"content":"use ql2::term::TermType;\n\nuse crate::Command;\n\npub(crate) fn new\u003cT\u003e(value: T) -\u003e Command\nwhere\n    T: Into\u003cString\u003e,\n{\n    Command::new(TermType::Json).with_arg(Command::from_json(value.into()))\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::Converter;\n    use crate::{r, Result};\n\n    #[tokio::test]\n    async fn test_json_table() -\u003e Result\u003c()\u003e {\n        let data = [1, 2, 3];\n        let conn = r.connection().connect().await?;\n        let data_obtained: [u8; 3] = r.json(\"[1, 2, 3]\").run(\u0026conn).await?.unwrap().parse()?;\n\n        assert!(data_obtained == data);\n\n        Ok(())\n    }\n}\n","traces":[{"line":5,"address":[2841120,2841427],"length":1,"stats":{"Line":1},"fn_name":"new\u003c\u0026str\u003e"},{"line":9,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":18,"address":[4956485,4956533,4956119,4956080],"length":1,"stats":{"Line":6},"fn_name":"test_json_table"},{"line":19,"address":[5815600],"length":1,"stats":{"Line":1},"fn_name":null},{"line":20,"address":[5815620,5816348,5815654,5815886,5815725,5816075],"length":1,"stats":{"Line":4},"fn_name":null},{"line":21,"address":[5816318,5816576,5817276,5815669,5817415],"length":1,"stats":{"Line":4},"fn_name":null},{"line":23,"address":[5817655,5817389,5817618],"length":1,"stats":{"Line":2},"fn_name":null},{"line":25,"address":[4956496,4956156,4956111,4956216],"length":1,"stats":{"Line":5},"fn_name":null}],"covered":8,"coverable":8},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","keys.rs"],"content":"use ql2::term::TermType;\n\nuse crate::Command;\n\npub(crate) fn new() -\u003e Command {\n    Command::new(TermType::Keys)\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::Converter;\n    use crate::spec::{set_up, tear_down};\n    use crate::Result;\n\n    #[tokio::test]\n    async fn test_keys_values() -\u003e Result\u003c()\u003e {\n        let (conn, table, table_name) = set_up(true).await?;\n        let data_obtained: Vec\u003cString\u003e = table.get(1).keys().run(\u0026conn).await?.unwrap().parse()?;\n\n        assert!(data_obtained == vec![\"content\", \"id\", \"title\", \"view\"]);\n\n        tear_down(conn, \u0026table_name).await\n    }\n}\n","traces":[{"line":5,"address":[2435600],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":6,"address":[2435612],"length":1,"stats":{"Line":1},"fn_name":null},{"line":16,"address":[4645289,4645996,4645381,4645704,4645280,4645312,4645478],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":17,"address":[4645443,4646444,4645661,4645508,4645829,4646007],"length":1,"stats":{"Line":4},"fn_name":null},{"line":18,"address":[4647583,4645529,4646391,4645612,4646693,4647433],"length":1,"stats":{"Line":5},"fn_name":null},{"line":20,"address":[4648131,4647568,4647881],"length":1,"stats":{"Line":2},"fn_name":null},{"line":22,"address":[4648459,4648593,4648200,4648324,4645547,4648091,4648384],"length":1,"stats":{"Line":7},"fn_name":null}],"covered":7,"coverable":7},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","le.rs"],"content":"use ql2::term::TermType;\nuse serde::Serialize;\n\nuse crate::arguments::Args;\nuse crate::Command;\n\nuse super::CmdOpts;\n\npub(crate) fn new(args: impl LeArg) -\u003e Command {\n    args.into_le_opts().add_to_cmd(Command::new(TermType::Le))\n}\n\npub trait LeArg {\n    fn into_le_opts(self) -\u003e CmdOpts;\n}\n\nimpl\u003cT: Serialize\u003e LeArg for T {\n    fn into_le_opts(self) -\u003e CmdOpts {\n        CmdOpts::Single(Command::from_json(self))\n    }\n}\n\nimpl LeArg for Command {\n    fn into_le_opts(self) -\u003e CmdOpts {\n        CmdOpts::Single(self)\n    }\n}\n\nimpl\u003cS, T\u003e LeArg for Args\u003cT\u003e\nwhere\n    S: Serialize,\n    T: IntoIterator\u003cItem = S\u003e,\n{\n    fn into_le_opts(self) -\u003e CmdOpts {\n        let commands = self.0.into_iter().map(Command::from_json).collect();\n\n        CmdOpts::Many(commands)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::Converter;\n    use crate::spec::{set_up, tear_down};\n    use crate::{args, r, Result};\n\n    #[tokio::test]\n    async fn test_le_data() -\u003e Result\u003c()\u003e {\n        let (conn, table, table_name) = set_up(true).await?;\n        let data_obtained: bool = table\n            .get(1)\n            .g(\"view\")\n            .le(10)\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(data_obtained);\n\n        tear_down(conn, \u0026table_name).await\n    }\n\n    #[tokio::test]\n    async fn test_le_data_r() -\u003e Result\u003c()\u003e {\n        let conn = r.connection().connect().await?;\n        let data_obtained: bool = r.le(args!([5, 6, 7])).run(\u0026conn).await?.unwrap().parse()?;\n\n        assert!(data_obtained);\n\n        Ok(())\n    }\n}\n","traces":[{"line":9,"address":[2450220,2450409,2450436,2450193,2450240,2450000],"length":1,"stats":{"Line":2},"fn_name":"new\u003creql_rust::arguments::Args\u003c[i32; 3]\u003e\u003e"},{"line":10,"address":[2450429,2450017,2450263,2450213],"length":1,"stats":{"Line":2},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":24,"address":[2172064],"length":1,"stats":{"Line":0},"fn_name":"into_le_opts"},{"line":25,"address":[2172080],"length":1,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":48,"address":[4711544,4711129,4711152,4711221,4711318,4711836,4711120],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":49,"address":[4711501,4711847,4711283,4711348,4711669,4712284],"length":1,"stats":{"Line":4},"fn_name":null},{"line":50,"address":[4712798,4713313,4712517,4713212,4712231,4713503,4713269,4712721,4712993],"length":1,"stats":{"Line":6},"fn_name":null},{"line":54,"address":[7877824],"length":1,"stats":{"Line":5},"fn_name":null},{"line":55,"address":[4713116],"length":1,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[4713392,4713706],"length":1,"stats":{"Line":1},"fn_name":null},{"line":61,"address":[1950636,1950696,1950976,1950591],"length":1,"stats":{"Line":7},"fn_name":null},{"line":65,"address":[1951509,1951461,1951095,1951056],"length":1,"stats":{"Line":6},"fn_name":"test_le_data_r"},{"line":66,"address":[4714613,4714684,4715034,4715366,4714579,4714845],"length":1,"stats":{"Line":4},"fn_name":null},{"line":67,"address":[4714628,4716294,4715277,4716388,4715594],"length":1,"stats":{"Line":4},"fn_name":null},{"line":69,"address":[4716596,4716373],"length":1,"stats":{"Line":1},"fn_name":null},{"line":71,"address":[1951472,1951087,1951132,1951192],"length":1,"stats":{"Line":5},"fn_name":null}],"covered":18,"coverable":21},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","limit.rs"],"content":"use ql2::term::TermType;\n\nuse crate::Command;\n\npub(crate) fn new(step: usize) -\u003e Command {\n    let arg = Command::from_json(step);\n\n    Command::new(TermType::Limit).with_arg(arg)\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::cmd::order_by::OrderByOption;\n    use crate::prelude::Converter;\n    use crate::spec::{set_up, tear_down, Post};\n    use crate::Result;\n\n    #[tokio::test]\n    async fn test_limit_data() -\u003e Result\u003c()\u003e {\n        let data = Post::get_many_data();\n        let (conn, table, table_name) = set_up(true).await?;\n        let data_obtained: Vec\u003cPost\u003e = table\n            .order_by(OrderByOption::default().index(\"title\"))\n            .limit(1)\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(data_obtained.first() == data.first());\n\n        tear_down(conn, \u0026table_name).await\n    }\n}\n","traces":[{"line":5,"address":[2706083,2706114,2705872],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":6,"address":[2705897],"length":1,"stats":{"Line":1},"fn_name":null},{"line":8,"address":[2705995,2705924],"length":1,"stats":{"Line":2},"fn_name":null},{"line":19,"address":[2505493,2505445,2505040,2505079],"length":1,"stats":{"Line":6},"fn_name":"test_limit_data"},{"line":20,"address":[4884419],"length":1,"stats":{"Line":1},"fn_name":null},{"line":21,"address":[4884632,4884857,4884797,4884479,4885463,4885032],"length":1,"stats":{"Line":4},"fn_name":null},{"line":22,"address":[4886061,4886532,4886812,4886576,4885423,4885780,4886256,4885867,4886475,4885712,4885984],"length":1,"stats":{"Line":8},"fn_name":null},{"line":23,"address":[4885636,4885787,4885751,4885453,4885805],"length":1,"stats":{"Line":2},"fn_name":null},{"line":25,"address":[4885890,4885847,4886017,4884583,4886189,4884500],"length":1,"stats":{"Line":6},"fn_name":null},{"line":26,"address":[4886379],"length":1,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[4887244,4887073,4886696],"length":1,"stats":{"Line":2},"fn_name":null},{"line":32,"address":[2505116,2505071,2505456,2505176],"length":1,"stats":{"Line":7},"fn_name":null}],"covered":11,"coverable":12},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","line.rs"],"content":"use ql2::term::TermType;\nuse serde::{Deserialize, Serialize};\n\nuse crate::prelude::Geometry;\nuse crate::types::{GeoType, ReqlType};\nuse crate::Command;\n\nuse super::point::Point;\n\n#[derive(Debug, Serialize, Deserialize, Clone, PartialEq, PartialOrd, Geometry)]\npub struct Line {\n    #[serde(rename = \"$reql_type$\")]\n    pub reql_type: ReqlType,\n    pub coordinates: Vec\u003c[f64; 2]\u003e,\n    #[serde(rename = \"type\")]\n    pub typ: GeoType,\n}\n\nimpl Line {\n    pub fn new(points: \u0026[Point]) -\u003e Self {\n        assert!(points.len() \u003e= 2);\n\n        Self {\n            reql_type: ReqlType::Geometry,\n            typ: GeoType::LineString,\n            coordinates: points.iter().map(|point| point.coordinates).collect(),\n        }\n    }\n\n    /// Convert a Line object into a Polygon object.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// line.fill() → polygon\n    /// ```\n    ///\n    /// Where:\n    /// - polygon: [Polygon](crate::cmd::polygon::Polygon)\n    ///\n    /// # Description\n    ///\n    /// If the last point does not specify the same coordinates as the first point,\n    /// `polygon` will close the polygon by connecting them.\n    ///\n    /// Longitude (−180 to 180) and latitude (−90 to 90)\n    /// of vertices are plotted on a perfect sphere.\n    /// See [Geospatial support](https://rethinkdb.com/docs/geo-support/python/)\n    /// for more information on ReQL’s coordinate system.\n    ///\n    /// If the last point does not specify the same coordinates as the first point,\n    /// `polygon` will close the polygon by connecting them.\n    /// You cannot directly construct a polygon with holes in it using `polygon`,\n    /// but you can use [polygon_sub](crate::types::Polygon::polygon_sub)\n    /// to use a second polygon within the interior of the first to define a hole.\n    ///\n    /// ## Examples\n    ///\n    /// Create a line object and then convert it to a polygon.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{args, r, Result};\n    /// use serde_json::json;\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///\n    ///     let response = r.line(\u0026[\n    ///         r.point(-122.423246, 37.779388),\n    ///         r.point(-122.423246, 37.329898),\n    ///         r.point(-121.886420, 37.329898),\n    ///         r.point(-121.886420, 37.779388),\n    ///     ])\n    ///     .fill()\n    ///     .run(\u0026conn)\n    ///     .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [polygon](crate::r::polygon)\n    /// - [line](crate::r::line)\n    pub fn fill(self) -\u003e Command {\n        super::fill::new().with_parent(self.into())\n    }\n}\n\nimpl From\u003cLine\u003e for Command {\n    fn from(line: Line) -\u003e Self {\n        line.coordinates\n            .iter()\n            .fold(Command::new(TermType::Line), |command, coord| {\n                let point: Command = Point::new(coord[0], coord[1]).into();\n\n                command.with_arg(point)\n            })\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use serde::{Deserialize, Serialize};\n\n    use crate::prelude::Converter;\n    use crate::spec::{set_up, tear_down};\n    use crate::types::{Line, Point};\n    use crate::{r, Result};\n\n    #[derive(Debug, Serialize, Deserialize, PartialEq)]\n    struct Route {\n        id: u8,\n        route: Line,\n    }\n\n    #[tokio::test]\n    async fn test_line_data() -\u003e Result\u003c()\u003e {\n        let route = Route {\n            id: 1,\n            route: r.line(\u0026[\n                Point::new(-122.423246, 37.779388),\n                Point::new(-121.886420, 37.329898),\n            ]),\n        };\n        let (conn, table, table_name) = set_up(false).await?;\n        table.clone().insert(\u0026route).run(\u0026conn).await?;\n        let response: Route = table.get(1).run(\u0026conn).await?.unwrap().parse()?;\n\n        assert!(response == route);\n\n        tear_down(conn, \u0026table_name).await\n    }\n}\n","traces":[{"line":20,"address":[2026656],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":21,"address":[2026690,2026741],"length":1,"stats":{"Line":1},"fn_name":null},{"line":26,"address":[2908732,2908675],"length":1,"stats":{"Line":4},"fn_name":null},{"line":88,"address":[2909101,2908832],"length":1,"stats":{"Line":1},"fn_name":"fill"},{"line":89,"address":[2026902,2027142,2026984],"length":1,"stats":{"Line":2},"fn_name":null},{"line":94,"address":[2172363,2172144],"length":1,"stats":{"Line":1},"fn_name":"from"},{"line":95,"address":[2172174,2172246,2172334],"length":1,"stats":{"Line":3},"fn_name":null},{"line":97,"address":[2172286],"length":1,"stats":{"Line":2},"fn_name":null},{"line":98,"address":[2574390,2574475],"length":1,"stats":{"Line":2},"fn_name":null},{"line":100,"address":[2574504],"length":1,"stats":{"Line":1},"fn_name":null},{"line":121,"address":[4723008,4723047,4723461,4723413],"length":1,"stats":{"Line":6},"fn_name":"test_line_data"},{"line":124,"address":[5318996],"length":1,"stats":{"Line":1},"fn_name":null},{"line":129,"address":[5318810,5319374,5319133,5319196,5319788,5318581],"length":1,"stats":{"Line":4},"fn_name":null},{"line":130,"address":[5318759,5319778,5320012,5318602],"length":1,"stats":{"Line":4},"fn_name":null},{"line":131,"address":[5318623,5318708,5320752,5320876,5321770,5321596],"length":1,"stats":{"Line":5},"fn_name":null},{"line":133,"address":[5322252,5321756,5322194],"length":1,"stats":{"Line":2},"fn_name":null},{"line":135,"address":[4723144,4723039,4723424,4723084],"length":1,"stats":{"Line":7},"fn_name":null}],"covered":17,"coverable":17},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","literal.rs"],"content":"use ql2::term::TermType;\nuse serde::Serialize;\n\nuse crate::Command;\n\npub(crate) fn new(selector: impl Serialize) -\u003e Command {\n    let arg = Command::from_json(selector);\n\n    Command::new(TermType::Literal).with_arg(arg)\n}\n\n// TODO write test\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","lt.rs"],"content":"use ql2::term::TermType;\nuse serde::Serialize;\n\nuse crate::arguments::Args;\nuse crate::Command;\n\nuse super::CmdOpts;\n\npub(crate) fn new(args: impl LtArg) -\u003e Command {\n    args.into_lt_opts().add_to_cmd(Command::new(TermType::Lt))\n}\n\npub trait LtArg {\n    fn into_lt_opts(self) -\u003e CmdOpts;\n}\n\nimpl\u003cT: Serialize\u003e LtArg for T {\n    fn into_lt_opts(self) -\u003e CmdOpts {\n        CmdOpts::Single(Command::from_json(self))\n    }\n}\n\nimpl LtArg for Command {\n    fn into_lt_opts(self) -\u003e CmdOpts {\n        CmdOpts::Single(self)\n    }\n}\n\nimpl\u003cS, T\u003e LtArg for Args\u003cT\u003e\nwhere\n    S: Serialize,\n    T: IntoIterator\u003cItem = S\u003e,\n{\n    fn into_lt_opts(self) -\u003e CmdOpts {\n        let commands = self.0.into_iter().map(Command::from_json).collect();\n\n        CmdOpts::Many(commands)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::Converter;\n    use crate::spec::{set_up, tear_down};\n    use crate::{args, r, Result};\n\n    #[tokio::test]\n    async fn test_lt_data() -\u003e Result\u003c()\u003e {\n        let (conn, table, table_name) = set_up(true).await?;\n        let data_obtained: bool = table\n            .get(1)\n            .g(\"view\")\n            .lt(15)\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(data_obtained);\n\n        tear_down(conn, \u0026table_name).await\n    }\n\n    #[tokio::test]\n    async fn test_lt_data_r() -\u003e Result\u003c()\u003e {\n        let conn = r.connection().connect().await?;\n        let data_obtained: bool = r.lt(args!([5, 6, 7])).run(\u0026conn).await?.unwrap().parse()?;\n\n        assert!(data_obtained);\n\n        Ok(())\n    }\n}\n","traces":[{"line":9,"address":[4736953,4736980,4736784,4736737,4736764,4736544],"length":1,"stats":{"Line":2},"fn_name":"new\u003creql_rust::arguments::Args\u003c[i32; 3]\u003e\u003e"},{"line":10,"address":[4736757,4736973,4736807,4736561],"length":1,"stats":{"Line":2},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":24,"address":[2172416],"length":1,"stats":{"Line":0},"fn_name":"into_lt_opts"},{"line":25,"address":[2172432],"length":1,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":48,"address":[2942663,2943077,2943029,2942624],"length":1,"stats":{"Line":6},"fn_name":"test_lt_data"},{"line":49,"address":[4562052,4561987,4562551,4562205,4562373,4562988],"length":1,"stats":{"Line":4},"fn_name":null},{"line":50,"address":[4563697,4563502,4563221,4564017,4563425,4564207,4563916,4563973,4562935],"length":1,"stats":{"Line":6},"fn_name":null},{"line":54,"address":[7878336],"length":1,"stats":{"Line":5},"fn_name":null},{"line":55,"address":[4563820],"length":1,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[4564410,4564096],"length":1,"stats":{"Line":1},"fn_name":null},{"line":61,"address":[4564504,4562091,4564367,4564740,4564628,4564688,4564874],"length":1,"stats":{"Line":7},"fn_name":null},{"line":65,"address":[2943120,2943525,2943573,2943159],"length":1,"stats":{"Line":6},"fn_name":"test_lt_data_r"},{"line":66,"address":[4565388,4565549,4565738,4566070,4565283,4565317],"length":1,"stats":{"Line":4},"fn_name":null},{"line":67,"address":[4565981,4566298,4565332,4566998,4567092],"length":1,"stats":{"Line":4},"fn_name":null},{"line":69,"address":[4567077,4567300],"length":1,"stats":{"Line":1},"fn_name":null},{"line":71,"address":[2943196,2943536,2943151,2943256],"length":1,"stats":{"Line":5},"fn_name":null}],"covered":18,"coverable":21},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","map.rs"],"content":"use ql2::term::TermType;\n\nuse crate::arguments::Args;\nuse crate::prelude::Func;\nuse crate::Command;\n\nuse super::CmdOpts;\n\npub(crate) fn new(args: impl MapArg) -\u003e Command {\n    let (args, func) = args.into_map_opts();\n    let mut command = Command::new(TermType::Map);\n\n    if let Some(args) = args {\n        command = args.add_to_cmd(command);\n    }\n\n    command.with_arg(func)\n}\n\npub trait MapArg {\n    fn into_map_opts(self) -\u003e (Option\u003cCmdOpts\u003e, Command);\n}\n\nimpl MapArg for Func {\n    fn into_map_opts(self) -\u003e (Option\u003cCmdOpts\u003e, Command) {\n        (None, self.0)\n    }\n}\n\nimpl MapArg for Args\u003c(Command, Func)\u003e {\n    fn into_map_opts(self) -\u003e (Option\u003cCmdOpts\u003e, Command) {\n        let Func(func) = self.0 .1;\n\n        (Some(CmdOpts::Single(self.0 .0)), func)\n    }\n}\n\nimpl\u003cT\u003e MapArg for Args\u003c(T, Func)\u003e\nwhere\n    T: AsRef\u003c[Command]\u003e,\n{\n    fn into_map_opts(self) -\u003e (Option\u003cCmdOpts\u003e, Command) {\n        let Func(func) = self.0 .1;\n\n        (Some(CmdOpts::Many(self.0 .0.as_ref().to_vec())), func)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::*;\n    use crate::{r, Result};\n\n    #[tokio::test]\n    async fn test_map_ops() -\u003e Result\u003c()\u003e {\n        let conn = r.connection().connect().await?;\n        let data_obtained: Vec\u003cu8\u003e = r\n            .expr([1, 2, 3, 4, 5])\n            .map(func!(|val| val.clone() * val))\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(data_obtained == vec![1, 4, 9, 16, 25]);\n\n        Ok(())\n    }\n}\n","traces":[{"line":9,"address":[3397228,3397249,3396608],"length":1,"stats":{"Line":1},"fn_name":"new\u003creql_rust::cmd::func::Func\u003e"},{"line":10,"address":[3396625],"length":1,"stats":{"Line":1},"fn_name":null},{"line":11,"address":[3396756],"length":1,"stats":{"Line":1},"fn_name":null},{"line":13,"address":[3396830,3397136],"length":1,"stats":{"Line":1},"fn_name":null},{"line":14,"address":[3397110,3396942],"length":1,"stats":{"Line":0},"fn_name":null},{"line":17,"address":[3397045],"length":1,"stats":{"Line":1},"fn_name":null},{"line":25,"address":[2741120],"length":1,"stats":{"Line":1},"fn_name":"into_map_opts"},{"line":26,"address":[2822784],"length":1,"stats":{"Line":1},"fn_name":null},{"line":31,"address":[2656704],"length":1,"stats":{"Line":0},"fn_name":"into_map_opts"},{"line":32,"address":[2656726],"length":1,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[2656753],"length":1,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[4991865,4992200,4992517,4992044,4991856,4991957,4991888],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":56,"address":[4992010,4992157,4992324,4992528,4992074,4992867],"length":1,"stats":{"Line":4},"fn_name":null},{"line":57,"address":[4993760,4994324,4994543,4994130,4993894,4992857,4994600,4994640,4994053,4994874],"length":1,"stats":{"Line":7},"fn_name":null},{"line":58,"address":[4992786,4993107],"length":1,"stats":{"Line":2},"fn_name":null},{"line":59,"address":[4993170,4993799,4993128,4993909,4995280,4993072,4995318],"length":1,"stats":{"Line":4},"fn_name":"{closure#0}"},{"line":60,"address":[4994086,4994258,4993962,4992092,4993874],"length":1,"stats":{"Line":5},"fn_name":null},{"line":61,"address":[4994447],"length":1,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[4994763,4995188,4995004],"length":1,"stats":{"Line":2},"fn_name":null},{"line":67,"address":[2578572,2578912,2578527,2578632],"length":1,"stats":{"Line":5},"fn_name":null}],"covered":15,"coverable":23},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","match_.rs"],"content":"use ql2::term::TermType;\nuse regex::Regex;\n\nuse crate::Command;\n\npub(crate) fn new(regex: Regex) -\u003e Command {\n    let arg = Command::from_json(regex.as_str());\n\n    Command::new(TermType::Match).with_arg(arg)\n}\n\n#[cfg(test)]\nmod tests {\n    use regex::Regex;\n\n    use crate::prelude::*;\n    use crate::types::{MatchItem, MatchResponse};\n    use crate::{r, Result};\n\n    #[tokio::test]\n    async fn test_match_ops() -\u003e Result\u003c()\u003e {\n        let conn = r.connection().connect().await?;\n        let regexp = Regex::new(\".*@(.*)\")?;\n        let data = MatchResponse {\n            start: 0,\n            end: 15,\n            str: \"name@domain.com\".static_string(),\n            groups: vec![MatchItem {\n                start: 5,\n                end: 15,\n                str: \"domain.com\".static_string(),\n            }],\n        };\n        let response: MatchResponse = r\n            .expr(\"name@domain.com\")\n            .match_(regexp)\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(response == data);\n\n        Ok(())\n    }\n\n    #[tokio::test]\n    async fn test_match_ops_return_none() -\u003e Result\u003c()\u003e {\n        let conn = r.connection().connect().await?;\n        let regexp = Regex::new(\".*@(.*)\")?;\n        let response: Option\u003cMatchResponse\u003e = r\n            .expr(\"name[at]domain.com\")\n            .match_(regexp)\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(response == None);\n\n        Ok(())\n    }\n}\n","traces":[{"line":6,"address":[2518828,2518512],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":7,"address":[2518539,2518624],"length":1,"stats":{"Line":2},"fn_name":null},{"line":9,"address":[2518719,2518648],"length":1,"stats":{"Line":2},"fn_name":null},{"line":21,"address":[2943616,2943655,2944069,2944021],"length":1,"stats":{"Line":6},"fn_name":"test_match_ops"},{"line":22,"address":[1718563,1718374,1718840,1718213,1718096,1718142],"length":1,"stats":{"Line":4},"fn_name":null},{"line":23,"address":[1719097,1719210,1718806],"length":1,"stats":{"Line":2},"fn_name":null},{"line":27,"address":[1719180],"length":1,"stats":{"Line":1},"fn_name":null},{"line":28,"address":[1719503,1719408],"length":1,"stats":{"Line":1},"fn_name":null},{"line":34,"address":[1719764,1719859,1720477,1720073,1720534,1720910,1720002,1720571,1720258,1719891],"length":1,"stats":{"Line":7},"fn_name":null},{"line":36,"address":[1719823],"length":1,"stats":{"Line":1},"fn_name":null},{"line":37,"address":[7908105],"length":1,"stats":{"Line":5},"fn_name":null},{"line":38,"address":[1720381],"length":1,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[1720788,1721065,1721032],"length":1,"stats":{"Line":2},"fn_name":null},{"line":44,"address":[1721038],"length":1,"stats":{"Line":5},"fn_name":null},{"line":48,"address":[1721193,1721273,1721485,1721184,1721216,1721350,1721784],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":49,"address":[1721374,1721445,1721606,1721795,1721328,1722072],"length":1,"stats":{"Line":4},"fn_name":null},{"line":50,"address":[1722038,1722329,1722442],"length":1,"stats":{"Line":2},"fn_name":null},{"line":51,"address":[1722656,1722688,1723274,1722799,1723691,1723354,1722412,1723055,1723331,1722870],"length":1,"stats":{"Line":7},"fn_name":null},{"line":53,"address":[1722620],"length":1,"stats":{"Line":1},"fn_name":null},{"line":54,"address":[1721389,1722829,1722668,1722998,1722711],"length":1,"stats":{"Line":5},"fn_name":null},{"line":55,"address":[1723178],"length":1,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[1723847,1723566,1723814],"length":1,"stats":{"Line":2},"fn_name":null},{"line":61,"address":[1723820],"length":1,"stats":{"Line":5},"fn_name":null}],"covered":21,"coverable":23},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","max.rs"],"content":"use std::borrow::Cow;\n\nuse ql2::term::TermType;\nuse reql_macros::CommandOptions;\nuse serde::Serialize;\n\nuse crate::arguments::Args;\nuse crate::prelude::Func;\nuse crate::Command;\n\npub(crate) fn new(args: impl MaxArg) -\u003e Command {\n    let (arg, opts) = args.into_max_opts();\n    let mut command = Command::new(TermType::Max);\n\n    if let Some(arg) = arg {\n        command = command.with_arg(arg)\n    }\n\n    command.with_opts(opts)\n}\n\npub trait MaxArg {\n    fn into_max_opts(self) -\u003e (Option\u003cCommand\u003e, MaxOption);\n}\n\nimpl MaxArg for () {\n    fn into_max_opts(self) -\u003e (Option\u003cCommand\u003e, MaxOption) {\n        (None, Default::default())\n    }\n}\n\nimpl\u003cT\u003e MaxArg for Args\u003cT\u003e\nwhere\n    T: Into\u003cString\u003e,\n{\n    fn into_max_opts(self) -\u003e (Option\u003cCommand\u003e, MaxOption) {\n        let arg = Command::from_json(self.0.into());\n\n        (Some(arg), Default::default())\n    }\n}\n\nimpl MaxArg for Func {\n    fn into_max_opts(self) -\u003e (Option\u003cCommand\u003e, MaxOption) {\n        (Some(self.0), Default::default())\n    }\n}\n\nimpl MaxArg for MaxOption {\n    fn into_max_opts(self) -\u003e (Option\u003cCommand\u003e, MaxOption) {\n        (None, self)\n    }\n}\n\nimpl MaxArg for Command {\n    fn into_max_opts(self) -\u003e (Option\u003cCommand\u003e, MaxOption) {\n        (Some(self), Default::default())\n    }\n}\n\n#[derive(Debug, Clone, Serialize, Default, PartialEq, PartialOrd, CommandOptions)]\npub struct MaxOption {\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub index: Option\u003cCow\u003c'static, str\u003e\u003e,\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::Converter;\n    use crate::spec::{set_up, tear_down, Post};\n    use crate::{args, Result};\n\n    #[tokio::test]\n    async fn test_max_data() -\u003e Result\u003c()\u003e {\n        let data = Post::get_many_data();\n        let (conn, table, table_name) = set_up(true).await?;\n        let data_obtained: Post = table\n            .max(args!(\"view\"))\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(Some(\u0026data_obtained) == data.first());\n\n        tear_down(conn, \u0026table_name).await\n    }\n}\n","traces":[{"line":11,"address":[4775920,4776518,4776539],"length":1,"stats":{"Line":1},"fn_name":"new\u003creql_rust::arguments::Args\u003c\u0026str\u003e\u003e"},{"line":12,"address":[4775953],"length":1,"stats":{"Line":1},"fn_name":null},{"line":13,"address":[4776057],"length":1,"stats":{"Line":1},"fn_name":null},{"line":15,"address":[4776429,4776131],"length":1,"stats":{"Line":2},"fn_name":null},{"line":16,"address":[4776403,4776246],"length":1,"stats":{"Line":2},"fn_name":null},{"line":19,"address":[4776336],"length":1,"stats":{"Line":1},"fn_name":null},{"line":27,"address":[5405808,5405984],"length":1,"stats":{"Line":0},"fn_name":"into_max_opts"},{"line":28,"address":[5405825],"length":1,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[1901854,1901568],"length":1,"stats":{"Line":1},"fn_name":"into_max_opts\u003c\u0026str\u003e"},{"line":37,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":44,"address":[2741232,2741459],"length":1,"stats":{"Line":0},"fn_name":"into_max_opts"},{"line":45,"address":[2741283],"length":1,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[2457248],"length":1,"stats":{"Line":0},"fn_name":"into_max_opts"},{"line":51,"address":[2457267],"length":1,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[2172496,2172723],"length":1,"stats":{"Line":0},"fn_name":"into_max_opts"},{"line":57,"address":[2172547],"length":1,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[5324192,5324377,5324224,5324201,5324293,5324949,5324603],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":75,"address":[5324355],"length":1,"stats":{"Line":1},"fn_name":null},{"line":76,"address":[5325436,5324960,5324560,5324785,5324407,5324725],"length":1,"stats":{"Line":4},"fn_name":null},{"line":77,"address":[5326329,5326676,5326373,5325858,5325781,5325664,5325402,5326272,5325345,5326053],"length":1,"stats":{"Line":7},"fn_name":null},{"line":78,"address":[5325375],"length":1,"stats":{"Line":1},"fn_name":null},{"line":79,"address":[5324511,5324428,5325814,5325644,5325687,5325986],"length":1,"stats":{"Line":6},"fn_name":null},{"line":80,"address":[5326176],"length":1,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[5326937,5327048,5326552],"length":1,"stats":{"Line":2},"fn_name":null},{"line":86,"address":[2579023,2579068,2579128,2579408],"length":1,"stats":{"Line":7},"fn_name":null}],"covered":17,"coverable":26},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","merge.rs"],"content":"use ql2::term::TermType;\nuse serde::Serialize;\n\nuse crate::arguments::Args;\nuse crate::prelude::Func;\nuse crate::Command;\n\nuse super::CmdOpts;\n\npub(crate) fn new(args: impl MergeArg) -\u003e Command {\n    args.into_merge_opts()\n        .add_to_cmd(Command::new(TermType::Merge))\n}\n\npub trait MergeArg {\n    fn into_merge_opts(self) -\u003e CmdOpts;\n}\n\nimpl\u003cT\u003e MergeArg for T\nwhere\n    T: Serialize,\n{\n    fn into_merge_opts(self) -\u003e CmdOpts {\n        CmdOpts::Single(Command::from_json(self))\n    }\n}\n\nimpl MergeArg for Command {\n    fn into_merge_opts(self) -\u003e CmdOpts {\n        CmdOpts::Single(self)\n    }\n}\n\nimpl MergeArg for Func {\n    fn into_merge_opts(self) -\u003e CmdOpts {\n        CmdOpts::Single(self.0)\n    }\n}\n\nimpl\u003cS, T\u003e MergeArg for Args\u003cT\u003e\nwhere\n    S: Into\u003cCommand\u003e,\n    T: IntoIterator\u003cItem = S\u003e,\n{\n    fn into_merge_opts(self) -\u003e CmdOpts {\n        CmdOpts::Many(self.0.into_iter().map(|cmd| cmd.into()).collect())\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use std::collections::HashMap;\n\n    use serde::{Deserialize, Serialize};\n    use uuid::Uuid;\n\n    use crate::args;\n    use crate::prelude::*;\n    use crate::spec::*;\n    use crate::Session;\n    use crate::{r, Result};\n\n    #[derive(Debug, Serialize, Deserialize, PartialEq, Eq)]\n    struct Comment {\n        id: u8,\n        post_id: u8,\n        message: String,\n    }\n\n    impl Comment {\n        fn new(id: u8, post_id: u8, message: \u0026str) -\u003e Self {\n            Self {\n                id,\n                post_id,\n                message: String::from(message),\n            }\n        }\n    }\n\n    #[derive(Debug, Serialize, Deserialize, PartialEq, Eq)]\n    struct MergePostToComment {\n        id: u8,\n        post_id: u8,\n        message: String,\n        post: Post,\n    }\n\n    #[tokio::test]\n    async fn test_merge_ops() -\u003e Result\u003c()\u003e {\n        let (\n            conn,\n            comment_table,\n            post_table,\n            merged_post_comments,\n            comment_table_name,\n            post_table_name,\n        ) = set_up2().await?;\n\n        let response: Vec\u003cMergePostToComment\u003e = comment_table\n            .merge(func!(|comment| {\n                let mut posts = HashMap::new();\n\n                posts.insert(\"post\", post_table.get(comment.g(\"post_id\")));\n\n                r.hash_map(posts)\n            }))\n            .order_by(r.expr(\"id\"))\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(response == merged_post_comments);\n\n        tear_down2(conn, comment_table_name, post_table_name).await\n    }\n\n    #[tokio::test]\n    async fn test_merge_ops_multi() -\u003e Result\u003c()\u003e {\n        let (conn, comment_table, post_table, _, comment_table_name, post_table_name) =\n            set_up2().await?;\n\n        let response = post_table\n            .get(1)\n            .merge(args!([comment_table.clone().get(1), comment_table.get(2),]))\n            .run(\u0026conn)\n            .await?;\n\n        assert!(response.is_some());\n\n        tear_down2(conn, comment_table_name, post_table_name).await\n    }\n\n    async fn set_up2() -\u003e Result\u003c(\n        Session,\n        Command,\n        Command,\n        Vec\u003cMergePostToComment\u003e,\n        String,\n        String,\n    )\u003e {\n        let comment_table_name = Uuid::new_v4().to_string();\n        let posts = Post::get_many_data();\n        let comments = vec![\n            Comment::new(1, 1, \"Hello\"),\n            Comment::new(2, 1, \"Hello\"),\n            Comment::new(3, 2, \"Bueno dias\"),\n        ];\n        let merged_post_comments: Vec\u003cMergePostToComment\u003e = comments\n            .iter()\n            .map(|comment| MergePostToComment {\n                id: comment.id,\n                post_id: comment.post_id,\n                message: String::from(\u0026comment.message),\n                post: posts\n                    .clone()\n                    .into_iter()\n                    .find(|post| post.id == comment.post_id)\n                    .unwrap(),\n            })\n            .collect();\n\n        let (conn, post_table, post_table_name) = set_up(true).await?;\n        r.table_create(comment_table_name.as_str())\n            .run(\u0026conn)\n            .await?;\n        let comment_table = r.table(comment_table_name.as_str());\n        comment_table.clone().insert(comments).run(\u0026conn).await?;\n\n        Ok((\n            conn,\n            comment_table,\n            post_table,\n            merged_post_comments,\n            comment_table_name,\n            post_table_name,\n        ))\n    }\n\n    async fn tear_down2(\n        conn: Session,\n        comment_table_name: String,\n        post_table_name: String,\n    ) -\u003e Result\u003c()\u003e {\n        r.table_drop(\u0026comment_table_name).run(\u0026conn).await?;\n        tear_down(conn, \u0026post_table_name).await\n    }\n}\n","traces":[{"line":10,"address":[7661356,7661596,7661168,7661408,7661623,7661648,7661865,7661838,7661383],"length":1,"stats":{"Line":3},"fn_name":"new\u003creql_rust::cmd::func::Func\u003e"},{"line":11,"address":[7661547,7661665,7661184,7661424,7661307,7661789],"length":1,"stats":{"Line":6},"fn_name":null},{"line":12,"address":[7661476,7661616,7661340,7661376,7661717,7661580,7661236,7661822,7661858],"length":1,"stats":{"Line":6},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[2172752],"length":1,"stats":{"Line":1},"fn_name":"into_merge_opts"},{"line":30,"address":[2172768],"length":1,"stats":{"Line":1},"fn_name":null},{"line":35,"address":[2741488],"length":1,"stats":{"Line":1},"fn_name":"into_merge_opts"},{"line":36,"address":[2741504],"length":1,"stats":{"Line":1},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":71,"address":[2476736],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":75,"address":[2476798],"length":1,"stats":{"Line":1},"fn_name":null},{"line":89,"address":[1935733,1935513,1936251,1935504,1935605,1935536,1935959],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":90,"address":[1935667,1935763,1935916,1936084,1936262,1936871],"length":1,"stats":{"Line":4},"fn_name":null},{"line":91,"address":[1936560],"length":1,"stats":{"Line":1},"fn_name":null},{"line":92,"address":[1936571],"length":1,"stats":{"Line":1},"fn_name":null},{"line":93,"address":[1936638],"length":1,"stats":{"Line":1},"fn_name":null},{"line":94,"address":[1936700],"length":1,"stats":{"Line":1},"fn_name":null},{"line":95,"address":[1936724],"length":1,"stats":{"Line":1},"fn_name":null},{"line":96,"address":[1936748],"length":1,"stats":{"Line":1},"fn_name":null},{"line":99,"address":[1938853,1937840,1938577,1938382,1939131,1938897,1938075,1936772,1938146,1938305,1938796],"length":1,"stats":{"Line":8},"fn_name":null},{"line":100,"address":[1937879,1940853,1936826,1937077,1940272,1937817,1940681,1937919],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":101,"address":[1940299],"length":1,"stats":{"Line":1},"fn_name":null},{"line":103,"address":[1940405,1940719,1940674],"length":1,"stats":{"Line":2},"fn_name":null},{"line":105,"address":[1940731],"length":1,"stats":{"Line":1},"fn_name":null},{"line":107,"address":[1937976,1938041,1938161,1938122,1938028],"length":1,"stats":{"Line":2},"fn_name":null},{"line":108,"address":[1938214,1938338,1938510,1935784,1935867],"length":1,"stats":{"Line":5},"fn_name":null},{"line":109,"address":[1938700],"length":1,"stats":{"Line":0},"fn_name":null},{"line":113,"address":[1939463,1939017,1939562],"length":1,"stats":{"Line":2},"fn_name":null},{"line":115,"address":[1935802,1939943,1939723,1939813,1939477],"length":1,"stats":{"Line":7},"fn_name":null},{"line":119,"address":[1941614,1940889,1940912,1940880,1940981,1941086,1941316],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":120,"address":[1941625,1941444,1941046,1942073,1941273,1941116],"length":1,"stats":{"Line":5},"fn_name":null},{"line":123,"address":[1942332,1943009,1942843,1942780,1943086,1943287,1943503],"length":1,"stats":{"Line":6},"fn_name":null},{"line":125,"address":[1942428,1942819,1942858,1942476],"length":1,"stats":{"Line":2},"fn_name":null},{"line":126,"address":[1943042,1942909,1943214,1941222,1941137],"length":1,"stats":{"Line":5},"fn_name":null},{"line":127,"address":[1943533,1943407],"length":1,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[1943795,1943906,1943393],"length":1,"stats":{"Line":2},"fn_name":null},{"line":131,"address":[1944307,1943809,1944167,1941155,1944087],"length":1,"stats":{"Line":7},"fn_name":null},{"line":134,"address":[2476880],"length":1,"stats":{"Line":1},"fn_name":"set_up2"},{"line":142,"address":[1922518,1922919],"length":1,"stats":{"Line":2},"fn_name":null},{"line":143,"address":[1922941],"length":1,"stats":{"Line":1},"fn_name":null},{"line":144,"address":[1923132,1923010,1923218,1923293],"length":1,"stats":{"Line":1},"fn_name":null},{"line":145,"address":[1923089],"length":1,"stats":{"Line":1},"fn_name":null},{"line":146,"address":[1923161],"length":1,"stats":{"Line":1},"fn_name":null},{"line":147,"address":[1923247],"length":1,"stats":{"Line":1},"fn_name":null},{"line":149,"address":[1923491,1923641,1923582],"length":1,"stats":{"Line":3},"fn_name":null},{"line":151,"address":[1923629,1927282,1927364,1927396,1926992],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":152,"address":[1927041],"length":1,"stats":{"Line":1},"fn_name":null},{"line":153,"address":[1927056],"length":1,"stats":{"Line":1},"fn_name":null},{"line":154,"address":[1927063],"length":1,"stats":{"Line":1},"fn_name":null},{"line":155,"address":[1927245,1927086,1927180,1927161],"length":1,"stats":{"Line":4},"fn_name":null},{"line":158,"address":[1927440,1927172,1927453],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":163,"address":[1923771,1922741,1923704,1922584,1924304],"length":1,"stats":{"Line":4},"fn_name":null},{"line":164,"address":[1924761,1924526,1924684,1924561,1924962,1925170,1924284],"length":1,"stats":{"Line":6},"fn_name":null},{"line":165,"address":[1924541,1922690,1924584,1924717,1924889,1922605],"length":1,"stats":{"Line":6},"fn_name":null},{"line":166,"address":[1925200,1925052],"length":1,"stats":{"Line":1},"fn_name":null},{"line":167,"address":[1925352,1925266],"length":1,"stats":{"Line":2},"fn_name":null},{"line":168,"address":[1925451,1922623,1925374],"length":1,"stats":{"Line":4},"fn_name":null},{"line":170,"address":[1926718],"length":1,"stats":{"Line":2},"fn_name":null},{"line":171,"address":[1926516],"length":1,"stats":{"Line":2},"fn_name":null},{"line":172,"address":[1926525],"length":1,"stats":{"Line":2},"fn_name":null},{"line":173,"address":[1926587],"length":1,"stats":{"Line":2},"fn_name":null},{"line":174,"address":[1926634],"length":1,"stats":{"Line":2},"fn_name":null},{"line":175,"address":[1926658],"length":1,"stats":{"Line":2},"fn_name":null},{"line":176,"address":[1926688],"length":1,"stats":{"Line":2},"fn_name":null},{"line":180,"address":[2476944],"length":1,"stats":{"Line":1},"fn_name":"tear_down2"},{"line":185,"address":[1927643,1927758,1928119,1927901,1927687],"length":1,"stats":{"Line":4},"fn_name":null},{"line":186,"address":[1928820,1929015,1928888,1927702],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":65,"coverable":69},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","min.rs"],"content":"use std::borrow::Cow;\n\nuse ql2::term::TermType;\nuse reql_macros::CommandOptions;\nuse serde::Serialize;\n\nuse crate::arguments::Args;\nuse crate::prelude::Func;\nuse crate::Command;\n\npub(crate) fn new(args: impl MinArg) -\u003e Command {\n    let (arg, opts) = args.into_min_opts();\n    let mut command = Command::new(TermType::Min);\n\n    if let Some(arg) = arg {\n        command = command.with_arg(arg)\n    }\n\n    command.with_opts(opts)\n}\n\npub trait MinArg {\n    fn into_min_opts(self) -\u003e (Option\u003cCommand\u003e, MinOption);\n}\n\nimpl MinArg for () {\n    fn into_min_opts(self) -\u003e (Option\u003cCommand\u003e, MinOption) {\n        (None, Default::default())\n    }\n}\n\nimpl\u003cT\u003e MinArg for Args\u003cT\u003e\nwhere\n    T: Into\u003cString\u003e,\n{\n    fn into_min_opts(self) -\u003e (Option\u003cCommand\u003e, MinOption) {\n        let arg = Command::from_json(self.0.into());\n\n        (Some(arg), Default::default())\n    }\n}\n\nimpl MinArg for Func {\n    fn into_min_opts(self) -\u003e (Option\u003cCommand\u003e, MinOption) {\n        (Some(self.0), Default::default())\n    }\n}\n\nimpl MinArg for MinOption {\n    fn into_min_opts(self) -\u003e (Option\u003cCommand\u003e, MinOption) {\n        (None, self)\n    }\n}\n\nimpl MinArg for Command {\n    fn into_min_opts(self) -\u003e (Option\u003cCommand\u003e, MinOption) {\n        (Some(self), Default::default())\n    }\n}\n\n#[derive(Debug, Clone, Serialize, Default, PartialEq, PartialOrd, CommandOptions)]\npub struct MinOption {\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub index: Option\u003cCow\u003c'static, str\u003e\u003e,\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::Converter;\n    use crate::spec::{set_up, tear_down, Post};\n    use crate::{args, Result};\n\n    #[tokio::test]\n    async fn test_min_data() -\u003e Result\u003c()\u003e {\n        let data = Post::get_many_data();\n        let (conn, table, table_name) = set_up(true).await?;\n        let data_obtained: Post = table\n            .min(args!(\"view\"))\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(Some(\u0026data_obtained) == data.last());\n\n        tear_down(conn, \u0026table_name).await\n    }\n}\n","traces":[{"line":11,"address":[4777222,4776624,4777243],"length":1,"stats":{"Line":1},"fn_name":"new\u003creql_rust::arguments::Args\u003c\u0026str\u003e\u003e"},{"line":12,"address":[4776657],"length":1,"stats":{"Line":1},"fn_name":null},{"line":13,"address":[4776761],"length":1,"stats":{"Line":1},"fn_name":null},{"line":15,"address":[4776835,4777133],"length":1,"stats":{"Line":2},"fn_name":null},{"line":16,"address":[4776950,4777107],"length":1,"stats":{"Line":2},"fn_name":null},{"line":19,"address":[4777040],"length":1,"stats":{"Line":1},"fn_name":null},{"line":27,"address":[5406192,5406368],"length":1,"stats":{"Line":0},"fn_name":"into_min_opts"},{"line":28,"address":[5406209],"length":1,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[1902032,1902318],"length":1,"stats":{"Line":1},"fn_name":"into_min_opts\u003c\u0026str\u003e"},{"line":37,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":44,"address":[2741568,2741795],"length":1,"stats":{"Line":0},"fn_name":"into_min_opts"},{"line":45,"address":[2741619],"length":1,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[2727728],"length":1,"stats":{"Line":0},"fn_name":"into_min_opts"},{"line":51,"address":[2727747],"length":1,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[2172832,2173059],"length":1,"stats":{"Line":0},"fn_name":"into_min_opts"},{"line":57,"address":[2172883],"length":1,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[5150425,5150997,5150272,5150651,5150249,5150240,5150341],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":75,"address":[5150403],"length":1,"stats":{"Line":1},"fn_name":null},{"line":76,"address":[5150455,5150608,5151484,5151008,5150773,5150833],"length":1,"stats":{"Line":4},"fn_name":null},{"line":77,"address":[5152377,5151906,5152724,5151393,5152101,5152421,5151450,5152320,5151829,5151712],"length":1,"stats":{"Line":7},"fn_name":null},{"line":78,"address":[5151423],"length":1,"stats":{"Line":1},"fn_name":null},{"line":79,"address":[5150476,5151735,5151692,5151862,5150559,5152034],"length":1,"stats":{"Line":6},"fn_name":null},{"line":80,"address":[5152224],"length":1,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[5152985,5153096,5152600],"length":1,"stats":{"Line":2},"fn_name":null},{"line":86,"address":[2579519,2579624,2579564,2579904],"length":1,"stats":{"Line":7},"fn_name":null}],"covered":17,"coverable":26},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","minutes.rs"],"content":"use ql2::term::TermType;\n\nuse crate::Command;\n\npub(crate) fn new() -\u003e Command {\n    Command::new(TermType::Minutes)\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::Converter;\n    use crate::{r, Result};\n\n    #[tokio::test]\n    async fn test_minutes_ops() -\u003e Result\u003c()\u003e {\n        let conn = r.connection().connect().await?;\n\n        let minutes = r.now().minutes();\n        let minutes1 = minutes.clone().value();\n        let minutes2: u8 = minutes.cmd().run(\u0026conn).await?.unwrap().parse()?;\n\n        assert!(minutes1 == minutes2);\n\n        Ok(())\n    }\n}\n","traces":[{"line":5,"address":[2702208],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":6,"address":[2702220],"length":1,"stats":{"Line":1},"fn_name":null},{"line":15,"address":[2801319,2801280,2801733,2801685],"length":1,"stats":{"Line":6},"fn_name":"test_minutes_ops"},{"line":16,"address":[4552826,4552142,4552096,4552215,4552565,4552376],"length":1,"stats":{"Line":4},"fn_name":null},{"line":18,"address":[4553072,4552816],"length":1,"stats":{"Line":2},"fn_name":null},{"line":19,"address":[4553163,4553100],"length":1,"stats":{"Line":2},"fn_name":null},{"line":20,"address":[4554007,4552157,4553207,4553294,4554102],"length":1,"stats":{"Line":4},"fn_name":null},{"line":22,"address":[4554295,4554081],"length":1,"stats":{"Line":1},"fn_name":null},{"line":24,"address":[2801416,2801356,2801696,2801311],"length":1,"stats":{"Line":5},"fn_name":null}],"covered":9,"coverable":9},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","month.rs"],"content":"use ql2::term::TermType;\n\nuse crate::Command;\n\npub(crate) fn new() -\u003e Command {\n    Command::new(TermType::Month)\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::Converter;\n    use crate::{r, Result};\n\n    #[tokio::test]\n    async fn test_month_ops() -\u003e Result\u003c()\u003e {\n        let conn = r.connection().connect().await?;\n\n        let month = r.now().month();\n        let month1 = month.clone().value();\n        let month2: u8 = month.cmd().run(\u0026conn).await?.unwrap().parse()?;\n\n        assert!(month1 == month2);\n\n        Ok(())\n    }\n}\n","traces":[{"line":5,"address":[2702256],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":6,"address":[2702268],"length":1,"stats":{"Line":1},"fn_name":null},{"line":15,"address":[1853543,1853504,1853909,1853957],"length":1,"stats":{"Line":6},"fn_name":"test_month_ops"},{"line":16,"address":[5518997,5518574,5518647,5518528,5518808,5519258],"length":1,"stats":{"Line":4},"fn_name":null},{"line":18,"address":[5519504,5519248],"length":1,"stats":{"Line":2},"fn_name":null},{"line":19,"address":[5519595,5519532],"length":1,"stats":{"Line":2},"fn_name":null},{"line":20,"address":[5520439,5518589,5519639,5520534,5519726],"length":1,"stats":{"Line":4},"fn_name":null},{"line":22,"address":[5520727,5520513],"length":1,"stats":{"Line":1},"fn_name":null},{"line":24,"address":[1853920,1853640,1853580,1853535],"length":1,"stats":{"Line":5},"fn_name":null}],"covered":9,"coverable":9},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","mul.rs"],"content":"use std::ops::Mul;\n\nuse ql2::term::TermType;\nuse serde::Serialize;\n\nuse crate::Command;\n\nimpl\u003cT: MulArg\u003e Mul\u003cT\u003e for Command {\n    type Output = Self;\n\n    fn mul(self, arg: T) -\u003e Self {\n        Command::new(TermType::Mul)\n            .with_arg(arg.into_mul_opts())\n            .with_parent(self)\n    }\n}\n\npub trait MulArg {\n    fn into_mul_opts(self) -\u003e Command;\n}\n\nimpl\u003cT: AsRef\u003c[f64]\u003e + Serialize\u003e MulArg for T {\n    fn into_mul_opts(self) -\u003e Command {\n        Command::from_json(self)\n    }\n}\n\nimpl MulArg for Command {\n    fn into_mul_opts(self) -\u003e Command {\n        self\n    }\n}\n\n// TODO write test\n","traces":[{"line":11,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":12,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":13,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":14,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[2173088],"length":1,"stats":{"Line":1},"fn_name":"into_mul_opts"},{"line":30,"address":[2173096],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":6,"coverable":8},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","ne.rs"],"content":"use ql2::term::TermType;\nuse serde::Serialize;\n\nuse crate::arguments::Args;\nuse crate::Command;\n\nuse super::CmdOpts;\n\npub(crate) fn new(args: impl NeArg) -\u003e Command {\n    args.into_ne_opts().add_to_cmd(Command::new(TermType::Ne))\n}\n\npub trait NeArg {\n    fn into_ne_opts(self) -\u003e CmdOpts;\n}\n\nimpl\u003cT\u003e NeArg for T\nwhere\n    T: Serialize,\n{\n    fn into_ne_opts(self) -\u003e CmdOpts {\n        CmdOpts::Single(Command::from_json(self))\n    }\n}\n\nimpl NeArg for Command {\n    fn into_ne_opts(self) -\u003e CmdOpts {\n        CmdOpts::Single(self)\n    }\n}\n\nimpl\u003cS, T\u003e NeArg for Args\u003cT\u003e\nwhere\n    S: Serialize,\n    T: IntoIterator\u003cItem = S\u003e,\n{\n    fn into_ne_opts(self) -\u003e CmdOpts {\n        let commands = self.0.into_iter().map(Command::from_json).collect();\n\n        CmdOpts::Many(commands)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::Converter;\n    use crate::spec::{set_up, tear_down};\n    use crate::{args, r, Result};\n\n    #[tokio::test]\n    async fn test_ne_data() -\u003e Result\u003c()\u003e {\n        let (conn, table, table_name) = set_up(true).await?;\n        let data_obtained: bool = table\n            .get(1)\n            .g(\"title\")\n            .ne(\"title\")\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(data_obtained);\n\n        tear_down(conn, \u0026table_name).await\n    }\n\n    #[tokio::test]\n    async fn test_ne_data_r() -\u003e Result\u003c()\u003e {\n        let conn = r.connection().connect().await?;\n        let data_obtained: bool = r.ne(args!([5, 6, 7])).run(\u0026conn).await?.unwrap().parse()?;\n\n        assert!(data_obtained);\n\n        Ok(())\n    }\n}\n","traces":[{"line":9,"address":[4737268,4737312,4737295,4737088,4737532,4737505],"length":1,"stats":{"Line":2},"fn_name":"new\u003c\u0026str\u003e"},{"line":10,"address":[4737525,4737288,4737329,4737121],"length":1,"stats":{"Line":2},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":27,"address":[2173120],"length":1,"stats":{"Line":0},"fn_name":"into_ne_opts"},{"line":28,"address":[2173136],"length":1,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":51,"address":[2569481,2569670,2569896,2570188,2569472,2569573,2569504],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":52,"address":[2569635,2569853,2569700,2570199,2570021,2570636],"length":1,"stats":{"Line":4},"fn_name":null},{"line":53,"address":[2570869,2571862,2571672,2571628,2571352,2571571,2570583,2571157,2571080],"length":1,"stats":{"Line":6},"fn_name":null},{"line":57,"address":[7878848],"length":1,"stats":{"Line":5},"fn_name":null},{"line":58,"address":[2571475],"length":1,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[2572065,2571751],"length":1,"stats":{"Line":1},"fn_name":null},{"line":64,"address":[2569739,2572529,2572343,2572022,2572283,2572159,2572395],"length":1,"stats":{"Line":7},"fn_name":null},{"line":68,"address":[2572800,2572809,2572957,2572832,2572889,2573092,2573391],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":69,"address":[2572947,2572981,2573052,2573402,2573734,2573213],"length":1,"stats":{"Line":4},"fn_name":null},{"line":70,"address":[2574756,2573962,2573645,2574662,2572996],"length":1,"stats":{"Line":4},"fn_name":null},{"line":72,"address":[2574741,2574964],"length":1,"stats":{"Line":1},"fn_name":null},{"line":74,"address":[2574938],"length":1,"stats":{"Line":5},"fn_name":null}],"covered":18,"coverable":21},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","not.rs"],"content":"use std::ops::Not;\n\nuse ql2::term::TermType;\n\nuse crate::Command;\n\nimpl Not for Command {\n    type Output = Self;\n\n    fn not(self) -\u003e Self::Output {\n        Command::new(TermType::Not).with_arg(self)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use std::ops::Not;\n\n    use crate::prelude::Converter;\n    use crate::{r, Result};\n\n    #[tokio::test]\n    async fn test_not_data_r() -\u003e Result\u003c()\u003e {\n        let conn = r.connection().connect().await?;\n        let data_obtained: bool = r.not(r.expr(false)).run(\u0026conn).await?.unwrap().parse()?;\n\n        assert!(data_obtained);\n\n        Ok(())\n    }\n\n    #[tokio::test]\n    async fn test_not_data() -\u003e Result\u003c()\u003e {\n        let object = vec![\"id\", \"id1\", \"title\", \"title1\"];\n        let conn = r.connection().connect().await?;\n        let data_obtained: bool = r\n            .object(object)\n            .has_fields(\"content\")\n            .not()\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(data_obtained);\n\n        Ok(())\n    }\n}\n","traces":[{"line":10,"address":[2173385,2173416,2173200],"length":1,"stats":{"Line":1},"fn_name":"not"},{"line":11,"address":[2173311,2173222],"length":1,"stats":{"Line":2},"fn_name":null},{"line":23,"address":[1951552,1951957,1951591,1952005],"length":1,"stats":{"Line":6},"fn_name":"test_not_data_r"},{"line":24,"address":[7369365,7369786,7369436,7369331,7369597,7370049],"length":1,"stats":{"Line":4},"fn_name":null},{"line":25,"address":[7369380,7370288,7371000,7370039,7371094],"length":1,"stats":{"Line":4},"fn_name":null},{"line":27,"address":[7371302,7371079],"length":1,"stats":{"Line":1},"fn_name":null},{"line":29,"address":[1951968,1951628,1951583,1951688],"length":1,"stats":{"Line":5},"fn_name":null},{"line":33,"address":[7371534,7371360,7371369,7371669,7371738,7371392,7372140,7371449],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":34,"address":[7371789,7371505],"length":1,"stats":{"Line":2},"fn_name":null},{"line":35,"address":[7371629,7372448,7371558,7371962,7371897,7372151],"length":1,"stats":{"Line":4},"fn_name":null},{"line":36,"address":[7373596,7372840,7372911,7373373,7373406,7372650,7372438,7373316,7373097],"length":1,"stats":{"Line":6},"fn_name":null},{"line":37,"address":[7372394],"length":1,"stats":{"Line":1},"fn_name":null},{"line":40,"address":[7372752,7373039,7371573,7372870],"length":1,"stats":{"Line":3},"fn_name":null},{"line":41,"address":[7373220],"length":1,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[7373770,7373485],"length":1,"stats":{"Line":1},"fn_name":null},{"line":47,"address":[1952184,1952079,1952124,1952464],"length":1,"stats":{"Line":5},"fn_name":null}],"covered":15,"coverable":16},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","now.rs"],"content":"use ql2::term::TermType;\n\nuse crate::Command;\n\npub(crate) fn new() -\u003e Command {\n    Command::new(TermType::Now)\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::Converter;\n    use crate::types::Time;\n    use crate::{r, Result};\n\n    #[tokio::test]\n    async fn test_now_time() -\u003e Result\u003c()\u003e {\n        let conn = r.connection().connect().await?;\n        let time1 = r.now().value();\n        let time2: Time = r.now().cmd().run(\u0026conn).await?.unwrap().parse()?;\n\n        assert!(time1.is_valid());\n        assert!(time2.is_valid());\n\n        Ok(())\n    }\n}\n","traces":[{"line":5,"address":[2028784],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":6,"address":[2028796],"length":1,"stats":{"Line":1},"fn_name":null},{"line":16,"address":[1729405,1729540,1729280,1729257,1729337,1729839,1729248],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":17,"address":[1729395,1729429,1729500,1729661,1729850,1730111],"length":1,"stats":{"Line":4},"fn_name":null},{"line":18,"address":[1730353,1730101],"length":1,"stats":{"Line":2},"fn_name":null},{"line":19,"address":[1731310,1731142,1729444,1730380,1730430],"length":1,"stats":{"Line":4},"fn_name":null},{"line":21,"address":[1731547,1731292,1731572],"length":1,"stats":{"Line":2},"fn_name":null},{"line":22,"address":[1731608,1731561,1731641],"length":1,"stats":{"Line":2},"fn_name":null},{"line":24,"address":[1731614],"length":1,"stats":{"Line":5},"fn_name":null}],"covered":9,"coverable":9},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","nth.rs"],"content":"use ql2::term::TermType;\n\nuse crate::Command;\n\npub(crate) fn new(index: isize) -\u003e Command {\n    let arg = Command::from_json(index);\n\n    Command::new(TermType::Nth).with_arg(arg)\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::cmd::order_by::OrderByOption;\n    use crate::prelude::Converter;\n    use crate::spec::{set_up, tear_down, Post};\n    use crate::Result;\n\n    #[tokio::test]\n    async fn test_nth_data() -\u003e Result\u003c()\u003e {\n        let data = Post::get_many_data();\n        let (conn, table, table_name) = set_up(true).await?;\n        let data_obtained: Post = table\n            .order_by(OrderByOption::default().index(\"title\"))\n            .nth(-1)\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(data.last() == Some(\u0026data_obtained));\n\n        tear_down(conn, \u0026table_name).await\n    }\n}\n","traces":[{"line":5,"address":[2444576,2444818,2444787],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":6,"address":[2444601],"length":1,"stats":{"Line":1},"fn_name":null},{"line":8,"address":[2444628,2444699],"length":1,"stats":{"Line":2},"fn_name":null},{"line":19,"address":[1962624,1962633,1962725,1962817,1963043,1963389,1962656],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":20,"address":[1962787],"length":1,"stats":{"Line":1},"fn_name":null},{"line":21,"address":[1962847,1963165,1963225,1963400,1963831,1963000],"length":1,"stats":{"Line":4},"fn_name":null},{"line":22,"address":[1964946,1964354,1964845,1964080,1964902,1965234,1964431,1963791,1964150,1964237,1964626],"length":1,"stats":{"Line":8},"fn_name":null},{"line":23,"address":[1964004,1964119,1964157,1964175,1963821],"length":1,"stats":{"Line":2},"fn_name":null},{"line":25,"address":[1962868,1964559,1964217,1962951,1964260,1964387],"length":1,"stats":{"Line":6},"fn_name":null},{"line":26,"address":[1964749],"length":1,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[1965118,1965495,1965626],"length":1,"stats":{"Line":2},"fn_name":null},{"line":32,"address":[1965959,1965699,1962886,1965823,1965879,1965585,1966089],"length":1,"stats":{"Line":7},"fn_name":null}],"covered":11,"coverable":12},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","object.rs"],"content":"use ql2::term::TermType;\nuse serde::Serialize;\n\nuse crate::Command;\n\npub(crate) fn new\u003cS, T\u003e(values: T) -\u003e Command\nwhere\n    S: Serialize,\n    T: IntoIterator\u003cItem = S\u003e,\n{\n    let mut command = Command::new(TermType::Object);\n\n    for value in values {\n        let arg = Command::from_json(value);\n\n        command = command.with_arg(arg);\n    }\n\n    command\n}\n\n#[cfg(test)]\nmod tests {\n    use serde::{Deserialize, Serialize};\n\n    use crate::prelude::Converter;\n    use crate::{r, Result};\n\n    #[derive(Debug, PartialEq, Eq, Serialize, Deserialize)]\n    struct InnerPost {\n        id: String,\n        title: String,\n    }\n\n    #[tokio::test]\n    async fn test_object_converted() -\u003e Result\u003c()\u003e {\n        let post = InnerPost {\n            id: \"id1\".to_string(),\n            title: \"title1\".to_string(),\n        };\n        let object = vec![\"id\", \"id1\", \"title\", \"title1\"];\n\n        let conn = r.connection().connect().await?;\n        let data_obtained: InnerPost = r.object(object).run(\u0026conn).await?.unwrap().parse()?;\n\n        assert!(data_obtained == post);\n\n        Ok(())\n    }\n}\n","traces":[{"line":6,"address":[2842079,2842134,2841456],"length":1,"stats":{"Line":1},"fn_name":"new\u003c\u0026str, alloc::vec::Vec\u003c\u0026str, alloc::alloc::Global\u003e\u003e"},{"line":11,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":13,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":14,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":16,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":36,"address":[4640665,4640746,4640881,4641114,4640576,4640585,4640608],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":38,"address":[4640719],"length":1,"stats":{"Line":1},"fn_name":null},{"line":39,"address":[4640987],"length":1,"stats":{"Line":1},"fn_name":null},{"line":41,"address":[4641102,4641176],"length":1,"stats":{"Line":2},"fn_name":null},{"line":43,"address":[4641349,4640770,4640841,4641284,4641825],"length":1,"stats":{"Line":4},"fn_name":null},{"line":44,"address":[4640785,4642032,4641771,4642733,4642905],"length":1,"stats":{"Line":4},"fn_name":null},{"line":46,"address":[4643234,4643201,4642891],"length":1,"stats":{"Line":2},"fn_name":null},{"line":48,"address":[4643207],"length":1,"stats":{"Line":5},"fn_name":null}],"covered":14,"coverable":14},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","offsets_of.rs"],"content":"use ql2::term::TermType;\nuse serde::Serialize;\n\nuse crate::prelude::Func;\nuse crate::Command;\n\npub(crate) fn new(args: impl OffsetsOfArg) -\u003e Command {\n    Command::new(TermType::OffsetsOf).with_arg(args.into_offsets_of_opts())\n}\n\npub trait OffsetsOfArg {\n    fn into_offsets_of_opts(self) -\u003e Command;\n}\n\nimpl\u003cT\u003e OffsetsOfArg for T\nwhere\n    T: Serialize,\n{\n    fn into_offsets_of_opts(self) -\u003e Command {\n        Command::from_json(self)\n    }\n}\n\nimpl OffsetsOfArg for Func {\n    fn into_offsets_of_opts(self) -\u003e Command {\n        self.0\n    }\n}\n\nimpl OffsetsOfArg for Command {\n    fn into_offsets_of_opts(self) -\u003e Command {\n        self\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::Converter;\n    use crate::{r, Result};\n\n    #[tokio::test]\n    async fn test_offset_of_ops() -\u003e Result\u003c()\u003e {\n        let conn = r.connection().connect().await?;\n        let response: Vec\u003cusize\u003e = r\n            .expr(['a', 'b', 'c'])\n            .offsets_of('c')\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(response.first() == Some(\u00262));\n\n        Ok(())\n    }\n}\n","traces":[{"line":7,"address":[5680869,5680608],"length":1,"stats":{"Line":1},"fn_name":"new\u003cchar\u003e"},{"line":8,"address":[5680636,5680735,5680859],"length":1,"stats":{"Line":2},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":25,"address":[2741824],"length":1,"stats":{"Line":0},"fn_name":"into_offsets_of_opts"},{"line":26,"address":[2741832],"length":1,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[2173440],"length":1,"stats":{"Line":0},"fn_name":"into_offsets_of_opts"},{"line":32,"address":[2173448],"length":1,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[1854901,1854496,1854535,1854949],"length":1,"stats":{"Line":6},"fn_name":"test_offset_of_ops"},{"line":43,"address":[5036458,5036003,5036760,5036269,5036037,5036108],"length":1,"stats":{"Line":4},"fn_name":null},{"line":44,"address":[5037218,5037147,5037716,5036750,5037622,5037004,5037036,5037679,5037403,5037957],"length":1,"stats":{"Line":7},"fn_name":null},{"line":45,"address":[5036701],"length":1,"stats":{"Line":1},"fn_name":null},{"line":47,"address":[5037177,5037016,5037059,5036052,5037346],"length":1,"stats":{"Line":5},"fn_name":null},{"line":48,"address":[5037526],"length":1,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[5037829,5038185,5038089],"length":1,"stats":{"Line":2},"fn_name":null},{"line":54,"address":[1854527,1854912,1854632,1854572],"length":1,"stats":{"Line":5},"fn_name":null}],"covered":11,"coverable":16},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","or.rs"],"content":"use ql2::term::TermType;\n\nuse crate::{arguments::Args, Command};\n\nuse super::CmdOpts;\n\npub(crate) fn new(args: impl OrArg) -\u003e Command {\n    args.into_or_opts().add_to_cmd(Command::new(TermType::Or))\n}\n\npub trait OrArg {\n    fn into_or_opts(self) -\u003e CmdOpts;\n}\n\nimpl OrArg for bool {\n    fn into_or_opts(self) -\u003e CmdOpts {\n        CmdOpts::Single(Command::from_json(self))\n    }\n}\n\nimpl OrArg for Command {\n    fn into_or_opts(self) -\u003e CmdOpts {\n        CmdOpts::Single(self)\n    }\n}\n\nimpl\u003cT\u003e OrArg for Args\u003cT\u003e\nwhere\n    T: IntoIterator\u003cItem = bool\u003e,\n{\n    fn into_or_opts(self) -\u003e CmdOpts {\n        let commands = self.0.into_iter().map(Command::from_json).collect();\n\n        CmdOpts::Many(commands)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::Converter;\n    use crate::{args, r, Result};\n\n    #[tokio::test]\n    async fn test_or_ops() -\u003e Result\u003c()\u003e {\n        let conn = r.connection().connect().await?;\n        let data_obtained: bool = r\n            .or(args!([true, false]))\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(data_obtained);\n\n        Ok(())\n    }\n}\n","traces":[{"line":7,"address":[5157462,5157232,5157435],"length":1,"stats":{"Line":1},"fn_name":"new\u003creql_rust::arguments::Args\u003c[bool; 2]\u003e\u003e"},{"line":8,"address":[5157455,5157267],"length":1,"stats":{"Line":1},"fn_name":null},{"line":16,"address":[2155104],"length":1,"stats":{"Line":0},"fn_name":"into_or_opts"},{"line":17,"address":[2155136],"length":1,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[2173472],"length":1,"stats":{"Line":0},"fn_name":"into_or_opts"},{"line":23,"address":[2173488],"length":1,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":44,"address":[4769383,4769749,4769344,4769797],"length":1,"stats":{"Line":6},"fn_name":"test_or_ops"},{"line":45,"address":[5211891,5212157,5212346,5212647,5211925,5211996],"length":1,"stats":{"Line":4},"fn_name":null},{"line":46,"address":[5212621,5213262,5213538,5213077,5213575,5213765,5212895,5213481,5213006],"length":1,"stats":{"Line":6},"fn_name":null},{"line":47,"address":[5212589],"length":1,"stats":{"Line":1},"fn_name":null},{"line":48,"address":[5212918,5211940,5213036,5213205,5212875],"length":1,"stats":{"Line":5},"fn_name":null},{"line":49,"address":[5213385],"length":1,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[5213654,5213877],"length":1,"stats":{"Line":1},"fn_name":null},{"line":55,"address":[4769420,4769480,4769760,4769375],"length":1,"stats":{"Line":5},"fn_name":null}],"covered":12,"coverable":17},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","order_by.rs"],"content":"use std::borrow::Cow;\n\nuse ql2::term::TermType;\nuse reql_macros::CommandOptions;\nuse serde::Serialize;\n\nuse crate::arguments::Args;\nuse crate::prelude::Func;\nuse crate::Command;\n\nuse super::CmdOpts;\n\npub(crate) fn new(args: impl OrderByArg) -\u003e Command {\n    let (args, opts) = args.into_order_by_opts();\n    let mut command = Command::new(TermType::OrderBy);\n\n    if let Some(args) = args {\n        command = args.add_to_cmd(command)\n    }\n\n    command.with_opts(opts)\n}\n\npub trait OrderByArg {\n    fn into_order_by_opts(self) -\u003e (Option\u003cCmdOpts\u003e, OrderByOption);\n}\n\nimpl OrderByArg for OrderByOption {\n    fn into_order_by_opts(self) -\u003e (Option\u003cCmdOpts\u003e, OrderByOption) {\n        (Default::default(), self)\n    }\n}\n\nimpl OrderByArg for Func {\n    fn into_order_by_opts(self) -\u003e (Option\u003cCmdOpts\u003e, OrderByOption) {\n        (Some(CmdOpts::Single(self.0)), Default::default())\n    }\n}\n\nimpl OrderByArg for Command {\n    fn into_order_by_opts(self) -\u003e (Option\u003cCmdOpts\u003e, OrderByOption) {\n        (Some(CmdOpts::Single(self)), Default::default())\n    }\n}\n\nimpl OrderByArg for Args\u003c(Func, OrderByOption)\u003e {\n    fn into_order_by_opts(self) -\u003e (Option\u003cCmdOpts\u003e, OrderByOption) {\n        let Func(func) = self.0 .0;\n\n        (Some(CmdOpts::Single(func)), self.0 .1)\n    }\n}\n\nimpl OrderByArg for Args\u003c(Command, OrderByOption)\u003e {\n    fn into_order_by_opts(self) -\u003e (Option\u003cCmdOpts\u003e, OrderByOption) {\n        (Some(CmdOpts::Single(self.0 .0)), self.0 .1)\n    }\n}\n\nimpl OrderByArg for Args\u003c(Command, Command)\u003e {\n    fn into_order_by_opts(self) -\u003e (Option\u003cCmdOpts\u003e, OrderByOption) {\n        (\n            Some(CmdOpts::Many(vec![self.0 .0, self.0 .1])),\n            Default::default(),\n        )\n    }\n}\n\nimpl OrderByArg for Args\u003c(Func, Command)\u003e {\n    fn into_order_by_opts(self) -\u003e (Option\u003cCmdOpts\u003e, OrderByOption) {\n        let Func(func) = self.0 .0;\n        (\n            Some(CmdOpts::Many(vec![func, self.0 .1])),\n            Default::default(),\n        )\n    }\n}\n\n#[derive(Debug, Clone, Serialize, Default, PartialEq, PartialOrd, CommandOptions)]\n#[non_exhaustive]\npub struct OrderByOption {\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub index: Option\u003cCow\u003c'static, str\u003e\u003e,\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::Converter;\n    use crate::spec::{set_up, tear_down, Post};\n    use crate::{args, r, Result};\n\n    use super::OrderByOption;\n\n    #[tokio::test]\n    async fn test_order_by_with_opts() -\u003e Result\u003c()\u003e {\n        let data = Post::get_many_data();\n        let (conn, table, table_name) = set_up(true).await?;\n        let data_obtained: Vec\u003cPost\u003e = table\n            .order_by(OrderByOption::default().index(\"id\"))\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(data_obtained == data);\n\n        tear_down(conn, \u0026table_name).await\n    }\n\n    #[tokio::test]\n    async fn test_order_by_title_with_opts() -\u003e Result\u003c()\u003e {\n        let data = Post::get_many_data();\n        let (conn, table, table_name) = set_up(true).await?;\n        let order_by_option = OrderByOption::default().index(\"title\");\n        let data_obtained: Vec\u003cPost\u003e = table\n            .order_by(args!(r.expr(\"id\"), order_by_option))\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(data_obtained == data);\n\n        tear_down(conn, \u0026table_name).await\n    }\n}\n","traces":[{"line":13,"address":[4651998,4654160,4653427,4652096,4652019,4653406,4652702,4651392,4652800,4652723,4653504,4654139],"length":1,"stats":{"Line":4},"fn_name":"new\u003creql_rust::proto::Command\u003e"},{"line":14,"address":[4651409,4652817,4653521,4652113],"length":1,"stats":{"Line":4},"fn_name":null},{"line":15,"address":[4652243,4653680,4651539,4652947],"length":1,"stats":{"Line":4},"fn_name":null},{"line":17,"address":[4652317,4653754,4653317,4651909,4651613,4653021,4652613,4654050],"length":1,"stats":{"Line":7},"fn_name":null},{"line":18,"address":[4653133,4654024,4653866,4651725,4652587,4651883,4653291,4652429],"length":1,"stats":{"Line":6},"fn_name":null},{"line":21,"address":[4653225,4652521,4651817,4653958],"length":1,"stats":{"Line":4},"fn_name":null},{"line":29,"address":[2827682,2827456],"length":1,"stats":{"Line":1},"fn_name":"into_order_by_opts"},{"line":30,"address":[2745829,2745894],"length":1,"stats":{"Line":2},"fn_name":null},{"line":35,"address":[4546160,4546426],"length":1,"stats":{"Line":0},"fn_name":"into_order_by_opts"},{"line":36,"address":[2823556],"length":1,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[4588496,4588762],"length":1,"stats":{"Line":1},"fn_name":"into_order_by_opts"},{"line":42,"address":[2255252],"length":1,"stats":{"Line":1},"fn_name":null},{"line":47,"address":[2656928],"length":1,"stats":{"Line":0},"fn_name":"into_order_by_opts"},{"line":48,"address":[2738597],"length":1,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[2656964],"length":1,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[2657232],"length":1,"stats":{"Line":1},"fn_name":"into_order_by_opts"},{"line":56,"address":[2657254],"length":1,"stats":{"Line":1},"fn_name":null},{"line":61,"address":[2657504,2658021,2658060],"length":1,"stats":{"Line":1},"fn_name":"into_order_by_opts"},{"line":63,"address":[2739274,2739174],"length":1,"stats":{"Line":2},"fn_name":null},{"line":64,"address":[2657875],"length":1,"stats":{"Line":1},"fn_name":null},{"line":70,"address":[2658663,2658702,2658112],"length":1,"stats":{"Line":0},"fn_name":"into_order_by_opts"},{"line":71,"address":[2658134],"length":1,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[2658195,2658248],"length":1,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[2658503],"length":1,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[2945013,2944608,2945061,2944647],"length":1,"stats":{"Line":6},"fn_name":"test_order_by_with_opts"},{"line":96,"address":[2469363],"length":1,"stats":{"Line":1},"fn_name":null},{"line":97,"address":[7787960],"length":1,"stats":{"Line":4},"fn_name":null},{"line":98,"address":[2470974,2471169,2471489,2470731,2470367,2470656,2470897,2471445,2471719,2471388],"length":1,"stats":{"Line":7},"fn_name":null},{"line":99,"address":[2470580,2470397,2470703,2470738,2470756],"length":1,"stats":{"Line":2},"fn_name":null},{"line":100,"address":[2470930,2469527,2469444,2471102,2470711,2470806],"length":1,"stats":{"Line":6},"fn_name":null},{"line":101,"address":[2471292],"length":1,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[2471609,2472029,2471974],"length":1,"stats":{"Line":2},"fn_name":null},{"line":107,"address":[2472226,2472362,2469462,2471988,2472282,2472102,2472492],"length":1,"stats":{"Line":7},"fn_name":null},{"line":111,"address":[2473601,2472933,2472832,2472864,2473255,2472841,2473029],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":112,"address":[2472995],"length":1,"stats":{"Line":1},"fn_name":null},{"line":113,"address":[2473059,2473377,2473212,2473612,2473437,2473993],"length":1,"stats":{"Line":4},"fn_name":null},{"line":114,"address":[2473983,2474218],"length":1,"stats":{"Line":2},"fn_name":null},{"line":115,"address":[2474759,2475307,2474265,2474526,2475031,2475585,2475355,2474836,2475250,2474593],"length":1,"stats":{"Line":7},"fn_name":null},{"line":116,"address":[2474600,2474618,2474565,2474307],"length":1,"stats":{"Line":2},"fn_name":null},{"line":117,"address":[2473163,2474573,2474668,2473080,2474792,2474964],"length":1,"stats":{"Line":6},"fn_name":null},{"line":118,"address":[2475154],"length":1,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[2475895,2475475,2475840],"length":1,"stats":{"Line":2},"fn_name":null},{"line":124,"address":[2475854,2473098,2475986,2476166,2476380,2476110,2476250],"length":1,"stats":{"Line":7},"fn_name":null}],"covered":32,"coverable":43},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","outer_join.rs"],"content":"use ql2::term::TermType;\n\nuse crate::prelude::Func;\nuse crate::Command;\n\npub(crate) fn new(other_table: Command, func: Func) -\u003e Command {\n    let Func(func) = func;\n\n    Command::new(TermType::OuterJoin)\n        .with_arg(other_table)\n        .with_arg(func)\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::*;\n    use crate::spec::{Comment, Post};\n    use crate::types::JoinResponse;\n    use crate::Result;\n\n    #[tokio::test]\n    pub async fn test_outer_join_ops() -\u003e Result\u003c()\u003e {\n        let data = JoinResponse {\n            left: Some(Comment {\n                id: 4,\n                text: \"comment4\".to_string(),\n                post_id: 2,\n            }),\n            right: Some(Post {\n                id: 2,\n                title: \"title2\".to_string(),\n                content: Some(\"content2\".to_string()),\n                view: 2,\n            }),\n        };\n        let (conn, comment_table, post_table, comment_tablename, post_tablename) =\n            Comment::own_set_up().await?;\n\n        let response: Vec\u003cJoinResponse\u003cComment, Post\u003e\u003e = comment_table\n            .outer_join(\n                post_table,\n                func!(|comment, post| comment.g(\"post_id\").eq(post.g(\"id\"))),\n            )\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(response.len() \u003e 0);\n        assert_eq!(response.first(), Some(\u0026data));\n\n        Comment::own_tear_down(conn, comment_tablename, post_tablename).await\n    }\n}\n","traces":[{"line":6,"address":[2376288,2376640],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":7,"address":[2376323],"length":1,"stats":{"Line":1},"fn_name":null},{"line":9,"address":[2376374,2376572,2376497],"length":1,"stats":{"Line":3},"fn_name":null},{"line":10,"address":[2376457],"length":1,"stats":{"Line":1},"fn_name":null},{"line":11,"address":[2376524],"length":1,"stats":{"Line":1},"fn_name":null},{"line":22,"address":[2551253,2551385,2551615,2551898,2551152,2551184,2551161],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":24,"address":[2551724],"length":1,"stats":{"Line":1},"fn_name":null},{"line":29,"address":[2551993],"length":1,"stats":{"Line":1},"fn_name":null},{"line":36,"address":[7780401],"length":1,"stats":{"Line":4},"fn_name":null},{"line":39,"address":[2554643,2552960,2554353,2555398,2554560,2554841,2555060,2554198,2555117,2555164],"length":1,"stats":{"Line":7},"fn_name":null},{"line":41,"address":[2553014],"length":1,"stats":{"Line":1},"fn_name":null},{"line":42,"address":[2553049,2554183,2553635,2553232,2554253,2556827,2556784,2553267],"length":1,"stats":{"Line":5},"fn_name":"{closure#0}"},{"line":44,"address":[2554333,2554771,2551436,2554463,2554599,2551521],"length":1,"stats":{"Line":6},"fn_name":null},{"line":45,"address":[2554964],"length":1,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[2555780,2555284,2555732],"length":1,"stats":{"Line":2},"fn_name":null},{"line":50,"address":[2555828,2555753,2556104],"length":1,"stats":{"Line":2},"fn_name":null},{"line":52,"address":[2551454,2555990,2556499,2556369,2556290],"length":1,"stats":{"Line":7},"fn_name":null}],"covered":16,"coverable":17},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","pluck.rs"],"content":"use ql2::term::TermType;\nuse serde::Serialize;\n\nuse crate::arguments::Args;\nuse crate::Command;\n\nuse super::CmdOpts;\n\npub(crate) fn new(args: impl PluckArg) -\u003e Command {\n    args.into_pluck_opts()\n        .add_to_cmd(Command::new(TermType::Pluck))\n}\n\npub trait PluckArg {\n    fn into_pluck_opts(self) -\u003e CmdOpts;\n}\n\nimpl\u003cT\u003e PluckArg for T\nwhere\n    T: Serialize,\n{\n    fn into_pluck_opts(self) -\u003e CmdOpts {\n        CmdOpts::Single(Command::from_json(self))\n    }\n}\n\nimpl PluckArg for Command {\n    fn into_pluck_opts(self) -\u003e CmdOpts {\n        CmdOpts::Single(self)\n    }\n}\n\nimpl\u003cT\u003e PluckArg for Args\u003cT\u003e\nwhere\n    T: IntoIterator\u003cItem = Command\u003e,\n{\n    fn into_pluck_opts(self) -\u003e CmdOpts {\n        CmdOpts::Many(self.0.into_iter().collect())\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use serde::{Deserialize, Serialize};\n\n    use crate::prelude::Converter;\n    use crate::spec::{set_up, tear_down, Post};\n    use crate::Result;\n\n    #[derive(Debug, Serialize, Deserialize, PartialEq, Eq)]\n    struct InnerPost {\n        id: u8,\n        title: String,\n    }\n\n    #[tokio::test]\n    async fn test_pluck_data() -\u003e Result\u003c()\u003e {\n        let data = Post::get_one_data();\n        let data = InnerPost {\n            id: data.id,\n            title: data.title,\n        };\n        let (conn, table, table_name) = set_up(true).await?;\n        let data_obtained: InnerPost = table\n            .get(1)\n            .pluck([\"id\", \"title\"])\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(data_obtained == data);\n\n        tear_down(conn, \u0026table_name).await\n    }\n}\n","traces":[{"line":9,"address":[5012016,5012235,5012262],"length":1,"stats":{"Line":1},"fn_name":"new\u003c[\u0026str; 2]\u003e"},{"line":10,"address":[5012186,5012033],"length":1,"stats":{"Line":2},"fn_name":null},{"line":11,"address":[5012255,5012114,5012219],"length":1,"stats":{"Line":2},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":28,"address":[2173856],"length":1,"stats":{"Line":0},"fn_name":"into_pluck_opts"},{"line":29,"address":[2173872],"length":1,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[4947344,4947312,4947497,4947727,4948141,4947413,4947321],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":58,"address":[4947475],"length":1,"stats":{"Line":1},"fn_name":null},{"line":60,"address":[4947844],"length":1,"stats":{"Line":1},"fn_name":null},{"line":61,"address":[4947847],"length":1,"stats":{"Line":1},"fn_name":null},{"line":63,"address":[7909001],"length":1,"stats":{"Line":4},"fn_name":null},{"line":64,"address":[4949488,4948997,4949074,4948513,4949545,4948842,4949589,4948877,4949269,4949829],"length":1,"stats":{"Line":7},"fn_name":null},{"line":66,"address":[4948764],"length":1,"stats":{"Line":1},"fn_name":null},{"line":67,"address":[4947633,4948900,4949030,4949202,4947548,4948857],"length":1,"stats":{"Line":6},"fn_name":null},{"line":68,"address":[4949392],"length":1,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[4950155,4950210,4949715],"length":1,"stats":{"Line":2},"fn_name":null},{"line":74,"address":[4950463,4950407,4950573,4950706,4950169,4950283,4947566],"length":1,"stats":{"Line":7},"fn_name":null}],"covered":15,"coverable":20},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","point.rs"],"content":"use ql2::term::TermType;\nuse serde::{Deserialize, Serialize};\n\nuse crate::constants::{MAX_LATITUDE_VALUE, MAX_LONGITUDE_VALUE};\nuse crate::prelude::Geometry;\nuse crate::types::{GeoType, ReqlType};\nuse crate::Command;\n\n#[derive(Debug, Serialize, Deserialize, Clone, PartialEq, PartialOrd, Geometry)]\npub struct Point {\n    #[serde(rename = \"$reql_type$\")]\n    pub reql_type: ReqlType,\n    pub coordinates: [f64; 2],\n    #[serde(rename = \"type\")]\n    pub typ: GeoType,\n}\n\nimpl Point {\n    pub fn new(longitude: f64, latitude: f64) -\u003e Self {\n        assert!((-MAX_LONGITUDE_VALUE..=MAX_LONGITUDE_VALUE).contains(\u0026longitude));\n        assert!((-MAX_LATITUDE_VALUE..=MAX_LATITUDE_VALUE).contains(\u0026latitude));\n\n        Self {\n            reql_type: ReqlType::Geometry,\n            coordinates: [longitude, latitude],\n            typ: GeoType::Point,\n        }\n    }\n}\n\nimpl From\u003cPoint\u003e for Command {\n    fn from(point: Point) -\u003e Self {\n        point\n            .coordinates\n            .iter()\n            .fold(Command::new(TermType::Point), |command, coord| {\n                command.with_arg(Command::from_json(coord))\n            })\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use serde::{Deserialize, Serialize};\n\n    use crate::prelude::Converter;\n    use crate::spec::{set_up, tear_down};\n    use crate::types::Point;\n    use crate::{r, Result};\n\n    #[derive(Debug, Serialize, Deserialize, PartialEq)]\n    struct User {\n        id: u8,\n        name: String,\n        location: Point,\n    }\n\n    #[tokio::test]\n    async fn test_point_data() -\u003e Result\u003c()\u003e {\n        let user = User {\n            id: 1,\n            name: \"Yaoundé\".to_string(),\n            location: r.point(-122.423246, 37.779388),\n        };\n        let (conn, table, table_name) = set_up(false).await?;\n        table.clone().insert(\u0026user).run(\u0026conn).await?;\n        let response: User = table.get(1).run(\u0026conn).await?.unwrap().parse()?;\n\n        assert!(response == user);\n\n        tear_down(conn, \u0026table_name).await\n    }\n}\n","traces":[{"line":19,"address":[2688976],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":20,"address":[2607354,2607410],"length":1,"stats":{"Line":1},"fn_name":null},{"line":21,"address":[4658856,4658786,4658729],"length":1,"stats":{"Line":2},"fn_name":null},{"line":25,"address":[2607460],"length":1,"stats":{"Line":1},"fn_name":null},{"line":32,"address":[2173936],"length":1,"stats":{"Line":1},"fn_name":"from"},{"line":33,"address":[2173964,2174029],"length":1,"stats":{"Line":2},"fn_name":null},{"line":36,"address":[2173985],"length":1,"stats":{"Line":2},"fn_name":null},{"line":37,"address":[2699249,2699415],"length":1,"stats":{"Line":1},"fn_name":null},{"line":59,"address":[1686453,1686352,1686563,1686865,1686361,1686384,1687125],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":62,"address":[1686533],"length":1,"stats":{"Line":1},"fn_name":null},{"line":63,"address":[1687001],"length":1,"stats":{"Line":1},"fn_name":null},{"line":65,"address":[1686593,1686822,1687740,1687118,1687192],"length":1,"stats":{"Line":4},"fn_name":null},{"line":66,"address":[1687730,1686614,1686771,1687964],"length":1,"stats":{"Line":4},"fn_name":null},{"line":67,"address":[1689548,1689756,1686635,1688704,1688828,1686720],"length":1,"stats":{"Line":5},"fn_name":null},{"line":69,"address":[1689742,1690180,1690238],"length":1,"stats":{"Line":2},"fn_name":null},{"line":71,"address":[1690564,1686653,1690475,1690416,1690292,1690194,1690700],"length":1,"stats":{"Line":7},"fn_name":null}],"covered":16,"coverable":16},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","polygon.rs"],"content":"use ql2::term::TermType;\nuse serde::{Deserialize, Serialize};\n\nuse crate::prelude::Geometry;\nuse crate::types::{GeoType, ReqlType};\nuse crate::Command;\n\nuse super::point::Point;\nuse super::polygon_sub;\n\n#[derive(Debug, Serialize, Deserialize, Clone, PartialEq, PartialOrd, Geometry)]\npub struct Polygon {\n    #[serde(rename = \"$reql_type$\")]\n    pub reql_type: ReqlType,\n    pub coordinates: Vec\u003cVec\u003c[f64; 2]\u003e\u003e,\n    #[serde(rename = \"type\")]\n    pub typ: GeoType,\n}\n\nimpl Polygon {\n    pub fn new(points: \u0026[Point]) -\u003e Self {\n        assert!(points.len() \u003e= 3);\n\n        Self {\n            reql_type: ReqlType::Geometry,\n            typ: GeoType::Polygon,\n            coordinates: vec![points.iter().map(|point| point.coordinates).collect()],\n        }\n    }\n\n    pub fn new_from_vec(coordinates: Vec\u003cVec\u003c[f64; 2]\u003e\u003e) -\u003e Self {\n        Self {\n            reql_type: ReqlType::Geometry,\n            typ: GeoType::Polygon,\n            coordinates,\n        }\n    }\n\n    /// Use `polygon2` to “punch out” a hole in `polygon1`.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// polygon1.polygon_sub(polygon2) → polygon\n    /// ```\n    ///\n    /// Where:\n    /// - polygon1, polygon1, polygon: [Polygon](crate::cmd::polygon::Polygon)\n    ///\n    /// # Description\n    ///\n    /// `polygon2` must be completely contained within `polygon1` and must\n    /// have no holes itself (it must not be the output of `polygon_sub` itself).\n    ///\n    /// ## Examples\n    ///\n    /// Define a polygon with a hole punched in it.\n    ///\n    /// ```\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::types::Polygon;\n    /// use reql_rust::{args, r, Result};\n    /// use serde_json::json;\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let expected_data = Polygon::new_from_vec(vec![\n    ///         vec![\n    ///             [-122.4, 37.7],\n    ///             [-122.4, 37.3],\n    ///             [-121.8, 37.3],\n    ///             [-121.8, 37.7],\n    ///             [-122.4, 37.7],\n    ///         ],\n    ///         vec![\n    ///             [-122.3, 37.4],\n    ///             [-122.3, 37.6],\n    ///             [-122.0, 37.6],\n    ///             [-122.0, 37.4],\n    ///             [-122.3, 37.4],\n    ///         ],\n    ///     ]);\n    ///     let outer_polygon = r.polygon(\u0026[\n    ///         r.point(-122.4, 37.7),\n    ///         r.point(-122.4, 37.3),\n    ///         r.point(-121.8, 37.3),\n    ///         r.point(-121.8, 37.7),\n    ///     ]);\n    ///     let inner_polygon = r.polygon(\u0026[\n    ///         r.point(-122.3, 37.4),\n    ///         r.point(-122.3, 37.6),\n    ///         r.point(-122.0, 37.6),\n    ///         r.point(-122.0, 37.4),\n    ///     ]);\n    ///\n    ///     let response: Polygon = outer_polygon\n    ///         .polygon_sub(inner_polygon)\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == expected_data);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [polygon](crate::r::polygon)\n    pub fn polygon_sub(self, polygon: Polygon) -\u003e Command {\n        polygon_sub::new(polygon).with_parent(self.into())\n    }\n}\n\nimpl From\u003cPolygon\u003e for Command {\n    fn from(polygon: Polygon) -\u003e Self {\n        polygon.coordinates.iter().flatten().fold(\n            Command::new(TermType::Polygon),\n            |command, coord| {\n                let point: Command = Point::new(coord[0], coord[1]).into();\n\n                command.with_arg(point)\n            },\n        )\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use serde::{Deserialize, Serialize};\n\n    use crate::prelude::Converter;\n    use crate::spec::{set_up, tear_down};\n    use crate::types::{Point, Polygon};\n    use crate::{r, Result};\n\n    #[derive(Debug, Serialize, Deserialize, PartialEq)]\n    struct Rectangle {\n        id: u8,\n        rectangle: Polygon,\n    }\n\n    #[tokio::test]\n    async fn test_polygon_data() -\u003e Result\u003c()\u003e {\n        let rectangle = Rectangle {\n            id: 1,\n            rectangle: r.polygon(\u0026[\n                Point::new(-122.423246, 37.779388),\n                Point::new(-122.423246, 37.329898),\n                Point::new(-121.886420, 37.329898),\n                Point::new(-121.886420, 37.779388),\n            ]),\n        };\n        let (conn, table, table_name) = set_up(false).await?;\n        table.clone().insert(\u0026rectangle).run(\u0026conn).await?;\n        let response: Rectangle = table.get(1).run(\u0026conn).await?.unwrap().parse()?;\n\n        assert!(response == rectangle);\n\n        tear_down(conn, \u0026table_name).await\n    }\n}\n","traces":[{"line":21,"address":[2161011,2160704],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":22,"address":[2160747,2160792],"length":1,"stats":{"Line":1},"fn_name":null},{"line":27,"address":[2236944,2236960],"length":1,"stats":{"Line":4},"fn_name":"{closure#0}"},{"line":31,"address":[5043088],"length":1,"stats":{"Line":1},"fn_name":"new_from_vec"},{"line":111,"address":[2242832,2243142],"length":1,"stats":{"Line":1},"fn_name":"polygon_sub"},{"line":112,"address":[2242853,2243123,2242965],"length":1,"stats":{"Line":2},"fn_name":null},{"line":117,"address":[2174064,2174284],"length":1,"stats":{"Line":1},"fn_name":"from"},{"line":118,"address":[2174250,2174094,2174166],"length":1,"stats":{"Line":3},"fn_name":null},{"line":119,"address":[2174211],"length":1,"stats":{"Line":1},"fn_name":null},{"line":120,"address":[2684688,2684985,2684954],"length":1,"stats":{"Line":1},"fn_name":"{closure#0}"},{"line":121,"address":[2684726,2684811],"length":1,"stats":{"Line":2},"fn_name":null},{"line":123,"address":[2684840],"length":1,"stats":{"Line":1},"fn_name":null},{"line":145,"address":[1337381,1336873,1336896,1336864,1336965,1338017,1337079],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":148,"address":[1337586],"length":1,"stats":{"Line":1},"fn_name":null},{"line":155,"address":[1337850,1338028,1338442,1337338,1337787,1337109],"length":1,"stats":{"Line":4},"fn_name":null},{"line":156,"address":[1338432,1338666,1337287,1337130],"length":1,"stats":{"Line":4},"fn_name":null},{"line":157,"address":[1337151,1339542,1340448,1337236,1339412,1340268],"length":1,"stats":{"Line":5},"fn_name":null},{"line":159,"address":[1340933,1340875,1340431],"length":1,"stats":{"Line":2},"fn_name":null},{"line":161,"address":[1341395,1341111,1341170,1340987,1337169,1340889,1341259],"length":1,"stats":{"Line":7},"fn_name":null}],"covered":19,"coverable":19},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","polygon_sub.rs"],"content":"use ql2::term::TermType;\n\nuse crate::types::Polygon;\nuse crate::Command;\n\npub(crate) fn new(polygon: Polygon) -\u003e Command {\n    let arg: Command = polygon.into();\n\n    Command::new(TermType::PolygonSub).with_arg(arg)\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::cmd::polygon::Polygon;\n    use crate::prelude::Converter;\n    use crate::types::Point;\n    use crate::{r, Result};\n\n    #[tokio::test]\n    async fn test_polygon_sub_ops() -\u003e Result\u003c()\u003e {\n        let conn = r.connection().connect().await?;\n        let expected_data = Polygon::new_from_vec(vec![\n            vec![\n                [-122.4, 37.7],\n                [-122.4, 37.3],\n                [-121.8, 37.3],\n                [-121.8, 37.7],\n                [-122.4, 37.7],\n            ],\n            vec![\n                [-122.3, 37.4],\n                [-122.3, 37.6],\n                [-122.0, 37.6],\n                [-122.0, 37.4],\n                [-122.3, 37.4],\n            ],\n        ]);\n        let outer_polygon = r.polygon(\u0026[\n            Point::new(-122.4, 37.7),\n            Point::new(-122.4, 37.3),\n            Point::new(-121.8, 37.3),\n            Point::new(-121.8, 37.7),\n        ]);\n        let inner_polygon = r.polygon(\u0026[\n            Point::new(-122.3, 37.4),\n            Point::new(-122.3, 37.6),\n            Point::new(-122.0, 37.6),\n            Point::new(-122.0, 37.4),\n        ]);\n        let response: Polygon = outer_polygon\n            .polygon_sub(inner_polygon)\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(response == expected_data);\n\n        Ok(())\n    }\n}\n","traces":[{"line":6,"address":[2444832,2445096,2445127],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":7,"address":[2444849],"length":1,"stats":{"Line":1},"fn_name":null},{"line":9,"address":[2444931,2445006],"length":1,"stats":{"Line":2},"fn_name":null},{"line":20,"address":[4770336,4770375,4770789,4770741],"length":1,"stats":{"Line":6},"fn_name":"test_polygon_sub_ops"},{"line":21,"address":[2588686,2588757,2588640,2589107,2588918,2589375],"length":1,"stats":{"Line":4},"fn_name":null},{"line":22,"address":[2589649,2589912,2590153,2589360],"length":1,"stats":{"Line":2},"fn_name":null},{"line":23,"address":[2589803,2589632],"length":1,"stats":{"Line":2},"fn_name":null},{"line":24,"address":[2589693],"length":1,"stats":{"Line":1},"fn_name":null},{"line":25,"address":[2589719],"length":1,"stats":{"Line":1},"fn_name":null},{"line":26,"address":[2589755],"length":1,"stats":{"Line":1},"fn_name":null},{"line":27,"address":[2589771],"length":1,"stats":{"Line":1},"fn_name":null},{"line":28,"address":[2589787],"length":1,"stats":{"Line":1},"fn_name":null},{"line":30,"address":[2589892,2590069],"length":1,"stats":{"Line":2},"fn_name":null},{"line":31,"address":[2589959],"length":1,"stats":{"Line":1},"fn_name":null},{"line":32,"address":[2589985],"length":1,"stats":{"Line":1},"fn_name":null},{"line":33,"address":[2590021],"length":1,"stats":{"Line":1},"fn_name":null},{"line":34,"address":[2590037],"length":1,"stats":{"Line":1},"fn_name":null},{"line":35,"address":[2590053],"length":1,"stats":{"Line":1},"fn_name":null},{"line":38,"address":[2590413],"length":1,"stats":{"Line":1},"fn_name":null},{"line":39,"address":[2590268],"length":1,"stats":{"Line":1},"fn_name":null},{"line":40,"address":[2590344],"length":1,"stats":{"Line":1},"fn_name":null},{"line":41,"address":[2590375],"length":1,"stats":{"Line":1},"fn_name":null},{"line":42,"address":[2590406],"length":1,"stats":{"Line":1},"fn_name":null},{"line":44,"address":[2590744],"length":1,"stats":{"Line":1},"fn_name":null},{"line":45,"address":[2590602],"length":1,"stats":{"Line":1},"fn_name":null},{"line":46,"address":[2590675],"length":1,"stats":{"Line":1},"fn_name":null},{"line":47,"address":[2590706],"length":1,"stats":{"Line":1},"fn_name":null},{"line":48,"address":[2590737],"length":1,"stats":{"Line":1},"fn_name":null},{"line":50,"address":[2591423,2590905,2591056,2591699,2591238,2591980,2590997,2591740,2591642,2591167],"length":1,"stats":{"Line":7},"fn_name":null},{"line":51,"address":[2590941],"length":1,"stats":{"Line":1},"fn_name":null},{"line":52,"address":[2588701,2591036,2591079,2591197,2591366],"length":1,"stats":{"Line":5},"fn_name":null},{"line":53,"address":[2591546],"length":1,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[2592138,2592105,2591858],"length":1,"stats":{"Line":2},"fn_name":null},{"line":59,"address":[2592111],"length":1,"stats":{"Line":5},"fn_name":null}],"covered":33,"coverable":34},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","prepend.rs"],"content":"use ql2::term::TermType;\nuse serde::Serialize;\n\nuse crate::Command;\n\npub(crate) fn new(args: impl PrependArg) -\u003e Command {\n    Command::new(TermType::Prepend).with_arg(args.into_prepend_opts())\n}\n\npub trait PrependArg {\n    fn into_prepend_opts(self) -\u003e Command;\n}\n\nimpl\u003cT\u003e PrependArg for T\nwhere\n    T: Serialize,\n{\n    fn into_prepend_opts(self) -\u003e Command {\n        Command::from_json(self)\n    }\n}\n\nimpl PrependArg for Command {\n    fn into_prepend_opts(self) -\u003e Command {\n        self\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::Converter;\n    use crate::{r, Result};\n\n    #[tokio::test]\n    async fn test_prepend_ops() -\u003e Result\u003c()\u003e {\n        let conn = r.connection().connect().await?;\n        let response: [u8; 6] = r\n            .expr([10, 20, 30, 40, 50])\n            .prepend(0)\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(response == [0, 10, 20, 30, 40, 50]);\n\n        Ok(())\n    }\n}\n","traces":[{"line":6,"address":[5681205,5680944],"length":1,"stats":{"Line":1},"fn_name":"new\u003ci32\u003e"},{"line":7,"address":[5681195,5680972,5681071],"length":1,"stats":{"Line":2},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":24,"address":[2174336],"length":1,"stats":{"Line":0},"fn_name":"into_prepend_opts"},{"line":25,"address":[2174344],"length":1,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[2505941,2505989,2505575,2505536],"length":1,"stats":{"Line":6},"fn_name":"test_prepend_ops"},{"line":36,"address":[2795130,2794780,2795454,2794675,2794941,2794709],"length":1,"stats":{"Line":4},"fn_name":null},{"line":37,"address":[2795444,2795838,2795909,2796094,2796407,2796640,2795695,2795727,2796370,2796313],"length":1,"stats":{"Line":7},"fn_name":null},{"line":38,"address":[2795373],"length":1,"stats":{"Line":1},"fn_name":null},{"line":40,"address":[2794724,2795707,2795868,2796037,2795750],"length":1,"stats":{"Line":5},"fn_name":null},{"line":41,"address":[2796217],"length":1,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[2796515,2796747,2796784],"length":1,"stats":{"Line":2},"fn_name":null},{"line":47,"address":[2505567,2505952,2505672,2505612],"length":1,"stats":{"Line":5},"fn_name":null}],"covered":11,"coverable":14},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","random.rs"],"content":"use ql2::term::TermType;\nuse reql_macros::CommandOptions;\nuse serde::Serialize;\n\nuse crate::arguments::Args;\nuse crate::Command;\n\npub(crate) fn new(args: impl RandomArg) -\u003e Command {\n    let (arg1, arg2, opts) = args.into_random_opts();\n    let mut command = Command::new(TermType::Random);\n\n    if let Some(arg) = arg1 {\n        command = command.with_arg(arg)\n    }\n\n    if let Some(arg) = arg2 {\n        command = command.with_arg(arg)\n    }\n\n    command.with_opts(opts)\n}\n\npub trait RandomArg {\n    fn into_random_opts(self) -\u003e (Option\u003cCommand\u003e, Option\u003cCommand\u003e, RandomOption);\n}\n\nimpl RandomArg for () {\n    fn into_random_opts(self) -\u003e (Option\u003cCommand\u003e, Option\u003cCommand\u003e, RandomOption) {\n        (None, None, Default::default())\n    }\n}\n\nimpl RandomArg for f64 {\n    fn into_random_opts(self) -\u003e (Option\u003cCommand\u003e, Option\u003cCommand\u003e, RandomOption) {\n        (Some(Command::from_json(self)), None, Default::default())\n    }\n}\n\nimpl RandomArg for Command {\n    fn into_random_opts(self) -\u003e (Option\u003cCommand\u003e, Option\u003cCommand\u003e, RandomOption) {\n        (Some(self), None, Default::default())\n    }\n}\n\nimpl RandomArg for Args\u003c(f64, f64)\u003e {\n    fn into_random_opts(self) -\u003e (Option\u003cCommand\u003e, Option\u003cCommand\u003e, RandomOption) {\n        (\n            Some(Command::from_json(self.0 .0)),\n            Some(Command::from_json(self.0 .1)),\n            Default::default(),\n        )\n    }\n}\n\nimpl RandomArg for Args\u003c(Command, Command)\u003e {\n    fn into_random_opts(self) -\u003e (Option\u003cCommand\u003e, Option\u003cCommand\u003e, RandomOption) {\n        (Some(self.0 .0), Some(self.0 .1), Default::default())\n    }\n}\n\nimpl RandomArg for Args\u003c(f64, f64, RandomOption)\u003e {\n    fn into_random_opts(self) -\u003e (Option\u003cCommand\u003e, Option\u003cCommand\u003e, RandomOption) {\n        (\n            Some(Command::from_json(self.0 .0)),\n            Some(Command::from_json(self.0 .1)),\n            self.0 .2,\n        )\n    }\n}\n\nimpl RandomArg for Args\u003c(Command, Command, RandomOption)\u003e {\n    fn into_random_opts(self) -\u003e (Option\u003cCommand\u003e, Option\u003cCommand\u003e, RandomOption) {\n        (Some(self.0 .0), Some(self.0 .1), self.0 .2)\n    }\n}\n\n#[derive(\n    Debug, Default, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Serialize, CommandOptions,\n)]\npub struct RandomOption {\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub float: Option\u003cbool\u003e,\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::Converter;\n    use crate::{args, r, Result};\n\n    use super::RandomOption;\n\n    #[tokio::test]\n    async fn test_random_data() -\u003e Result\u003c()\u003e {\n        let conn = r.connection().connect().await?;\n        let data_obtained1: f64 = r.random(()).run(\u0026conn).await?.unwrap().parse()?;\n        let data_obtained2: isize = r.random(100.).run(\u0026conn).await?.unwrap().parse()?;\n        let data_obtained3: f64 = r\n            .random(args!(-100.52, -10.71, RandomOption::default().float(true)))\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(data_obtained1.is_normal());\n        assert!(data_obtained2 \u003e= 0);\n        assert!(data_obtained3.is_normal());\n\n        Ok(())\n    }\n}\n","traces":[{"line":8,"address":[2603864,2604976,2605951,2602928,2603952,2604884,2604770,2605837,2603750],"length":1,"stats":{"Line":3},"fn_name":"new\u003cf64\u003e"},{"line":9,"address":[2604996,2602954,2603972],"length":1,"stats":{"Line":3},"fn_name":null},{"line":10,"address":[2603085,2605170,2604103],"length":1,"stats":{"Line":3},"fn_name":null},{"line":12,"address":[2603182,2604442,2605509,2605267,2603424,2604200],"length":1,"stats":{"Line":5},"fn_name":null},{"line":13,"address":[2604416,2603398,2603303,2605388,2605483,2604321],"length":1,"stats":{"Line":4},"fn_name":null},{"line":16,"address":[2605445,2604670,2605737,2603426,2603360,2604378,2604444,2603650,2605511],"length":1,"stats":{"Line":5},"fn_name":null},{"line":17,"address":[2604528,2603624,2604644,2605595,2605711,2603510],"length":1,"stats":{"Line":2},"fn_name":null},{"line":20,"address":[2605685,2603599,2604618],"length":1,"stats":{"Line":3},"fn_name":null},{"line":28,"address":[2598992,2599160,2599187],"length":1,"stats":{"Line":1},"fn_name":"into_random_opts"},{"line":29,"address":[2599171,2599009],"length":1,"stats":{"Line":1},"fn_name":null},{"line":34,"address":[1593187,1592960,1593164],"length":1,"stats":{"Line":1},"fn_name":"into_random_opts"},{"line":35,"address":[2599436,2599242],"length":1,"stats":{"Line":1},"fn_name":null},{"line":40,"address":[4589513,4589490,4589280],"length":1,"stats":{"Line":0},"fn_name":"into_random_opts"},{"line":41,"address":[2256067,2256241],"length":1,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[2659060,2658752],"length":1,"stats":{"Line":0},"fn_name":"into_random_opts"},{"line":48,"address":[2658793],"length":1,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[2658928,2658840],"length":1,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[2658930],"length":1,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[2659388,2659361,2659088],"length":1,"stats":{"Line":0},"fn_name":"into_random_opts"},{"line":57,"address":[2659372,2659145],"length":1,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[2659408,2659661],"length":1,"stats":{"Line":1},"fn_name":"into_random_opts"},{"line":64,"address":[2659430],"length":1,"stats":{"Line":1},"fn_name":null},{"line":65,"address":[2659545,2659480],"length":1,"stats":{"Line":2},"fn_name":null},{"line":66,"address":[2659581],"length":1,"stats":{"Line":1},"fn_name":null},{"line":72,"address":[2659696],"length":1,"stats":{"Line":0},"fn_name":"into_random_opts"},{"line":73,"address":[2659718],"length":1,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[1855397,1855445,1855031,1854992],"length":1,"stats":{"Line":6},"fn_name":"test_random_data"},{"line":94,"address":[2513220,2513257,2513609,2513798,2513447,2514059],"length":1,"stats":{"Line":4},"fn_name":null},{"line":95,"address":[2514304,2514049,2513275,2515071,2514968,2513404],"length":1,"stats":{"Line":5},"fn_name":null},{"line":96,"address":[2513290,2515968,2516056,2515304,2515061,2513361],"length":1,"stats":{"Line":5},"fn_name":null},{"line":97,"address":[2517054,2516755,2516498,2516974,2517031,2517256,2516569,2516359],"length":1,"stats":{"Line":5},"fn_name":null},{"line":98,"address":[2516245,2516042],"length":1,"stats":{"Line":2},"fn_name":null},{"line":99,"address":[2516528,2516410,2513305,2516697],"length":1,"stats":{"Line":4},"fn_name":null},{"line":100,"address":[2516878],"length":1,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[2517141,2517374,2517347],"length":1,"stats":{"Line":2},"fn_name":null},{"line":105,"address":[2517423,2517358],"length":1,"stats":{"Line":1},"fn_name":null},{"line":106,"address":[2517412,2517457,2517490],"length":1,"stats":{"Line":2},"fn_name":null},{"line":108,"address":[1855128,1855023,1855408,1855068],"length":1,"stats":{"Line":5},"fn_name":null}],"covered":27,"coverable":38},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","range.rs"],"content":"use ql2::term::TermType;\n\nuse crate::{arguments::Args, Command};\n\npub(crate) fn new(args: impl RangeArg) -\u003e Command {\n    let (arg1, arg2) = args.into_range_opts();\n    let mut command = Command::new(TermType::Range);\n\n    if let Some(arg) = arg1 {\n        command = command.with_arg(arg)\n    }\n\n    if let Some(arg) = arg2 {\n        command = command.with_arg(arg)\n    }\n\n    command\n}\n\npub trait RangeArg {\n    fn into_range_opts(self) -\u003e (Option\u003cCommand\u003e, Option\u003cCommand\u003e);\n}\n\nimpl RangeArg for () {\n    fn into_range_opts(self) -\u003e (Option\u003cCommand\u003e, Option\u003cCommand\u003e) {\n        (None, None)\n    }\n}\n\nimpl RangeArg for isize {\n    fn into_range_opts(self) -\u003e (Option\u003cCommand\u003e, Option\u003cCommand\u003e) {\n        (None, Some(Command::from_json(self)))\n    }\n}\n\nimpl RangeArg for Args\u003c(isize, isize)\u003e {\n    fn into_range_opts(self) -\u003e (Option\u003cCommand\u003e, Option\u003cCommand\u003e) {\n        (\n            Some(Command::from_json(self.0 .0)),\n            Some(Command::from_json(self.0 .1)),\n        )\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::Converter;\n    use crate::{args, r, Result};\n\n    #[tokio::test]\n    async fn test_range_data() -\u003e Result\u003c()\u003e {\n        let data = [0, 1, 2, 3];\n        let data2 = [-5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5];\n        let conn = r.connection().connect().await?;\n        let response: [isize; 4] = r.range(4).run(\u0026conn).await?.unwrap().parse()?;\n        let response2: [isize; 4] = r.range(()).limit(4).run(\u0026conn).await?.unwrap().parse()?;\n        let response3: [isize; 11] = r.range(args!(-5, 6)).run(\u0026conn).await?.unwrap().parse()?;\n\n        assert!(response == data);\n        assert!(response2 == data);\n        assert!(response3 == data2);\n\n        Ok(())\n    }\n}\n","traces":[{"line":5,"address":[7974977,7974866,7975056,7976857,7975927,7976746,7976000,7974112,7975816],"length":1,"stats":{"Line":3},"fn_name":"new\u003cisize\u003e"},{"line":6,"address":[7975089,7976017,7974137],"length":1,"stats":{"Line":3},"fn_name":null},{"line":7,"address":[7976127,7975199,7974247],"length":1,"stats":{"Line":3},"fn_name":null},{"line":9,"address":[7974344,7975532,7975296,7976224,7976460,7974580],"length":1,"stats":{"Line":4},"fn_name":null},{"line":10,"address":[7976434,7975506,7974459,7975411,7974554,7976339],"length":1,"stats":{"Line":2},"fn_name":null},{"line":13,"address":[7975757,7975468,7976462,7975534,7976396,7974807,7976687,7974516,7974582],"length":1,"stats":{"Line":7},"fn_name":null},{"line":14,"address":[7976661,7975731,7974781,7974666,7975617,7976546],"length":1,"stats":{"Line":4},"fn_name":null},{"line":17,"address":[7976608,7974728,7975678],"length":1,"stats":{"Line":3},"fn_name":null},{"line":25,"address":[5224640],"length":1,"stats":{"Line":1},"fn_name":"into_range_opts"},{"line":26,"address":[2832387],"length":1,"stats":{"Line":1},"fn_name":null},{"line":31,"address":[2751012,2750832],"length":1,"stats":{"Line":1},"fn_name":"into_range_opts"},{"line":32,"address":[2750857],"length":1,"stats":{"Line":1},"fn_name":null},{"line":37,"address":[2660148,2659920],"length":1,"stats":{"Line":1},"fn_name":"into_range_opts"},{"line":39,"address":[2659957],"length":1,"stats":{"Line":1},"fn_name":null},{"line":40,"address":[2660059,2660002],"length":1,"stats":{"Line":2},"fn_name":null},{"line":51,"address":[4891661,4891924,4891376,4892230,4891385,4891465,4891408],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":52,"address":[4891524],"length":1,"stats":{"Line":1},"fn_name":null},{"line":53,"address":[4891555],"length":1,"stats":{"Line":1},"fn_name":null},{"line":54,"address":[4891688,4891884,4891651,4892049,4892241,4892514],"length":1,"stats":{"Line":4},"fn_name":null},{"line":55,"address":[4893579,4892504,4891706,4891839,4892746,4893445],"length":1,"stats":{"Line":5},"fn_name":null},{"line":56,"address":[4894740,4891721,4893820,4894531,4891794,4893569],"length":1,"stats":{"Line":5},"fn_name":null},{"line":57,"address":[4891736,4894650,4894930,4895629,4895899],"length":1,"stats":{"Line":4},"fn_name":null},{"line":59,"address":[4896086,4895878,4896118],"length":1,"stats":{"Line":2},"fn_name":null},{"line":60,"address":[4896188,4896154,4896097],"length":1,"stats":{"Line":2},"fn_name":null},{"line":61,"address":[4896222,4896259,4896165],"length":1,"stats":{"Line":2},"fn_name":null},{"line":63,"address":[2802192,2801852,2801912,2801807],"length":1,"stats":{"Line":5},"fn_name":null}],"covered":26,"coverable":26},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","rebalance.rs"],"content":"use ql2::term::TermType;\n\nuse crate::Command;\n\npub(crate) fn new() -\u003e Command {\n    Command::new(TermType::Rebalance)\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::Converter;\n    use crate::spec::{set_up, tear_down};\n    use crate::types::RebalanceResponse;\n    use crate::Result;\n\n    #[tokio::test]\n    async fn test_rebalance_table() -\u003e Result\u003c()\u003e {\n        let (conn, table, table_name) = set_up(true).await?;\n        let response: RebalanceResponse = table.rebalance().run(\u0026conn).await?.unwrap().parse()?;\n\n        assert!(response.rebalanced == 1);\n\n        tear_down(conn, \u0026table_name).await\n    }\n}\n","traces":[{"line":5,"address":[2028832],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":6,"address":[2028844],"length":1,"stats":{"Line":1},"fn_name":null},{"line":17,"address":[1793832,1794124,1793509,1793408,1793417,1793606,1793440],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":18,"address":[1794567,1793636,1793571,1793957,1794135,1793789],"length":1,"stats":{"Line":4},"fn_name":null},{"line":19,"address":[1793740,1793657,1794519,1794824,1795727,1795533],"length":1,"stats":{"Line":5},"fn_name":null},{"line":21,"address":[1795705,1796026],"length":1,"stats":{"Line":1},"fn_name":null},{"line":23,"address":[1796263,1796394,1793675,1795983,1796524,1796319,1796139],"length":1,"stats":{"Line":7},"fn_name":null}],"covered":7,"coverable":7},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","reconfigure.rs"],"content":"use std::borrow::Cow;\nuse std::collections::HashMap;\n\nuse ql2::term::TermType;\nuse reql_macros::CommandOptions;\nuse serde::{Serialize, Serializer};\n\nuse crate::arguments::{EmergencyRepair, Replicas};\nuse crate::Command;\n\npub(crate) fn new(opts: ReconfigureOption) -\u003e Command {\n    Command::new(TermType::Reconfigure).with_opts(opts)\n}\n\n#[derive(Debug, Clone, Default, PartialEq, CommandOptions)]\n#[non_exhaustive]\npub struct ReconfigureOption {\n    /// the number of shards, an integer from 1-64. Required.\n    pub shards: Option\u003cu8\u003e,\n    /// either an usize or a mapping struct. Required.\n    /// - If `replicas` is an usize, it specifies the number of replicas per shard.\n    /// Specifying more replicas than there are servers will return an error.\n    /// - If `replicas` is an struct, it specifies key-value pairs of server tags\n    /// and the number of replicas to assign to those servers:\n    /// `{\"tag1\": 2, \"tag2\": 4, \"tag3\": 2, ...}`.\n    /// For more information about server tags, read\n    /// [Administration tools](https://rethinkdb.com/docs/administration-tools/).\n    pub replicas: Option\u003cReplicas\u003e,\n    /// the generated configuration will not be applied to the table, only returned.\n    pub dry_run: Option\u003cbool\u003e,\n    /// Used for the Emergency Repair mode.\n    /// See \u003chttps://rethinkdb.com/api/python/reconfigure#emergency-repair-mode\u003e\n    /// for more information.\n    pub emergency_repair: Option\u003cEmergencyRepair\u003e,\n}\n\nimpl Serialize for ReconfigureOption {\n    fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    where\n        S: Serializer,\n    {\n        #[derive(Serialize)]\n        struct InnerOptions\u003c'a\u003e {\n            #[serde(skip_serializing_if = \"Option::is_none\")]\n            dry_run: Option\u003cbool\u003e,\n            #[serde(skip_serializing_if = \"Option::is_none\")]\n            emergency_repair: Option\u003cEmergencyRepair\u003e,\n            #[serde(skip_serializing_if = \"Option::is_none\")]\n            shards: Option\u003cu8\u003e,\n            #[serde(skip_serializing_if = \"Option::is_none\")]\n            replicas: Option\u003cInnerReplicas\u003c'a\u003e\u003e,\n            /// the primary server specified by its server tag.\n            /// Required if `replicas` is an object; the tag must be in the object.\n            /// This must not be specified if `replicas` is an usize.\n            #[serde(skip_serializing_if = \"Option::is_none\")]\n            primary_replica_tag: Option\u003c\u0026'a Cow\u003c'static, str\u003e\u003e,\n        }\n\n        #[derive(Serialize)]\n        #[serde(untagged)]\n        enum InnerReplicas\u003c'a\u003e {\n            Int(usize),\n            Map(\u0026'a HashMap\u003cCow\u003c'static, str\u003e, usize\u003e),\n        }\n\n        let (replicas, primary_replica_tag) = match \u0026self.replicas {\n            Some(Replicas::Int(i)) =\u003e (Some(InnerReplicas::Int(*i)), None),\n            Some(Replicas::Map {\n                replicas,\n                primary_replica_tag,\n            }) =\u003e (\n                Some(InnerReplicas::Map(replicas)),\n                Some(primary_replica_tag),\n            ),\n            None =\u003e (None, None),\n        };\n\n        let opts = InnerOptions {\n            dry_run: self.dry_run,\n            emergency_repair: self.emergency_repair,\n            replicas,\n            primary_replica_tag,\n            shards: self.shards,\n        };\n\n        opts.serialize(serializer)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::arguments::Replicas;\n    use crate::prelude::Converter;\n    use crate::spec::{set_up, tear_down};\n    use crate::types::ReconfigureResponse;\n    use crate::Result;\n\n    use super::ReconfigureOption;\n\n    #[tokio::test]\n    async fn test_reconfigure_table() -\u003e Result\u003c()\u003e {\n        let (conn, table, table_name) = set_up(true).await?;\n        let reconfigure_option = ReconfigureOption::default()\n            .shards(2)\n            .replicas(Replicas::Int(1));\n        let response: ReconfigureResponse = table\n            .reconfigure(reconfigure_option)\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(response.reconfigured == 1);\n\n        tear_down(conn, \u0026table_name).await\n    }\n}\n","traces":[{"line":11,"address":[2512799,2512560,2512830],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":12,"address":[4568231,4568134],"length":1,"stats":{"Line":2},"fn_name":null},{"line":38,"address":[2220512],"length":1,"stats":{"Line":1},"fn_name":"serialize\u003cserde_json::value::ser::Serializer\u003e"},{"line":66,"address":[2220858,2220542,2220628],"length":1,"stats":{"Line":3},"fn_name":null},{"line":67,"address":[2220645],"length":1,"stats":{"Line":1},"fn_name":null},{"line":68,"address":[2385566],"length":1,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[2303945],"length":1,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[2303991],"length":1,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[2303755],"length":1,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[2304075],"length":1,"stats":{"Line":1},"fn_name":null},{"line":80,"address":[2304079],"length":1,"stats":{"Line":1},"fn_name":null},{"line":83,"address":[2304109],"length":1,"stats":{"Line":1},"fn_name":null},{"line":86,"address":[2304188],"length":1,"stats":{"Line":1},"fn_name":null},{"line":101,"address":[1855488,1855941,1855527,1855893],"length":1,"stats":{"Line":6},"fn_name":"test_reconfigure_table"},{"line":102,"address":[5048117,5048295,5048675,5047949,5047731,5047796],"length":1,"stats":{"Line":4},"fn_name":null},{"line":103,"address":[5048665,5048950,5049005],"length":1,"stats":{"Line":3},"fn_name":null},{"line":105,"address":[5048957],"length":1,"stats":{"Line":1},"fn_name":null},{"line":106,"address":[5050178,5049623,5049899,5049020,5049176,5049428,5049842,5049943,5049351,5049234],"length":1,"stats":{"Line":7},"fn_name":null},{"line":107,"address":[5049064],"length":1,"stats":{"Line":1},"fn_name":null},{"line":108,"address":[5047900,5049384,5049556,5047817,5049257],"length":1,"stats":{"Line":5},"fn_name":null},{"line":109,"address":[5049746],"length":1,"stats":{"Line":0},"fn_name":null},{"line":113,"address":[5050358,5050060],"length":1,"stats":{"Line":1},"fn_name":null},{"line":115,"address":[1855904,1855564,1855519,1855624],"length":1,"stats":{"Line":7},"fn_name":null}],"covered":18,"coverable":26},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","reduce.rs"],"content":"use ql2::term::TermType;\n\nuse crate::prelude::Func;\nuse crate::Command;\n\npub(crate) fn new(func: Func) -\u003e Command {\n    Command::new(TermType::Reduce).with_arg(func.0)\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::*;\n    use crate::spec::{set_up, tear_down, Post};\n    use crate::{r, Result};\n\n    #[tokio::test]\n    async fn test_reduce_ops() -\u003e Result\u003c()\u003e {\n        let post_number = Post::get_many_data().len();\n        let (conn, table, table_name) = set_up(true).await?;\n        let response: usize = table\n            .map(func!(|| r.expr(1)))\n            .reduce(func!(|left, right| left + right))\n            .default(0)\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(response == post_number);\n\n        tear_down(conn, \u0026table_name).await\n    }\n}\n","traces":[{"line":6,"address":[2155432,2155401,2155216],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":7,"address":[2155327,2155238],"length":1,"stats":{"Line":2},"fn_name":null},{"line":17,"address":[2480395,2479936,2480037,2479968,2479945,2480169,2480614],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":18,"address":[2480099,2480528],"length":1,"stats":{"Line":2},"fn_name":null},{"line":19,"address":[2480352,2480199,2481281,2480638],"length":1,"stats":{"Line":3},"fn_name":null},{"line":20,"address":[2483891,2484190,2481237,2483948,2483079,2483992,2483477,2483672,2481944,2483400,2483203,2483283],"length":1,"stats":{"Line":9},"fn_name":null},{"line":21,"address":[2481522,2482093,2485136,2485153,2481487,2481983,2481271,2482075],"length":1,"stats":{"Line":4},"fn_name":"{closure#0}"},{"line":22,"address":[2482068,2483064,2485225,2482516,2485184,2482113,2482148,2482100,2483118,2483218],"length":1,"stats":{"Line":5},"fn_name":"{closure#1}"},{"line":24,"address":[2480220,2480303,2483306,2483433,2483263,2483605],"length":1,"stats":{"Line":6},"fn_name":null},{"line":25,"address":[2483795],"length":1,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[2484073,2484398],"length":1,"stats":{"Line":1},"fn_name":null},{"line":31,"address":[2484732,2480238,2484496,2484354,2484620,2484680,2484866],"length":1,"stats":{"Line":7},"fn_name":null}],"covered":11,"coverable":12},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","rem.rs"],"content":"use std::ops::Rem;\n\nuse ql2::term::TermType;\n\nuse crate::Command;\n\nimpl\u003cT: RemArg\u003e Rem\u003cT\u003e for Command {\n    type Output = Self;\n\n    fn rem(self, arg: T) -\u003e Self {\n        Command::new(TermType::Mod)\n            .with_arg(arg.into_rem_opts())\n            .with_parent(self)\n    }\n}\n\npub trait RemArg {\n    fn into_rem_opts(self) -\u003e Command;\n}\n\nimpl RemArg for f64 {\n    fn into_rem_opts(self) -\u003e Command {\n        Command::from_json(self)\n    }\n}\n\nimpl RemArg for Command {\n    fn into_rem_opts(self) -\u003e Command {\n        self\n    }\n}\n\n// TODO write test\n","traces":[{"line":10,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":11,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":12,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":13,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[2155456],"length":1,"stats":{"Line":0},"fn_name":"into_rem_opts"},{"line":23,"address":[2155474],"length":1,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[2174624],"length":1,"stats":{"Line":0},"fn_name":"into_rem_opts"},{"line":29,"address":[2174632],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":8},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","replace.rs"],"content":"use ql2::term::TermType;\nuse reql_macros::CommandOptions;\nuse serde::Serialize;\n\nuse crate::arguments::{Args, Durability, ReturnChanges};\nuse crate::Command;\n\nuse super::func::Func;\n\npub(crate) fn new(args: impl ReplaceArg) -\u003e Command {\n    let (arg, opts) = args.into_replace_opts();\n\n    Command::new(TermType::Replace)\n        .with_arg(arg)\n        .with_opts(opts)\n}\n\npub trait ReplaceArg {\n    fn into_replace_opts(self) -\u003e (Command, ReplaceOption);\n}\n\nimpl\u003cT\u003e ReplaceArg for T\nwhere\n    T: Serialize,\n{\n    fn into_replace_opts(self) -\u003e (Command, ReplaceOption) {\n        (Command::from_json(self), Default::default())\n    }\n}\n\nimpl ReplaceArg for Command {\n    fn into_replace_opts(self) -\u003e (Command, ReplaceOption) {\n        (self, Default::default())\n    }\n}\n\nimpl ReplaceArg for Func {\n    fn into_replace_opts(self) -\u003e (Command, ReplaceOption) {\n        (self.0, Default::default())\n    }\n}\n\nimpl\u003cT\u003e ReplaceArg for Args\u003c(T, ReplaceOption)\u003e\nwhere\n    T: Serialize,\n{\n    fn into_replace_opts(self) -\u003e (Command, ReplaceOption) {\n        (Command::from_json(self.0 .0), self.0 .1)\n    }\n}\n\nimpl ReplaceArg for Args\u003c(Command, ReplaceOption)\u003e {\n    fn into_replace_opts(self) -\u003e (Command, ReplaceOption) {\n        (self.0 .0, self.0 .1)\n    }\n}\n\nimpl ReplaceArg for Args\u003c(Func, ReplaceOption)\u003e {\n    fn into_replace_opts(self) -\u003e (Command, ReplaceOption) {\n        (self.0 .0 .0, self.0 .1)\n    }\n}\n\n#[derive(Debug, Clone, Copy, Serialize, Default, PartialEq, PartialOrd, CommandOptions)]\npub struct ReplaceOption {\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub durability: Option\u003cDurability\u003e,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub return_changes: Option\u003cReturnChanges\u003e,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub non_atomic: Option\u003cbool\u003e,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub ignore_write_hook: Option\u003cbool\u003e,\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::*;\n    use crate::spec::*;\n    use crate::types::MutationResponse;\n    use crate::Result;\n\n    #[tokio::test]\n    async fn test_replace_docs() -\u003e Result\u003c()\u003e {\n        let data = Post::get_one_data();\n        let (conn, table, table_name) = set_up(true).await?;\n        let response: MutationResponse = table\n            .get(1)\n            .replace(data)\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(response.replaced == 1);\n\n        tear_down(conn, \u0026table_name).await\n    }\n\n    #[tokio::test]\n    async fn test_replace_docs_with_func() -\u003e Result\u003c()\u003e {\n        let lenght = Post::get_many_data().len();\n        let (conn, table, table_name) = set_up(true).await?;\n        let response: MutationResponse = table\n            .replace(func!(|post| post.without(\"view\")))\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(response.replaced == lenght);\n\n        tear_down(conn, \u0026table_name).await\n    }\n}\n","traces":[{"line":10,"address":[2221355,2221040,2221750,2221382,2221408,2221723],"length":1,"stats":{"Line":2},"fn_name":"new\u003creql_rust::spec::Post\u003e"},{"line":11,"address":[2221425,2221057],"length":1,"stats":{"Line":2},"fn_name":null},{"line":13,"address":[2221680,2221312,2221286,2221153,2221521,2221654],"length":1,"stats":{"Line":6},"fn_name":null},{"line":14,"address":[2221227,2221595],"length":1,"stats":{"Line":2},"fn_name":null},{"line":15,"address":[2221666,2221298],"length":1,"stats":{"Line":2},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":27,"address":[5078913],"length":1,"stats":{"Line":1},"fn_name":null},{"line":32,"address":[2174656,2174817],"length":1,"stats":{"Line":0},"fn_name":"into_replace_opts"},{"line":33,"address":[4589602],"length":1,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[2823808,2823969],"length":1,"stats":{"Line":1},"fn_name":"into_replace_opts"},{"line":39,"address":[2742194],"length":1,"stats":{"Line":1},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[2660176],"length":1,"stats":{"Line":0},"fn_name":"into_replace_opts"},{"line":54,"address":[2660197],"length":1,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[2660288],"length":1,"stats":{"Line":0},"fn_name":"into_replace_opts"},{"line":60,"address":[2660309],"length":1,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[5051285,5051193,5051605,5051184,5051377,5054101,5051216,5051958],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":85,"address":[5051347],"length":1,"stats":{"Line":1},"fn_name":null},{"line":86,"address":[5051407,5051969,5052406,5051712,5051794,5051562],"length":1,"stats":{"Line":4},"fn_name":null},{"line":87,"address":[5052843,5052920,5053115,5053334,5052695,5052353,5053391,5053435,5053671],"length":1,"stats":{"Line":6},"fn_name":null},{"line":89,"address":[5052619],"length":1,"stats":{"Line":1},"fn_name":null},{"line":90,"address":[7931601],"length":1,"stats":{"Line":5},"fn_name":null},{"line":91,"address":[5053238],"length":1,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[5053958,5053552],"length":1,"stats":{"Line":1},"fn_name":null},{"line":97,"address":[2945631,2945676,2945736,2946016],"length":1,"stats":{"Line":7},"fn_name":null},{"line":101,"address":[2946096,2946549,2946501,2946135],"length":1,"stats":{"Line":6},"fn_name":"test_replace_docs_with_func"},{"line":102,"address":[5055434,5055027],"length":1,"stats":{"Line":2},"fn_name":null},{"line":103,"address":[7796073],"length":1,"stats":{"Line":3},"fn_name":null},{"line":104,"address":[5057387,5057144,5057801,5057013,5056143,5057582,5057310,5057902,5058140,5057858],"length":1,"stats":{"Line":7},"fn_name":null},{"line":105,"address":[5056394,5057151,5057169,5056178,5059220,5059184,5056429,5057052],"length":1,"stats":{"Line":4},"fn_name":"{closure#0}"},{"line":106,"address":[5057515,5057124,5055209,5057219,5057343,5055124],"length":1,"stats":{"Line":6},"fn_name":null},{"line":107,"address":[5057705],"length":1,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[5058019,5058348],"length":1,"stats":{"Line":1},"fn_name":null},{"line":113,"address":[2946127,2946172,2946512,2946232],"length":1,"stats":{"Line":7},"fn_name":null}],"covered":25,"coverable":35},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","round.rs"],"content":"use ql2::term::TermType;\n\nuse crate::Command;\n\npub(crate) fn new(args: impl RoundArg) -\u003e Command {\n    let mut command = Command::new(TermType::Round);\n\n    if let Some(arg) = args.into_round_opts() {\n        command = command.with_arg(arg)\n    }\n\n    command\n}\n\npub trait RoundArg {\n    fn into_round_opts(self) -\u003e Option\u003cCommand\u003e;\n}\n\nimpl RoundArg for () {\n    fn into_round_opts(self) -\u003e Option\u003cCommand\u003e {\n        None\n    }\n}\n\nimpl RoundArg for Command {\n    fn into_round_opts(self) -\u003e Option\u003cCommand\u003e {\n        Some(self)\n    }\n}\n\nimpl RoundArg for f64 {\n    fn into_round_opts(self) -\u003e Option\u003cCommand\u003e {\n        Some(Command::from_json(self))\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::Converter;\n    use crate::{r, Result};\n\n    #[tokio::test]\n    async fn test_round_data() -\u003e Result\u003c()\u003e {\n        let conn = r.connection().connect().await?;\n        let data_obtained: u8 = r.round(12.345).run(\u0026conn).await?.unwrap().parse()?;\n        let data_obtained2: u8 = r.expr(12.345).round().run(\u0026conn).await?.unwrap().parse()?;\n        let data_obtained3: u8 = r.round(r.expr(12.345)).run(\u0026conn).await?.unwrap().parse()?;\n\n        assert!(\n            data_obtained == 12\n                \u0026\u0026 data_obtained == data_obtained2\n                \u0026\u0026 data_obtained == data_obtained3\n        );\n\n        Ok(())\n    }\n}\n","traces":[{"line":5,"address":[2691539,2690992],"length":1,"stats":{"Line":3},"fn_name":"new\u003c()\u003e"},{"line":6,"address":[2609364,2609460],"length":1,"stats":{"Line":6},"fn_name":null},{"line":8,"address":[1874855,1875378,1875741,1874797,1876307,1875130,1875468,1875976,1876034],"length":1,"stats":{"Line":8},"fn_name":null},{"line":9,"address":[2609781,2609636],"length":1,"stats":{"Line":4},"fn_name":null},{"line":12,"address":[2691480],"length":1,"stats":{"Line":3},"fn_name":null},{"line":20,"address":[2748528],"length":1,"stats":{"Line":1},"fn_name":"into_round_opts"},{"line":21,"address":[2748532],"length":1,"stats":{"Line":1},"fn_name":null},{"line":26,"address":[2174848],"length":1,"stats":{"Line":1},"fn_name":"into_round_opts"},{"line":27,"address":[2174864],"length":1,"stats":{"Line":1},"fn_name":null},{"line":32,"address":[2748544],"length":1,"stats":{"Line":1},"fn_name":"into_round_opts"},{"line":33,"address":[2748570],"length":1,"stats":{"Line":1},"fn_name":null},{"line":43,"address":[2506071,2506032,2506485,2506437],"length":1,"stats":{"Line":6},"fn_name":"test_round_data"},{"line":44,"address":[2832180,2832407,2832758,2832217,2833027,2832569],"length":1,"stats":{"Line":4},"fn_name":null},{"line":45,"address":[2833017,2833272,2833936,2832235,2832364,2834032],"length":1,"stats":{"Line":5},"fn_name":null},{"line":46,"address":[2835051,2832321,2834022,2832250,2834260,2834955],"length":1,"stats":{"Line":5},"fn_name":null},{"line":47,"address":[2835252,2835947,2835041,2836040,2832265],"length":1,"stats":{"Line":4},"fn_name":null},{"line":49,"address":[2836315,2836275],"length":1,"stats":{"Line":1},"fn_name":null},{"line":50,"address":[2836025,2836212,2836266],"length":1,"stats":{"Line":3},"fn_name":null},{"line":51,"address":[2836203],"length":1,"stats":{"Line":1},"fn_name":null},{"line":52,"address":[2836260],"length":1,"stats":{"Line":1},"fn_name":null},{"line":55,"address":[2506168,2506448,2506063,2506108],"length":1,"stats":{"Line":5},"fn_name":null}],"covered":21,"coverable":21},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","run.rs"],"content":"use std::borrow::Cow;\nuse std::sync::atomic::Ordering;\nuse std::{mem, str};\n\nuse async_stream::try_stream;\nuse futures::io::{AsyncReadExt, AsyncWriteExt};\nuse futures::stream::{Stream, StreamExt};\nuse futures::{AsyncRead, AsyncWrite};\nuse ql2::query::QueryType;\nuse ql2::response::{ErrorType, ResponseType};\nuse reql_macros::CommandOptions;\nuse serde::de::DeserializeOwned;\nuse serde::{Deserialize, Serialize};\nuse serde_json::Value;\nuse tracing::trace;\n\nuse crate::arguments::{Args, Durability, Format, ReadMode};\nuse crate::constants::{DATA_SIZE, DEFAULT_RETHINKDB_DBNAME, HEADER_SIZE, TOKEN_SIZE};\nuse crate::proto::{Payload, Query};\nuse crate::{err, Command, Connection, Result, Session};\n\n#[derive(Deserialize, Debug)]\n#[allow(dead_code)]\npub(crate) struct Response {\n    t: i32,\n    e: Option\u003ci32\u003e,\n    pub(crate) r: Value,\n    b: Option\u003cValue\u003e,\n    p: Option\u003cValue\u003e,\n    n: Option\u003cValue\u003e,\n}\n\nimpl Response {\n    fn new() -\u003e Self {\n        Self {\n            t: ResponseType::SuccessAtom as i32,\n            e: None,\n            r: Value::Array(Vec::new()),\n            b: None,\n            p: None,\n            n: None,\n        }\n    }\n}\n\n#[derive(Debug, Clone, CommandOptions, Serialize, Default, PartialEq, PartialOrd)]\npub struct RunOption {\n    /// One of three possible values affecting\n    /// the consistency guarantee for the query (default: `ReadMode::Single`).\n    /// - `ReadMode::Single` (the default) returns values that are in memory\n    /// (but not necessarily written to disk) on the primary replica.\n    /// - `ReadMode::Majority` will only return values that are safely\n    /// committed on disk on a majority of replicas.\n    /// This requires sending a message to every replica on each read,\n    /// so it is the slowest but most consistent.\n    /// - `ReadMode::Outdated` will return values that are in memory\n    /// on an arbitrarily-selected replica.\n    /// This is the fastest but least consistent.\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub read_mode: Option\u003cReadMode\u003e,\n    /// what format to return times in (default: `Format::Native`).\n    /// Set this to `Format::Raw`\n    /// if you want times returned as JSON objects for exporting.\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub time_format: Option\u003cFormat\u003e,\n    /// whether or not to return a profile\n    /// of the query’s execution (default: `false`).\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub profile: Option\u003cbool\u003e,\n    /// possible values are `Durability::Hard` and `Durability::Soft`.\n    /// In soft durability mode RethinkDB will acknowledge\n    /// the write immediately after receiving it,\n    /// but before the write has been committed to disk.\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub durability: Option\u003cDurability\u003e,\n    /// what format to return `grouped_data` and\n    /// `grouped_streams` in (default: `Format::Native`).\n    /// Set this to `Format::Raw` if you want the raw pseudotype.\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub group_format: Option\u003cFormat\u003e,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub noreply: Option\u003cbool\u003e,\n    /// the database to run this query against as a string.\n    /// The default is the database specified in\n    /// the `db` [connection](crate::connection::Connection)\n    /// method (which defaults to `test`).\n    /// The database may also be specified with the db command.\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub db: Option\u003cDb\u003e,\n    /// the maximum numbers of array elements\n    /// that can be returned by a query (default: 100,000).\n    /// This affects all ReQL commands that return arrays.\n    /// Note that it has no effect on the size of arrays\n    /// being **written** to the database;\n    /// those always have an upper limit of 100,000 elements.\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub array_limit: Option\u003cusize\u003e,\n    /// what format to return binary data in (default: `Format::Native`).\n    /// Set this to `Format::Raw` if you want the raw pseudotype.\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub binary_format: Option\u003cFormat\u003e,\n    /// minimum number of rows to wait for before batching\n    /// a result set (default: 8). This is an usize.\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub min_batch_rows: Option\u003cusize\u003e,\n    /// maximum number of rows to wait for before batching\n    /// a result set (default: unlimited). This is an usize.\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub max_batch_rows: Option\u003cusize\u003e,\n    /// maximum number of bytes to wait for before batching\n    /// a result set (default: 1MB). This is an usize.\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub max_batch_bytes: Option\u003cusize\u003e,\n    /// maximum number of seconds to wait before batching\n    /// a result set (default: 0.5).\n    /// This is a f64 and may be specified to the microsecond.\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub max_batch_seconds: Option\u003cf64\u003e,\n    /// factor to scale the other parameters down by on the first batch (default: 4).\n    /// For example, with this set to 8 and `max_batch_rows` set to 80,\n    /// on the first batch `max_batch_rows` will be adjusted to 10 (80 / 8).\n    /// This allows the first batch to return faster.\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub first_batch_scaledown_factor: Option\u003cusize\u003e,\n}\n\n#[derive(Debug, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]\npub struct Db(pub Cow\u003c'static, str\u003e);\n\nimpl RunOption {\n    async fn default_db(self, session: \u0026Session) -\u003e RunOption {\n        let session_db = session.inner.db.lock().await;\n        if self.db.is_none() \u0026\u0026 *session_db != DEFAULT_RETHINKDB_DBNAME {\n            return self.db(\u0026*session_db);\n        }\n        self\n    }\n}\n\npub trait RunArg {\n    fn into_run_opts(self) -\u003e Result\u003c(Connection, RunOption)\u003e;\n}\n\nimpl RunArg for \u0026Session {\n    fn into_run_opts(self) -\u003e Result\u003c(Connection, RunOption)\u003e {\n        let conn = self.connection()?;\n        Ok((conn, Default::default()))\n    }\n}\n\nimpl RunArg for Connection {\n    fn into_run_opts(self) -\u003e Result\u003c(Connection, RunOption)\u003e {\n        Ok((self, Default::default()))\n    }\n}\n\nimpl RunArg for Args\u003c(\u0026Session, RunOption)\u003e {\n    fn into_run_opts(self) -\u003e Result\u003c(Connection, RunOption)\u003e {\n        let Args((session, options)) = self;\n        let conn = session.connection()?;\n        Ok((conn, options))\n    }\n}\n\nimpl RunArg for Args\u003c(Connection, RunOption)\u003e {\n    fn into_run_opts(self) -\u003e Result\u003c(Connection, RunOption)\u003e {\n        let Args(arg) = self;\n        Ok(arg)\n    }\n}\n\nimpl RunArg for \u0026mut Session {\n    fn into_run_opts(self) -\u003e Result\u003c(Connection, RunOption)\u003e {\n        self.connection()?.into_run_opts()\n    }\n}\n\nimpl RunArg for Args\u003c(\u0026mut Session, RunOption)\u003e {\n    fn into_run_opts(self) -\u003e Result\u003c(Connection, RunOption)\u003e {\n        let Args((session, options)) = self;\n        let conn = session.connection()?;\n\n        Args((conn, options)).into_run_opts()\n    }\n}\n\npub(crate) fn new\u003cA, T\u003e(query: Command, arg: A) -\u003e impl Stream\u003cItem = Result\u003cT\u003e\u003e\nwhere\n    A: RunArg,\n    T: Unpin + DeserializeOwned,\n{\n    try_stream! {\n        let (mut conn, mut opts) = arg.into_run_opts()?;\n        opts = opts.default_db(\u0026conn.session).await;\n        let change_feed = query.change_feed();\n        if change_feed {\n            conn.session.inner.mark_change_feed();\n        }\n        let noreply = opts.noreply.unwrap_or_default();\n        let mut payload = Payload(QueryType::Start, Some(Query(\u0026query)), opts);\n\n        loop {\n            let (response_type, resp) = conn.request(\u0026payload, noreply).await?;\n            trace!(\"yielding response; token: {}\", conn.token);\n\n            match response_type {\n                ResponseType::SuccessAtom | ResponseType::ServerInfo =\u003e {\n                    for val in serde_json::from_value::\u003cVec\u003cT\u003e\u003e(resp.r)? {\n                        yield val;\n                    }\n                    break;\n                }\n                ResponseType::SuccessSequence =\u003e {\n                    yield serde_json::from_value::\u003cT\u003e(resp.r)?;\n                    break;\n                }\n                ResponseType::SuccessPartial =\u003e {\n                    if conn.closed() {\n                        // reopen so we can use the connection in future\n                        conn.set_closed(false);\n                        trace!(\"connection closed; token: {}\", conn.token);\n                        break;\n                    }\n                    payload = Payload(QueryType::Continue, None, Default::default());\n                    // for val in serde_json::from_value::\u003cVec\u003cT\u003e\u003e(resp.r)? {\n                    //     yield val;\n                    // }\n                    yield serde_json::from_value::\u003cT\u003e(resp.r)?;\n                    continue;\n                }\n                ResponseType::WaitComplete =\u003e { break; }\n                typ =\u003e {\n                    let msg = error_message(resp.r)?;\n                    match typ {\n                        // This feed has been closed by conn.close().\n                        ResponseType::ClientError if change_feed \u0026\u0026 msg.contains(\"not in stream cache\") =\u003e { break; }\n                        _ =\u003e Err(response_error(typ, resp.e, msg))?,\n                    }\n                }\n            }\n        }\n    }\n}\n\nimpl Payload\u003c'_\u003e {\n    fn encode(\u0026self, token: u64) -\u003e Result\u003cVec\u003cu8\u003e\u003e {\n        let bytes = self.to_bytes()?;\n        let data_len = bytes.len();\n        let mut buf = Vec::with_capacity(HEADER_SIZE + data_len);\n        buf.extend_from_slice(\u0026token.to_le_bytes());\n        buf.extend_from_slice(\u0026(data_len as u32).to_le_bytes());\n        buf.extend_from_slice(\u0026bytes);\n        Ok(buf)\n    }\n}\n\nimpl Connection {\n    fn send_response(\u0026self, db_token: u64, resp: Result\u003c(ResponseType, Response)\u003e) {\n        if let Some(tx) = self.session.inner.channels.get(\u0026db_token) {\n            if let Err(error) = tx.unbounded_send(resp) {\n                if error.is_disconnected() {\n                    self.session.inner.channels.remove(\u0026db_token);\n                }\n            }\n        }\n    }\n\n    pub(crate) async fn request\u003c'a\u003e(\n        \u0026mut self,\n        query: \u0026'a Payload\u003c'a\u003e,\n        noreply: bool,\n    ) -\u003e Result\u003c(ResponseType, Response)\u003e {\n        self.submit(query, noreply).await;\n        match self.rx.lock().await.next().await {\n            Some(resp) =\u003e resp,\n            None =\u003e Ok((ResponseType::SuccessAtom, Response::new())),\n        }\n    }\n\n    async fn submit\u003c'a\u003e(\u0026self, query: \u0026'a Payload\u003c'a\u003e, noreply: bool) {\n        let mut db_token = self.token;\n        let result = self.exec(query, noreply, \u0026mut db_token).await;\n        self.send_response(db_token, result);\n    }\n\n    async fn exec\u003c'a\u003e(\n        \u0026self,\n        query: \u0026'a Payload\u003c'a\u003e,\n        noreply: bool,\n        db_token: \u0026mut u64,\n    ) -\u003e Result\u003c(ResponseType, Response)\u003e {\n        let buf = query.encode(self.token)?;\n        let mut stream = self.session.inner.stream.lock().await;\n        let tls_stream = mem::take(\u0026mut stream.tls_stream);\n\n        trace!(\"sending query; token: {}, payload: {}\", self.token, query);\n        if let Some(tcp_stream) = tls_stream {\n            self.tcp_ops(tcp_stream, buf, noreply, db_token).await\n        } else {\n            self.tcp_ops(stream.stream.clone(), buf, noreply, db_token)\n                .await\n        }\n    }\n\n    async fn tcp_ops\u003cT\u003e(\n        \u0026self,\n        mut stream: T,\n        buf: Vec\u003cu8\u003e,\n        noreply: bool,\n        db_token: \u0026mut u64,\n    ) -\u003e Result\u003c(ResponseType, Response)\u003e\n    where\n        T: Unpin + AsyncWrite + AsyncReadExt + AsyncRead + AsyncReadExt,\n    {\n        stream.write_all(\u0026buf).await?;\n        trace!(\"query sent; token: {}\", self.token);\n\n        if noreply {\n            return Ok((ResponseType::SuccessAtom, Response::new()));\n        }\n\n        trace!(\"reading header; token: {}\", self.token);\n        let mut header = [0u8; HEADER_SIZE];\n        stream.read_exact(\u0026mut header).await?;\n\n        let mut buf = [0u8; TOKEN_SIZE];\n        buf.copy_from_slice(\u0026header[..TOKEN_SIZE]);\n        *db_token = {\n            let token = u64::from_le_bytes(buf);\n            trace!(\"db_token: {}\", token);\n            if token \u003e self.session.inner.token.load(Ordering::SeqCst) {\n                self.session.inner.mark_broken();\n                return Err(err::ReqlDriverError::ConnectionBroken.into());\n            }\n            token\n        };\n\n        let mut buf = [0u8; DATA_SIZE];\n        buf.copy_from_slice(\u0026header[TOKEN_SIZE..]);\n        let len = u32::from_le_bytes(buf) as usize;\n        trace!(\n            \"header read; token: {}, db_token: {}, response_len: {}\",\n            self.token,\n            db_token,\n            len\n        );\n\n        trace!(\"reading body; token: {}\", self.token);\n        let mut buf = vec![0u8; len];\n        stream.read_exact(\u0026mut buf).await?;\n\n        trace!(\n            \"body read; token: {}, db_token: {}, body: {}\",\n            self.token,\n            db_token,\n            super::bytes_to_string(\u0026buf),\n        );\n\n        let resp = serde_json::from_slice::\u003cResponse\u003e(\u0026buf)?;\n        trace!(\"response successfully parsed; token: {}\", self.token,);\n\n        let response_type = ResponseType::from_i32(resp.t).ok_or_else(|| {\n            err::ReqlDriverError::Other(format!(\"unknown response type `{}`\", resp.t))\n        })?;\n\n        if let Some(error_type) = resp.e {\n            let msg = error_message(resp.r)?;\n            return Err(response_error(response_type, Some(error_type), msg));\n        }\n\n        Ok((response_type, resp))\n    }\n}\n\nfn error_message(response: Value) -\u003e Result\u003cString\u003e {\n    let messages = serde_json::from_value::\u003cVec\u003cString\u003e\u003e(response)?;\n    Ok(messages.join(\" \"))\n}\n\nfn response_error(\n    response_type: ResponseType,\n    error_type: Option\u003ci32\u003e,\n    msg: String,\n) -\u003e err::ReqlError {\n    match response_type {\n        ResponseType::ClientError =\u003e err::ReqlDriverError::Other(msg).into(),\n        ResponseType::CompileError =\u003e err::ReqlError::Compile(msg),\n        ResponseType::RuntimeError =\u003e match error_type.map(ErrorType::from_i32).ok_or_else(|| {\n            err::ReqlDriverError::Other(format!(\"unexpected runtime error: {}\", msg))\n        }) {\n            Ok(Some(ErrorType::Internal)) =\u003e err::ReqlRuntimeError::Internal(msg).into(),\n            Ok(Some(ErrorType::ResourceLimit)) =\u003e err::ReqlRuntimeError::ResourceLimit(msg).into(),\n            Ok(Some(ErrorType::QueryLogic)) =\u003e err::ReqlRuntimeError::QueryLogic(msg).into(),\n            Ok(Some(ErrorType::NonExistence)) =\u003e err::ReqlRuntimeError::NonExistence(msg).into(),\n            Ok(Some(ErrorType::OpFailed)) =\u003e err::ReqlAvailabilityError::OpFailed(msg).into(),\n            Ok(Some(ErrorType::OpIndeterminate)) =\u003e {\n                err::ReqlAvailabilityError::OpIndeterminate(msg).into()\n            }\n            Ok(Some(ErrorType::User)) =\u003e err::ReqlRuntimeError::User(msg).into(),\n            Ok(Some(ErrorType::PermissionError)) =\u003e err::ReqlRuntimeError::Permission(msg).into(),\n            Err(error) =\u003e error.into(),\n            _ =\u003e err::ReqlDriverError::Other(format!(\"unexpected runtime error: {}\", msg)).into(),\n        },\n        _ =\u003e err::ReqlDriverError::Other(format!(\"unexpected response: {}\", msg)).into(),\n    }\n}\n","traces":[{"line":34,"address":[2499344],"length":1,"stats":{"Line":0},"fn_name":"new"},{"line":38,"address":[2499369],"length":1,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[1478494,1479002,1477966,1478110,1478184,1479065,1477920],"length":1,"stats":{"Line":50},"fn_name":"{async_fn#0}"},{"line":132,"address":[1478294,1478091,1478131,1478505],"length":1,"stats":{"Line":20},"fn_name":null},{"line":133,"address":[1478596,1478662],"length":1,"stats":{"Line":20},"fn_name":null},{"line":134,"address":[1478965,1478808,1478978],"length":1,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[1478749],"length":1,"stats":{"Line":10},"fn_name":null},{"line":145,"address":[2458714,2458735,2458240],"length":1,"stats":{"Line":4},"fn_name":"into_run_opts"},{"line":146,"address":[2458427,2458264],"length":1,"stats":{"Line":4},"fn_name":null},{"line":147,"address":[2458526,2458375],"length":1,"stats":{"Line":9},"fn_name":null},{"line":152,"address":[2458768,2458995],"length":1,"stats":{"Line":0},"fn_name":"into_run_opts"},{"line":153,"address":[2458785],"length":1,"stats":{"Line":0},"fn_name":null},{"line":158,"address":[2660400,2661086],"length":1,"stats":{"Line":2},"fn_name":"into_run_opts"},{"line":159,"address":[2660416],"length":1,"stats":{"Line":2},"fn_name":null},{"line":160,"address":[2660924,2660460,2660520],"length":1,"stats":{"Line":4},"fn_name":null},{"line":161,"address":[2660697],"length":1,"stats":{"Line":2},"fn_name":null},{"line":166,"address":[2661136],"length":1,"stats":{"Line":0},"fn_name":"into_run_opts"},{"line":167,"address":[2661153],"length":1,"stats":{"Line":0},"fn_name":null},{"line":168,"address":[2661168],"length":1,"stats":{"Line":0},"fn_name":null},{"line":173,"address":[2459024],"length":1,"stats":{"Line":0},"fn_name":"into_run_opts"},{"line":174,"address":[2459048],"length":1,"stats":{"Line":0},"fn_name":null},{"line":179,"address":[2661987,2661248],"length":1,"stats":{"Line":0},"fn_name":"into_run_opts"},{"line":180,"address":[2661265],"length":1,"stats":{"Line":0},"fn_name":null},{"line":181,"address":[2661393,2661333,2661721],"length":1,"stats":{"Line":0},"fn_name":null},{"line":183,"address":[2661514],"length":1,"stats":{"Line":0},"fn_name":null},{"line":187,"address":[1425974,1425712],"length":1,"stats":{"Line":5},"fn_name":"new\u003creql_rust::arguments::Args\u003c(\u0026reql_rust::connection::Session, reql_rust::cmd::run::RunOption)\u003e, serde_json::value::Value\u003e"},{"line":192,"address":[1425739,1425824],"length":1,"stats":{"Line":10},"fn_name":null},{"line":193,"address":[1426175,1427343],"length":1,"stats":{"Line":17},"fn_name":null},{"line":194,"address":[1426265,1428416,1428287,1428148,1427469,1426998],"length":1,"stats":{"Line":55},"fn_name":null},{"line":195,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":196,"address":[1428596],"length":1,"stats":{"Line":11},"fn_name":null},{"line":197,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":200,"address":[1428738,1428783],"length":1,"stats":{"Line":22},"fn_name":null},{"line":202,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":203,"address":[1429434,1428899,1429277,1426947,1429002,1429361,1429141,1426286],"length":1,"stats":{"Line":58},"fn_name":null},{"line":204,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":206,"address":[1431474],"length":1,"stats":{"Line":6},"fn_name":null},{"line":207,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":208,"address":[1431619,1438512],"length":1,"stats":{"Line":8},"fn_name":null},{"line":209,"address":[1438542],"length":1,"stats":{"Line":4},"fn_name":null},{"line":211,"address":[1438918],"length":1,"stats":{"Line":1},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":214,"address":[1431700],"length":1,"stats":{"Line":3},"fn_name":null},{"line":215,"address":[1437415],"length":1,"stats":{"Line":0},"fn_name":null},{"line":217,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":218,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":220,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":221,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":222,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":224,"address":[1433759,1435297],"length":1,"stats":{"Line":2},"fn_name":null},{"line":228,"address":[1435428],"length":1,"stats":{"Line":1},"fn_name":null},{"line":229,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":231,"address":[1431798],"length":1,"stats":{"Line":0},"fn_name":null},{"line":232,"address":[1431531],"length":1,"stats":{"Line":0},"fn_name":null},{"line":233,"address":[1431545],"length":1,"stats":{"Line":0},"fn_name":null},{"line":234,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":236,"address":[1432535],"length":1,"stats":{"Line":0},"fn_name":null},{"line":237,"address":[1432552],"length":1,"stats":{"Line":0},"fn_name":null},{"line":246,"address":[2175661,2174912],"length":1,"stats":{"Line":10},"fn_name":"encode"},{"line":247,"address":[2174950,2175077],"length":1,"stats":{"Line":10},"fn_name":null},{"line":248,"address":[2175217,2175053],"length":1,"stats":{"Line":10},"fn_name":null},{"line":249,"address":[2175225],"length":1,"stats":{"Line":5},"fn_name":null},{"line":250,"address":[2175363,2175302],"length":1,"stats":{"Line":20},"fn_name":null},{"line":251,"address":[2175424],"length":1,"stats":{"Line":10},"fn_name":null},{"line":252,"address":[2175494],"length":1,"stats":{"Line":10},"fn_name":null},{"line":253,"address":[2175554],"length":1,"stats":{"Line":10},"fn_name":null},{"line":258,"address":[2459312,2460146,2459979],"length":1,"stats":{"Line":5},"fn_name":"send_response"},{"line":259,"address":[2459342,2459436],"length":1,"stats":{"Line":10},"fn_name":null},{"line":260,"address":[2459622,2459523],"length":1,"stats":{"Line":10},"fn_name":null},{"line":261,"address":[2459880,2459775],"length":1,"stats":{"Line":0},"fn_name":null},{"line":262,"address":[2459910],"length":1,"stats":{"Line":0},"fn_name":null},{"line":268,"address":[2460208],"length":1,"stats":{"Line":10},"fn_name":"request"},{"line":273,"address":[1445119,1444946,1444780,1444627,1444571],"length":1,"stats":{"Line":32},"fn_name":null},{"line":274,"address":[1444731,1445601,1444648,1445247,1445191],"length":1,"stats":{"Line":20},"fn_name":null},{"line":275,"address":[1445895],"length":1,"stats":{"Line":5},"fn_name":null},{"line":276,"address":[1445865,1445993],"length":1,"stats":{"Line":0},"fn_name":null},{"line":280,"address":[1443892,1443820,1443648,1444163,1443681],"length":1,"stats":{"Line":40},"fn_name":"{async_fn#0}"},{"line":281,"address":[1443775],"length":1,"stats":{"Line":10},"fn_name":null},{"line":282,"address":[1443841,1444017,1443794,1444174],"length":1,"stats":{"Line":22},"fn_name":null},{"line":283,"address":[1444298],"length":1,"stats":{"Line":5},"fn_name":null},{"line":286,"address":[2460400],"length":1,"stats":{"Line":10},"fn_name":"exec"},{"line":292,"address":[1439754,1440125,1440265],"length":1,"stats":{"Line":20},"fn_name":null},{"line":293,"address":[1439818,1439971,1440537,1440788,1440239],"length":1,"stats":{"Line":31},"fn_name":null},{"line":294,"address":[1440880,1440963],"length":1,"stats":{"Line":20},"fn_name":null},{"line":296,"address":[1441837,1441684,1441951,1442038,1441520,1441158],"length":1,"stats":{"Line":30},"fn_name":null},{"line":297,"address":[1442515],"length":1,"stats":{"Line":10},"fn_name":null},{"line":298,"address":[1442558,1439922,1443117,1439839],"length":1,"stats":{"Line":0},"fn_name":null},{"line":300,"address":[1442639,1439857],"length":1,"stats":{"Line":12},"fn_name":null},{"line":301,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":305,"address":[1653024,1652832],"length":1,"stats":{"Line":10},"fn_name":"tcp_ops\u003casync_native_tls::tls_stream::TlsStream\u003casync_net::tcp::TcpStream\u003e\u003e"},{"line":315,"address":[1446464,1461926,1462358,1447242,1446807,1461526,1446621,1446404,1461586,1461743],"length":1,"stats":{"Line":30},"fn_name":null},{"line":316,"address":[1463338,1462820,1463251,1447871,1462458,1448138,1463137,1462984,1447345,1448024,1448225,1447707],"length":1,"stats":{"Line":30},"fn_name":null},{"line":318,"address":[1448636,1463746],"length":1,"stats":{"Line":10},"fn_name":null},{"line":319,"address":[1463864,1448757],"length":1,"stats":{"Line":0},"fn_name":null},{"line":322,"address":[1463992,1449678,1448885,1464518,1449247,1449765,1464671,1464785,1464872,1449411,1464354,1449564],"length":1,"stats":{"Line":30},"fn_name":null},{"line":323,"address":[1450176,1465280],"length":1,"stats":{"Line":10},"fn_name":null},{"line":324,"address":[1446485,1465727,1461692,1450643,1446570,1450207,1461607,1465302],"length":1,"stats":{"Line":22},"fn_name":null},{"line":326,"address":[1450558,1465647],"length":1,"stats":{"Line":5},"fn_name":null},{"line":327,"address":[1450737,1450586,1465673,1465821],"length":1,"stats":{"Line":10},"fn_name":null},{"line":328,"address":[1452344,1467425],"length":1,"stats":{"Line":5},"fn_name":null},{"line":329,"address":[1465852,1450768],"length":1,"stats":{"Line":5},"fn_name":null},{"line":330,"address":[1451301,1466385,1466549,1451819,1451618,1466023,1450939,1466702,1451732,1466816,1451465,1466903],"length":1,"stats":{"Line":15},"fn_name":null},{"line":331,"address":[1467303,1452219],"length":1,"stats":{"Line":5},"fn_name":null},{"line":332,"address":[1452449,1467524],"length":1,"stats":{"Line":0},"fn_name":null},{"line":333,"address":[1452494,1467566],"length":1,"stats":{"Line":0},"fn_name":null},{"line":335,"address":[1467417,1452336],"length":1,"stats":{"Line":5},"fn_name":null},{"line":338,"address":[1452354,1467432],"length":1,"stats":{"Line":5},"fn_name":null},{"line":339,"address":[1467459,1452381,1467672,1452600],"length":1,"stats":{"Line":10},"fn_name":null},{"line":340,"address":[1467703,1452631],"length":1,"stats":{"Line":5},"fn_name":null},{"line":341,"address":[1467878,1468404,1452806,1468240,1453686,1468758,1453332,1453599,1468671,1468557,1453485,1453168],"length":1,"stats":{"Line":15},"fn_name":null},{"line":343,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":344,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":345,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":348,"address":[1470273,1470360,1454940,1470159,1455093,1455207,1469480,1454776,1454414,1469842,1455294,1470006],"length":1,"stats":{"Line":15},"fn_name":null},{"line":349,"address":[1470768,1455705],"length":1,"stats":{"Line":5},"fn_name":null},{"line":350,"address":[1455874,1455740,1470935,1471367,1446503,1470803,1456309,1461625],"length":1,"stats":{"Line":10},"fn_name":null},{"line":352,"address":[1458045,1472657,1457205,1471832,1456774,1456938,1472149,1472350,1456412,1473097,1457091,1471470,1457292,1472263,1457605,1471996],"length":1,"stats":{"Line":15},"fn_name":null},{"line":354,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":355,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":356,"address":[1457536,1472588],"length":1,"stats":{"Line":0},"fn_name":null},{"line":359,"address":[1458055,1458376,1473107,1458148,1473200,1473428],"length":1,"stats":{"Line":10},"fn_name":null},{"line":360,"address":[1459147,1459249,1458504,1459324,1473556,1458860,1459012,1473912,1474064,1474199,1474376,1474301],"length":1,"stats":{"Line":15},"fn_name":null},{"line":362,"address":[1477696,1474758,1459709,1476912,1459926,1474975],"length":1,"stats":{"Line":5},"fn_name":"{closure#0}\u003casync_native_tls::tls_stream::TlsStream\u003casync_net::tcp::TcpStream\u003e\u003e"},{"line":363,"address":[1476950,1477734],"length":1,"stats":{"Line":0},"fn_name":null},{"line":366,"address":[1474889,1460004,1475053,1459840],"length":1,"stats":{"Line":6},"fn_name":null},{"line":367,"address":[1460724,1475547,1475758,1475071,1460022,1460513],"length":1,"stats":{"Line":2},"fn_name":null},{"line":368,"address":[1475656,1460622,1475963,1460929],"length":1,"stats":{"Line":2},"fn_name":null},{"line":371,"address":[1460092,1475141],"length":1,"stats":{"Line":5},"fn_name":null},{"line":375,"address":[2499744,2500128],"length":1,"stats":{"Line":1},"fn_name":"error_message"},{"line":376,"address":[2499941,2499761],"length":1,"stats":{"Line":1},"fn_name":null},{"line":377,"address":[2500032,2499911],"length":1,"stats":{"Line":2},"fn_name":null},{"line":380,"address":[2500160,2502378,2502320],"length":1,"stats":{"Line":1},"fn_name":"response_error"},{"line":385,"address":[2500208],"length":1,"stats":{"Line":1},"fn_name":null},{"line":386,"address":[2500316,2502373],"length":1,"stats":{"Line":0},"fn_name":null},{"line":387,"address":[2500401],"length":1,"stats":{"Line":0},"fn_name":null},{"line":388,"address":[2500820,2500500,2500838,2501044,2500777],"length":1,"stats":{"Line":5},"fn_name":null},{"line":389,"address":[2733142],"length":1,"stats":{"Line":0},"fn_name":null},{"line":391,"address":[2501404,2502279],"length":1,"stats":{"Line":0},"fn_name":null},{"line":392,"address":[2502274,2501511],"length":1,"stats":{"Line":0},"fn_name":null},{"line":393,"address":[2501618,2502269],"length":1,"stats":{"Line":2},"fn_name":null},{"line":394,"address":[2501725,2502264],"length":1,"stats":{"Line":0},"fn_name":null},{"line":395,"address":[2501832,2502259],"length":1,"stats":{"Line":0},"fn_name":null},{"line":397,"address":[2502254,2501939],"length":1,"stats":{"Line":0},"fn_name":null},{"line":399,"address":[2502046,2502249],"length":1,"stats":{"Line":2},"fn_name":null},{"line":400,"address":[2502150],"length":1,"stats":{"Line":0},"fn_name":null},{"line":401,"address":[2500885,2501020],"length":1,"stats":{"Line":0},"fn_name":null},{"line":402,"address":[2500836,2501180],"length":1,"stats":{"Line":0},"fn_name":null},{"line":404,"address":[2500282,2500569],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":88,"coverable":149},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","sample.rs"],"content":"use ql2::term::TermType;\n\nuse crate::Command;\n\npub(crate) fn new(number: usize) -\u003e Command {\n    let arg = Command::from_json(number);\n\n    Command::new(TermType::Sample).with_arg(arg)\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::Converter;\n    use crate::spec::{set_up, tear_down, Post};\n    use crate::Result;\n\n    #[tokio::test]\n    async fn test_sample_data() -\u003e Result\u003c()\u003e {\n        let (conn, table, table_name) = set_up(true).await?;\n        let data_obtained: Vec\u003cPost\u003e = table.sample(3).run(\u0026conn).await?.unwrap().parse()?;\n\n        assert!(data_obtained.len() == 3);\n\n        tear_down(conn, \u0026table_name).await\n    }\n}\n","traces":[{"line":5,"address":[2706128,2706339,2706370],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":6,"address":[2706153],"length":1,"stats":{"Line":1},"fn_name":null},{"line":8,"address":[2706251,2706180],"length":1,"stats":{"Line":2},"fn_name":null},{"line":18,"address":[1797288,1797580,1796965,1796873,1796896,1797062,1796864],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":19,"address":[1797027,1797245,1797413,1797092,1798028,1797591],"length":1,"stats":{"Line":4},"fn_name":null},{"line":20,"address":[1798285,1798994,1799129,1797975,1797113,1797196],"length":1,"stats":{"Line":5},"fn_name":null},{"line":22,"address":[1799423,1799114,1799484],"length":1,"stats":{"Line":2},"fn_name":null},{"line":24,"address":[1797131,1799677,1799733,1799808,1799938,1799444,1799553],"length":1,"stats":{"Line":7},"fn_name":null}],"covered":8,"coverable":8},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","seconds.rs"],"content":"use ql2::term::TermType;\n\nuse crate::Command;\n\npub(crate) fn new() -\u003e Command {\n    Command::new(TermType::Seconds)\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::Converter;\n    use crate::{r, Result};\n\n    #[tokio::test]\n    async fn test_seconds_ops() -\u003e Result\u003c()\u003e {\n        let conn = r.connection().connect().await?;\n\n        let seconds = r.now().seconds();\n        let seconds1 = seconds.clone().value();\n        let seconds2: f64 = seconds.cmd().run(\u0026conn).await?.unwrap().parse()?;\n\n        assert!(seconds1.is_normal());\n        assert!(seconds2.is_normal());\n\n        Ok(())\n    }\n}\n","traces":[{"line":5,"address":[2745200],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":6,"address":[2745212],"length":1,"stats":{"Line":1},"fn_name":null},{"line":15,"address":[1960137,1960431,1960730,1960217,1960128,1960294,1960160],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":16,"address":[1960318,1960272,1961002,1960552,1960741,1960391],"length":1,"stats":{"Line":4},"fn_name":null},{"line":18,"address":[1961248,1960992],"length":1,"stats":{"Line":2},"fn_name":null},{"line":19,"address":[1961339,1961276],"length":1,"stats":{"Line":2},"fn_name":null},{"line":20,"address":[1961391,1962191,1961478,1960333,1962300],"length":1,"stats":{"Line":4},"fn_name":null},{"line":22,"address":[1962485,1962462,1962278],"length":1,"stats":{"Line":2},"fn_name":null},{"line":23,"address":[1962562,1962474,1962521],"length":1,"stats":{"Line":2},"fn_name":null},{"line":25,"address":[1962532],"length":1,"stats":{"Line":5},"fn_name":null}],"covered":10,"coverable":10},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","set_difference.rs"],"content":"use ql2::term::TermType;\nuse serde::Serialize;\n\nuse crate::Command;\n\npub(crate) fn new(args: impl SetDifferenceArg) -\u003e Command {\n    Command::new(TermType::SetDifference).with_arg(args.into_set_difference_opts())\n}\n\npub trait SetDifferenceArg {\n    fn into_set_difference_opts(self) -\u003e Command;\n}\n\nimpl\u003cS, T\u003e SetDifferenceArg for T\nwhere\n    S: Serialize,\n    T: IntoIterator\u003cItem = S\u003e + Serialize,\n{\n    fn into_set_difference_opts(self) -\u003e Command {\n        Command::from_json(self)\n    }\n}\n\nimpl SetDifferenceArg for Command {\n    fn into_set_difference_opts(self) -\u003e Command {\n        self\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::Converter;\n    use crate::{r, Result};\n\n    #[tokio::test]\n    async fn test_set_difference_ops() -\u003e Result\u003c()\u003e {\n        let conn = r.connection().connect().await?;\n        let response: [u8; 3] = r\n            .expr([10, 20, 30, 40, 50])\n            .set_difference([20, 40])\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(response == [10, 30, 50]);\n\n        Ok(())\n    }\n}\n","traces":[{"line":6,"address":[5681280,5681560],"length":1,"stats":{"Line":1},"fn_name":"new\u003c[i32; 2]\u003e"},{"line":7,"address":[5681311,5681550,5681406],"length":1,"stats":{"Line":2},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":25,"address":[2175696],"length":1,"stats":{"Line":0},"fn_name":"into_set_difference_opts"},{"line":26,"address":[2175704],"length":1,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[4763641,4764223,4763632,4763924,4763789,4763721,4763664],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":37,"address":[4764234,4763884,4763779,4764558,4764045,4763813],"length":1,"stats":{"Line":4},"fn_name":null},{"line":38,"address":[4765539,4765226,4764803,4765772,4764859,4764548,4765041,4764970,4765445,4765502],"length":1,"stats":{"Line":7},"fn_name":null},{"line":39,"address":[4764477],"length":1,"stats":{"Line":1},"fn_name":null},{"line":40,"address":[4764781],"length":1,"stats":{"Line":1},"fn_name":null},{"line":41,"address":[4764882,4763828,4765000,4765169,4764839],"length":1,"stats":{"Line":5},"fn_name":null},{"line":42,"address":[4765349],"length":1,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[4765879,4765916,4765647],"length":1,"stats":{"Line":2},"fn_name":null},{"line":48,"address":[4765890],"length":1,"stats":{"Line":5},"fn_name":null}],"covered":12,"coverable":15},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","set_insert.rs"],"content":"use ql2::term::TermType;\nuse serde::Serialize;\n\nuse crate::Command;\n\npub(crate) fn new(value: impl Serialize) -\u003e Command {\n    let arg = Command::from_json(value);\n\n    Command::new(TermType::SetInsert).with_arg(arg)\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::Converter;\n    use crate::{r, Result};\n\n    #[tokio::test]\n    async fn test_set_insert_ops() -\u003e Result\u003c()\u003e {\n        let conn = r.connection().connect().await?;\n        let response: [u8; 6] = r\n            .expr([10, 20, 30, 40, 50])\n            .set_insert(60)\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(response == [10, 20, 30, 40, 50, 60]);\n\n        Ok(())\n    }\n}\n","traces":[{"line":6,"address":[2981840,2982043,2982070],"length":1,"stats":{"Line":1},"fn_name":"new\u003ci32\u003e"},{"line":7,"address":[2981864],"length":1,"stats":{"Line":1},"fn_name":null},{"line":9,"address":[2981890,2981957],"length":1,"stats":{"Line":2},"fn_name":null},{"line":18,"address":[1868976,1869133,1869268,1869567,1869065,1869008,1868985],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":19,"address":[1869578,1869902,1869228,1869123,1869157,1869389],"length":1,"stats":{"Line":4},"fn_name":null},{"line":20,"address":[1870764,1870545,1870821,1870858,1870360,1870146,1871091,1870178,1870289,1869892],"length":1,"stats":{"Line":7},"fn_name":null},{"line":21,"address":[1869821],"length":1,"stats":{"Line":1},"fn_name":null},{"line":23,"address":[1870158,1870319,1870488,1870201,1869172],"length":1,"stats":{"Line":5},"fn_name":null},{"line":24,"address":[1870668],"length":1,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[1871198,1871235,1870966],"length":1,"stats":{"Line":2},"fn_name":null},{"line":30,"address":[1871209],"length":1,"stats":{"Line":5},"fn_name":null}],"covered":10,"coverable":11},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","set_intersection.rs"],"content":"use ql2::term::TermType;\nuse serde::Serialize;\n\nuse crate::Command;\n\npub(crate) fn new(args: impl SetIntersectionArg) -\u003e Command {\n    Command::new(TermType::SetIntersection).with_arg(args.into_set_intersection_opts())\n}\n\npub trait SetIntersectionArg {\n    fn into_set_intersection_opts(self) -\u003e Command;\n}\n\nimpl\u003cS, T\u003e SetIntersectionArg for T\nwhere\n    S: Serialize,\n    T: IntoIterator\u003cItem = S\u003e + Serialize,\n{\n    fn into_set_intersection_opts(self) -\u003e Command {\n        Command::from_json(self)\n    }\n}\n\nimpl SetIntersectionArg for Command {\n    fn into_set_intersection_opts(self) -\u003e Command {\n        self\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::Converter;\n    use crate::{r, Result};\n\n    #[tokio::test]\n    async fn test_set_intersection_ops() -\u003e Result\u003c()\u003e {\n        let conn = r.connection().connect().await?;\n        let response: [u8; 2] = r\n            .expr([10, 20, 30, 40, 50])\n            .set_intersection([20, 40])\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(response == [20, 40]);\n\n        Ok(())\n    }\n}\n","traces":[{"line":6,"address":[5681944,5681664],"length":1,"stats":{"Line":1},"fn_name":"new\u003c[i32; 2]\u003e"},{"line":7,"address":[5681934,5681695,5681790],"length":1,"stats":{"Line":2},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":25,"address":[2175728],"length":1,"stats":{"Line":0},"fn_name":"into_set_intersection_opts"},{"line":26,"address":[2175736],"length":1,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[2539839,2539405,2539280,2539248,2539257,2539337,2539540],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":37,"address":[2539850,2539500,2539661,2540174,2539395,2539429],"length":1,"stats":{"Line":4},"fn_name":null},{"line":38,"address":[2540657,2541364,2540475,2540842,2540164,2541061,2541118,2540586,2540419,2541155],"length":1,"stats":{"Line":7},"fn_name":null},{"line":39,"address":[2540093],"length":1,"stats":{"Line":1},"fn_name":null},{"line":40,"address":[2540397],"length":1,"stats":{"Line":1},"fn_name":null},{"line":41,"address":[2540455,2540498,2539444,2540785,2540616],"length":1,"stats":{"Line":5},"fn_name":null},{"line":42,"address":[2540965],"length":1,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[2541508,2541235,2541471],"length":1,"stats":{"Line":2},"fn_name":null},{"line":48,"address":[2541482],"length":1,"stats":{"Line":5},"fn_name":null}],"covered":12,"coverable":15},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","set_union.rs"],"content":"use ql2::term::TermType;\nuse serde::Serialize;\n\nuse crate::Command;\n\npub(crate) fn new(args: impl SetUnionArg) -\u003e Command {\n    Command::new(TermType::SetUnion).with_arg(args.into_set_union_opts())\n}\n\npub trait SetUnionArg {\n    fn into_set_union_opts(self) -\u003e Command;\n}\n\nimpl\u003cS, T\u003e SetUnionArg for T\nwhere\n    S: Serialize,\n    T: IntoIterator\u003cItem = S\u003e + Serialize,\n{\n    fn into_set_union_opts(self) -\u003e Command {\n        Command::from_json(self)\n    }\n}\n\nimpl SetUnionArg for Command {\n    fn into_set_union_opts(self) -\u003e Command {\n        self\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::Converter;\n    use crate::{r, Result};\n\n    #[tokio::test]\n    async fn test_set_union_ops() -\u003e Result\u003c()\u003e {\n        let conn = r.connection().connect().await?;\n        let response: [u8; 7] = r\n            .expr([10, 20, 30, 40, 50])\n            .set_union([60, 70])\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(response == [10, 20, 30, 40, 50, 60, 70]);\n\n        Ok(())\n    }\n}\n","traces":[{"line":6,"address":[5682328,5682048],"length":1,"stats":{"Line":1},"fn_name":"new\u003c[i32; 2]\u003e"},{"line":7,"address":[5682318,5682174,5682079],"length":1,"stats":{"Line":2},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":25,"address":[2175760],"length":1,"stats":{"Line":0},"fn_name":"into_set_union_opts"},{"line":26,"address":[2175768],"length":1,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[2541561,2541709,2541844,2541552,2541641,2541584,2542143],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":37,"address":[2541965,2542154,2542478,2541733,2541804,2541699],"length":1,"stats":{"Line":4},"fn_name":null},{"line":38,"address":[2542890,2542723,2543365,2542468,2543146,2543422,2543688,2542779,2543459,2542961],"length":1,"stats":{"Line":7},"fn_name":null},{"line":39,"address":[2542397],"length":1,"stats":{"Line":1},"fn_name":null},{"line":40,"address":[2542701],"length":1,"stats":{"Line":1},"fn_name":null},{"line":41,"address":[2543089,2542802,2541748,2542759,2542920],"length":1,"stats":{"Line":5},"fn_name":null},{"line":42,"address":[2543269],"length":1,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[2543795,2543832,2543563],"length":1,"stats":{"Line":2},"fn_name":null},{"line":48,"address":[2543806],"length":1,"stats":{"Line":5},"fn_name":null}],"covered":12,"coverable":15},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","set_write_hook.rs"],"content":"use ql2::term::TermType;\n\nuse crate::prelude::Func;\nuse crate::{types::Binary, Command};\n\npub(crate) fn new(args: impl SetWriteHookArg) -\u003e Command {\n    Command::new(TermType::SetWriteHook).with_arg(args.into_set_write_hook_opts())\n}\n\npub trait SetWriteHookArg {\n    fn into_set_write_hook_opts(self) -\u003e Command;\n}\n\nimpl SetWriteHookArg for Command {\n    fn into_set_write_hook_opts(self) -\u003e Command {\n        self\n    }\n}\n\nimpl SetWriteHookArg for Option\u003cu8\u003e {\n    fn into_set_write_hook_opts(self) -\u003e Command {\n        Command::from_json(self)\n    }\n}\n\nimpl SetWriteHookArg for Func {\n    fn into_set_write_hook_opts(self) -\u003e Command {\n        self.0\n    }\n}\n\nimpl SetWriteHookArg for Binary {\n    fn into_set_write_hook_opts(self) -\u003e Command {\n        Command::from_json(self)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::*;\n    use crate::spec::{set_up, tear_down};\n    use crate::types::SetWriteHookResponse;\n    use crate::Result;\n\n    #[tokio::test]\n    async fn test_set_write_hook_ops() -\u003e Result\u003c()\u003e {\n        let (conn, table, table_name) = set_up(false).await?;\n\n        let response: SetWriteHookResponse = table\n            .set_write_hook(func!(|_, _, new_val| new_val))\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert_eq!(response.created, Some(1));\n\n        tear_down(conn, \u0026table_name).await\n    }\n}\n","traces":[{"line":6,"address":[3397328,3397614],"length":1,"stats":{"Line":1},"fn_name":"new\u003creql_rust::cmd::func::Func\u003e"},{"line":7,"address":[3397604,3397350,3397450],"length":1,"stats":{"Line":2},"fn_name":null},{"line":15,"address":[2175792],"length":1,"stats":{"Line":0},"fn_name":"into_set_write_hook_opts"},{"line":16,"address":[2175800],"length":1,"stats":{"Line":0},"fn_name":null},{"line":21,"address":[7625296],"length":1,"stats":{"Line":0},"fn_name":"into_set_write_hook_opts"},{"line":22,"address":[2801438],"length":1,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[2742352],"length":1,"stats":{"Line":1},"fn_name":"into_set_write_hook_opts"},{"line":28,"address":[2742360],"length":1,"stats":{"Line":1},"fn_name":null},{"line":33,"address":[2775008],"length":1,"stats":{"Line":0},"fn_name":"into_set_write_hook_opts"},{"line":34,"address":[2775019],"length":1,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[2411721,2411008,2410976,2410985,2411077,2411203,2411429],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":47,"address":[2411554,2411233,2411386,2411139,2411732,2412185],"length":1,"stats":{"Line":4},"fn_name":null},{"line":49,"address":[2414553,2414509,2414892,2413789,2413662,2414233,2414452,2413955,2414038,2412140],"length":1,"stats":{"Line":7},"fn_name":null},{"line":50,"address":[2413647,2412175,2415888,2415939,2413124,2413701,2413796,2412391,2412794,2412426,2413814],"length":1,"stats":{"Line":5},"fn_name":"{closure#0}"},{"line":51,"address":[2411337,2411254,2414166,2413864,2413994],"length":1,"stats":{"Line":5},"fn_name":null},{"line":52,"address":[2414356],"length":1,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[2415073,2415152,2414704],"length":1,"stats":{"Line":2},"fn_name":null},{"line":58,"address":[2411272,2415487,2415621,2415245,2415435,2415375,2415087],"length":1,"stats":{"Line":7},"fn_name":null}],"covered":11,"coverable":18},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","skip.rs"],"content":"use ql2::term::TermType;\n\nuse crate::Command;\n\npub(crate) fn new(step: usize) -\u003e Command {\n    let arg = Command::from_json(step);\n\n    Command::new(TermType::Skip).with_arg(arg)\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::Converter;\n    use crate::spec::{set_up, tear_down, Post};\n    use crate::Result;\n\n    #[tokio::test]\n    async fn test_skip_data() -\u003e Result\u003c()\u003e {\n        let data = Post::get_many_data();\n        let (conn, table, table_name) = set_up(true).await?;\n        let data_obtained: Vec\u003cPost\u003e = table\n            .skip(data.len() - 1)\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(data_obtained.first() == data.first());\n\n        tear_down(conn, \u0026table_name).await\n    }\n}\n","traces":[{"line":5,"address":[2377026,2376784,2376995],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":6,"address":[2376809],"length":1,"stats":{"Line":1},"fn_name":null},{"line":8,"address":[2376907,2376836],"length":1,"stats":{"Line":2},"fn_name":null},{"line":18,"address":[1966464,1966625,1966441,1967197,1966851,1966432,1966533],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":19,"address":[1966595],"length":1,"stats":{"Line":1},"fn_name":null},{"line":20,"address":[1967208,1967641,1966808,1967033,1966973,1966655],"length":1,"stats":{"Line":4},"fn_name":null},{"line":21,"address":[1967593,1967884,1968149,1968421,1968226,1968741,1967983,1968640,1968977,1968697],"length":1,"stats":{"Line":7},"fn_name":null},{"line":22,"address":[1967915,1967990,1968008,1967814,1967623],"length":1,"stats":{"Line":1},"fn_name":null},{"line":23,"address":[1968354,1966759,1967963,1968182,1966676,1968058],"length":1,"stats":{"Line":6},"fn_name":null},{"line":24,"address":[1968544],"length":1,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[1969238,1968861,1969409],"length":1,"stats":{"Line":2},"fn_name":null},{"line":30,"address":[1969663,1969743,1966694,1969483,1969607,1969871,1969368],"length":1,"stats":{"Line":7},"fn_name":null}],"covered":11,"coverable":12},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","slice.rs"],"content":"use ql2::term::TermType;\nuse reql_macros::CommandOptions;\nuse serde::Serialize;\n\nuse crate::{\n    arguments::{Args, Status},\n    Command,\n};\n\npub(crate) fn new(args: impl SliceArg) -\u003e Command {\n    let (start_offset, end_offset, opts) = args.into_slice_opts();\n    let mut command = Command::new(TermType::Slice).with_arg(start_offset);\n\n    if let Some(end_offset) = end_offset {\n        command = command.with_arg(end_offset);\n    }\n\n    command.with_opts(opts)\n}\n\npub trait SliceArg {\n    fn into_slice_opts(self) -\u003e (Command, Option\u003cCommand\u003e, SliceOption);\n}\n\nimpl SliceArg for isize {\n    fn into_slice_opts(self) -\u003e (Command, Option\u003cCommand\u003e, SliceOption) {\n        (Command::from_json(self), None, Default::default())\n    }\n}\n\nimpl SliceArg for Args\u003c(isize, isize)\u003e {\n    fn into_slice_opts(self) -\u003e (Command, Option\u003cCommand\u003e, SliceOption) {\n        (\n            Command::from_json(self.0 .0),\n            Some(Command::from_json(self.0 .1)),\n            Default::default(),\n        )\n    }\n}\n\nimpl SliceArg for Args\u003c(isize, SliceOption)\u003e {\n    fn into_slice_opts(self) -\u003e (Command, Option\u003cCommand\u003e, SliceOption) {\n        (Command::from_json(self.0 .0), None, self.0 .1)\n    }\n}\n\nimpl SliceArg for Args\u003c(isize, isize, SliceOption)\u003e {\n    fn into_slice_opts(self) -\u003e (Command, Option\u003cCommand\u003e, SliceOption) {\n        (\n            Command::from_json(self.0 .0),\n            Some(Command::from_json(self.0 .1)),\n            self.0 .2,\n        )\n    }\n}\n\n#[derive(Debug, Clone, Copy, Serialize, Default, PartialEq, PartialOrd, CommandOptions)]\npub struct SliceOption {\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub left_bound: Option\u003cStatus\u003e,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub right_bound: Option\u003cStatus\u003e,\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::cmd::order_by::OrderByOption;\n    use crate::prelude::Converter;\n    use crate::spec::{set_up, tear_down, Post};\n    use crate::{args, Result};\n\n    #[tokio::test]\n    async fn test_slice_data() -\u003e Result\u003c()\u003e {\n        let data = Post::get_many_data();\n        let (conn, table, table_name) = set_up(true).await?;\n        let data_obtained: Vec\u003cPost\u003e = table\n            .order_by(OrderByOption::default().index(\"id\"))\n            .slice(args!(4, 5))\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(data_obtained.last() == data.last());\n\n        tear_down(conn, \u0026table_name).await\n    }\n}\n","traces":[{"line":10,"address":[2539120,2538432,2539207],"length":1,"stats":{"Line":1},"fn_name":"new\u003creql_rust::arguments::Args\u003c(isize, isize)\u003e\u003e"},{"line":11,"address":[2538465],"length":1,"stats":{"Line":1},"fn_name":null},{"line":12,"address":[2538708,2538611],"length":1,"stats":{"Line":2},"fn_name":null},{"line":14,"address":[2538776,2539046],"length":1,"stats":{"Line":2},"fn_name":null},{"line":15,"address":[2539020,2538897],"length":1,"stats":{"Line":2},"fn_name":null},{"line":18,"address":[2538987],"length":1,"stats":{"Line":1},"fn_name":null},{"line":26,"address":[4758816,4759005,4759028],"length":1,"stats":{"Line":0},"fn_name":"into_slice_opts"},{"line":27,"address":[2778041,2778221],"length":1,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[7641776,7642053],"length":1,"stats":{"Line":1},"fn_name":"into_slice_opts"},{"line":34,"address":[2662070],"length":1,"stats":{"Line":1},"fn_name":null},{"line":35,"address":[2662086,2662174],"length":1,"stats":{"Line":2},"fn_name":null},{"line":36,"address":[2662176],"length":1,"stats":{"Line":1},"fn_name":null},{"line":42,"address":[2662352],"length":1,"stats":{"Line":0},"fn_name":"into_slice_opts"},{"line":43,"address":[2662374],"length":1,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[2662752,2662512],"length":1,"stats":{"Line":0},"fn_name":"into_slice_opts"},{"line":50,"address":[2662534],"length":1,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[2662617,2662553],"length":1,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[2662653],"length":1,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[2489117,2488361,2488771,2488384,2488453,2488352,2488545],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":74,"address":[2488515],"length":1,"stats":{"Line":1},"fn_name":null},{"line":75,"address":[2489128,2488728,2488575,2488893,2488953,2489559],"length":1,"stats":{"Line":4},"fn_name":null},{"line":76,"address":[2489808,2490147,2490695,2490739,2490030,2490224,2490975,2489911,2490419,2489519,2490638],"length":1,"stats":{"Line":8},"fn_name":null},{"line":77,"address":[2489549,2489732,2489847,2489950,2489968],"length":1,"stats":{"Line":2},"fn_name":null},{"line":78,"address":[2489855],"length":1,"stats":{"Line":1},"fn_name":null},{"line":79,"address":[2488596,2488679,2490180,2490352,2490010,2490053],"length":1,"stats":{"Line":6},"fn_name":null},{"line":80,"address":[2490542],"length":1,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[2491407,2491236,2490859],"length":1,"stats":{"Line":2},"fn_name":null},{"line":86,"address":[2488614,2491604,2491660,2491366,2491740,2491870,2491480],"length":1,"stats":{"Line":7},"fn_name":null}],"covered":19,"coverable":28},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","splice_at.rs"],"content":"use ql2::term::TermType;\nuse serde::Serialize;\n\nuse crate::{arguments::Args, Command};\n\npub(crate) fn new(args: impl SpliceAtArg) -\u003e Command {\n    let (arg_offset, arg_value) = args.into_splice_at_opts();\n\n    Command::new(TermType::SpliceAt)\n        .with_arg(arg_offset)\n        .with_arg(arg_value)\n}\n\npub trait SpliceAtArg {\n    fn into_splice_at_opts(self) -\u003e (Command, Command);\n}\n\nimpl\u003cS, T\u003e SpliceAtArg for Args\u003c(isize, T)\u003e\nwhere\n    S: Serialize,\n    T: IntoIterator\u003cItem = S\u003e + Serialize,\n{\n    fn into_splice_at_opts(self) -\u003e (Command, Command) {\n        (Command::from_json(self.0 .0), Command::from_json(self.0 .1))\n    }\n}\n\nimpl SpliceAtArg for Args\u003c(Command, Command)\u003e {\n    fn into_splice_at_opts(self) -\u003e (Command, Command) {\n        (self.0 .0, self.0 .1)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::Converter;\n    use crate::{args, r, Result};\n\n    #[tokio::test]\n    async fn test_splice_at_ops() -\u003e Result\u003c()\u003e {\n        let conn = r.connection().connect().await?;\n        let response: [String; 4] = r\n            .expr([\"Moussa\", \"Ali\"])\n            .splice_at(args!(1, [\"Fati\", \"Alima\"]))\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(response == [\"Moussa\", \"Fati\", \"Alima\", \"Ali\"]);\n\n        Ok(())\n    }\n}\n","traces":[{"line":6,"address":[5149776,5150193],"length":1,"stats":{"Line":1},"fn_name":"new\u003creql_rust::arguments::Args\u003c(isize, [\u0026str; 2])\u003e\u003e"},{"line":7,"address":[5149793],"length":1,"stats":{"Line":1},"fn_name":null},{"line":9,"address":[5150064,5149929,5150130],"length":1,"stats":{"Line":3},"fn_name":null},{"line":10,"address":[5150003],"length":1,"stats":{"Line":1},"fn_name":null},{"line":11,"address":[5150071],"length":1,"stats":{"Line":1},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":29,"address":[2662784],"length":1,"stats":{"Line":0},"fn_name":"into_splice_at_opts"},{"line":30,"address":[2662805],"length":1,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[4958064,4958517,4958103,4958469],"length":1,"stats":{"Line":6},"fn_name":"test_splice_at_ops"},{"line":41,"address":[2960988,2961661,2960917,2961149,2960883,2961338],"length":1,"stats":{"Line":4},"fn_name":null},{"line":42,"address":[2962268,2962672,2962453,2963135,2962729,2962054,2962197,2962086,2961651,2962766],"length":1,"stats":{"Line":7},"fn_name":null},{"line":43,"address":[2961581],"length":1,"stats":{"Line":1},"fn_name":null},{"line":44,"address":[2961884],"length":1,"stats":{"Line":1},"fn_name":null},{"line":45,"address":[2962066,2962227,2962396,2962109,2960932],"length":1,"stats":{"Line":5},"fn_name":null},{"line":46,"address":[2962576],"length":1,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[2963290,2963010,2963257],"length":1,"stats":{"Line":2},"fn_name":null},{"line":52,"address":[2963263],"length":1,"stats":{"Line":5},"fn_name":null}],"covered":15,"coverable":18},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","split.rs"],"content":"use ql2::term::TermType;\n\nuse crate::{arguments::Args, Command};\n\npub(crate) fn new(args: impl SplitArg) -\u003e Command {\n    let (arg1, arg2) = args.into_split_opts();\n    let mut command = Command::new(TermType::Split);\n\n    if let Some(arg) = arg1 {\n        command = command.with_arg(arg);\n    }\n\n    if let Some(arg1) = arg2 {\n        command = command.with_arg(arg1);\n    }\n\n    command\n}\n\npub trait SplitArg {\n    fn into_split_opts(self) -\u003e (Option\u003cCommand\u003e, Option\u003cCommand\u003e);\n}\n\nimpl SplitArg for () {\n    fn into_split_opts(self) -\u003e (Option\u003cCommand\u003e, Option\u003cCommand\u003e) {\n        (None, None)\n    }\n}\n\nimpl SplitArg for \u0026str {\n    fn into_split_opts(self) -\u003e (Option\u003cCommand\u003e, Option\u003cCommand\u003e) {\n        (Some(Command::from_json(self)), None)\n    }\n}\n\nimpl SplitArg for Command {\n    fn into_split_opts(self) -\u003e (Option\u003cCommand\u003e, Option\u003cCommand\u003e) {\n        (Some(self), None)\n    }\n}\n\nimpl SplitArg for Args\u003c(\u0026str, usize)\u003e {\n    fn into_split_opts(self) -\u003e (Option\u003cCommand\u003e, Option\u003cCommand\u003e) {\n        (\n            Some(Command::from_json(self.0 .0)),\n            Some(Command::from_json(self.0 .1)),\n        )\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::{args, prelude::Converter, r, Result};\n\n    #[tokio::test]\n    async fn test_split_ops() -\u003e Result\u003c()\u003e {\n        let conn = r.connection().connect().await?;\n        let data = [\"foo\".to_owned(), \"bar\".to_owned(), \"bax\".to_owned()];\n        let response: [String; 3] = r\n            .expr(\"foo bar bax\")\n            .split(())\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(response == data);\n\n        Ok(())\n    }\n\n    #[tokio::test]\n    async fn test_split_ops_entries() -\u003e Result\u003c()\u003e {\n        let conn = r.connection().connect().await?;\n        let data = [\n            \"12\".to_owned(),\n            \"37\".to_owned(),\n            String::new(),\n            \"22\".to_owned(),\n            String::new(),\n        ];\n        let response: [String; 5] = r\n            .expr(\"12,37,,22,\")\n            .split(\",\")\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(response == data);\n\n        Ok(())\n    }\n\n    #[tokio::test]\n    async fn test_split_ops_entries_limit() -\u003e Result\u003c()\u003e {\n        let conn = r.connection().connect().await?;\n        let data = [\n            \"12\".to_owned(),\n            \"37\".to_owned(),\n            String::new(),\n            \"22,\".to_owned(),\n        ];\n        let response: [String; 4] = r\n            .expr(\"12,37,,22,\")\n            .split(args!(\",\", 3))\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(response == data);\n\n        Ok(())\n    }\n}\n","traces":[{"line":5,"address":[7979592,7977856,7976928,7978832,7977785,7978645,7977674,7979703,7978756],"length":1,"stats":{"Line":3},"fn_name":"new\u003c()\u003e"},{"line":6,"address":[7977873,7976945,7978865],"length":1,"stats":{"Line":3},"fn_name":null},{"line":7,"address":[7977055,7978026,7978975],"length":1,"stats":{"Line":3},"fn_name":null},{"line":9,"address":[7979308,7979072,7978123,7977152,7977388,7978359],"length":1,"stats":{"Line":5},"fn_name":null},{"line":10,"address":[7979282,7978238,7977267,7978333,7977362,7979187],"length":1,"stats":{"Line":4},"fn_name":null},{"line":13,"address":[7979244,7977390,7978586,7979533,7977615,7978361,7978295,7977324,7979310],"length":1,"stats":{"Line":5},"fn_name":null},{"line":14,"address":[7977474,7978560,7977589,7979393,7979507,7978445],"length":1,"stats":{"Line":2},"fn_name":null},{"line":17,"address":[7979454,7978507,7977536],"length":1,"stats":{"Line":3},"fn_name":null},{"line":25,"address":[3397664],"length":1,"stats":{"Line":1},"fn_name":"into_split_opts"},{"line":26,"address":[3397683],"length":1,"stats":{"Line":1},"fn_name":null},{"line":31,"address":[3397776],"length":1,"stats":{"Line":1},"fn_name":"into_split_opts"},{"line":32,"address":[3397808],"length":1,"stats":{"Line":1},"fn_name":null},{"line":37,"address":[2175824],"length":1,"stats":{"Line":0},"fn_name":"into_split_opts"},{"line":38,"address":[2175840],"length":1,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[2662912,2663138],"length":1,"stats":{"Line":1},"fn_name":"into_split_opts"},{"line":45,"address":[2662936],"length":1,"stats":{"Line":1},"fn_name":null},{"line":46,"address":[2663049,2662988],"length":1,"stats":{"Line":2},"fn_name":null},{"line":56,"address":[1737593,1737741,1737876,1738175,1737584,1737673,1737616],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":57,"address":[1738186,1737836,1737765,1738459,1737997,1737731],"length":1,"stats":{"Line":4},"fn_name":null},{"line":58,"address":[1738936,1738429,1738696],"length":1,"stats":{"Line":2},"fn_name":null},{"line":59,"address":[1739676,1739713,1739033,1739215,1739400,1738909,1739144,1739619,1740052,1739001],"length":1,"stats":{"Line":7},"fn_name":null},{"line":62,"address":[1739056,1739013,1737780,1739343,1739174],"length":1,"stats":{"Line":5},"fn_name":null},{"line":63,"address":[1739523],"length":1,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[1740226,1739930,1740193],"length":1,"stats":{"Line":2},"fn_name":null},{"line":69,"address":[1740199],"length":1,"stats":{"Line":5},"fn_name":null},{"line":73,"address":[1740352,1740477,1740614,1740329,1740320,1740409,1740913],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":74,"address":[1740735,1740501,1740924,1741197,1740467,1740574],"length":1,"stats":{"Line":4},"fn_name":null},{"line":75,"address":[1741690],"length":1,"stats":{"Line":1},"fn_name":null},{"line":76,"address":[1741167],"length":1,"stats":{"Line":1},"fn_name":null},{"line":77,"address":[1741434],"length":1,"stats":{"Line":1},"fn_name":null},{"line":78,"address":[1741510],"length":1,"stats":{"Line":1},"fn_name":null},{"line":79,"address":[1741558],"length":1,"stats":{"Line":1},"fn_name":null},{"line":80,"address":[1741637],"length":1,"stats":{"Line":1},"fn_name":null},{"line":82,"address":[1742156,1742085,1742344,1742620,1742657,1741908,1742563,1743092,1741968,1741813],"length":1,"stats":{"Line":7},"fn_name":null},{"line":85,"address":[1742115,1742284,1741948,1741991,1740516],"length":1,"stats":{"Line":5},"fn_name":null},{"line":86,"address":[1742467],"length":1,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[1743266,1742970,1743233],"length":1,"stats":{"Line":2},"fn_name":null},{"line":92,"address":[5108428,5108488,5108383,5108768],"length":1,"stats":{"Line":5},"fn_name":null},{"line":96,"address":[5108887,5109301,5108848,5109253],"length":1,"stats":{"Line":6},"fn_name":"test_split_ops_entries_limit"},{"line":97,"address":[1743612,1743507,1743541,1743773,1744235,1743962],"length":1,"stats":{"Line":4},"fn_name":null},{"line":98,"address":[1744672],"length":1,"stats":{"Line":1},"fn_name":null},{"line":99,"address":[1744205],"length":1,"stats":{"Line":1},"fn_name":null},{"line":100,"address":[1744472],"length":1,"stats":{"Line":1},"fn_name":null},{"line":101,"address":[1744548],"length":1,"stats":{"Line":1},"fn_name":null},{"line":102,"address":[1744596],"length":1,"stats":{"Line":1},"fn_name":null},{"line":104,"address":[1745101,1745357,1745633,1744768,1745576,1745670,1744990,1745172,1746041,1744958],"length":1,"stats":{"Line":7},"fn_name":null},{"line":106,"address":[1744863],"length":1,"stats":{"Line":1},"fn_name":null},{"line":107,"address":[1745300,1745131,1743556,1744970,1745013],"length":1,"stats":{"Line":5},"fn_name":null},{"line":108,"address":[1745480],"length":1,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[1745919,1746182,1746215],"length":1,"stats":{"Line":2},"fn_name":null},{"line":114,"address":[1746188],"length":1,"stats":{"Line":5},"fn_name":null}],"covered":46,"coverable":51},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","status.rs"],"content":"use ql2::term::TermType;\n\nuse crate::Command;\n\npub(crate) fn new() -\u003e Command {\n    Command::new(TermType::Status)\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::Converter;\n    use crate::spec::{set_up, tear_down};\n    use crate::types::StatusResponse;\n    use crate::Result;\n\n    #[tokio::test]\n    async fn test_status_table() -\u003e Result\u003c()\u003e {\n        let (conn, table, table_name) = set_up(true).await?;\n        let response: StatusResponse = table.status().run(\u0026conn).await?.unwrap().parse()?;\n\n        assert!(response.name.unwrap() == table_name);\n\n        tear_down(conn, \u0026table_name).await\n    }\n}\n","traces":[{"line":5,"address":[2702304],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":6,"address":[2702316],"length":1,"stats":{"Line":1},"fn_name":null},{"line":17,"address":[4772320,4772725,4772359,4772773],"length":1,"stats":{"Line":6},"fn_name":"test_status_table"},{"line":18,"address":[5683199,5682803,5683031,5683377,5682876,5683809],"length":1,"stats":{"Line":4},"fn_name":null},{"line":19,"address":[5683761,5682982,5684066,5682897,5684783,5684990],"length":1,"stats":{"Line":5},"fn_name":null},{"line":21,"address":[5684925,5685456,5685302],"length":1,"stats":{"Line":2},"fn_name":null},{"line":23,"address":[4772456,4772351,4772736,4772396],"length":1,"stats":{"Line":7},"fn_name":null}],"covered":7,"coverable":7},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","sub.rs"],"content":"use std::ops::Sub;\n\nuse ql2::term::TermType;\n\nuse crate::Command;\n\nimpl\u003cT: SubArg\u003e Sub\u003cT\u003e for Command {\n    type Output = Self;\n\n    fn sub(self, arg: T) -\u003e Self {\n        Command::new(TermType::Sub)\n            .with_arg(arg.into_sub_opts())\n            .with_parent(self)\n    }\n}\n\npub trait SubArg {\n    fn into_sub_opts(self) -\u003e Command;\n}\n\nimpl SubArg for f64 {\n    fn into_sub_opts(self) -\u003e Command {\n        Command::from_json(self)\n    }\n}\n\nimpl SubArg for Vec\u003cf64\u003e {\n    fn into_sub_opts(self) -\u003e Command {\n        Command::from_json(self)\n    }\n}\n\nimpl SubArg for Command {\n    fn into_sub_opts(self) -\u003e Command {\n        self\n    }\n}\n\n// TODO write test\n","traces":[{"line":10,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":11,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":12,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":13,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[2518880],"length":1,"stats":{"Line":0},"fn_name":"into_sub_opts"},{"line":23,"address":[2518898],"length":1,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[3397920],"length":1,"stats":{"Line":0},"fn_name":"into_sub_opts"},{"line":29,"address":[3397932],"length":1,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[2175968],"length":1,"stats":{"Line":0},"fn_name":"into_sub_opts"},{"line":35,"address":[2175976],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":10},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","sum.rs"],"content":"use ql2::term::TermType;\n\nuse crate::prelude::Func;\nuse crate::Command;\n\npub(crate) fn new(args: impl SumArg) -\u003e Command {\n    let mut command = Command::new(TermType::Sum);\n\n    if let Some(arg) = args.into_sum_opts() {\n        command = command.with_arg(arg)\n    }\n\n    command\n}\n\npub trait SumArg {\n    fn into_sum_opts(self) -\u003e Option\u003cCommand\u003e;\n}\n\nimpl SumArg for () {\n    fn into_sum_opts(self) -\u003e Option\u003cCommand\u003e {\n        None\n    }\n}\n\nimpl SumArg for \u0026str {\n    fn into_sum_opts(self) -\u003e Option\u003cCommand\u003e {\n        let arg = Command::from_json(self);\n\n        Some(arg)\n    }\n}\n\nimpl SumArg for Func {\n    fn into_sum_opts(self) -\u003e Option\u003cCommand\u003e {\n        Some(self.0)\n    }\n}\n\nimpl SumArg for Command {\n    fn into_sum_opts(self) -\u003e Option\u003cCommand\u003e {\n        Some(self)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::Converter;\n    use crate::spec::{set_up, tear_down, Post};\n    use crate::Result;\n\n    #[tokio::test]\n    async fn test_sum_data() -\u003e Result\u003c()\u003e {\n        let data: u8 = Post::get_many_data().iter().map(|post| post.view).sum();\n        let (conn, table, table_name) = set_up(true).await?;\n        let data_obtained: u8 = table.sum(\"view\").run(\u0026conn).await?.unwrap().parse()?;\n\n        assert!(data_obtained == data);\n\n        tear_down(conn, \u0026table_name).await\n    }\n}\n","traces":[{"line":6,"address":[1693573,1693008],"length":1,"stats":{"Line":1},"fn_name":"new\u003c\u0026str\u003e"},{"line":7,"address":[1693054,1693156],"length":1,"stats":{"Line":2},"fn_name":null},{"line":9,"address":[1693222,1693497,1693164],"length":1,"stats":{"Line":3},"fn_name":null},{"line":10,"address":[1693329,1693471],"length":1,"stats":{"Line":2},"fn_name":null},{"line":13,"address":[1693522],"length":1,"stats":{"Line":1},"fn_name":null},{"line":21,"address":[2441504],"length":1,"stats":{"Line":0},"fn_name":"into_sum_opts"},{"line":22,"address":[5012420],"length":1,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[2441520],"length":1,"stats":{"Line":1},"fn_name":"into_sum_opts"},{"line":28,"address":[2441553],"length":1,"stats":{"Line":1},"fn_name":null},{"line":30,"address":[2441564],"length":1,"stats":{"Line":1},"fn_name":null},{"line":35,"address":[2742384],"length":1,"stats":{"Line":0},"fn_name":"into_sum_opts"},{"line":36,"address":[2742400],"length":1,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[2176000],"length":1,"stats":{"Line":0},"fn_name":"into_sum_opts"},{"line":42,"address":[2176016],"length":1,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[2507559,2507925,2507973,2507520],"length":1,"stats":{"Line":6},"fn_name":"test_sum_data"},{"line":54,"address":[5018168,5017795,5021181,5021168],"length":1,"stats":{"Line":4},"fn_name":"{closure#0}"},{"line":55,"address":[5019070,5018412,5017855,5018008],"length":1,"stats":{"Line":3},"fn_name":null},{"line":56,"address":[5019327,5019010,5020134,5017959,5020036,5017876],"length":1,"stats":{"Line":5},"fn_name":null},{"line":58,"address":[5020113,5020433],"length":1,"stats":{"Line":1},"fn_name":null},{"line":60,"address":[2507551,2507596,2507656,2507936],"length":1,"stats":{"Line":7},"fn_name":null}],"covered":14,"coverable":20},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","sync.rs"],"content":"use ql2::term::TermType;\n\nuse crate::Command;\n\npub(crate) fn new() -\u003e Command {\n    Command::new(TermType::Sync)\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::*;\n    use crate::spec::{set_up, tear_down};\n    use crate::types::SyncResponse;\n    use crate::Result;\n\n    #[tokio::test]\n    async fn test_sync_ops() -\u003e Result\u003c()\u003e {\n        let (conn, table, table_name) = set_up(true).await?;\n        let sync_response: SyncResponse = table.sync().run(\u0026conn).await?.unwrap().parse()?;\n\n        assert!(sync_response.synced == 1);\n\n        tear_down(conn, \u0026table_name).await\n    }\n}\n","traces":[{"line":5,"address":[2308160],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":6,"address":[2308172],"length":1,"stats":{"Line":1},"fn_name":null},{"line":17,"address":[1856023,1855984,1856389,1856437],"length":1,"stats":{"Line":6},"fn_name":"test_sync_ops"},{"line":18,"address":[7626727,7625796,7625949,7626295,7626117,7625731],"length":1,"stats":{"Line":4},"fn_name":null},{"line":19,"address":[7626679,7625817,7626984,7625900,7627782,7627693],"length":1,"stats":{"Line":5},"fn_name":null},{"line":21,"address":[7627762,7628081],"length":1,"stats":{"Line":1},"fn_name":null},{"line":23,"address":[1856060,1856400,1856120,1856015],"length":1,"stats":{"Line":7},"fn_name":null}],"covered":7,"coverable":7},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","table.rs"],"content":"use ql2::term::TermType;\nuse reql_macros::CommandOptions;\nuse serde::Serialize;\n\nuse crate::arguments::{Args, IdentifierFormat, ReadMode};\nuse crate::Command;\n\npub(crate) fn new(args: impl TableArg) -\u003e Command {\n    let (arg, opts) = args.into_table_opts();\n\n    Command::new(TermType::Table).with_arg(arg).with_opts(opts)\n}\n\npub trait TableArg {\n    fn into_table_opts(self) -\u003e (Command, TableOption);\n}\n\nimpl\u003cT\u003e TableArg for T\nwhere\n    T: Into\u003cString\u003e,\n{\n    fn into_table_opts(self) -\u003e (Command, TableOption) {\n        (Command::from_json(self.into()), Default::default())\n    }\n}\n\nimpl\u003cT\u003e TableArg for Args\u003c(T, TableOption)\u003e\nwhere\n    T: Into\u003cString\u003e,\n{\n    fn into_table_opts(self) -\u003e (Command, TableOption) {\n        (Command::from_json(self.0 .0.into()), self.0 .1)\n    }\n}\n\n#[derive(Debug, Clone, Copy, Serialize, Default, PartialEq, PartialOrd, CommandOptions)]\n#[non_exhaustive]\npub struct TableOption {\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub read_mode: Option\u003cReadMode\u003e,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub identifier_format: Option\u003cIdentifierFormat\u003e,\n}\n\n#[cfg(test)]\nmod tests {\n    use serde_json::Value;\n\n    use crate::arguments::ReadMode;\n    use crate::cmd::table::TableOption;\n    use crate::prelude::*;\n    use crate::{args, r, Result};\n\n    #[tokio::test]\n    async fn test_table() -\u003e Result\u003c()\u003e {\n        let conn = r.connection().connect().await?;\n        let table: Vec\u003cValue\u003e = r\n            .db(\"todo_app\")\n            .table(\"geo\")\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(table.len() \u003e 0);\n        Ok(())\n    }\n\n    #[tokio::test]\n    async fn test_table_with_options() -\u003e Result\u003c()\u003e {\n        let conn = r.connection().connect().await?;\n        let table_options = TableOption::default().read_mode(ReadMode::Outdated);\n        let table: Vec\u003cValue\u003e = r\n            .db(\"todo_app\")\n            .table(args!(\"geo\", table_options))\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(table.len() \u003e 0);\n        Ok(())\n    }\n}\n","traces":[{"line":8,"address":[1354695,1354336,1354664],"length":1,"stats":{"Line":9},"fn_name":"new\u003c\u0026str\u003e"},{"line":9,"address":[1354369],"length":1,"stats":{"Line":9},"fn_name":null},{"line":11,"address":[1354461,1354539],"length":1,"stats":{"Line":18},"fn_name":null},{"line":22,"address":[1352995,1352816],"length":1,"stats":{"Line":8},"fn_name":"into_table_opts\u003c\u0026str\u003e"},{"line":23,"address":[1352849],"length":1,"stats":{"Line":8},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":55,"address":[2946592,2946997,2946631,2947045],"length":1,"stats":{"Line":6},"fn_name":"test_table"},{"line":56,"address":[7722877,7723066,7722716,7722611,7722645,7723339],"length":1,"stats":{"Line":4},"fn_name":null},{"line":57,"address":[7723562,7723804,7723309,7723989,7723622,7724302,7724265,7723733,7724208,7724538],"length":1,"stats":{"Line":7},"fn_name":null},{"line":60,"address":[7882713],"length":1,"stats":{"Line":5},"fn_name":null},{"line":61,"address":[7724112],"length":1,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[7724665,7724415,7724709],"length":1,"stats":{"Line":2},"fn_name":null},{"line":66,"address":[7724678],"length":1,"stats":{"Line":5},"fn_name":null},{"line":70,"address":[2947541,2947127,2947088,2947493],"length":1,"stats":{"Line":6},"fn_name":"test_table_with_options"},{"line":71,"address":[7724981,7725402,7724947,7725663,7725213,7725052],"length":1,"stats":{"Line":4},"fn_name":null},{"line":72,"address":[7725645,7725908],"length":1,"stats":{"Line":2},"fn_name":null},{"line":73,"address":[7726281,7726756,7726813,7726170,7726537,7726138,7727086,7726352,7726850,7725979],"length":1,"stats":{"Line":7},"fn_name":null},{"line":75,"address":[7726041],"length":1,"stats":{"Line":1},"fn_name":null},{"line":76,"address":[7726150,7724996,7726480,7726193,7726311],"length":1,"stats":{"Line":5},"fn_name":null},{"line":77,"address":[7726660],"length":1,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[7727241,7726963,7727197],"length":1,"stats":{"Line":2},"fn_name":null},{"line":82,"address":[2947504,2947224,2947164,2947119],"length":1,"stats":{"Line":5},"fn_name":null}],"covered":21,"coverable":23},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","table_create.rs"],"content":"use std::borrow::Cow;\nuse std::collections::HashMap;\n\nuse ql2::term::TermType;\nuse reql_macros::CommandOptions;\nuse serde::{Serialize, Serializer};\n\nuse crate::arguments::{Args, Durability, Replicas};\nuse crate::Command;\n\npub(crate) fn new(args: impl TableCreateArg) -\u003e Command {\n    let (arg, opts) = args.into_table_create_opts();\n\n    Command::new(TermType::TableCreate)\n        .with_arg(arg)\n        .with_opts(opts)\n}\n\npub trait TableCreateArg {\n    fn into_table_create_opts(self) -\u003e (Command, TableCreateOption);\n}\n\nimpl\u003cT\u003e TableCreateArg for T\nwhere\n    T: Into\u003cString\u003e,\n{\n    fn into_table_create_opts(self) -\u003e (Command, TableCreateOption) {\n        (Command::from_json(self.into()), Default::default())\n    }\n}\n\nimpl\u003cT\u003e TableCreateArg for Args\u003c(T, TableCreateOption)\u003e\nwhere\n    T: Into\u003cString\u003e,\n{\n    fn into_table_create_opts(self) -\u003e (Command, TableCreateOption) {\n        (Command::from_json(self.0 .0.into()), self.0 .1)\n    }\n}\n\n#[derive(Debug, Default, Clone, PartialEq, CommandOptions)]\n#[non_exhaustive]\npub struct TableCreateOption {\n    pub primary_key: Option\u003cCow\u003c'static, str\u003e\u003e,\n    pub durability: Option\u003cDurability\u003e,\n    pub shards: Option\u003cu8\u003e,\n    pub replicas: Option\u003cReplicas\u003e,\n}\n\nimpl Serialize for TableCreateOption {\n    fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    where\n        S: Serializer,\n    {\n        #[derive(Serialize)]\n        struct InnerOptions\u003c'a\u003e {\n            #[serde(skip_serializing_if = \"Option::is_none\")]\n            primary_key: Option\u003c\u0026'a Cow\u003c'static, str\u003e\u003e,\n            #[serde(skip_serializing_if = \"Option::is_none\")]\n            durability: Option\u003cDurability\u003e,\n            #[serde(skip_serializing_if = \"Option::is_none\")]\n            shards: Option\u003cu8\u003e,\n            #[serde(skip_serializing_if = \"Option::is_none\")]\n            replicas: Option\u003cInnerReplicas\u003c'a\u003e\u003e,\n            #[serde(skip_serializing_if = \"Option::is_none\")]\n            primary_replica_tag: Option\u003c\u0026'a Cow\u003c'static, str\u003e\u003e,\n        }\n\n        #[derive(Serialize)]\n        #[serde(untagged)]\n        enum InnerReplicas\u003c'a\u003e {\n            Int(usize),\n            Map(\u0026'a HashMap\u003cCow\u003c'static, str\u003e, usize\u003e),\n        }\n\n        let (replicas, primary_replica_tag) = match \u0026self.replicas {\n            Some(Replicas::Int(i)) =\u003e (Some(InnerReplicas::Int(*i)), None),\n            Some(Replicas::Map {\n                replicas,\n                primary_replica_tag,\n            }) =\u003e (\n                Some(InnerReplicas::Map(replicas)),\n                Some(primary_replica_tag),\n            ),\n            None =\u003e (None, None),\n        };\n\n        let opts = InnerOptions {\n            replicas,\n            primary_replica_tag,\n            primary_key: self.primary_key.as_ref(),\n            durability: self.durability,\n            shards: self.shards,\n        };\n\n        opts.serialize(serializer)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use uuid::Uuid;\n\n    use crate::cmd::table_create::TableCreateOption;\n    use crate::types::DbResponse;\n    use crate::{args, prelude::*, Session};\n    use crate::{r, Result};\n\n    #[tokio::test]\n    async fn test_create_table() -\u003e Result\u003c()\u003e {\n        let table_name = Uuid::new_v4().to_string();\n        let conn = r.connection().connect().await?;\n        let table_created: DbResponse = r\n            .table_create(table_name.as_str())\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        drop_table(\u0026table_name, table_created, \u0026conn).await\n    }\n\n    #[tokio::test]\n    async fn test_create_table_with_options() -\u003e Result\u003c()\u003e {\n        let table_name = Uuid::new_v4().to_string();\n        let conn = r.connection().connect().await?;\n        let table_options = TableCreateOption::default().primary_key(\"id\");\n        let table_created = r\n            .db(\"test\")\n            .table_create(args!(table_name.as_str(), table_options))\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        drop_table(\u0026table_name, table_created, \u0026conn).await\n    }\n\n    async fn drop_table(table_name: \u0026str, table_created: DbResponse, conn: \u0026Session) -\u003e Result\u003c()\u003e {\n        assert!(table_created.tables_created \u003e Some(0));\n        r.table_drop(table_name).run(conn).await?;\n        Ok(())\n    }\n}\n","traces":[{"line":11,"address":[2972016,2972672,2972619,2973265],"length":1,"stats":{"Line":6},"fn_name":"new\u003creql_rust::arguments::Args\u003c(\u0026str, reql_rust::cmd::table_create::TableCreateOption)\u003e\u003e"},{"line":12,"address":[2972033,2972705],"length":1,"stats":{"Line":6},"fn_name":null},{"line":14,"address":[2972905,2973202,2973038,2972556,2972259,2972392],"length":1,"stats":{"Line":18},"fn_name":null},{"line":15,"address":[2972333,2972979],"length":1,"stats":{"Line":6},"fn_name":null},{"line":16,"address":[2973050,2972404],"length":1,"stats":{"Line":6},"fn_name":null},{"line":27,"address":[2973312,2973489],"length":1,"stats":{"Line":5},"fn_name":"into_table_create_opts\u003c\u0026str\u003e"},{"line":28,"address":[2973345],"length":1,"stats":{"Line":5},"fn_name":null},{"line":36,"address":[1903168,1903367],"length":1,"stats":{"Line":1},"fn_name":"into_table_create_opts\u003c\u0026str\u003e"},{"line":37,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":51,"address":[2974113,2973520],"length":1,"stats":{"Line":5},"fn_name":"serialize\u003cserde_json::value::ser::Serializer\u003e"},{"line":76,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":110,"address":[1584005,1584053,1583639,1583600],"length":1,"stats":{"Line":6},"fn_name":"test_create_table"},{"line":111,"address":[2493670,2494001],"length":1,"stats":{"Line":2},"fn_name":null},{"line":112,"address":[7781816],"length":1,"stats":{"Line":4},"fn_name":null},{"line":113,"address":[2495476,2495439,2494906,2495163,2494763,2494977,2494795,2495382,2495841],"length":1,"stats":{"Line":6},"fn_name":null},{"line":114,"address":[2494510],"length":1,"stats":{"Line":1},"fn_name":null},{"line":115,"address":[7781660],"length":1,"stats":{"Line":6},"fn_name":null},{"line":116,"address":[2495286],"length":1,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[7781489],"length":1,"stats":{"Line":8},"fn_name":null},{"line":124,"address":[1584549,1584135,1584501,1584096],"length":1,"stats":{"Line":6},"fn_name":"test_create_table_with_options"},{"line":125,"address":[2496819,2497204],"length":1,"stats":{"Line":2},"fn_name":null},{"line":126,"address":[2497487,2497036,2497283,2496883,2497219,2497764],"length":1,"stats":{"Line":4},"fn_name":null},{"line":127,"address":[2497754,2497989],"length":1,"stats":{"Line":2},"fn_name":null},{"line":128,"address":[2498036,2498521,2498765,2499319,2499363,2499737,2499043,2498588,2499262,2498848],"length":1,"stats":{"Line":7},"fn_name":null},{"line":130,"address":[2498603,2498114,2498063,2498560],"length":1,"stats":{"Line":2},"fn_name":null},{"line":131,"address":[2498568,2498804,2498976,2498674,2496987,2496904],"length":1,"stats":{"Line":6},"fn_name":null},{"line":132,"address":[2499166],"length":1,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[1584512,1584172,1584232,1584127],"length":1,"stats":{"Line":8},"fn_name":null},{"line":139,"address":[1581552,1581611],"length":1,"stats":{"Line":5},"fn_name":"drop_table"},{"line":140,"address":[2492655,2492624,2492417],"length":1,"stats":{"Line":2},"fn_name":null},{"line":141,"address":[2492648,2492466,2492732,2492924],"length":1,"stats":{"Line":3},"fn_name":null},{"line":142,"address":[2493500],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":35,"coverable":44},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","table_drop.rs"],"content":"use ql2::term::TermType;\n\nuse crate::Command;\n\npub(crate) fn new(table_name: impl Into\u003cString\u003e) -\u003e Command {\n    Command::new(TermType::TableDrop).with_arg(Command::from_json(table_name.into()))\n}\n\n#[cfg(test)]\nmod tests {\n    use uuid::Uuid;\n\n    use crate::prelude::*;\n    use crate::types::DbResponse;\n    use crate::{r, Result};\n\n    #[tokio::test]\n    async fn test_drop_table() -\u003e Result\u003c()\u003e {\n        let table_name = Uuid::new_v4().to_string();\n        let conn = r.connection().connect().await?;\n\n        r.table_create(table_name.as_str()).run(\u0026conn).await?;\n\n        let table_dropped: DbResponse = r\n            .table_drop(table_name.as_str())\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(table_dropped.tables_dropped \u003e Some(0));\n\n        Ok(())\n    }\n}\n","traces":[{"line":5,"address":[2199651,2199328],"length":1,"stats":{"Line":1},"fn_name":"new\u003c\u0026str\u003e"},{"line":6,"address":[2199478,2199370,2199632],"length":1,"stats":{"Line":2},"fn_name":null},{"line":18,"address":[5165072,5164281,5164304,5164675,5164272,5164373,5164449],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":19,"address":[5164427,5164800],"length":1,"stats":{"Line":2},"fn_name":null},{"line":20,"address":[5164632,5164879,5165368,5165083,5164815,5164479],"length":1,"stats":{"Line":4},"fn_name":null},{"line":22,"address":[5164583,5164500,5165596,5165342],"length":1,"stats":{"Line":4},"fn_name":null},{"line":24,"address":[5167065,5167145,5166568,5166416,5166846,5166451,5167514,5167122,5166651],"length":1,"stats":{"Line":6},"fn_name":null},{"line":25,"address":[5166323],"length":1,"stats":{"Line":1},"fn_name":null},{"line":26,"address":[5166779,5164518,5166431,5166607,5166474],"length":1,"stats":{"Line":5},"fn_name":null},{"line":27,"address":[5166969],"length":1,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[5167671,5167389,5167704],"length":1,"stats":{"Line":2},"fn_name":null},{"line":33,"address":[5167677],"length":1,"stats":{"Line":5},"fn_name":null}],"covered":11,"coverable":12},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","table_list.rs"],"content":"use crate::Command;\nuse ql2::term::TermType;\n\npub(crate) fn new() -\u003e Command {\n    Command::new(TermType::TableList)\n}\n#[cfg(test)]\nmod tests {\n    use crate::prelude::*;\n    use crate::{r, Result};\n\n    #[tokio::test]\n    async fn test_list_table() -\u003e Result\u003c()\u003e {\n        let conn = r.connection().connect().await?;\n        let db_list: Vec\u003cString\u003e = r.table_list().run(\u0026conn).await?.unwrap().parse()?;\n\n        assert!(db_list.len() \u003e 0);\n        Ok(())\n    }\n}\n","traces":[{"line":4,"address":[2702352],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":5,"address":[2702364],"length":1,"stats":{"Line":1},"fn_name":null},{"line":13,"address":[1871280,1871312,1871289,1871369,1871437,1871871,1871572],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":14,"address":[1871532,1871427,1871693,1871882,1872143,1871461],"length":1,"stats":{"Line":4},"fn_name":null},{"line":15,"address":[1871476,1873071,1873211,1872371,1872133],"length":1,"stats":{"Line":4},"fn_name":null},{"line":17,"address":[1873434,1873184,1873478],"length":1,"stats":{"Line":2},"fn_name":null},{"line":18,"address":[1873447],"length":1,"stats":{"Line":5},"fn_name":null}],"covered":7,"coverable":7},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","time.rs"],"content":"use ql2::term::TermType;\nuse time::{Date, OffsetDateTime, PrimitiveDateTime, Time, UtcOffset};\n\nuse crate::{arguments::Args, types::timezone_to_string, Command};\n\npub(crate) fn new(\n    offset_datetime: OffsetDateTime,\n    timezone_formated: String,\n    with_time: bool,\n) -\u003e Command {\n    let date = offset_datetime.date();\n    let month: u8 = date.month().into();\n    let mut command = Command::new(TermType::Time);\n    command = command.with_arg(Command::from_json(date.year()));\n    command = command.with_arg(Command::from_json(month));\n    command = command.with_arg(Command::from_json(date.day()));\n\n    if with_time {\n        let time = offset_datetime.time();\n\n        command = command.with_arg(Command::from_json(time.hour()));\n        command = command.with_arg(Command::from_json(time.minute()));\n        command = command.with_arg(Command::from_json(time.second()));\n    }\n\n    command.with_arg(Command::from_json(timezone_formated))\n}\n\npub trait TimeArg {\n    fn into_time_opts(self) -\u003e (OffsetDateTime, String, bool);\n}\n\nimpl TimeArg for Args\u003c(Date, UtcOffset)\u003e {\n    fn into_time_opts(self) -\u003e (OffsetDateTime, String, bool) {\n        let (offset_datetime, timezone_formated) =\n            make_time(self.0 .0, time::macros::time!(0:00), self.0 .1);\n\n        (offset_datetime, timezone_formated, false)\n    }\n}\n\nimpl TimeArg for Args\u003c(Date, Time, UtcOffset)\u003e {\n    fn into_time_opts(self) -\u003e (OffsetDateTime, String, bool) {\n        let (offset_datetime, timezone_formated) = make_time(self.0 .0, self.0 .1, self.0 .2);\n\n        (offset_datetime, timezone_formated, true)\n    }\n}\n\nfn make_time(date: Date, time: Time, timezone: UtcOffset) -\u003e (OffsetDateTime, String) {\n    let timezone_formated = timezone_to_string(timezone);\n    let primetive_datetime = PrimitiveDateTime::new(date, time);\n    let offset_datetime = primetive_datetime.assume_offset(timezone);\n\n    (offset_datetime, timezone_formated)\n}\n\n#[cfg(test)]\nmod tests {\n    use time::macros::{date, offset, time};\n\n    use crate::prelude::Converter;\n    use crate::types::Time;\n    use crate::{args, r, Result};\n\n    #[tokio::test]\n    async fn test_time_ops() -\u003e Result\u003c()\u003e {\n        let conn = r.connection().connect().await?;\n        let date = date!(1986 - 11 - 3);\n        let timezone = offset!(+01:00);\n        let time = time!(09:30:40);\n\n        let date_time = r.time(args!(date, time, timezone));\n        let time1 = date_time.clone().value();\n        let time2: Time = date_time.cmd().run(\u0026conn).await?.unwrap().parse()?;\n\n        assert!(time2 == time1);\n\n        Ok(())\n    }\n}\n","traces":[{"line":6,"address":[2779168,2779858,2781465],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":11,"address":[2861038,2860873],"length":1,"stats":{"Line":2},"fn_name":null},{"line":12,"address":[2861045],"length":1,"stats":{"Line":1},"fn_name":null},{"line":13,"address":[2861105],"length":1,"stats":{"Line":1},"fn_name":null},{"line":14,"address":[2861487,2861150],"length":1,"stats":{"Line":1},"fn_name":null},{"line":15,"address":[2861517,2861722,2861413],"length":1,"stats":{"Line":1},"fn_name":null},{"line":16,"address":[2861913,2861674,2861744],"length":1,"stats":{"Line":1},"fn_name":null},{"line":18,"address":[2861903,2862930],"length":1,"stats":{"Line":2},"fn_name":null},{"line":19,"address":[2780410],"length":1,"stats":{"Line":1},"fn_name":null},{"line":21,"address":[2780835,2780499],"length":1,"stats":{"Line":1},"fn_name":null},{"line":22,"address":[2781108,2780770,2780857],"length":1,"stats":{"Line":1},"fn_name":null},{"line":23,"address":[2781287,2781043,2781130],"length":1,"stats":{"Line":1},"fn_name":null},{"line":26,"address":[2781421,2780287,2781309],"length":1,"stats":{"Line":1},"fn_name":null},{"line":34,"address":[2744816],"length":1,"stats":{"Line":1},"fn_name":"into_time_opts"},{"line":35,"address":[2663269],"length":1,"stats":{"Line":1},"fn_name":null},{"line":38,"address":[2663319],"length":1,"stats":{"Line":1},"fn_name":null},{"line":43,"address":[2745104],"length":1,"stats":{"Line":1},"fn_name":"into_time_opts"},{"line":44,"address":[2745123],"length":1,"stats":{"Line":1},"fn_name":null},{"line":46,"address":[2663591],"length":1,"stats":{"Line":1},"fn_name":null},{"line":50,"address":[2781504,2781936],"length":1,"stats":{"Line":1},"fn_name":"make_time"},{"line":51,"address":[2781582],"length":1,"stats":{"Line":1},"fn_name":null},{"line":52,"address":[2781629],"length":1,"stats":{"Line":1},"fn_name":null},{"line":53,"address":[2781701],"length":1,"stats":{"Line":1},"fn_name":null},{"line":55,"address":[2781804],"length":1,"stats":{"Line":1},"fn_name":null},{"line":67,"address":[2581511,2581877,2581472,2581925],"length":1,"stats":{"Line":6},"fn_name":"test_time_ops"},{"line":68,"address":[5410688,5410968,5410734,5411157,5410807,5411598],"length":1,"stats":{"Line":4},"fn_name":null},{"line":69,"address":[5411403],"length":1,"stats":{"Line":1},"fn_name":null},{"line":70,"address":[5411414],"length":1,"stats":{"Line":1},"fn_name":null},{"line":71,"address":[5411442],"length":1,"stats":{"Line":1},"fn_name":null},{"line":73,"address":[5411844,5411457],"length":1,"stats":{"Line":2},"fn_name":null},{"line":74,"address":[5411911,5411848],"length":1,"stats":{"Line":2},"fn_name":null},{"line":75,"address":[5412025,5410749,5412737,5412919,5411938],"length":1,"stats":{"Line":4},"fn_name":null},{"line":77,"address":[5413196,5412890,5413163],"length":1,"stats":{"Line":2},"fn_name":null},{"line":79,"address":[2581503,2581548,2581608,2581888],"length":1,"stats":{"Line":5},"fn_name":null}],"covered":34,"coverable":34},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","time_of_day.rs"],"content":"use ql2::term::TermType;\n\nuse crate::Command;\n\npub(crate) fn new() -\u003e Command {\n    Command::new(TermType::TimeOfDay)\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::Converter;\n    use crate::{r, Result};\n\n    #[tokio::test]\n    async fn test_date_ops() -\u003e Result\u003c()\u003e {\n        let conn = r.connection().connect().await?;\n\n        let datetime = r.now().time_of_day();\n        let date1 = datetime.clone().value();\n        let date2: f64 = datetime.cmd().run(\u0026conn).await?.unwrap().parse()?;\n\n        assert!(date1.is_normal());\n        assert!(date2.is_normal());\n\n        Ok(())\n    }\n}\n","traces":[{"line":5,"address":[2028880],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":6,"address":[2028892],"length":1,"stats":{"Line":1},"fn_name":null},{"line":15,"address":[4772855,4773221,4772816,4773269],"length":1,"stats":{"Line":6},"fn_name":"test_date_ops"},{"line":16,"address":[5195429,5195690,5194960,5195006,5195240,5195079],"length":1,"stats":{"Line":4},"fn_name":null},{"line":18,"address":[5195936,5195680],"length":1,"stats":{"Line":2},"fn_name":null},{"line":19,"address":[5195964,5196027],"length":1,"stats":{"Line":2},"fn_name":null},{"line":20,"address":[5196166,5195021,5196988,5196879,5196079],"length":1,"stats":{"Line":4},"fn_name":null},{"line":22,"address":[5197173,5196966,5197150],"length":1,"stats":{"Line":2},"fn_name":null},{"line":23,"address":[5197250,5197209,5197162],"length":1,"stats":{"Line":2},"fn_name":null},{"line":25,"address":[4772847,4772952,4772892,4773232],"length":1,"stats":{"Line":5},"fn_name":null}],"covered":10,"coverable":10},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","timezone.rs"],"content":"use ql2::term::TermType;\n\nuse crate::Command;\n\npub(crate) fn new() -\u003e Command {\n    Command::new(TermType::Timezone)\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::Converter;\n    use crate::{r, Result};\n\n    #[tokio::test]\n    async fn test_timezone_ops() -\u003e Result\u003c()\u003e {\n        let conn = r.connection().connect().await?;\n\n        let timezone = r.now().timezone();\n        let timezone2: String = timezone.clone().cmd().run(\u0026conn).await?.unwrap().parse()?;\n\n        assert!(timezone.value().to_string() != timezone2);\n\n        Ok(())\n    }\n}\n","traces":[{"line":5,"address":[2702400],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":6,"address":[2702412],"length":1,"stats":{"Line":1},"fn_name":null},{"line":15,"address":[2416121,2416198,2416335,2416634,2416041,2416064,2416032],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":16,"address":[2416176,2416456,2416222,2416295,2416906,2416645],"length":1,"stats":{"Line":4},"fn_name":null},{"line":18,"address":[2416896,2417152],"length":1,"stats":{"Line":2},"fn_name":null},{"line":19,"address":[2418135,2417242,2416237,2417180,2417963],"length":1,"stats":{"Line":4},"fn_name":null},{"line":21,"address":[2418081,2418596,2418381],"length":1,"stats":{"Line":2},"fn_name":null},{"line":23,"address":[2418565],"length":1,"stats":{"Line":5},"fn_name":null}],"covered":8,"coverable":8},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","to_epoch_time.rs"],"content":"use ql2::term::TermType;\n\nuse crate::Command;\n\npub(crate) fn new() -\u003e Command {\n    Command::new(TermType::ToEpochTime)\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::Converter;\n    use crate::{r, Result};\n\n    #[tokio::test]\n    async fn test_to_epoch_time_ops() -\u003e Result\u003c()\u003e {\n        let conn = r.connection().connect().await?;\n\n        let time = r.now().to_epoch_time();\n        let time1 = time.clone().value();\n        let time2: f64 = time.cmd().run(\u0026conn).await?.unwrap().parse()?;\n\n        assert!(time1.is_normal());\n        assert!(time2.is_normal());\n\n        Ok(())\n    }\n}\n","traces":[{"line":5,"address":[2745248],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":6,"address":[2745260],"length":1,"stats":{"Line":1},"fn_name":null},{"line":15,"address":[2803303,2803669,2803717,2803264],"length":1,"stats":{"Line":6},"fn_name":"test_to_epoch_time_ops"},{"line":16,"address":[5197925,5197575,5197736,5197502,5198186,5197456],"length":1,"stats":{"Line":4},"fn_name":null},{"line":18,"address":[5198432,5198176],"length":1,"stats":{"Line":2},"fn_name":null},{"line":19,"address":[5198460,5198523],"length":1,"stats":{"Line":2},"fn_name":null},{"line":20,"address":[5199484,5199375,5198575,5198662,5197517],"length":1,"stats":{"Line":4},"fn_name":null},{"line":22,"address":[5199669,5199646,5199462],"length":1,"stats":{"Line":2},"fn_name":null},{"line":23,"address":[5199705,5199658,5199746],"length":1,"stats":{"Line":2},"fn_name":null},{"line":25,"address":[2803340,2803400,2803680,2803295],"length":1,"stats":{"Line":5},"fn_name":null}],"covered":10,"coverable":10},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","to_geojson.rs"],"content":"use ql2::term::TermType;\n\nuse crate::Command;\n\npub(crate) fn new() -\u003e Command {\n    Command::new(TermType::ToGeojson)\n}\n\n#[cfg(test)]\nmod tests {\n    use serde::{Deserialize, Serialize};\n\n    use crate::cmd::point::Point;\n    use crate::prelude::Converter;\n    use crate::spec::{set_up, tear_down};\n    use crate::types::{GeoJson, GeoType};\n    use crate::{r, Result};\n\n    #[derive(Debug, Serialize, Deserialize, PartialEq)]\n    struct User {\n        id: u8,\n        name: String,\n        location: Point,\n    }\n\n    #[tokio::test]\n    async fn test_to_geojson_ops() -\u003e Result\u003c()\u003e {\n        let user = User {\n            id: 1,\n            name: \"sfo\".to_string(),\n            location: r.point(-122.423246, 37.779388),\n        };\n        let geo: GeoJson\u003c[f64; 2]\u003e = GeoJson {\n            typ: GeoType::Point,\n            coordinates: [-122.423246, 37.779388],\n        };\n        let (conn, table, table_name) = set_up(false).await?;\n        table.clone().insert(\u0026user).run(\u0026conn).await?;\n        let location: GeoJson\u003c[f64; 2]\u003e = table\n            .get(1)\n            .g(\"location\")\n            .to_geojson()\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(location == geo);\n\n        tear_down(conn, \u0026table_name).await\n    }\n}\n","traces":[{"line":5,"address":[2155696],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":6,"address":[2155708],"length":1,"stats":{"Line":1},"fn_name":null},{"line":27,"address":[2787376,2787829,2787415,2787781],"length":1,"stats":{"Line":6},"fn_name":"test_to_geojson_ops"},{"line":30,"address":[5228933],"length":1,"stats":{"Line":1},"fn_name":null},{"line":31,"address":[5229401],"length":1,"stats":{"Line":1},"fn_name":null},{"line":35,"address":[5229526],"length":1,"stats":{"Line":1},"fn_name":null},{"line":37,"address":[5230194,5228993,5229222,5229584,5229658],"length":1,"stats":{"Line":4},"fn_name":null},{"line":38,"address":[5230184,5229171,5229014,5230418],"length":1,"stats":{"Line":4},"fn_name":null},{"line":39,"address":[5231980,5231274,5231158,5231360,5231560,5232037,5232060,5232303,5231483,5231761],"length":1,"stats":{"Line":7},"fn_name":null},{"line":43,"address":[5231383,5231516,5231688,5229120,5231340,5229035],"length":1,"stats":{"Line":6},"fn_name":null},{"line":44,"address":[5231884],"length":1,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[5232609,5232667,5232189],"length":1,"stats":{"Line":2},"fn_name":null},{"line":50,"address":[2787452,2787407,2787792,2787512],"length":1,"stats":{"Line":7},"fn_name":null}],"covered":12,"coverable":13},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","to_iso8601.rs"],"content":"use ql2::term::TermType;\n\nuse crate::Command;\n\npub(crate) fn new() -\u003e Command {\n    Command::new(TermType::ToIso8601)\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::Converter;\n    use crate::{r, Result};\n\n    #[tokio::test]\n    async fn test_to_iso8601_ops() -\u003e Result\u003c()\u003e {\n        let conn = r.connection().connect().await?;\n\n        let iso8601 = r.now().to_iso8601();\n        let iso8601_1 = iso8601.clone().value();\n        let iso8601_2: String = iso8601.cmd().run(\u0026conn).await?.unwrap().parse()?;\n\n        assert!(!iso8601_1.is_empty());\n        assert!(!iso8601_2.is_empty());\n\n        Ok(())\n    }\n}\n","traces":[{"line":5,"address":[2155744],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":6,"address":[2155756],"length":1,"stats":{"Line":1},"fn_name":null},{"line":15,"address":[1696985,1696928,1697498,1697062,1696896,1696905,1697199],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":16,"address":[1697509,1697159,1697040,1697086,1697320,1697770],"length":1,"stats":{"Line":4},"fn_name":null},{"line":18,"address":[1698016,1697760],"length":1,"stats":{"Line":2},"fn_name":null},{"line":19,"address":[1698044,1698107],"length":1,"stats":{"Line":2},"fn_name":null},{"line":20,"address":[1698134,1698221,1698937,1699076,1697101],"length":1,"stats":{"Line":4},"fn_name":null},{"line":22,"address":[1699055,1699355,1699328],"length":1,"stats":{"Line":2},"fn_name":null},{"line":23,"address":[1699344,1699391,1699430],"length":1,"stats":{"Line":2},"fn_name":null},{"line":25,"address":[1699399],"length":1,"stats":{"Line":5},"fn_name":null}],"covered":10,"coverable":10},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","to_json.rs"],"content":"use ql2::term::TermType;\n\nuse crate::Command;\n\npub(crate) fn new() -\u003e Command {\n    Command::new(TermType::ToJsonString)\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::Converter;\n    use crate::spec::{set_up, tear_down};\n    use crate::Result;\n\n    #[tokio::test]\n    async fn test_to_json_string() -\u003e Result\u003c()\u003e {\n        let (conn, table, table_name) = set_up(true).await?;\n        let data_obtained: String = table.get(1).to_json().run(\u0026conn).await?.unwrap().parse()?;\n\n        assert!(!data_obtained.is_empty());\n\n        tear_down(conn, \u0026table_name).await\n    }\n}\n","traces":[{"line":5,"address":[2518928],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":6,"address":[2518940],"length":1,"stats":{"Line":1},"fn_name":null},{"line":16,"address":[1769240,1769532,1768848,1768816,1768825,1768917,1769014],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":17,"address":[1769044,1769365,1769980,1768979,1769197,1769543],"length":1,"stats":{"Line":4},"fn_name":null},{"line":18,"address":[1770229,1769065,1769927,1770969,1769148,1771103],"length":1,"stats":{"Line":5},"fn_name":null},{"line":20,"address":[1771400,1771456,1771089],"length":1,"stats":{"Line":2},"fn_name":null},{"line":22,"address":[1771649,1771709,1771525,1769083,1771784,1771918,1771416],"length":1,"stats":{"Line":7},"fn_name":null}],"covered":7,"coverable":7},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","type_of.rs"],"content":"use ql2::term::TermType;\n\nuse crate::Command;\n\npub(crate) fn new() -\u003e Command {\n    Command::new(TermType::TypeOf)\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::Converter;\n    use crate::types::TypeOf;\n    use crate::{r, Result};\n\n    #[tokio::test]\n    async fn test_type_of_ops() -\u003e Result\u003c()\u003e {\n        let conn = r.connection().connect().await?;\n        let array: TypeOf = r\n            .expr([1, 2, 3])\n            .type_of()\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n        let boolean: TypeOf = r.expr(true).type_of().run(\u0026conn).await?.unwrap().parse()?;\n        let db: TypeOf = r.db(\"test\").type_of().run(\u0026conn).await?.unwrap().parse()?;\n        let string: TypeOf = r.expr(\"foo\").type_of().run(\u0026conn).await?.unwrap().parse()?;\n\n        assert!(array == TypeOf::Array);\n        assert!(boolean == TypeOf::Bool);\n        assert!(db == TypeOf::Db);\n        assert!(string == TypeOf::String);\n\n        Ok(())\n    }\n}\n","traces":[{"line":5,"address":[2028928],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":6,"address":[2028940],"length":1,"stats":{"Line":1},"fn_name":null},{"line":16,"address":[2843049,2843118,2843736,2843436,2842969,2842960,2842992],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":17,"address":[2844049,2843145,2843108,2843558,2843396,2843747],"length":1,"stats":{"Line":4},"fn_name":null},{"line":18,"address":[2844685,2844904,2844289,2844039,2844984,2845173,2844428,2844499,2844961],"length":1,"stats":{"Line":6},"fn_name":null},{"line":19,"address":[2843990],"length":1,"stats":{"Line":1},"fn_name":null},{"line":21,"address":[2843353,2844458,2844627,2844340,2843163],"length":1,"stats":{"Line":5},"fn_name":null},{"line":22,"address":[2844808],"length":1,"stats":{"Line":0},"fn_name":null},{"line":25,"address":[2843310,2843181,2845067,2845305,2846000,2846100],"length":1,"stats":{"Line":5},"fn_name":null},{"line":26,"address":[2843196,2846070,2843267,2846301,2846996,2847096],"length":1,"stats":{"Line":5},"fn_name":null},{"line":27,"address":[2848091,2847297,2847992,2847066,2843211],"length":1,"stats":{"Line":4},"fn_name":null},{"line":29,"address":[2848311,2848278,2848066],"length":1,"stats":{"Line":2},"fn_name":null},{"line":30,"address":[2848380,2848289,2848347],"length":1,"stats":{"Line":2},"fn_name":null},{"line":31,"address":[2848446,2848358,2848414],"length":1,"stats":{"Line":2},"fn_name":null},{"line":32,"address":[2848483,2848516,2848420],"length":1,"stats":{"Line":2},"fn_name":null},{"line":34,"address":[2848494],"length":1,"stats":{"Line":5},"fn_name":null}],"covered":15,"coverable":16},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","ungroup.rs"],"content":"use ql2::term::TermType;\n\nuse crate::Command;\n\npub(crate) fn new() -\u003e Command {\n    Command::new(TermType::Ungroup)\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::Converter;\n    use crate::spec::{set_up, tear_down, Post};\n    use crate::types::UngroupItem;\n    use crate::Result;\n\n    #[tokio::test]\n    async fn test_ungroup_data() -\u003e Result\u003c()\u003e {\n        let (conn, table, table_name) = set_up(true).await?;\n        let data_obtained: Vec\u003cUngroupItem\u003cString, Post\u003e\u003e = table\n            .group(\"title\")\n            .ungroup()\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(data_obtained.len() == 4);\n\n        tear_down(conn, \u0026table_name).await\n    }\n}\n","traces":[{"line":5,"address":[2308208],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":6,"address":[2308220],"length":1,"stats":{"Line":1},"fn_name":null},{"line":17,"address":[1856519,1856480,1856885,1856933],"length":1,"stats":{"Line":6},"fn_name":"test_ungroup_data"},{"line":18,"address":[5167971,5168036,5168357,5168979,5168189,5168535],"length":1,"stats":{"Line":4},"fn_name":null},{"line":19,"address":[5169648,5168919,5169924,5169376,5169453,5169867,5169968,5170199,5169228],"length":1,"stats":{"Line":6},"fn_name":null},{"line":22,"address":[5168140,5169282,5169581,5168057,5169409],"length":1,"stats":{"Line":5},"fn_name":null},{"line":23,"address":[5169771],"length":1,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[5170088,5170397,5170458],"length":1,"stats":{"Line":2},"fn_name":null},{"line":29,"address":[1856556,1856896,1856616,1856511],"length":1,"stats":{"Line":7},"fn_name":null}],"covered":8,"coverable":9},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","union.rs"],"content":"use ql2::term::TermType;\nuse reql_macros::CommandOptions;\nuse serde::Serialize;\n\nuse crate::arguments::{Args, Interleave};\nuse crate::Command;\n\nuse super::CmdOpts;\n\npub(crate) fn new(args: impl UnionArg) -\u003e Command {\n    let (args, opts) = args.into_union_opts();\n\n    args.add_to_cmd(Command::new(TermType::Union))\n        .with_opts(opts)\n}\n\npub trait UnionArg {\n    fn into_union_opts(self) -\u003e (CmdOpts, UnionOption);\n}\n\nimpl UnionArg for Command {\n    fn into_union_opts(self) -\u003e (CmdOpts, UnionOption) {\n        (CmdOpts::Single(self), Default::default())\n    }\n}\n\nimpl UnionArg for Vec\u003cCommand\u003e {\n    fn into_union_opts(self) -\u003e (CmdOpts, UnionOption) {\n        (CmdOpts::Many(self), Default::default())\n    }\n}\n\nimpl UnionArg for Args\u003c(Command, UnionOption)\u003e {\n    fn into_union_opts(self) -\u003e (CmdOpts, UnionOption) {\n        (CmdOpts::Single(self.0 .0), self.0 .1)\n    }\n}\n\nimpl UnionArg for Args\u003c(Vec\u003cCommand\u003e, UnionOption)\u003e {\n    fn into_union_opts(self) -\u003e (CmdOpts, UnionOption) {\n        (CmdOpts::Many(self.0 .0), self.0 .1)\n    }\n}\n\n#[derive(Debug, Clone, Serialize, Default, PartialEq, PartialOrd, CommandOptions)]\npub struct UnionOption {\n    /// The optional `interleave` argument controls\n    /// how the sequences will be merged:\n    /// - `Interleave::Bool(true)`: results will be mixed together;\n    /// this is the fastest setting, but ordering of elements is not guaranteed.\n    /// (This is the default.)\n    /// - `Interleave::Bool(false)`: input sequences will be appended to one another, left to right.\n    /// - `Interleave::FieldName(field_name)`: a string will be taken as the name of a field\n    /// to perform a merge-sort on. The input sequences must be ordered **before** being passed to `union`.\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub interleave: Option\u003cInterleave\u003e,\n}\n\n#[cfg(test)]\nmod tests {\n    use serde::{Deserialize, Serialize};\n    use serde_json::json;\n    use uuid::Uuid;\n\n    use crate::prelude::*;\n    use crate::spec::{set_up, tear_down};\n    use crate::{r, Result};\n\n    #[derive(Debug, Serialize, Deserialize, PartialEq, Eq)]\n    struct AuthorPost {\n        id: Option\u003cu8\u003e,\n        first_name: Option\u003cString\u003e,\n        last_name: Option\u003cString\u003e,\n        title: Option\u003cString\u003e,\n        content: Option\u003cString\u003e,\n        view: Option\u003cu8\u003e,\n    }\n\n    #[tokio::test]\n    async fn test_union_data() -\u003e Result\u003c()\u003e {\n        let authors_data = json!([\n            {\"id\": 1, \"first_name\": \"john\", \"last_name\": \"doe\"},\n            {\"id\": 2, \"first_name\": \"juan\", \"last_name\": \"don\"},\n            {\"id\": 3, \"first_name\": \"jean\", \"last_name\": \"dupont\"}\n        ]);\n        let table_name2 = Uuid::new_v4().to_string();\n        let (conn, table, table_name) = set_up(true).await?;\n\n        r.table_create(table_name2.as_str()).run(\u0026conn).await?;\n        r.table(table_name2.as_str())\n            .insert(authors_data)\n            .run(\u0026conn)\n            .await?;\n\n        let data_obtained: Vec\u003cAuthorPost\u003e = table\n            .union(r.table(table_name2.as_str()))\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(data_obtained.len() \u003e 0);\n\n        r.table_drop(table_name2.as_str()).run(\u0026conn).await?;\n        tear_down(conn, \u0026table_name).await\n    }\n}\n","traces":[{"line":10,"address":[2588457,2588403,2588000],"length":1,"stats":{"Line":1},"fn_name":"new\u003creql_rust::proto::Command\u003e"},{"line":11,"address":[2588017],"length":1,"stats":{"Line":1},"fn_name":null},{"line":13,"address":[2588369,2588396,2588169],"length":1,"stats":{"Line":2},"fn_name":null},{"line":14,"address":[2588321],"length":1,"stats":{"Line":1},"fn_name":null},{"line":22,"address":[2176064,2176282],"length":1,"stats":{"Line":1},"fn_name":"into_union_opts"},{"line":23,"address":[2176115],"length":1,"stats":{"Line":1},"fn_name":null},{"line":28,"address":[3398188,3397984],"length":1,"stats":{"Line":0},"fn_name":"into_union_opts"},{"line":29,"address":[3398000],"length":1,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[2663728],"length":1,"stats":{"Line":0},"fn_name":"into_union_opts"},{"line":35,"address":[2663749],"length":1,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[2663936],"length":1,"stats":{"Line":0},"fn_name":"into_union_opts"},{"line":41,"address":[2663956],"length":1,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[5688789,5688384,5688837,5688423],"length":1,"stats":{"Line":6},"fn_name":"test_union_data"},{"line":81,"address":[4627582,4629356,4629143,4629673,4629858,4628688,4628158,4629943,4630128,4627375,4627973,4627888,4627268,4629563,4628578,4627637,4627703,4628371,4628958,4628873,4626566],"length":1,"stats":{"Line":12},"fn_name":null},{"line":86,"address":[4630360,4630435],"length":1,"stats":{"Line":2},"fn_name":null},{"line":87,"address":[4626726,4630467,4630535,4631112,4627099],"length":1,"stats":{"Line":4},"fn_name":null},{"line":89,"address":[4626747,4627048,4631344,4631082],"length":1,"stats":{"Line":4},"fn_name":null},{"line":90,"address":[4632421,4632194,4632263,4632705,4632298,4632913,4632090,4632504],"length":1,"stats":{"Line":7},"fn_name":null},{"line":91,"address":[4632209],"length":1,"stats":{"Line":1},"fn_name":null},{"line":92,"address":[4626997,4632278,4632632,4632321,4626768,4632460],"length":1,"stats":{"Line":6},"fn_name":null},{"line":93,"address":[4632795,4632943],"length":1,"stats":{"Line":1},"fn_name":null},{"line":95,"address":[4633131,4634204,4633881,4633461,4633961,4633206,4633662,4633938,4633378,4632983],"length":1,"stats":{"Line":7},"fn_name":null},{"line":96,"address":[4633032,4633178,4633231,4633213],"length":1,"stats":{"Line":2},"fn_name":null},{"line":97,"address":[4633281,4633417,4633186,4626789,4626946,4633589],"length":1,"stats":{"Line":6},"fn_name":null},{"line":98,"address":[4633785],"length":1,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[4634090,4634321,4634366],"length":1,"stats":{"Line":2},"fn_name":null},{"line":104,"address":[4626895,4634342,4626810,4634446],"length":1,"stats":{"Line":4},"fn_name":null},{"line":105,"address":[4635888,4635715,4636024,4626828,4635591,4635473,4635774],"length":1,"stats":{"Line":7},"fn_name":null}],"covered":21,"coverable":28},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","upcase.rs"],"content":"use ql2::term::TermType;\n\nuse crate::Command;\n\npub(crate) fn new() -\u003e Command {\n    Command::new(TermType::Upcase)\n}\n\n// TODO write test\n","traces":[{"line":5,"address":[2435648],"length":1,"stats":{"Line":0},"fn_name":"new"},{"line":6,"address":[2435660],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":2},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","update.rs"],"content":"use ql2::term::TermType;\nuse reql_macros::CommandOptions;\nuse serde::Serialize;\n\nuse crate::arguments::{Args, Durability, ReturnChanges};\nuse crate::Command;\n\nuse super::func::Func;\n\npub(crate) fn new(args: impl UpdateArg) -\u003e Command {\n    let (arg, opts) = args.into_update_opts();\n\n    Command::new(TermType::Update).with_arg(arg).with_opts(opts)\n}\n\npub trait UpdateArg {\n    fn into_update_opts(self) -\u003e (Command, UpdateOption);\n}\n\nimpl\u003cT\u003e UpdateArg for T\nwhere\n    T: Serialize,\n{\n    fn into_update_opts(self) -\u003e (Command, UpdateOption) {\n        (Command::from_json(self), Default::default())\n    }\n}\n\nimpl UpdateArg for Command {\n    fn into_update_opts(self) -\u003e (Command, UpdateOption) {\n        (self, Default::default())\n    }\n}\n\nimpl UpdateArg for Func {\n    fn into_update_opts(self) -\u003e (Command, UpdateOption) {\n        (self.0, Default::default())\n    }\n}\n\nimpl\u003cT\u003e UpdateArg for Args\u003c(T, UpdateOption)\u003e\nwhere\n    T: Serialize,\n{\n    fn into_update_opts(self) -\u003e (Command, UpdateOption) {\n        (Command::from_json(self.0 .0), self.0 .1)\n    }\n}\n\nimpl UpdateArg for Args\u003c(Command, UpdateOption)\u003e {\n    fn into_update_opts(self) -\u003e (Command, UpdateOption) {\n        (self.0 .0, self.0 .1)\n    }\n}\n\nimpl UpdateArg for Args\u003c(Func, UpdateOption)\u003e {\n    fn into_update_opts(self) -\u003e (Command, UpdateOption) {\n        (self.0 .0 .0, self.0 .1)\n    }\n}\n\n#[derive(Debug, Clone, Copy, Serialize, Default, PartialEq, PartialOrd, CommandOptions)]\npub struct UpdateOption {\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub durability: Option\u003cDurability\u003e,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub return_changes: Option\u003cReturnChanges\u003e,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub non_atomic: Option\u003cbool\u003e,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub ignore_write_hook: Option\u003cbool\u003e,\n}\n\n#[cfg(test)]\nmod tests {\n    use serde_json::json;\n\n    use crate::prelude::*;\n    use crate::spec::*;\n    use crate::types::MutationResponse;\n    use crate::Result;\n\n    #[tokio::test]\n    async fn test_update_docs() -\u003e Result\u003c()\u003e {\n        let (conn, table, table_name) = set_up(true).await?;\n        let response: MutationResponse = table\n            .get(1)\n            .update(json!({\"view\": 0}))\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(response.replaced == 1);\n\n        tear_down(conn, \u0026table_name).await\n    }\n}\n","traces":[{"line":10,"address":[5013253,5013226,5012880],"length":1,"stats":{"Line":1},"fn_name":"new\u003cserde_json::value::Value\u003e"},{"line":11,"address":[5012897],"length":1,"stats":{"Line":1},"fn_name":null},{"line":13,"address":[5013022,5013096],"length":1,"stats":{"Line":2},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":25,"address":[2333793],"length":1,"stats":{"Line":1},"fn_name":null},{"line":30,"address":[2176481,2176320],"length":1,"stats":{"Line":0},"fn_name":"into_update_opts"},{"line":31,"address":[4591250],"length":1,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[2824257,2824096],"length":1,"stats":{"Line":0},"fn_name":"into_update_opts"},{"line":37,"address":[2742482],"length":1,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[2664160],"length":1,"stats":{"Line":0},"fn_name":"into_update_opts"},{"line":52,"address":[2664181],"length":1,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[2664272],"length":1,"stats":{"Line":0},"fn_name":"into_update_opts"},{"line":58,"address":[2664293],"length":1,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[2950394,2949952,2950166,2950686,2949984,2949961,2950053],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":85,"address":[2951134,2950519,2950115,2950351,2950196,2950697],"length":1,"stats":{"Line":4},"fn_name":null},{"line":86,"address":[2951081,2952324,2952129,2952644,2951822,2951893,2952880,2952543,2952052,2952600],"length":1,"stats":{"Line":7},"fn_name":null},{"line":88,"address":[2951499,2951340,2951391,2951706,2951869,2951908],"length":1,"stats":{"Line":3},"fn_name":null},{"line":89,"address":[2950217,2952085,2950302,2952257,2951961],"length":1,"stats":{"Line":5},"fn_name":null},{"line":90,"address":[2952447],"length":1,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[2952761,2953083],"length":1,"stats":{"Line":1},"fn_name":null},{"line":96,"address":[2582044,2582384,2582104,2581999],"length":1,"stats":{"Line":7},"fn_name":null}],"covered":12,"coverable":23},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","uuid.rs"],"content":"use ql2::term::TermType;\n\nuse crate::Command;\n\npub(crate) fn new(args: impl UuidArg) -\u003e Command {\n    let mut command = Command::new(TermType::Uuid);\n\n    if let Some(arg) = args.into_uui_opts() {\n        command = command.with_arg(arg)\n    }\n\n    command\n}\n\npub trait UuidArg {\n    fn into_uui_opts(self) -\u003e Option\u003cCommand\u003e;\n}\n\nimpl UuidArg for () {\n    fn into_uui_opts(self) -\u003e Option\u003cCommand\u003e {\n        None\n    }\n}\n\nimpl UuidArg for \u0026str {\n    fn into_uui_opts(self) -\u003e Option\u003cCommand\u003e {\n        Some(Command::from_json(self))\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::Converter;\n    use crate::{r, Result};\n\n    #[tokio::test]\n    async fn test_uuid_ops() -\u003e Result\u003c()\u003e {\n        let conn = r.connection().connect().await?;\n        let response: String = r.uuid(()).run(\u0026conn).await?.unwrap().parse()?;\n\n        assert!(!response.is_empty());\n\n        Ok(())\n    }\n}\n","traces":[{"line":5,"address":[1693616,1694143],"length":1,"stats":{"Line":1},"fn_name":"new\u003c()\u003e"},{"line":6,"address":[1693728,1693636],"length":1,"stats":{"Line":2},"fn_name":null},{"line":8,"address":[1693794,1694067,1693736],"length":1,"stats":{"Line":2},"fn_name":null},{"line":9,"address":[1694041,1693900],"length":1,"stats":{"Line":0},"fn_name":null},{"line":12,"address":[1694092],"length":1,"stats":{"Line":1},"fn_name":null},{"line":20,"address":[2748624],"length":1,"stats":{"Line":1},"fn_name":"into_uui_opts"},{"line":21,"address":[2748628],"length":1,"stats":{"Line":1},"fn_name":null},{"line":26,"address":[2748640],"length":1,"stats":{"Line":0},"fn_name":"into_uui_opts"},{"line":27,"address":[2748672],"length":1,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[2582464,2582503,2582917,2582869],"length":1,"stats":{"Line":6},"fn_name":"test_uuid_ops"},{"line":38,"address":[2836986,2837247,2836565,2836531,2836636,2836797],"length":1,"stats":{"Line":4},"fn_name":null},{"line":39,"address":[2838175,2837475,2837237,2836580,2838310],"length":1,"stats":{"Line":4},"fn_name":null},{"line":41,"address":[2838532,2838296,2838571],"length":1,"stats":{"Line":2},"fn_name":null},{"line":43,"address":[2582495,2582880,2582600,2582540],"length":1,"stats":{"Line":5},"fn_name":null}],"covered":11,"coverable":14},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","values.rs"],"content":"use ql2::term::TermType;\n\nuse crate::Command;\n\npub(crate) fn new() -\u003e Command {\n    Command::new(TermType::Values)\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::spec::{set_up, tear_down};\n    use crate::Result;\n\n    #[tokio::test]\n    async fn test_values_fields() -\u003e Result\u003c()\u003e {\n        let (conn, table, table_name) = set_up(true).await?;\n        let data_obtained = table.get(1).values().run(\u0026conn).await?.unwrap();\n\n        assert!(data_obtained.is_array());\n\n        tear_down(conn, \u0026table_name).await\n    }\n}\n","traces":[{"line":5,"address":[2155792],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":6,"address":[2155804],"length":1,"stats":{"Line":1},"fn_name":null},{"line":15,"address":[1706294,1706520,1706812,1706197,1706096,1706128,1706105],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":16,"address":[1706477,1707260,1706324,1706259,1706645,1706823],"length":1,"stats":{"Line":4},"fn_name":null},{"line":17,"address":[1706428,1707207,1706345,1707509],"length":1,"stats":{"Line":4},"fn_name":null},{"line":19,"address":[1708452,1708398,1708307],"length":1,"stats":{"Line":2},"fn_name":null},{"line":21,"address":[1708645,1708412,1708705,1706363,1708914,1708780,1708521],"length":1,"stats":{"Line":7},"fn_name":null}],"covered":7,"coverable":7},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","wait.rs"],"content":"use ql2::term::TermType;\nuse reql_macros::CommandOptions;\nuse serde::Serialize;\n\nuse crate::arguments::{Args, WaitFor};\nuse crate::Command;\n\npub(crate) fn new(args: impl WaitArg) -\u003e Command {\n    let (args, opts) = args.into_wait_opts();\n    let mut command = Command::new(TermType::Wait);\n\n    if let Some(arg) = args {\n        command = command.with_arg(arg)\n    }\n\n    command.with_opts(opts)\n}\n\npub trait WaitArg {\n    fn into_wait_opts(self) -\u003e (Option\u003cCommand\u003e, WaitOption);\n}\n\nimpl WaitArg for () {\n    fn into_wait_opts(self) -\u003e (Option\u003cCommand\u003e, WaitOption) {\n        Default::default()\n    }\n}\n\nimpl WaitArg for WaitOption {\n    fn into_wait_opts(self) -\u003e (Option\u003cCommand\u003e, WaitOption) {\n        (None, self)\n    }\n}\n\nimpl WaitArg for Command {\n    fn into_wait_opts(self) -\u003e (Option\u003cCommand\u003e, WaitOption) {\n        (Some(self), Default::default())\n    }\n}\n\nimpl WaitArg for Args\u003c(Command, WaitOption)\u003e {\n    fn into_wait_opts(self) -\u003e (Option\u003cCommand\u003e, WaitOption) {\n        (Some(self.0 .0), self.0 .1)\n    }\n}\n\n#[derive(Debug, Copy, Clone, Serialize, Default, PartialEq, PartialOrd, CommandOptions)]\npub struct WaitOption {\n    /// a enum indicating a table status to wait on before returning\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub wait_for: Option\u003cWaitFor\u003e,\n    /// a number indicating maximum time, in seconds,\n    /// to wait for the table to be ready.\n    /// If this value is exceeded, a ReqlRuntimeError will be thrown.\n    /// A value of0 means no timeout. The default is 0 (no timeout).\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub timeout: Option\u003cf64\u003e,\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::Converter;\n    use crate::spec::{set_up, tear_down};\n    use crate::types::WaitResponse;\n    use crate::Result;\n\n    #[tokio::test]\n    async fn test_wait_table() -\u003e Result\u003c()\u003e {\n        let (conn, table, table_name) = set_up(true).await?;\n        let response: WaitResponse = table.wait(()).run(\u0026conn).await?.unwrap().parse()?;\n\n        assert!(response.ready == 1);\n\n        tear_down(conn, \u0026table_name).await\n    }\n}\n","traces":[{"line":8,"address":[7656256,7656229,7655696],"length":1,"stats":{"Line":1},"fn_name":"new\u003c()\u003e"},{"line":9,"address":[7655713],"length":1,"stats":{"Line":1},"fn_name":null},{"line":10,"address":[7655801],"length":1,"stats":{"Line":1},"fn_name":null},{"line":12,"address":[7655895,7656185],"length":1,"stats":{"Line":1},"fn_name":null},{"line":13,"address":[7656010,7656159],"length":1,"stats":{"Line":0},"fn_name":null},{"line":16,"address":[7656100],"length":1,"stats":{"Line":1},"fn_name":null},{"line":24,"address":[7656320],"length":1,"stats":{"Line":1},"fn_name":"into_wait_opts"},{"line":25,"address":[2137868],"length":1,"stats":{"Line":1},"fn_name":null},{"line":30,"address":[2137888],"length":1,"stats":{"Line":0},"fn_name":"into_wait_opts"},{"line":31,"address":[2137908],"length":1,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[2176512,2176724],"length":1,"stats":{"Line":0},"fn_name":"into_wait_opts"},{"line":37,"address":[2176564],"length":1,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[2664384],"length":1,"stats":{"Line":0},"fn_name":"into_wait_opts"},{"line":43,"address":[2664406],"length":1,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[4774304,4774757,4774343,4774709],"length":1,"stats":{"Line":6},"fn_name":"test_wait_table"},{"line":69,"address":[5399415,5398637,5398419,5398484,5398805,5398983],"length":1,"stats":{"Line":4},"fn_name":null},{"line":70,"address":[5399367,5400381,5398505,5398588,5400470,5399672],"length":1,"stats":{"Line":5},"fn_name":null},{"line":72,"address":[5400450,5400769],"length":1,"stats":{"Line":1},"fn_name":null},{"line":74,"address":[4774720,4774335,4774380,4774440],"length":1,"stats":{"Line":7},"fn_name":null}],"covered":12,"coverable":19},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","with_fields.rs"],"content":"use ql2::term::TermType;\nuse serde::Serialize;\n\nuse crate::Command;\n\npub(crate) fn new(fields: impl Serialize) -\u003e Command {\n    Command::new(TermType::WithFields).with_arg(Command::from_json(fields))\n}\n\n#[cfg(test)]\nmod tests {\n    use serde::{Deserialize, Serialize};\n\n    use crate::prelude::Converter;\n    use crate::spec::{set_up, tear_down, Post};\n    use crate::Result;\n\n    #[derive(Debug, Serialize, Deserialize, PartialEq, Eq, PartialOrd, Ord)]\n    struct InnerPost {\n        id: u8,\n        title: String,\n    }\n\n    #[tokio::test]\n    async fn test_with_fields() -\u003e Result\u003c()\u003e {\n        let data: Vec\u003cInnerPost\u003e = Post::get_many_data()\n            .into_iter()\n            .map(|post| InnerPost {\n                id: post.id,\n                title: post.title,\n            })\n            .collect();\n        let (conn, table, table_name) = set_up(true).await?;\n        let mut data_obtained: Vec\u003cInnerPost\u003e = table\n            .with_fields([\"id\", \"title\"])\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        data_obtained.sort_by(|a, b| a.id.cmp(\u0026b.id));\n\n        assert!(data_obtained == data);\n\n        tear_down(conn, \u0026table_name).await\n    }\n}\n","traces":[{"line":6,"address":[3398509,3398224],"length":1,"stats":{"Line":1},"fn_name":"new\u003c[\u0026str; 2]\u003e"},{"line":7,"address":[3398245,3398344,3398499],"length":1,"stats":{"Line":2},"fn_name":null},{"line":25,"address":[3010053,3010789,3009961,3009952,3009984,3010145,3010371],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":26,"address":[3010115,3010496],"length":1,"stats":{"Line":2},"fn_name":null},{"line":28,"address":[3013707,3013648],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":29,"address":[3013678],"length":1,"stats":{"Line":1},"fn_name":null},{"line":30,"address":[3013681],"length":1,"stats":{"Line":1},"fn_name":null},{"line":33,"address":[3010800,3010328,3010562,3011319,3010175,3010625],"length":1,"stats":{"Line":4},"fn_name":null},{"line":34,"address":[3012256,3012212,3012492,3011664,3012155,3011309,3011547,3011936,3011741,3011209],"length":1,"stats":{"Line":7},"fn_name":null},{"line":35,"address":[3011239],"length":1,"stats":{"Line":1},"fn_name":null},{"line":36,"address":[3010279,3010196,3011570,3011869,3011697,3011527],"length":1,"stats":{"Line":6},"fn_name":null},{"line":37,"address":[3012059],"length":1,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[3012376,3012753,3013760,3013805],"length":1,"stats":{"Line":4},"fn_name":"{closure#1}"},{"line":43,"address":[3012845,3012768],"length":1,"stats":{"Line":1},"fn_name":null},{"line":45,"address":[3010214,3012918,3013098,3012804,3013042,3013178,3013308],"length":1,"stats":{"Line":7},"fn_name":null}],"covered":14,"coverable":15},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","without.rs"],"content":"use ql2::term::TermType;\nuse serde::Serialize;\n\nuse crate::arguments::Args;\nuse crate::Command;\n\nuse super::CmdOpts;\n\npub(crate) fn new(args: impl WithoutArg) -\u003e Command {\n    args.into_without_opts()\n        .add_to_cmd(Command::new(TermType::Without))\n}\n\npub trait WithoutArg {\n    fn into_without_opts(self) -\u003e CmdOpts;\n}\n\nimpl\u003cT\u003e WithoutArg for T\nwhere\n    T: Serialize,\n{\n    fn into_without_opts(self) -\u003e CmdOpts {\n        CmdOpts::Single(Command::from_json(self))\n    }\n}\n\nimpl WithoutArg for Command {\n    fn into_without_opts(self) -\u003e CmdOpts {\n        CmdOpts::Single(self)\n    }\n}\n\nimpl\u003cT\u003e WithoutArg for Args\u003cT\u003e\nwhere\n    T: IntoIterator\u003cItem = Command\u003e,\n{\n    fn into_without_opts(self) -\u003e CmdOpts {\n        CmdOpts::Many(self.0.into_iter().collect())\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use serde::{Deserialize, Serialize};\n\n    use crate::prelude::Converter;\n    use crate::spec::{set_up, tear_down, Post};\n    use crate::Result;\n\n    #[derive(Debug, Serialize, Deserialize, PartialEq, Eq)]\n    struct InnerPost {\n        id: u8,\n        title: String,\n    }\n\n    #[tokio::test]\n    async fn test_without_data() -\u003e Result\u003c()\u003e {\n        let data = Post::get_one_data();\n        let data = InnerPost {\n            id: data.id,\n            title: data.title,\n        };\n        let (conn, table, table_name) = set_up(true).await?;\n        let data_obtained: InnerPost = table\n            .get(1)\n            .without([\"content\", \"view\"])\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(data_obtained == data);\n\n        tear_down(conn, \u0026table_name).await\n    }\n}\n","traces":[{"line":9,"address":[2842395,2842422,2842655,2842448,2842176,2842628],"length":1,"stats":{"Line":2},"fn_name":"new\u003c[\u0026str; 2]\u003e"},{"line":10,"address":[2842193,2842481,2842579,2842346],"length":1,"stats":{"Line":4},"fn_name":null},{"line":11,"address":[2842648,2842415,2842274,2842507,2842379,2842612],"length":1,"stats":{"Line":4},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":28,"address":[2176752],"length":1,"stats":{"Line":0},"fn_name":"into_without_opts"},{"line":29,"address":[2176768],"length":1,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[5509737,5509728,5509829,5510557,5510143,5509760,5509913],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":58,"address":[5509891],"length":1,"stats":{"Line":1},"fn_name":null},{"line":60,"address":[5510260],"length":1,"stats":{"Line":1},"fn_name":null},{"line":61,"address":[5510263],"length":1,"stats":{"Line":1},"fn_name":null},{"line":63,"address":[7934057],"length":1,"stats":{"Line":4},"fn_name":null},{"line":64,"address":[5511961,5512245,5511904,5511413,5512005,5510929,5511293,5511490,5511685,5511258],"length":1,"stats":{"Line":7},"fn_name":null},{"line":66,"address":[5511180],"length":1,"stats":{"Line":1},"fn_name":null},{"line":67,"address":[5511446,5511618,5511316,5511273,5510049,5509964],"length":1,"stats":{"Line":6},"fn_name":null},{"line":68,"address":[5511808],"length":1,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[5512571,5512131,5512626],"length":1,"stats":{"Line":2},"fn_name":null},{"line":74,"address":[5513122,5512699,5512823,5512879,5512989,5509982,5512585],"length":1,"stats":{"Line":7},"fn_name":null}],"covered":15,"coverable":20},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","year.rs"],"content":"use ql2::term::TermType;\n\nuse crate::Command;\n\npub(crate) fn new() -\u003e Command {\n    Command::new(TermType::Year)\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::Converter;\n    use crate::{r, Result};\n\n    #[tokio::test]\n    async fn test_year_ops() -\u003e Result\u003c()\u003e {\n        let conn = r.connection().connect().await?;\n\n        let year = r.now().year();\n        let year1 = year.clone().value();\n        let year2: i32 = year.cmd().run(\u0026conn).await?.unwrap().parse()?;\n\n        assert!(year1 == year2);\n\n        Ok(())\n    }\n}\n","traces":[{"line":5,"address":[2155840],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":6,"address":[2155852],"length":1,"stats":{"Line":1},"fn_name":null},{"line":15,"address":[2804256,2804661,2804295,2804709],"length":1,"stats":{"Line":6},"fn_name":"test_year_ops"},{"line":16,"address":[5521047,5521208,5520928,5520974,5521397,5521658],"length":1,"stats":{"Line":4},"fn_name":null},{"line":18,"address":[5521904,5521648],"length":1,"stats":{"Line":2},"fn_name":null},{"line":19,"address":[5521995,5521932],"length":1,"stats":{"Line":2},"fn_name":null},{"line":20,"address":[5522039,5522934,5522839,5522126,5520989],"length":1,"stats":{"Line":4},"fn_name":null},{"line":22,"address":[5522913,5523127],"length":1,"stats":{"Line":1},"fn_name":null},{"line":24,"address":[2804332,2804672,2804287,2804392],"length":1,"stats":{"Line":5},"fn_name":null}],"covered":9,"coverable":9},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","zip.rs"],"content":"use ql2::term::TermType;\n\nuse crate::Command;\n\npub(crate) fn new() -\u003e Command {\n    Command::new(TermType::Zip)\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::Converter;\n    use crate::spec::{Comment, CommentWithPost};\n    use crate::{args, Result};\n\n    #[tokio::test]\n    pub async fn test_zip_ops() -\u003e Result\u003c()\u003e {\n        let data = CommentWithPost {\n            id: 1,\n            text: \"comment4\".to_string(),\n            post_id: 1,\n            title: \"title1\".to_string(),\n            content: Some(\"content1\".to_string()),\n            view: 10,\n        };\n        let (conn, comment_table, post_table, comment_tablename, post_tablename) =\n            Comment::own_set_up().await?;\n\n        let response: Vec\u003cCommentWithPost\u003e = comment_table\n            .eq_join(args!(\"post_id\", post_table))\n            .zip()\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(response.len() \u003e 0);\n        assert_eq!(response.first(), Some(\u0026data));\n\n        Comment::own_tear_down(conn, comment_tablename, post_tablename).await\n    }\n}\n","traces":[{"line":5,"address":[2155888],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":6,"address":[2155900],"length":1,"stats":{"Line":1},"fn_name":null},{"line":16,"address":[1972624,1972592,1972601,1972693,1972793,1973021,1973225],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":19,"address":[1972763],"length":1,"stats":{"Line":1},"fn_name":null},{"line":21,"address":[1973130],"length":1,"stats":{"Line":1},"fn_name":null},{"line":22,"address":[1973198,1973288],"length":1,"stats":{"Line":2},"fn_name":null},{"line":25,"address":[1974360,1972978,1972823,1973411,1973496],"length":1,"stats":{"Line":4},"fn_name":null},{"line":28,"address":[1974150,1974350,1975563,1974611,1974734,1975332,1974576,1975009,1975228,1975285,1974811],"length":1,"stats":{"Line":8},"fn_name":null},{"line":29,"address":[1974204],"length":1,"stats":{"Line":1},"fn_name":null},{"line":31,"address":[1974591,1972927,1974767,1974634,1974939,1972844],"length":1,"stats":{"Line":6},"fn_name":null},{"line":32,"address":[1975132],"length":1,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[1975894,1975936,1975452],"length":1,"stats":{"Line":2},"fn_name":null},{"line":37,"address":[1975915,1976227,1975978],"length":1,"stats":{"Line":2},"fn_name":null},{"line":39,"address":[1972862,1976122,1976619,1976413,1976489],"length":1,"stats":{"Line":7},"fn_name":null}],"covered":13,"coverable":14},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd.rs"],"content":"pub mod add;\npub mod and;\npub mod append;\npub mod args;\npub mod asc;\npub mod avg;\npub mod between;\npub mod binary;\npub mod bit_and;\npub mod bit_not;\npub mod bit_or;\npub mod bit_sal;\npub mod bit_sar;\npub mod bit_xor;\npub mod bracket;\npub mod branch;\npub mod ceil;\npub mod change_at;\npub mod changes;\npub mod circle;\npub mod coerce_to;\npub mod concat_map;\npub mod config;\npub mod connect;\npub mod contains;\npub mod count;\npub mod date;\npub mod day;\npub mod day_of_week;\npub mod day_of_year;\npub mod db;\npub mod db_create;\npub mod db_drop;\npub mod db_list;\npub mod default;\npub mod delete;\npub mod delete_at;\npub mod desc;\npub mod difference;\npub mod distance;\npub mod distinct;\npub mod div;\npub mod do_;\npub mod downcase;\npub mod during;\npub mod epoch_time;\npub mod eq;\npub mod eq_join;\npub mod error;\npub mod expr;\npub mod fill;\npub mod filter;\npub mod floor;\npub mod fold;\npub mod for_each;\npub(crate) mod func;\npub mod ge;\npub mod geojson;\npub mod get;\npub mod get_all;\npub mod get_field;\npub mod get_intersecting;\npub mod get_nearest;\npub mod get_write_hook;\npub mod grant;\npub mod group;\npub mod gt;\npub mod has_fields;\npub mod hash_map;\npub mod hours;\npub mod http;\npub mod in_timezone;\npub mod includes;\npub mod index_create;\npub mod index_drop;\npub mod index_list;\npub mod index_rename;\npub mod index_status;\npub mod index_wait;\npub mod info;\npub mod inner_join;\npub mod insert;\npub mod insert_at;\npub mod intersects;\npub mod is_empty;\npub mod iso8601;\npub mod js;\npub mod json;\npub mod keys;\npub mod le;\npub mod limit;\npub mod line;\npub mod literal;\npub mod lt;\npub mod map;\npub mod match_;\npub mod max;\npub mod merge;\npub mod min;\npub mod minutes;\npub mod month;\npub mod mul;\npub mod ne;\npub mod not;\npub mod now;\npub mod nth;\npub mod object;\npub mod offsets_of;\npub mod or;\npub mod order_by;\npub mod outer_join;\npub mod pluck;\npub mod point;\npub mod polygon;\npub mod polygon_sub;\npub mod prepend;\npub mod random;\npub mod range;\npub mod rebalance;\npub mod reconfigure;\npub mod reduce;\npub mod rem;\npub mod replace;\npub mod round;\npub mod run;\npub mod sample;\npub mod seconds;\npub mod set_difference;\npub mod set_insert;\npub mod set_intersection;\npub mod set_union;\npub mod set_write_hook;\npub mod skip;\npub mod slice;\npub mod splice_at;\npub mod split;\npub mod status;\npub mod sub;\npub mod sum;\npub mod sync;\npub mod table;\npub mod table_create;\npub mod table_drop;\npub mod table_list;\npub mod time;\npub mod time_of_day;\npub mod timezone;\npub mod to_epoch_time;\npub mod to_geojson;\npub mod to_iso8601;\npub mod to_json;\npub mod type_of;\npub mod ungroup;\npub mod union;\npub mod upcase;\npub mod update;\npub mod uuid;\npub mod values;\npub mod wait;\npub mod with_fields;\npub mod without;\npub mod year;\npub mod zip;\n\nuse std::borrow::Cow;\nuse std::ops::{BitAnd, BitOr, BitXor};\nuse std::str;\n\nuse ::time::UtcOffset;\nuse async_native_tls::TlsStream;\nuse async_net::TcpStream;\nuse futures::stream::Stream;\nuse futures::TryStreamExt;\nuse regex::Regex;\nuse serde::Serialize;\nuse serde_json::Value;\n\nuse crate::arguments::Permission;\nuse crate::prelude::Func;\nuse crate::Command;\nuse crate::Result;\n\npub trait StaticString {\n    fn static_string(self) -\u003e Cow\u003c'static, str\u003e;\n}\n\n#[derive(Debug)]\npub(crate) struct TcpStreamConnection {\n    pub(crate) stream: TcpStream,\n    pub(crate) tls_stream: Option\u003cTlsStream\u003cTcpStream\u003e\u003e,\n}\n\nimpl StaticString for \u0026'static str {\n    fn static_string(self) -\u003e Cow\u003c'static, str\u003e {\n        Cow::from(self)\n    }\n}\n\nimpl StaticString for String {\n    fn static_string(self) -\u003e Cow\u003c'static, str\u003e {\n        Cow::from(self)\n    }\n}\n\nimpl StaticString for \u0026Cow\u003c'static, str\u003e {\n    fn static_string(self) -\u003e Cow\u003c'static, str\u003e {\n        match self {\n            Cow::Borrowed(string) =\u003e Cow::Borrowed(*string),\n            Cow::Owned(string) =\u003e Cow::Owned(string.to_owned()),\n        }\n    }\n}\n\nimpl\u003c'a\u003e Command {\n    pub fn changes(self, args: impl changes::ChangesArg) -\u003e Self {\n        changes::new(args).with_parent(self)\n    }\n\n    /// Create a table.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// db.table_create(table_name) → response\n    /// db.table_create(args!(table_name, options)) → response\n    /// ```\n    ///\n    /// Where:\n    /// - table_name: \u0026str | String | Cow\u003c'static, str\u003e\n    /// - options: [TableCreateOption](crate::cmd::table_create::TableCreateOption)\n    /// - response: [DbResponse](crate::types::DbResponse)\n    ///\n    /// # Description\n    ///\n    /// A RethinkDB table is a collection of JSON documents.\n    ///\n    /// If a table with the same name already exists,\n    /// the command throws `ReqlOpFailedError`.\n    ///\n    /// ```text\n    /// Note: Only alphanumeric characters and underscores are valid for the table name.\n    ///\n    /// Invoking table_create without specifying a database using db creates a table in\n    /// the database specified in connect, or test if no database was specified.\n    /// ```\n    ///\n    /// The [data type](https://rethinkdb.com/docs/data-types/) of a primary key is usually a string\n    /// (like a UUID) or a number, but it can also be a time, binary object, boolean or an array.\n    /// Data types can be mixed in the primary key field, but all values must be unique. Using an array\n    /// as a primary key causes the primary key to behave like a compound index; read the documentation on\n    /// [compound secondary indexes](https://rethinkdb.com/docs/secondary-indexes/python/#compound-indexes)\n    /// for more information, as it applies to primary keys as well.\n    /// (Note that the primary index still only covers a single field,\n    /// while compound secondary indexes can cover multiple fields in a single index.)\n    /// Primary keys cannot be objects.\n    ///\n    /// Tables will be available for writing when the command returns.\n    ///\n    /// ## Examples\n    ///\n    /// Create a table named ‘simbad’ with the default settings.\n    ///\n    /// ```\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::types::DbResponse;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: DbResponse = r.db(\"test\")\n    ///         .table_create(\"simbad\")\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response.tables_created \u003e Some(0));\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Create a table named ‘simbad’ using the field ‘name’ as primary key.\n    ///\n    /// ```\n    /// use reql_rust::cmd::table_create::TableCreateOption;\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::types::DbResponse;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let table_create_option = TableCreateOption::default().primary_key(\"name\");\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: DbResponse = r.db(\"test\")\n    ///         .table_create(args!(\"simbad\", table_create_option))\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response.tables_created \u003e Some(0));\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Create a table set up for two shards and three replicas per shard.\n    /// This requires three available servers.\n    ///\n    /// ```\n    /// use reql_rust::arguments::Replicas;\n    /// use reql_rust::cmd::table_create::TableCreateOption;\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::types::DbResponse;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let table_create_option = TableCreateOption::default()\n    ///         .shards(2)\n    ///         .replicas(Replicas::Int(3));\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: DbResponse = r.db(\"test\")\n    ///         .table_create(args!(\"simbad\", table_create_option))\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response.tables_created \u003e Some(0));\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// Read [Sharding and replication](https://rethinkdb.com/docs/sharding-and-replication/)\n    /// for a complete discussion of the subject, including advanced topics.\n    ///\n    /// # Related commands\n    /// - [table_drop](Self::table_drop)\n    /// - [table_list](Self::table_list)\n    pub fn table_create(self, args: impl table_create::TableCreateArg) -\u003e Self {\n        table_create::new(args).with_parent(self)\n    }\n\n    /// Drop a table.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// db.table_drop(table_name) → response\n    /// ```\n    ///\n    /// Where:\n    /// - table_name: \u0026str | String | Cow\u003c'static, str\u003e\n    /// - response: [DbResponse](crate::types::DbResponse)\n    ///\n    /// # Description\n    ///\n    /// The table and all its data will be deleted.\n    ///\n    /// If the given table does not exist in the database,\n    /// the command throws `ReqlRuntimeError`.\n    ///\n    /// ## Examples\n    ///\n    /// Drop a table named ‘simbad’.\n    ///\n    /// ```\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::types::DbResponse;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: DbResponse = r.db(\"test\")\n    ///         .table_drop(\"simbad\")\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response.tables_dropped \u003e Some(0));\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [table_create](Self::table_create)\n    /// - [table_list](Self::table_list)\n    pub fn table_drop(self, table_name: impl Into\u003cString\u003e) -\u003e Self {\n        table_drop::new(table_name).with_parent(self)\n    }\n\n    /// List all table names in a database.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// db.table_list() → response\n    /// ```\n    ///\n    /// Where:\n    /// - response: Vec\u003cString\u003e\n    ///\n    /// ## Examples\n    ///\n    /// List all tables of the ‘test’ database.\n    ///\n    /// ```\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: Vec\u003cString\u003e = r.db(\"test\")\n    ///         .table_list()\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response.len() \u003e 0);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [table_create](Self::table_create)\n    /// - [table_drop](Self::table_drop)\n    pub fn table_list(self) -\u003e Self {\n        table_list::new().with_parent(self)\n    }\n\n    /// Return all documents in a table.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// db.table(name) → table\n    /// db.table(args!(name, options)) → table\n    /// r.table(name) → table\n    /// r.table(args!(name, options)) → table\n    /// ```\n    ///\n    /// Where:\n    /// - name: impl Into\u003cString\u003e | [Command](crate::Command)\n    /// - options: [TableOption](crate::cmd::table::TableOption)\n    ///\n    /// # Description\n    ///\n    /// Other commands may be chained after `table` to return a subset of documents\n    /// (such as [get](crate::Command::get) and [filter](crate::Command::filter))\n    /// or perform further processing.\n    ///\n    /// ## Examples\n    ///\n    /// Return all documents in the table ‘simbad’ of the default database.\n    ///\n    /// ```\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"simbad\").run(\u0026conn).await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Return all documents in the table ‘simbad’ of the database ‘heroes’.\n    ///\n    /// ```\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.db(\"heroes\").table(\"simbad\").run(\u0026conn).await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Allow potentially out-of-date data in exchange for faster reads.\n    ///\n    /// ```\n    /// use reql_rust::cmd::table::TableOption;\n    /// use reql_rust::arguments::ReadMode;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let table_option = TableOption::default().read_mode(ReadMode::Outdated);\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.db(\"heroes\").table(args!(\"simbad\", table_option)).run(\u0026conn).await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [filter](Self::filter)\n    /// - [get](Self::get)\n    pub fn table(self, args: impl table::TableArg) -\u003e Self {\n        table::new(args).with_parent(self)\n    }\n\n    /// Create a new secondary index on a table.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// table.index_drop(index_name) → response\n    /// ```\n    ///\n    /// Where:\n    /// - index_name: \u0026str | String | Cow\u003c'static, str\u003e\n    /// - response: [IndexResponse](crate::types::IndexResponse)\n    ///\n    /// # Description\n    ///\n    /// Secondary indexes improve the speed of many read queries at the slight\n    /// cost of increased storage space and decreased write performance.\n    /// For more information about secondary indexes,  read the article\n    /// “[Using secondary indexes in RethinkDB](https://rethinkdb.com/docs/secondary-indexes/python/).”\n    ///\n    /// RethinkDB supports different types of secondary indexes:\n    /// - **Simple indexes** based on the value of a single field.\n    /// - **Compound indexes** based on multiple fields.\n    /// - **Multi indexes** based on arrays of values.\n    /// - **Geospatial indexes** based on indexes of geometry objects,\n    /// created when the geo optional argument is true.\n    /// - Indexes based on **arbitrary expressions**.\n    ///\n    /// The `index_function` can be an anonymous function or a binary\n    /// representation obtained from the `function` field of [index_status](Self::index_status).\n    /// The function must be deterministic, and so cannot use a subquery or the `r.js` command.\n    ///\n    /// If successful, `create_index` will return an object of the form `{\"created\": 1}`.\n    /// If an index by that name already exists on the table, a `ReqlRuntimeError` will be thrown.\n    ///\n    /// ```text\n    /// that an index may not be immediately available after creation.\n    /// If your application needs to use indexes immediately after creation,\n    /// use the index_wait command to ensure the indexes are ready before use.\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Create a simple index based on the field `post_id`.\n    ///\n    /// ```\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::types::IndexResponse;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: IndexResponse = r.table(\"comments\")\n    ///         .index_create(\"post_id\")\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response.created \u003e Some(0));\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Create a simple index based on the nested field `author \u003e name`.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::types::IndexResponse;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: IndexResponse = r.table(\"comments\")\n    ///         .index_create(args!(\"author_name\", func!(|comment| comment.g(\"author\").g(\"name\"))))\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response.created \u003e Some(0));\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Create a geospatial index based on the field `location`.\n    ///\n    /// ```\n    /// use reql_rust::cmd::index_create::IndexCreateOption;\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::types::IndexResponse;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let index_create_option = IndexCreateOption::default().geo(true);\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: IndexResponse = r.table(\"places\")\n    ///         .index_create(args!(\"location\", index_create_option))\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response.created \u003e Some(0));\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// A geospatial index field should contain only geometry objects.\n    /// It will work with geometry ReQL terms\n    /// ([get_intersecting](Self::get_intersecting) and [get_nearest](Self::get_nearest))\n    /// as well as index-specific terms  ([index_status](Self::index_status),\n    /// [index_wait](Self::index_wait), [index_drop](Self::index_drop) and [index_list](Self::index_list)).\n    /// Using terms that rely on non-geometric ordering such as [get_all](Self::get_all),\n    /// [order_by](Self::order_by) and [between](Self::between) will result in an error.\n    ///\n    /// ## Examples\n    ///\n    /// Create a compound index based on the fields `post_id` and `date`.\n    ///\n    /// ```\n    /// use reql_rust::cmd::index_create::IndexCreateOption;\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::types::IndexResponse;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let index_create_option = IndexCreateOption::default().geo(true);\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: IndexResponse = r.table(\"comments\")\n    ///         .index_create(args!(\"post_and_date\", index_create_option))\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response.created \u003e Some(0));\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [index_wait](Self::index_wait)\n    /// - [index_status](Self::index_status)\n    /// - [index_list](Self::index_list)\n    /// - [index_drop](Self::index_drop)\n    pub fn index_create(self, args: impl index_create::IndexCreateArg) -\u003e Self {\n        index_create::new(args).with_parent(self)\n    }\n\n    /// Delete a previously created secondary index of this table.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// table.index_drop(index_name) → response\n    /// ```\n    ///\n    /// Where:\n    /// - index_name: \u0026str | String | Cow\u003c'static, str\u003e\n    /// - response: [IndexResponse](crate::types::IndexResponse)\n    ///\n    /// ## Examples\n    ///\n    /// Drop a secondary index named ‘code_name’.\n    ///\n    /// ```\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::types::IndexResponse;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: IndexResponse = r.table(\"comments\")\n    ///         .index_drop(\"code_name\")\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response.dropped \u003e Some(0));\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [index_create](Self::index_create)\n    /// - [index_list](Self::index_list)\n    pub fn index_drop(self, index_name: impl Into\u003cString\u003e) -\u003e Self {\n        index_drop::new(index_name).with_parent(self)\n    }\n\n    /// List all the secondary indexes of this table.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// table.index_list() → response\n    /// ```\n    ///\n    /// Where:\n    /// - response: Vec\u003cString\u003e\n    ///\n    /// ## Examples\n    ///\n    /// List the available secondary indexes for this table.\n    ///\n    /// ```\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: Vec\u003cString\u003e = r.table(\"comments\")\n    ///         .index_list()\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response.len() \u003e 0);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [index_create](Self::index_create)\n    /// - [index_drop](Self::index_drop)\n    pub fn index_list(self) -\u003e Self {\n        index_list::new().with_parent(self)\n    }\n\n    /// Rename an existing secondary index on a table.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// table.index_rename(args!(old_index_name, new_index_name)) → response\n    /// table.index_rename(args!(old_index_name, new_index_name, options)) → response\n    /// ```\n    ///\n    /// Where:\n    /// - old_index_name, new_index_name: \u0026str | String | Cow\u003c'static, str\u003e\n    /// - options: [IndexRenameOption](crate::cmd::index_rename::IndexRenameOption)\n    /// - response: [IndexResponse](crate::types::IndexResponse)\n    ///\n    /// # Description\n    ///\n    /// If the optional argument `overwrite` is specified as `true`,\n    /// a previously existing index with the new name will be deleted\n    /// and the index will be renamed. If `overwrite` is `false` (the default)\n    /// an error will be raised if the new index name already exists.\n    ///\n    /// The return value on success will be an object of the format `{'renamed': 1}`,\n    /// or `{'renamed': 0}` if the old and new names are the same.\n    ///\n    /// An error will be raised if the old index name does not exist,\n    /// if the new index name is already in use and `overwrite` is `false`,\n    /// or if either the old or new index name are the same as the primary key field name.\n    ///\n    /// ## Examples\n    ///\n    /// Rename an index on the comments table.\n    ///\n    /// ```\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::types::IndexResponse;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: IndexResponse = r.table(\"comments\")\n    ///         .index_rename(args!(\"post_id\", \"message_id\"))\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response.renamed \u003e Some(0));\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [index_create](Self::index_create)\n    /// - [index_status](Self::index_status)\n    /// - [index_list](Self::index_list)\n    /// - [index_drop](Self::index_drop)\n    pub fn index_rename(self, args: impl index_rename::IndexRenameArg) -\u003e Self {\n        index_rename::new(args).with_parent(self)\n    }\n\n    /// Get the status of the specified indexes on this table,\n    /// or the status of all indexes on this table if no indexes are specified.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// table.index_status(()) → response\n    /// table.index_status(index) → response\n    /// ```\n    ///\n    /// Where:\n    /// - index: \u0026str | [\u0026str; N]\n    /// - response: Vec\u003c[IndexStatusResponse](crate::types::IndexStatusResponse)\u003e\n    ///\n    /// # Description\n    ///\n    /// The `multi` field will be `true` or `false` depending on whether\n    /// this index was created as a multi index\n    /// (see [index_create](Self::index_create) for details).\n    /// The `outdated` field will be true if the index is outdated in\n    /// the current version of RethinkDB and needs to be rebuilt.\n    /// The `progress` field is a float between `0` and `1`,\n    /// indicating how far along the server is in constructing indexes after\n    /// the most recent change to the table that would affect them.\n    /// (`0` indicates no such indexes have been constructed; `1` indicates all of them have.)\n    ///\n    /// The `function` field is a binary object containing an opaque representation\n    /// of the secondary index (including the `multi` argument if specified).\n    /// It can be passed as the second argument to [index_create](Self::index_create) to create\n    /// a new index with the same function; see `index_create` for more information.\n    ///\n    /// ## Examples\n    ///\n    /// Get the status of all the indexes on `test`:\n    ///\n    /// ```\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::types::IndexStatusResponse;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: Vec\u003cIndexStatusResponse\u003e = r.table(\"test\")\n    ///         .index_status(())\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response.len() \u003e 0);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Get the status of the `timestamp` index:\n    ///\n    /// ```\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::types::IndexStatusResponse;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: Vec\u003cIndexStatusResponse\u003e = r.table(\"test\")\n    ///         .index_status(\"timestamp\")\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response.len() \u003e 0);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Save the binary representation of the index:\n    ///\n    /// ```\n    /// use reql_rust::types::IndexStatusResponse;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"test\")\n    ///         .index_status(\"timestamp\")\n    ///         .nth(0)\n    ///         .g(\"function\")\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [index_wait](Self::index_wait)\n    pub fn index_status(self, args: impl index_status::IndexStatusArg) -\u003e Self {\n        index_status::new(args).with_parent(self)\n    }\n\n    /// Wait for the specified indexes on this table to be ready,\n    /// or for all indexes on this table to be ready if no indexes are specified.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// table.index_wait(()) → response\n    /// table.index_wait(index) → response\n    /// ```\n    ///\n    /// Where:\n    /// - index: \u0026str | [\u0026str; N]\n    /// - response: [IndexStatusResponse](crate::types::IndexStatusResponse)\n    ///\n    /// ## Examples\n    ///\n    /// Wait for all indexes on the table `test` to be ready:\n    ///\n    /// ```\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::types::IndexStatusResponse;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: IndexStatusResponse = r.table(\"test\")\n    ///         .index_wait(())\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response.ready);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Wait for the index `timestamp` to be ready:\n    ///\n    /// ```\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::types::IndexStatusResponse;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: IndexStatusResponse = r.table(\"test\")\n    ///         .index_wait(\"timestamp\")\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response.ready);\n    ///     assert_eq!(response.index, \"author\");\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [index_status](Self::index_status)\n    pub fn index_wait(self, args: impl index_wait::IndexWaitArg) -\u003e Self {\n        index_wait::new(args).with_parent(self)\n    }\n\n    /// Sets the write hook on a table or overwrites it if one already exists.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// table.set_write_hook(params) → response\n    /// ```\n    ///\n    /// Where:\n    /// - params: func!(...) | None |\n    /// [Binary](crate::types::Binary) | [Command](crate::Command)\n    /// - response: [SetWriteHookResponse](crate::types::SetWriteHookResponse)\n    ///\n    /// # Description\n    ///\n    /// The `function` can be an anonymous function with the signature\n    /// `(context: object, old_val: object, new_val: object) -\u003e object`\n    /// or a binary representation obtained from the `function` field\n    /// of [get_write_hook](Self::get_write_hook).\n    /// The function must be deterministic,\n    /// and so cannot use a subquery or the `r.js` command.\n    ///\n    /// The first argument, `context`,\n    /// is a ReQL object containing the following properties:\n    /// - `primary_key`: primary key of the document being deleted, inserted, or modified\n    /// - `timestamp`: a ReQL `time` object representing the current query execution time\n    ///\n    /// Whenever a write operation on the table inserts, deletes or modifies a given document,\n    /// the write hook function will be called with the context parameter, the old value of\n    /// the document (or `null` on inserts) and the new value of the document (or `null` on deletes).\n    /// It then returns the value that should actually be inserted and/or replaced instead of `newVal`.\n    /// It can also return `r.error(...)` to abort the write.\n    ///\n    /// For simplicity, the write hook function is allowed\n    /// to return `null` exactly if and only if `newVal` is `null`.\n    /// This is just a safeguard to ensure you don’t accidentally\n    /// turn an insert/update into a deletion, or a deletion into an update.\n    ///\n    /// ## Examples\n    ///\n    /// Create a write hook\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::types::SetWriteHookResponse;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: SetWriteHookResponse = r.table(\"comments\")\n    ///         .set_write_hook(func!(|_, _, new_val| new_val))\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert_eq!(response.created, Some(1));\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Delete the write hook associated with the comments table.\n    ///\n    /// ```\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::types::SetWriteHookResponse;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: SetWriteHookResponse = r.table(\"comments\")\n    ///         .set_write_hook(None)\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert_eq!(response.deleted, Some(1));\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [get_write_hook](Self::get_write_hook)\n    pub fn set_write_hook(self, args: impl set_write_hook::SetWriteHookArg) -\u003e Self {\n        set_write_hook::new(args).with_parent(self)\n    }\n\n    /// Gets the write hook of this table.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// table.get_write_hook() → response\n    /// ```\n    ///\n    /// Where:\n    /// - response: [GetWriteHookResponse](crate::types::GetWriteHookResponse)\n    ///\n    /// # Description\n    ///\n    /// If a write hook exists, the result is an object of the following form:\n    ///\n    /// ```text\n    /// {\n    ///     \"function\": \u003cbinary\u003e,\n    ///     \"query\": \"setWriteHook(function(_var1, _var2, _var3) { return ...; })\",\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Get the write hook for the `comments` table.\n    ///\n    /// ```\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::types::GetWriteHookResponse;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: GetWriteHookResponse = r.table(\"comments\")\n    ///         .get_write_hook()\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert_eq!(\n    ///         response.query,\n    ///         \"setWriteHook(function(var1, var2, var3) { return var3; })\"\n    ///     );\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [set_write_hook](Self::set_write_hook)\n    pub fn get_write_hook(self) -\u003e Self {\n        get_write_hook::new().with_parent(self)\n    }\n\n    /// Insert documents into a table.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// table.insert(object) → response\n    /// table.insert(args!(object, options)) → response\n    /// ```\n    ///\n    /// Where:\n    /// - object: impl Serialize | [Command](crate::Command)\n    /// - options: [InsertOption](crate::cmd::insert::InsertOption)\n    /// - response: [MutationResponse](crate::types::MutationResponse)\n    ///\n    /// # Description\n    ///\n    /// Accepts a single document or an array of documents.\n    ///\n    /// ## Examples\n    ///\n    /// Insert a document into the table `posts`.\n    ///\n    /// ```\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::types::MutationResponse;\n    /// use reql_rust::{r, Result};\n    /// use serde_json::json;\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: MutationResponse = r.table(\"posts\")\n    ///         .insert(json!({\n    ///             \"id\": 1,\n    ///             \"title\": \"Lorem ipsum\",\n    ///             \"content\": \"Dolor sit amet\",\n    ///         }))\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response.inserted == 1);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Insert a document without a defined primary key into\n    /// the table `posts` where the primary key is `id`.\n    ///\n    /// ```\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::types::MutationResponse;\n    /// use reql_rust::{r, Result};\n    /// use serde_json::json;\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: MutationResponse = r.table(\"posts\")\n    ///         .insert(json!({\n    ///             \"title\": \"Lorem ipsum\",\n    ///             \"content\": \"Dolor sit amet\",\n    ///         }))\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response.inserted == 1);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Insert multiple documents into the table `users`.\n    ///\n    /// ```\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::types::MutationResponse;\n    /// use reql_rust::{r, Result};\n    /// use serde_json::json;\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: MutationResponse = r.table(\"users\")\n    ///         .insert(json!([\n    ///             {\"id\": \"malika\", \"email\": \"malika@rethinkdb.com\"},\n    ///             {\"id\": \"moussa\", \"email\": \"moussa@rethinkdb.com\"}\n    ///         ]))\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response.inserted == 1);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Insert a document into the table `users`,\n    /// replacing the document if the document already exists.\n    ///\n    /// ```\n    /// use reql_rust::arguments::Conflict;\n    /// use reql_rust::cmd::insert::InsertOption;\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::types::MutationResponse;\n    /// use reql_rust::{args, r, Result};\n    /// use serde_json::json;\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let insert_option = InsertOption::default().conflict(Conflict::Replace);\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: MutationResponse = r.table(\"users\")\n    ///         .insert(args!(\n    ///             json!({\"id\": \"malika\", \"email\": \"malika@rethinkdb.com\"}),\n    ///             insert_option\n    ///         ))\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response.inserted == 1);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Copy the documents from `posts` to `posts_backup`.\n    ///\n    /// ```\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::types::MutationResponse;\n    /// use reql_rust::{r, Result};\n    /// use serde_json::json;\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: MutationResponse = r.table(\"posts_backup\")\n    ///         .insert(r.table(\"posts\"))\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response.inserted == 1);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Get back a copy of the inserted document (with its generated primary key).\n    ///\n    /// ```\n    /// use reql_rust::arguments::ReturnChanges;\n    /// use reql_rust::cmd::insert::InsertOption;\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::types::MutationResponse;\n    /// use reql_rust::{args, r, Result};\n    /// use serde_json::json;\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let insert_option = InsertOption::default().return_changes(ReturnChanges::Bool(true));\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: MutationResponse = r.table(\"posts\")\n    ///         .insert(args!(\n    ///             json!({\"title\": \"Lorem ipsum\", \"content\": \"Dolor sit amet\"}),\n    ///             insert_option\n    ///         ))\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response.inserted == 1);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [update](Self::update)\n    /// - [replace](Self::replace)\n    /// - [delete](Self::delete)\n    pub fn insert(self, args: impl insert::InsertArg) -\u003e Self {\n        insert::new(args).with_parent(self)\n    }\n\n    /// Update JSON documents in a table.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// table.replace(object) → response\n    /// table.replace(func) → response\n    /// table.replace(args!(object, options)) → response\n    /// table.replace(args!(func, options)) → response\n    /// ```\n    ///\n    /// Where:\n    /// - object: impl Serialize | [Command](crate::Command)\n    /// - func: func!(...)\n    /// - options: [ReplaceOption](crate::cmd::replace::ReplaceOption)\n    /// - response: [MutationResponse](crate::types::MutationResponse)\n    ///\n    /// # Description\n    ///\n    /// Accepts a JSON document, a ReQL expression, or a combination of the two.\n    ///\n    /// ## Examples\n    ///\n    /// Update the status of the post with `id` of `1` to `published`.\n    ///\n    /// ```\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::types::MutationResponse;\n    /// use reql_rust::{r, Result};\n    /// use serde_json::json;\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: MutationResponse = r.table(\"posts\")\n    ///         .get(1)\n    ///         .update(json!({\"status\": \"published\"}))\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response.replaced == 1);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Update the status of all posts to `published`.\n    ///\n    /// ```\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::types::MutationResponse;\n    /// use reql_rust::{r, Result};\n    /// use serde_json::json;\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: MutationResponse = r.table(\"posts\")\n    ///         .update(json!({\"status\": \"published\"}))\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response.replaced == 100);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Update the status of all the posts written by Moussa.\n    ///\n    /// ```\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::types::MutationResponse;\n    /// use reql_rust::{r, Result};\n    /// use serde_json::json;\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: MutationResponse = r.table(\"posts\")\n    ///         .filter(json!({\"author\": \"Moussa\"}))\n    ///         .update(json!({\"status\": \"published\"}))\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response.replaced == 5);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ```text\n    /// Note that `filter`, `get_all` and similar operations\n    /// do **not** execute in an atomic fashion with `update`.\n    /// Read [Consistency guarantees](https://rethinkdb.com/docs/consistency) for more details.\n    /// Also, see the example for conditional updates\n    /// below for a solution using `branch` in an `update` clause.\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Increment the field `view` of the post with `id` of `1`.\n    /// This query will throw an error if the field `views` doesn’t exist.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::types::MutationResponse;\n    /// use reql_rust::{r, Result};\n    /// use serde_json::json;\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: MutationResponse = r.table(\"posts\")\n    ///         .get(1)\n    ///         .update(func!(|post| post.g(\"views\") + r.expr(1)))\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response.replaced == 1);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Increment the field view of the post with id of 1.\n    /// If the field views does not exist, it will be set to 0.\n    ///\n    /// ```\n    /// use std::ops::Add;\n    ///\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::types::MutationResponse;\n    /// use reql_rust::{r, Result};\n    /// use serde_json::json;\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: MutationResponse = r.table(\"posts\")\n    ///         .get(1)\n    ///         .update(func!(|post| post.g(\"views\").add(r.expr(1)).default(0)))\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response.replaced == 1);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Perform a conditional update.\n    ///\n    /// If the post has more than 100 views,\n    /// set the `type` of a post to `hot`,\n    /// else set it to `normal`.\n    ///\n    /// ```\n    /// use std::ops::Add;\n    ///\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::types::MutationResponse;\n    /// use reql_rust::{args, r, Result};\n    /// use serde_json::json;\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: MutationResponse = r.table(\"posts\")\n    ///         .get(1)\n    ///         .update(func!(|post| r.branch(\n    ///             post.g(\"views\").gt(100),\n    ///             args!(\n    ///                 r.expr(json!({\"type\": \"hot\"})),\n    ///                 r.expr(json!({\"type\": \"normal\"}))\n    ///             )\n    ///         )))\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response.replaced == 1);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Update the field `num_comments` with the result of a sub-query.\n    /// Because this update is not atomic, you must pass the `non_atomic` flag.\n    ///\n    /// ```\n    /// use std::collections::HashMap;\n    ///\n    /// use reql_rust::cmd::update::UpdateOption;\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::types::MutationResponse;\n    /// use reql_rust::{args, r, Result};\n    /// use serde_json::json;\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let update_option = UpdateOption::default().non_atomic(true);\n    ///     let conn = r.connection().connect().await?;\n    ///     let mut comments_filtered = HashMap::new();\n    ///     comments_filtered.insert(\n    ///         \"num_comments\",\n    ///         r.table(\"comments\")\n    ///             .filter(json!({\"id_post\": 1}))\n    ///             .count(())\n    ///     );\n    ///     let response: MutationResponse = r.table(\"posts\")\n    ///         .get(1)\n    ///         .update(args!(r.hash_map(comments_filtered), update_option))\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response.replaced == 1);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// If you forget to specify the `non_atomic` flag,\n    /// you will get a `ReqlRuntimeError`:\n    ///\n    /// ```text\n    /// ReqlRuntimeError: Could not prove function deterministic.\n    /// Maybe you want to use the non_atomic flag?\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Update the field `num_comments` with a random value between 0 and 100.\n    /// This update cannot be proven deterministic because of `r.js` (and in fact is not),\n    /// so you must pass the `non_atomic` flag.\n    ///\n    /// ```\n    /// use std::collections::HashMap;\n    ///\n    /// use reql_rust::cmd::update::UpdateOption;\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::types::MutationResponse;\n    /// use reql_rust::{args, r, Result};\n    /// use serde_json::json;\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let update_option = UpdateOption::default().non_atomic(true);\n    ///     let conn = r.connection().connect().await?;\n    ///     let mut comments_filtered = HashMap::new();\n    ///     comments_filtered.insert(\n    ///         \"num_comments\",\n    ///         r.js(\"Math.floor(Math.random()*100)\")\n    ///     );\n    ///     let response: MutationResponse = r.table(\"posts\")\n    ///         .get(1)\n    ///         .update(args!(r.hash_map(comments_filtered), update_option))\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response.replaced == 1);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Update the status of the post with `id` of `1` using soft durability.\n    ///\n    /// ```\n    /// use reql_rust::arguments::Durability;\n    /// use reql_rust::cmd::update::UpdateOption;\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::types::MutationResponse;\n    /// use reql_rust::{args, r, Result};\n    /// use serde_json::json;\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let update_option = UpdateOption::default().durability(Durability::Soft);\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: MutationResponse = r.table(\"posts\")\n    ///         .get(1)\n    ///         .update(args!(json!({\"status\": \"published\"}), update_option))\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response.replaced == 1);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [insert](Self::insert)\n    /// - [replace](Self::replace)\n    /// - [delete](Self::delete)\n    pub fn update(self, args: impl update::UpdateArg) -\u003e Self {\n        update::new(args).with_parent(self)\n    }\n\n    /// Replace documents in a table.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// table.replace(object) → response\n    /// table.replace(func) → response\n    /// table.replace(args!(object, options)) → response\n    /// table.replace(args!(func, options)) → response\n    /// ```\n    ///\n    /// Where:\n    /// - object: impl Serialize | [Command](crate::Command)\n    /// - func: func!(...)\n    /// - options: [ReplaceOption](crate::cmd::replace::ReplaceOption)\n    /// - response: [MutationResponse](crate::types::MutationResponse)\n    ///\n    /// # Description\n    ///\n    /// Accepts a JSON document or a ReQL expression, and replaces\n    /// the original document with the new one.\n    /// The new document must have the same primary key as the original document.\n    ///\n    /// The `replace` command can be used to both insert and delete documents.\n    /// If the “replaced” document has a primary key that doesn’t exist in the table,\n    /// the document will be inserted; if an existing document is replaced with `None`,\n    /// the document will be deleted.\n    /// Since `update` and `replace` operations are performed atomically,\n    /// this allows atomic inserts and deletes as well.\n    ///\n    /// ## Examples\n    ///\n    /// Replace the document with the primary key `1`.\n    ///\n    /// ```\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::types::MutationResponse;\n    /// use reql_rust::{r, Result};\n    /// use serde_json::json;\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: MutationResponse = r.table(\"posts\")\n    ///         .get(1)\n    ///         .replace(json!({\n    ///             \"id\": 1,\n    ///             \"title\": \"Lorem ipsum\",\n    ///             \"content\": \"Aleas jacta est\",\n    ///             \"status\": \"draft\"\n    ///         }))\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response.replaced == 1);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Remove the field `status` from all posts.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::types::MutationResponse;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: MutationResponse = r.table(\"posts\")\n    ///         .replace(func!(|post| post.without(\"status\")))\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response.replaced == 5);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Remove all the fields that are not `id`, `title` or `content`.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::types::MutationResponse;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: MutationResponse = r.table(\"posts\")\n    ///         .replace(func!(|post| post.pluck([\"id\", \"title\", \"content\"])))\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response.replaced == 5);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Replace the document with the primary key `1` using soft durability.\n    ///\n    /// ```\n    /// use reql_rust::arguments::Durability;\n    /// use reql_rust::cmd::replace::ReplaceOption;\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::types::MutationResponse;\n    /// use reql_rust::{args, r, Result};\n    /// use serde_json::json;\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let replace_option = ReplaceOption::default().durability(Durability::Soft);\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: MutationResponse = r.table(\"posts\")\n    ///         .get(1)\n    ///         .replace(args!(json!({\n    ///             \"id\": 1,\n    ///             \"title\": \"Lorem ipsum\",\n    ///             \"content\": \"Aleas jacta est\",\n    ///             \"status\": \"draft\"\n    ///         }), replace_option))\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response.replaced == 1);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Replace the document with the primary key `1` and return the\n    /// values of the document before and after the replace operation.\n    ///\n    /// ```\n    /// use reql_rust::arguments::ReturnChanges;\n    /// use reql_rust::cmd::replace::ReplaceOption;\n    /// use reql_rust::{args, r, Result};\n    /// use serde_json::json;\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let replace_option = ReplaceOption::default().return_changes(ReturnChanges::Bool(true));\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"posts\")\n    ///         .get(1)\n    ///         .replace(args!(json!({\n    ///             \"id\": 1,\n    ///             \"title\": \"Lorem ipsum\",\n    ///             \"content\": \"Aleas jacta est\",\n    ///             \"status\": \"draft\"\n    ///         }), replace_option))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [insert](Self::insert)\n    /// - [update](Self::update)\n    /// - [delete](Self::delete)\n    pub fn replace(self, args: impl replace::ReplaceArg) -\u003e Self {\n        replace::new(args).with_parent(self)\n    }\n\n    /// Delete one or more documents from a table.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// table.delete(()) → response\n    /// table.delete(options) → response\n    /// ```\n    ///\n    /// Where:\n    /// - options: [DeleteOption](crate::cmd::delete::DeleteOption)\n    /// - response: [MutationResponse](crate::types::MutationResponse)\n    ///\n    /// ## Examples\n    ///\n    /// Delete a single document from the table `comments`.\n    ///\n    /// ```\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::types::MutationResponse;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: MutationResponse = r.table(\"comments\")\n    ///         .get(\"7eab9e63-73f1-4f33-8ce4-95cbea626f59\")\n    ///         .delete(())\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response.deleted == 1);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Delete all documents from the table comments.\n    ///\n    /// ```\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::types::MutationResponse;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: MutationResponse = r.table(\"comments\")\n    ///         .delete(())\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response.deleted == 100);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Delete all comments where the field `id_post` is `3`.\n    ///\n    /// ```\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::types::MutationResponse;\n    /// use reql_rust::{r, Result};\n    /// use serde_json::json;\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: MutationResponse = r.table(\"comments\")\n    ///         .filter(json!({\"id_post\": 3}))\n    ///         .delete(())\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response.deleted == 5);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Delete a single document from the table `comments` and return its value.\n    ///\n    /// ```\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::arguments::ReturnChanges;\n    /// use reql_rust::cmd::delete::DeleteOption;\n    /// use reql_rust::types::MutationResponse;\n    /// use reql_rust::{r, Result};\n    /// use serde_json::json;\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let expected_data = json!({\n    ///         \"id\": \"7eab9e63-73f1-4f33-8ce4-95cbea626f59\",\n    ///         \"author\": \"Moussa\",\n    ///         \"comment\": \"Great post\",\n    ///         \"id_post\": 3\n    ///     });\n    ///     let delete_option = DeleteOption::default().return_changes(ReturnChanges::Bool(true));\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: MutationResponse = r.table(\"comments\")\n    ///         .get(\"7eab9e63-73f1-4f33-8ce4-95cbea626f59\")\n    ///         .delete(delete_option)\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     let old_val = response\n    ///         .clone()\n    ///         .changes\n    ///         .unwrap()\n    ///         .first()\n    ///         .unwrap()\n    ///         .to_owned()\n    ///         .old_val;\n    ///\n    ///     assert!(response.deleted == 1);\n    ///     assert_eq!(old_val, Some(expected_data));\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Delete all documents from the table `comments` without\n    /// waiting for the operation to be flushed to disk.\n    ///\n    /// ```\n    /// use reql_rust::arguments::Durability;\n    /// use reql_rust::cmd::delete::DeleteOption;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let delete_option = DeleteOption::default().durability(Durability::Soft);\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"comments\")\n    ///         .delete(delete_option)\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [insert](Self::insert)\n    /// - [update](Self::update)\n    /// - [replace](Self::replace)\n    pub fn delete(self, args: impl delete::DeleteArg) -\u003e Self {\n        delete::new(args).with_parent(self)\n    }\n\n    /// `sync` ensures that writes on a given\n    /// table are written to permanent storage.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// table.sync() → response\n    /// ```\n    ///\n    /// Where:\n    /// - response: [SyncResponse](crate::types::SyncResponse)\n    ///\n    /// # Description\n    ///\n    /// Queries that specify soft durability (`durability=Durability::Soft`)\n    /// do not give such guarantees, so `sync` can be used to ensure the state of these queries.\n    /// A call to `sync` does not return until all previous writes to the table are persisted.\n    ///\n    /// ## Examples\n    ///\n    /// After having updated multiple heroes with soft durability,\n    /// we now want to wait until these changes are persisted.\n    ///\n    /// ```\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::types::SyncResponse;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: SyncResponse = r.table(\"simbad\")\n    ///         .sync()\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response.synced == 1);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [noreply_wait](crate::connection::Session::noreply_wait)\n    pub fn sync(self) -\u003e Self {\n        sync::new().with_parent(self)\n    }\n\n    /// Get a document by primary key.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// table.get(keys) → singleRowSelection\n    /// ```\n    ///\n    /// Where:\n    /// - keys: impl Serialize | [Command](crate::Command)\n    ///\n    /// # Description\n    ///\n    /// If no document exists with that primary key, `get` will return `None`.\n    ///\n    /// ## Examples\n    ///\n    /// Find a document by UUID.\n    ///\n    /// ```\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"posts\")\n    ///         .get(\"a9849eef-7176-4411-935b-79a6e3c56a74\")\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Find a document and merge another document with it.\n    ///\n    /// ```\n    /// use reql_rust::{r, Result};\n    /// use serde_json::json;\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"heroes\")\n    ///         .get(3)\n    ///         .merge(json!({\n    ///             \"powers\": [\"invisibility\", \"speed\"]\n    ///         }))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [get_all](Self::get_all)\n    /// - [between](Self::between)\n    /// - [filter](Self::filter)\n    pub fn get(self, args: impl get::GetArg) -\u003e Self {\n        get::new(args).with_parent(self)\n    }\n\n    /// Get all documents where the given value\n    /// matches the value of the requested index.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// table.get_all(keys) → selection\n    /// table.get_all(args!(keys, options)) → selection\n    /// ```\n    ///\n    /// Where:\n    /// - keys: impl IntoIterator | [Command](crate::Command)\n    /// - options: [GetAllOption](crate::cmd::get_all::GetAllOption)\n    ///\n    /// ## Examples\n    ///\n    /// Secondary index keys are not guaranteed to be unique so we cannot\n    /// query via [get](Self::get) when using a secondary index.\n    ///\n    /// ```\n    /// use reql_rust::cmd::get_all::GetAllOption;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let get_all_option = GetAllOption::default().index(\"code_name\");\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"marvel\")\n    ///         .get_all(args!([\"man_of_steel\"], get_all_option))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Without an index argument, we default to the primary index.\n    /// While `get` will either return the document or `None` when no document\n    /// with such a primary key value exists, this will return either a one or zero length stream.\n    ///\n    /// ```\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"dc\")\n    ///         .get_all([\"superman\"])\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// You can get multiple documents in a single call to get_all.\n    ///\n    /// ```\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"dc\")\n    ///         .get_all([\"superman\", \"ant man\"])\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Note\n    ///\n    /// ```text\n    /// `get_all` does not perform any de-duplication.\n    /// If you pass the same key more than once, the same document will be returned multiple times.\n    /// ```\n    ///\n    /// # Related commands\n    /// - [get](Self::get)\n    /// - [between](Self::between)\n    /// - [filter](Self::filter)\n    pub fn get_all(self, values: impl get_all::GetAllArg) -\u003e Self {\n        get_all::new(values).with_parent(self)\n    }\n\n    /// Get all documents between two keys.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// table.between(args!(lower_key, upper_key)) → table_slice\n    /// table.between(args!(lower_key, upper_key, options)) → table_slice\n    /// ```\n    ///\n    /// Where:\n    /// - lower_key, upper_key: [Command](crate::Command)\n    /// - options: [BetweenOption](crate::cmd::between::BetweenOption)\n    ///\n    /// # Description\n    ///\n    /// You may also use the special constants `r::min_val()` and `r::max_val()` for boundaries,\n    /// which represent “less than any index key” and “more than any index key” respectively.\n    /// For instance, if you use `r::min_val()` as the lower key, then `between` will return\n    /// all documents whose primary keys (or indexes) are less than the specified upper key.\n    ///\n    /// If you use arrays as indexes (compound indexes),\n    /// they will be sorted using\n    /// [lexicographical order](https://en.wikipedia.org/wiki/Lexicographical_order).\n    /// Take the following range as an example:\n    ///\n    /// ```text\n    /// [[1, \"c\"] ... [5, \"e\"]]\n    /// ```\n    ///\n    /// This range includes all compound keys:\n    /// - whose first item is 1 and second item is equal or greater than “c”;\n    /// - whose first item is between 1 and 5,\n    /// **regardless of the value of the second item**;\n    /// - whose first item is 5 and second item is less than or equal to “e”.\n    ///\n    /// ## Examples\n    ///\n    /// Find all users with primary key \u003e= 10 and \u003c 20 (a normal half-open interval).\n    ///\n    /// ```\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"users\")\n    ///         .between(args!(r.expr(10), r.expr(20)))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Find all users with primary key \u003e= 10 and \u003c= 20 (an interval closed on both sides).\n    ///\n    /// ```\n    /// use reql_rust::arguments::Status;\n    /// use reql_rust::cmd::between::BetweenOption;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let between_option = BetweenOption::default().right_bound(Status::Closed);\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"users\")\n    ///         .between(args!(r.expr(10), r.expr(20), between_option))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Find all users with primary key \u003c 20.\n    ///\n    /// ```\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"users\")\n    ///         .between(args!(r::min_val(), r.expr(20)))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Find all users with primary key \u003e 10.\n    ///\n    /// ```\n    /// use reql_rust::arguments::Status;\n    /// use reql_rust::cmd::between::BetweenOption;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let between_option = BetweenOption::default().right_bound(Status::Open);\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"users\")\n    ///         .between(args!(r.expr(10), r::max_val(), between_option))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Between can be used on secondary indexes too.\n    /// Just pass an optional index argument giving the secondary index to query.\n    ///\n    /// ```\n    /// use reql_rust::cmd::between::BetweenOption;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let between_option = BetweenOption::default().index(\"code_name\");\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"dc\")\n    ///         .between(args!(r.expr(\"dark_knight\"), r.expr(\"man_of_steel\"), between_option))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Get all users whose full name is between “John Smith” and “Wade Welles.”\n    ///\n    /// ```\n    /// use reql_rust::cmd::between::BetweenOption;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let between_option = BetweenOption::default().index(\"full_name\");\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"dc\")\n    ///         .between(args!(r.expr([\"Smith\", \"John\"]), r.expr([\"Welles\", \"Wade\"]), between_option))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [get](Self::get)\n    /// - [get_all](Self::get_all)\n    /// - [filter](Self::filter)\n    pub fn between(self, args: impl between::BetweenArg) -\u003e Self {\n        between::new(args).with_parent(self)\n    }\n\n    /// Return all the elements in a sequence for which the given predicate is true.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// selection.filter(func) → selection\n    /// selection.filter(predicate) → selection\n    /// selection.filter(args!(func, options)) → selection\n    /// selection.filter(args!(predicate, options)) → selection\n    /// ```\n    ///\n    /// Where:\n    /// - predicate: [Command](crate::Command) | impl Serialize\n    /// - func: func!(...)\n    /// - options: [FilterOption](crate::cmd::filter::FilterOption)\n    ///\n    /// # Description\n    ///\n    /// Return all the elements in a sequence for which the given predicate is true.\n    /// The return value of `filter` will be the same as the input (sequence, stream, or array).\n    /// Documents can be filtered in a variety of ways—ranges, nested values, boolean conditions,\n    /// and the results of anonymous functions.\n    ///\n    /// By default, `filter` will silently skip documents with missing fields:\n    /// if the predicate tries to access a field that doesn’t exist\n    /// (for instance, the predicate `{\"age\": 30}` applied to a document with no `age` field),\n    /// that document will not be returned in the result set, and no error will be generated.\n    /// This behavior can be changed with the default optional argument\n    /// [FilterOption](crate::cmd::filter::FilterOption).\n    ///\n    /// ## Note\n    ///\n    /// `filter` does not use secondary indexes.\n    /// For retrieving documents via secondary indexes, consider\n    /// [get_all](Self::get_all), [between](Self::between) and [eq_join](Self::eq_join).\n    ///\n    /// # Basic predicates\n    ///\n    /// ## Examples\n    ///\n    /// Get all users who are 30 years old.\n    ///\n    /// ```\n    /// use reql_rust::{args, r, Result};\n    /// use serde_json::json;\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"users\")\n    ///         .filter(json!({\"age\": 30}))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// The predicate `{\"age\": 30}` selects documents in the `users` table\n    /// with an `age` field whose value is 30. Documents with an `age` field\n    /// set to any other value or with no `age` field present are skipped.\n    ///\n    /// While the `{\"field\": value}` style of predicate is useful for exact matches,\n    /// a more general way to write a predicate is to use an anonymous function that\n    /// returns `true` or `false`.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"users\")\n    ///         .filter(func!(|user| user.g(\"age\").eq(30)))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// In this case, the function returns `true` if the field `age` is equal to 30.\n    ///\n    /// Predicates to filter are evaluated on the server, and must use ReQL expressions.\n    /// You cannot use standard Java comparison operators such as `==`, `\u003c` / `\u003e` and `||` / `\u0026\u0026`.\n    ///\n    /// ## Examples\n    ///\n    /// Get all users who are more than 18 years old.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"users\")\n    ///         .filter(func!(|user| user.g(\"age\").gt(18)))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Get all users who are less than 18 years old and more than 13 years old.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"users\")\n    ///         .filter(func!(|user| user.clone().g(\"age\").lt(18).and(\n    ///             user.g(\"age\").gt(13)\n    ///         )))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Get all users who are more than 18 years old or have their parental consent.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"users\")\n    ///         .filter(func!(|user| user\n    ///             .clone()\n    ///             .g(\"age\")\n    ///             .ge(18)\n    ///             .or(user.g(\"hasParentalConsent\"))\n    ///         ))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Get all users who are more than 18 years old or have their parental consent.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"users\")\n    ///         .filter(func!(|user| user\n    ///             .clone()\n    ///             .g(\"age\")\n    ///             .ge(18)\n    ///             .or(user.g(\"hasParentalConsent\"))\n    ///         ))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # More complex predicates\n    ///\n    /// ## Examples\n    ///\n    /// Retrieve all users who subscribed between January\n    /// 1st, 2012 (included) and January 1st, 2013 (excluded).\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{args, r, Result};\n    /// use time::macros::{date, offset};\n    /// use time::UtcOffset;\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let timezone = UtcOffset::UTC;\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"users\")\n    ///         .filter(func!(|user| user.g(\"subscription_date\").during(args!(\n    ///             r.time(args!(date!(2012 - 1 - 1), timezone)),\n    ///             r.time(args!(date!(2015 - 1 - 1), timezone))\n    ///         ))))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Retrieve all users who have a gmail account (whose field email ends with @gmail.com).\n    ///\n    /// ```\n    /// use regex::Regex;\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let regexpr = Regex::new(\"@gmail.com$\")?;\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"users\")\n    ///         .filter(func!(|user| user.g(\"email\").match_(regexpr)))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Filter based on the presence of a value in an array.\n    ///\n    /// Given this schema for the `users` table.\n    ///\n    /// ```text\n    /// {\n    ///     \"name\": String,\n    ///     \"places_visited\": Vec\u003cString\u003e,\n    /// }\n    /// ```\n    ///\n    /// Retrieve all users whose field `places_visited` contains `Cameroon`.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"users\")\n    ///         .filter(func!(|user| user.g(\"places_visited\").contains(\"Cameroon\")))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Filter based on nested fields.\n    ///\n    /// Given this schema for the `users` table.\n    ///\n    /// ```text\n    /// {\n    ///     \"id\": String,\n    ///     \"name\": {\n    ///         \"first\": String,\n    ///         \"middle\": String,\n    ///         \"last\": String,\n    ///     },\n    /// }\n    /// ```\n    ///\n    /// Retrieve all users named “Moussa Ibrahim\n    /// (first name “Moussa”, last name “Ibrahim”),\n    /// with any middle name.\n    ///\n    /// ```\n    /// use reql_rust::{args, r, Result};\n    /// use serde_json::json;\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"users\")\n    ///         .filter(json!({\n    ///             \"name\": {\n    ///                 \"first\": \"Moussa\",\n    ///                 \"last\": \"Ibrahim\",\n    ///             }\n    ///         }))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// If you want an exact match for a field that is an object,\n    /// you will have to use anonymous functions.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"users\")\n    ///         .filter(func!(|user| user\n    ///             .clone()\n    ///             .g(\"name\")\n    ///             .g(\"first\")\n    ///             .eq(\"Moussa\")\n    ///             .and(user.g(\"name\").g(\"last\").eq(\"Ibrahim\"))\n    ///         ))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{args, r, Result};\n    /// use serde_json::json;\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"users\")\n    ///         .filter(func!(|user| user\n    ///             .g(\"name\")\n    ///             .eq(r.expr(json!({\n    ///                 \"first\": \"Moussa\",\n    ///                 \"last\": \"Ibrahim\",\n    ///             })))\n    ///         ))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [get](Self::get)\n    /// - [get_all](Self::get_all)\n    /// - [between](Self::between)\n    pub fn filter(self, args: impl filter::FilterArg) -\u003e Self {\n        filter::new(args).with_parent(self)\n    }\n\n    /// Returns an inner join of two sequences.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// sequence.inner_join(other_sequence, func) → response\n    /// ```\n    ///\n    /// Where:\n    /// - other_sequence: [Command](crate::Command)\n    /// - func: func!(...)\n    /// - response: [Vec\u003cJoinResponse\u003cLeft, Right\u003e\u003e](crate::types::JoinResponse)\n    ///\n    /// # Description\n    ///\n    /// The returned sequence represents an intersection of the left-hand sequence\n    /// and the right-hand sequence: each row of the left-hand sequence will be\n    /// compared with each row of the right-hand sequence to find all pairs of rows\n    /// which satisfy the predicate. In most cases, you will want to follow the join\n    /// with [zip](Self::zip) to combine the left and right results.\n    ///\n    /// ```text\n    /// Note that `inner_join` is slower and much less efficient than using `concat_map`\n    /// with `get_all`. You should avoid using `inner_join` in commands when possible.\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Return a list of all matchups between Marvel and DC heroes\n    /// in which the DC hero could beat the Marvel hero in a fight.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"marvel\")\n    ///         .inner_join(\n    ///             r.table(\"dc\"),\n    ///             func!(|marvel, dc| marvel.g(\"strength\").lt(dc.g(\"strength\")))\n    ///         )\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// (Compare this to an [outer_join](Self::outer_join) with\n    /// the same inputs and predicate, which would return a list\n    /// of **all** Marvel heroes along with any DC heroes with a higher strength.)\n    ///\n    /// # Related commands\n    /// - [eq_join](Self::eq_join)\n    /// - [outer_join](Self::outer_join)\n    /// - [zip](Self::zip)\n    pub fn inner_join(self, other_sequence: Command, func: Func) -\u003e Self {\n        inner_join::new(other_sequence, func).with_parent(self)\n    }\n\n    /// Returns a left outer join of two sequences.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// sequence.outer_join(other_sequence, func) → response\n    /// ```\n    ///\n    /// Where:\n    /// - other_sequence: [Command](crate::Command)\n    /// - func: func!(...)\n    /// - response: [Vec\u003cJoinResponse\u003cLeft, Right\u003e\u003e](crate::types::JoinResponse)\n    ///\n    /// # Description\n    ///\n    /// The returned sequence represents a union of the left-hand sequence and the\n    /// right-hand sequence: all documents in the left-hand sequence will be returned,\n    /// each matched with a document in the right-hand sequence if one satisfies the\n    /// predicate condition. In most cases, you will want to follow the join with\n    /// [zip](Self::zip) to combine the left and right results.\n    ///\n    /// ```text\n    /// Note that `outer_join` is slower and much less efficient than using `concat_map`\n    /// with `get_all`. You should avoid using `outer_join` in commands when possible.\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Return a list of all Marvel heroes, paired with\n    /// any DC heroes who could beat them in a fight.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"marvel\")\n    ///         .outer_join(\n    ///             r.table(\"dc\"),\n    ///             func!(|marvel, dc| marvel.g(\"strength\").lt(dc.g(\"strength\")))\n    ///         )\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// (Compare this to an [inner_join](Self::inner_join) with\n    /// the same inputs and predicate, which would return a list\n    /// only of the matchups in which the DC hero has the higher strength.)\n    ///\n    /// # Related commands\n    /// - [eq_join](Self::eq_join)\n    /// - [inner_join](Self::inner_join)\n    /// - [zip](Self::zip)\n    pub fn outer_join(self, other_sequence: Command, func: Func) -\u003e Self {\n        outer_join::new(other_sequence, func).with_parent(self)\n    }\n\n    /// Join tables using a field or function on the left-hand sequence\n    /// matching primary keys or secondary indexes on the right-hand table.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// sequence.eq_join(args!(left_field, right_table)) → response\n    /// sequence.eq_join(args!(func, right_table)) → response\n    /// sequence.eq_join(args!(left_field, right_table, options)) → response\n    /// sequence.eq_join(args!(func, right_table, options)) → response\n    /// ```\n    ///\n    /// Where:\n    /// - left_field, right_table: [Command](crate::Command)\n    /// - func: func!(...)\n    /// - options: [EqJoinOption](crate::cmd::eq_join::EqJoinOption)\n    /// - response: [Vec\u003cJoinResponse\u003cLeft, Right\u003e\u003e](crate::types::JoinResponse)\n    ///\n    /// # Description\n    ///\n    /// `eq_join` is more efficient than other ReQL join types, and operates much faster.\n    /// Documents in the result set consist of pairs of left-hand and right-hand documents,\n    /// matched when the field on the left-hand side exists and is non-null and an entry\n    /// with that field’s value exists in the specified index on the right-hand side.\n    ///\n    /// The result set of `eq_join` is a stream or array of\n    /// [JoinResponse\u003cLeftDocument, RightDocument\u003e](crate::types::JoinResponse).\n    /// Each object in the returned set will be an object of the form\n    /// `{ left: \u003cLeftDocument\u003e, right: \u003cRightDocument\u003e }`, where the values of `left` and\n    /// `right` will be the joined documents.\n    /// Use the [zip](Self::zip) command to merge the `left` and `right` fields together.\n    ///\n    /// The results from `eq_join` are, by default, not ordered.\n    ///\n    /// Suppose the players table contains these documents:\n    ///\n    /// ```text\n    /// [\n    ///     { \"id\": 1, \"player\": \"Moussa\", \"game_id\": 1 },\n    ///     { \"id\": 2, \"player\": \"Fatima\", \"game_id\": 3 },\n    ///     { \"id\": 3, \"player\": \"Abessolo\", \"game_id\": 2 },\n    ///     { \"id\": 4, \"player\": \"Kamga\", \"game_id\": 2 },\n    ///     { \"id\": 5, \"player\": \"Malika\", \"game_id\": 1 },\n    ///     { \"id\": 6, \"player\": \"Ibrahim\", \"game_id\": 3 }\n    /// ]\n    /// ```\n    ///\n    /// The games table contains these documents:\n    ///\n    /// [\n    ///     { \"id\": 1, \"field\": \"Aurion\" },\n    ///     { \"id\": 2, \"field\": \"Adventures of Nyangi\" },\n    ///     { \"id\": 3, \"field\": \"Gazkar\" }\n    /// ]\n    ///\n    /// ## Examples\n    ///\n    /// Match players with the games they’ve played against one another.\n    ///\n    /// Join these tables using `game_id` on the player table and `id` on the games table:\n    ///\n    /// ```\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"players\")\n    ///         .eq_join(args!(\"game_id\", r.table(\"games\")))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// For more information, see\n    /// [Table joins in RethinkDB](https://rethinkdb.com/docs/table-joins/).\n    ///\n    /// ## Examples\n    ///\n    /// Use a secondary index on the right table rather than the primary key.\n    /// If players have a secondary index on their cities, we can get a list\n    /// of arenas with players in the same area.\n    ///\n    /// ```\n    /// use reql_rust::cmd::eq_join::EqJoinOption;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"players\")\n    ///         .eq_join(args!(\n    ///             \"city_id\",\n    ///             r.table(\"arenas\"),\n    ///             EqJoinOption::default().index(\"city_id\")\n    ///         ))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Use a function instead of a field to join on a more complicated expression.\n    /// Suppose the players have lists of favorite games ranked in order in a field\n    /// such as \"favorites\": [3, 2, 1]. Get a list of players and their top favorite:\n    ///\n    /// ```\n    /// use reql_rust::cmd::eq_join::EqJoinOption;\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{args, r, Result};\n    /// use serde_json::json;\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"players\")\n    ///         .eq_join(args!(\n    ///             func!(|player| player.g(\"favorites\").nth(0)),\n    ///             r.table(\"games\")\n    ///         ))\n    ///         .without(json!([\n    ///             { \"left\": [\"favorites\", \"game_id\", \"id\"] },\n    ///             { \"right\": \"id\" }\n    ///         ]))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [inner_join](Self::inner_join)\n    /// - [outer_join](Self::outer_join)\n    /// - [without](Self::without)\n    /// - [zip](Self::zip)\n    pub fn eq_join(self, args: impl eq_join::EqJoinArg) -\u003e Self {\n        eq_join::new(args).with_parent(self)\n    }\n\n    /// Used to ‘zip’ up the result of a join by merging the ‘right’\n    /// fields into ‘left’ fields of each member of the sequence.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// stream.zip() → stream\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// ‘zips up’ the sequence by merging the left and right fields produced by a join.\n    ///\n    /// ```\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"posts\")\n    ///         .eq_join(args!(\"user_id\", r.table(\"users\")))\n    ///         .zip()\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [eq_join](Self::eq_join)\n    /// - [inner_join](Self::inner_join)\n    /// - [outer_join](Self::outer_join)\n    pub fn zip(self) -\u003e Self {\n        zip::new().with_parent(self)\n    }\n\n    /// Transform each element of one or more sequences\n    /// by applying a mapping function to them.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// sequence.map(func) → stream\n    /// sequence.map(sequence, func) → stream\n    /// sequence.map(sequences, func) → stream\n    /// r.map(sequence, func) → stream\n    /// r.map(sequence, sequence, func) → stream\n    /// r.map(sequence, sequences, func) → stream\n    /// ```\n    ///\n    /// Where:\n    /// - func: func!(...)\n    /// - sequence: [Command](crate::Command)\n    /// - sequences: [...] | \u0026[...] | vec![...]\n    ///\n    /// # Description\n    ///\n    /// If `map` is run with two or more sequences, it will iterate\n    /// for as many items as there are in the shortest sequence.\n    ///\n    /// Note that `map` can only be applied to sequences, not single values.\n    /// If you wish to apply a function to a single value/selection (including an array),\n    /// use the [do_](Self::do_) command.\n    ///\n    /// ## Examples\n    ///\n    /// Return the first five squares.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: Vec\u003cu8\u003e = r.expr([1, 2, 3, 4, 5])\n    ///         .map(func!(|val| val.clone() * val))\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert_eq!(response, [1, 4, 9, 16, 25]);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Sum the elements of three sequences.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let sequence1 = r.expr([100, 200, 300, 400]);\n    ///     let sequence2 = r.expr([10, 20, 30, 40]);\n    ///     let sequence3 = r.expr([1, 2, 3, 4]);\n    ///\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: Vec\u003cu32\u003e = r.map(sequence1, args!(\n    ///             [sequence2, sequence3],\n    ///             func!(|val1, val2, val3| val1 + val2 + val3)\n    ///         ))\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert_eq!(response, [111, 222, 333, 444]);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Rename a field when retrieving documents\n    /// using `map` and [merge](Self::merge).\n    ///\n    /// This example renames the field `id` to `user_id`\n    /// when retrieving documents from the table `users`.\n    ///\n    /// ```\n    /// use std::collections::HashMap;\n    ///\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"users\")\n    ///         .map(func!(|doc| {\n    ///             let mut user = HashMap::new();\n    ///             user.insert(\"user_id\", doc.clone().g(\"id\"));\n    ///             \n    ///             doc.merge(r.hash_map(user)).without(\"id\")\n    ///         }))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Assign every superhero an archenemy.\n    ///\n    /// ```\n    /// use std::collections::HashMap;\n    ///\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"heroes\")\n    ///         .map(args!(r.table(\"villains\"), func!(|hero, villain| {\n    ///             let mut villain_obj = HashMap::new();\n    ///             villain_obj.insert(\"villain\", villain);\n    ///\n    ///             hero.merge(r.hash_map(villain_obj))\n    ///         })))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [concat_map](Self::concat_map)\n    /// - [reduce](Self::reduce)\n    /// - [do_](Self::do_)\n    pub fn map(self, args: impl map::MapArg) -\u003e Self {\n        map::new(args).with_parent(self)\n    }\n\n    /// Plucks one or more attributes from a sequence of objects, filtering\n    /// out any objects in the sequence that do not have the specified fields.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// sequence.with_fields(selector) → stream\n    /// sequence.with_fields(selectors) → stream\n    /// ```\n    ///\n    /// Where:\n    /// - selector: \u0026str | String | Cow\u003c'static, String\u003e\n    /// - selectors: [...] | \u0026[...] | vec![...]\n    ///\n    /// # Description\n    ///\n    /// Functionally, this is identical to [has_fields](Self::has_fields)\n    /// followed by [pluck](Self::pluck) on a sequence.\n    ///\n    /// ## Examples\n    ///\n    /// Get a list of users and their posts, excluding any users who have not made any posts.\n    ///\n    /// Existing table structure:\n    ///\n    /// ```text\n    /// [\n    ///     { \"id\": 1, \"user\": \"bob\", \"email\": \"bob@foo.com\", \"posts\": [ 1, 4, 5 ] },\n    ///     { \"id\": 2, \"user\": \"george\", \"email\": \"george@foo.com\" },\n    ///     { \"id\": 3, \"user\": \"jane\", \"email\": \"jane@foo.com\", \"posts\": [ 2, 3, 6 ] }\n    /// ]\n    /// ```\n    ///\n    /// Command and output:\n    ///\n    /// ```\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"users\")\n    ///         .with_fields([\"id\", \"user\", \"posts\"])\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///\n    ///     // [\n    ///     //      { \"id\": 1, \"user\": \"bob\", \"posts\": [ 1, 4, 5 ] },\n    ///     //      { \"id\": 3, \"user\": \"jane\", \"posts\": [ 2, 3, 6 ] }\n    ///     // ]\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [has_fields](Self::has_fields)\n    /// - [pluck](Self::pluck)\n    /// - [without](Self::without)\n    pub fn with_fields(self, fields: impl Serialize) -\u003e Self {\n        with_fields::new(fields).with_parent(self)\n    }\n\n    // TODO write Doc\n    pub fn concat_map(self, func: Func) -\u003e Command {\n        concat_map::new(func).with_parent(self)\n    }\n\n    // TODO write Doc\n    pub fn order_by(self, args: impl order_by::OrderByArg) -\u003e Self {\n        order_by::new(args).with_parent(self)\n    }\n\n    /// Skip a number of elements from the head of the sequence.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// sequence.skip(n) → stream\n    /// ```\n    ///\n    /// Where:\n    /// - n: usize\n    ///\n    /// ## Examples\n    ///\n    /// Only so many can fit in our Pantheon of heroes.\n    ///\n    /// ```\n    /// use reql_rust::cmd::order_by::OrderByOption;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"players\")\n    ///         .order_by(OrderByOption::default().index(\"age\"))\n    ///         .skip(10)\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [order_by](Self::order_by)\n    /// - [limit](Self::limit)\n    /// - [slice](Self::slice)\n    /// - [nth](Self::nth)\n    pub fn skip(self, n: usize) -\u003e Self {\n        skip::new(n).with_parent(self)\n    }\n\n    /// End the sequence after the given numbers of elements.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// sequence.limit(n) → stream\n    /// ```\n    ///\n    /// Where:\n    /// - n: usize\n    ///\n    /// ## Examples\n    ///\n    /// Only so many can fit in our Pantheon of heroes.\n    ///\n    /// ```\n    /// use reql_rust::cmd::order_by::OrderByOption;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"players\")\n    ///         .order_by(OrderByOption::default().index(\"age\"))\n    ///         .limit(10)\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [order_by](Self::order_by)\n    /// - [skip](Self::skip)\n    /// - [slice](Self::slice)\n    /// - [nth](Self::nth)\n    pub fn limit(self, n: usize) -\u003e Self {\n        limit::new(n).with_parent(self)\n    }\n\n    /// Return the elements of a sequence within the specified range.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// selection.slice(start_offset) → selection\n    /// selection.slice(args!(start_offset, options)) → selection\n    /// selection.slice(args!(start_offset, end_offset)) → selection\n    /// selection.slice(args!(start_offset, end_offset, options)) → selection\n    /// ```\n    ///\n    /// Where:\n    /// - start_offset, end_offset: isize\n    /// - options: [SliceOption](crate::cmd::slice::SliceOption)\n    ///\n    /// # Description\n    ///\n    /// // TODO Complete this description\n    ///\n    /// ## Examples\n    ///\n    /// Return the fourth, fifth and sixth youngest players.\n    /// (The youngest player is at index 0, so those are elements 3-5.)\n    ///\n    /// ```\n    /// use reql_rust::cmd::order_by::OrderByOption;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"players\")\n    ///         .order_by(OrderByOption::default().index(\"age\"))\n    ///         .slice(args!(3, 6))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Return all but the top three playerss who have a red flag.\n    ///\n    /// ```\n    /// use reql_rust::{args, r, Result};\n    /// use serde_json::json;\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"players\")\n    ///         .filter(json!({\"flag\": \"red\"}))\n    ///         .slice(3)\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Return the holders of tickets `X` through `Y`,\n    /// assuming tickets are numbered sequentially.\n    /// We want to include ticket `Y`.\n    ///\n    /// ```\n    /// use reql_rust::arguments::Status;\n    /// use reql_rust::cmd::order_by::OrderByOption;\n    /// use reql_rust::cmd::slice::SliceOption;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let x = 3;\n    ///     let y = 6;\n    ///     let order_by_options = OrderByOption::default().index(\"ticket\");\n    ///     let slice_options = SliceOption::default().right_bound(Status::Closed);\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"users\")\n    ///         .order_by(order_by_options)\n    ///         .slice(args!(x, y, slice_options))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Return the elements of an array from the second through\n    /// two from the end (that is, not including the last two).\n    ///\n    /// ```\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: Vec\u003cu8\u003e = r.expr([0, 1, 2, 3, 4, 5])\n    ///         .slice(args!(2, -2))\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert_eq!(response, vec![2, 3]);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Return the thirds through fifth characters of a string.\n    ///\n    /// ```\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: String = r.expr(\"I love africa.\")\n    ///         .slice(args!(-7, -1))\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert_eq!(response, \"africa\");\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [order_by](Self::order_by)\n    /// - [skip](Self::skip)\n    /// - [limit](Self::limit)\n    /// - [nth](Self::nth)\n    pub fn slice(self, args: impl slice::SliceArg) -\u003e Self {\n        slice::new(args).with_parent(self)\n    }\n\n    /// Get the **nth** element of a sequence, counting from zero.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// sequence.nth(index) → object\n    /// ```\n    ///\n    /// Where:\n    /// - index: isize\n    ///\n    /// # Description\n    ///\n    /// If the argument is negative, count from the last element.\n    ///\n    /// ## Examples\n    ///\n    /// Select the second element in the array.\n    ///\n    /// ```\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: u8 = r.expr([1, 2, 3])\n    ///         .nth(1)\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == 2);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Select the bronze medalist from the competitors.\n    ///\n    /// ```\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"players\")\n    ///         .order_by(r.desc(\"score\"))\n    ///         .nth(3)\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Select the last place competitors.\n    ///\n    /// ```\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"players\")\n    ///         .order_by(r.desc(\"score\"))\n    ///         .nth(-1)\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [order_by](Self::order_by)\n    /// - [skip](Self::skip)\n    /// - [limit](Self::limit)\n    /// - [bracket](Self::bracket)\n    /// - [slice](Self::slice)\n    pub fn nth(self, index: isize) -\u003e Self {\n        nth::new(index).with_parent(self)\n    }\n\n    /// Get the indexes of an element in a sequence.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// sequence.offsets_of(datum) → array\n    /// sequence.offsets_of(func!(...)) → array\n    /// ```\n    ///\n    /// Where:\n    /// - datum: impl Serialize\n    ///\n    /// # Description\n    ///\n    /// If the argument is a predicate, get\n    /// the indexes of all elements matching it.\n    ///\n    /// ## Examples\n    ///\n    /// Find the position of the letter ‘c’.\n    ///\n    /// ```\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: Vec\u003cusize\u003e = r.expr(['a','b','c'])\n    ///         .offsets_of('c')\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert_eq!(response.first(), Some(\u00262));\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Find the popularity ranking of invisible heroes.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"marvel\")\n    ///         .union(r.table(\"dc\"))\n    ///         .order_by(r.expr(\"popularity\"))\n    ///         .offsets_of(func!(|hero| hero.g(\"superpowers\").contains(\"invisibility\")))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    pub fn offsets_of(self, args: impl offsets_of::OffsetsOfArg) -\u003e Self {\n        offsets_of::new(args).with_parent(self)\n    }\n\n    /// Test if a sequence is empty.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// sequence.is_empty() → bool\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Are there any documents in the simbad table?\n    ///\n    /// ```\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: bool = r.table(\"simbad\")\n    ///         .is_empty()\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [offsets_of](Self::offsets_of)\n    pub fn is_empty(self) -\u003e Self {\n        is_empty::new().with_parent(self)\n    }\n\n    /// Merge two or more sequences.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// stream.union(sequence) → stream\n    /// stream.union(vec![sequence]) → stream\n    /// stream.union(args!(sequence, options)) → stream\n    /// stream.union(args!(vec![sequence], options)) → stream\n    /// ```\n    ///\n    /// Where:\n    /// - sequence: [Command](crate::Command)\n    /// - options: [UnionOption](crate::cmd::union::UnionOption)\n    ///\n    /// ## Examples\n    ///\n    /// Construct a stream of all characters.\n    ///\n    /// ```\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"simbad\")\n    ///         .union(r.table(\"kirikou\"))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    pub fn union(self, args: impl union::UnionArg) -\u003e Self {\n        union::new(args).with_parent(self)\n    }\n\n    /// Select a given number of elements from\n    /// a sequence with uniform random distribution.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// sequence.sample(number) → selection\n    /// stream.sample(number) → array\n    /// array.sample(number) → array\n    /// ```\n    ///\n    /// Where:\n    /// - number: usize\n    /// - sequence, stream, array: [Command](crate::Command)\n    ///\n    /// # Description\n    ///\n    /// Select a given number of elements from a\n    /// sequence with uniform random distribution.\n    /// Selection is done without replacement.\n    ///\n    /// If the sequence has less than the requested\n    /// number of elements (i.e., calling `sample(10)`\n    /// on a sequence with only five elements), `sample`\n    /// will return the entire sequence in a random order.\n    ///\n    /// ## Examples\n    ///\n    /// Select 3 random heroes.\n    ///\n    /// ```\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"simbad\")\n    ///         .sample(3)\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Select and stratify 3 random heroes by belovedness.\n    ///\n    /// ```\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"simbad\")\n    ///         .group(\"belovedness\")\n    ///         .sample(3)\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    pub fn sample(self, number: usize) -\u003e Self {\n        sample::new(number).with_parent(self)\n    }\n\n    /// Takes a stream and partitions it into multiple\n    /// groups based on the fields or functions provided.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// sequence.group(field) → grouped_stream\n    /// sequence.group(func) → grouped_stream\n    /// sequence.group(args!(field, options)) → grouped_stream\n    /// sequence.group(args!(func, options)) → grouped_stream\n    /// r.group(sequence, field) → grouped_stream\n    /// r.group(sequence, func) → grouped_stream\n    /// r.group(sequence, args!(field, options)) → grouped_stream\n    /// r.group(sequence, args!(func, options)) → grouped_stream\n    /// ```\n    ///\n    /// Where:\n    /// - field: \u0026str | [\u0026str; N]\n    /// - func: func!(...) | [func!(...); N]\n    /// - grouped_stream: [GroupedStream](crate::types::GroupedStream)\n    /// - sequence: [Command](crate::Command)\n    ///\n    /// # Description\n    ///\n    /// With the `multi` flag single documents can be assigned to multiple groups,\n    /// similar to the behavior of\n    /// [multi-indexes](https://rethinkdb.com/docs/secondary-indexes/javascript).\n    /// When `multi` is `true` and the grouping value is an array, documents\n    /// will be placed in each group that corresponds to the elements of the array.\n    /// If the array is empty the row will be ignored.\n    ///\n    /// Suppose that the table games has the following data:\n    ///\n    /// ```text\n    /// [\n    ///     {id: 2, player: \"Moussa\", points: 15, class: \"ranked\"},\n    ///     {id: 5, player: \"Fatou\", points: 7, class: \"free\"},\n    ///     {id: 11, player: \"Moussa\", points: 10, class: \"free\"},\n    ///     {id: 12, player: \"Fatou\", points: 2, class: \"free\"}\n    /// ]\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Group games by player.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::types::{GroupedItem, GroupedStream};\n    /// use reql_rust::{args, r, Result};\n    /// use serde::{Serialize, Deserialize};\n    ///\n    /// #[derive(Serialize, Deserialize, PartialEq, Eq)]\n    /// struct Player {\n    ///     id: u8,\n    ///     player: String,\n    ///     points: u8,\n    ///     class: String,\n    /// }\n    ///\n    /// impl Player {\n    ///     fn new(id: u8, player: \u0026str, points: u8, class: \u0026str) -\u003e Self {\n    ///         Self {\n    ///             id,\n    ///             points,\n    ///             player: player.to_owned(),\n    ///             class: class.to_owned(),\n    ///         }\n    ///     }\n    /// }\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let expected_data = vec![\n    ///         GroupedItem {\n    ///             group: String::from(\"Fatou\"),\n    ///             values: vec![\n    ///                 Player::new(5, \"Fatou\", 7, \"free\"),\n    ///                 Player::new(12, \"Fatou\", 2, \"free\"),\n    ///             ]\n    ///         },\n    ///         GroupedItem {\n    ///             group: String::from(\"Moussa\"),\n    ///             values: vec![\n    ///                 Player::new(2, \"Moussa\", 15, \"ranked\"),\n    ///                 Player::new(11, \"Moussa\", 10, \"free\"),\n    ///             ]\n    ///         },\n    ///     ];\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: GroupedStream\u003cString, Player\u003e = r.table(\"games\")\n    ///         .group(\"player\")\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response.collect() == expected_data);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [ungroup](Self::ungroup)\n    /// - [map](Self::map)\n    /// - [reduce](Self::reduce)\n    /// - [count](Self::count)\n    /// - [sum](Self::sum)\n    /// - [avg](Self::avg)\n    /// - [min](Self::min)\n    /// - [max](Self::max)\n    pub fn group(self, args: impl group::GroupArg) -\u003e Self {\n        group::new(args).with_parent(self)\n    }\n\n    /// Takes a grouped stream or grouped data and turns it\n    /// into an array of objects representing the groups.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// grouped_stream.ungroup() → array\n    /// grouped_data.ungroup() → array\n    /// ```\n    ///\n    /// Where:\n    /// - grouped_stream, grouped_data: [Command](crate::Command)\n    ///\n    /// # Description\n    ///\n    /// Any commands chained after `ungroup` will operate on this array,\n    /// rather than operating on each group individually. This is useful\n    /// if you want to e.g. order the groups by the value of their reduction.\n    ///\n    /// The format of the array returned by `ungroup` is the same as\n    /// the default native format of grouped data in the javascript driver and data explorer.\n    ///\n    /// Suppose that the table games has the following data:\n    ///\n    /// ```text\n    /// [\n    ///     {id: 2, player: \"Moussa\", points: 15, type: \"ranked\"},\n    ///     {id: 5, player: \"Fatou\", points: 7, type: \"free\"},\n    ///     {id: 11, player: \"Ibrahim\", points: 10, type: \"free\"},\n    ///     {id: 12, player: \"Abess\", points: 2, type: \"free\"}\n    /// ]\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// What is the maximum number of points scored by each player, with the highest scorers first?\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{args, r, Result};\n    /// use serde_json::json;\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let expected_data = json!([\n    ///         {\n    ///             \"group\": \"Bob\",\n    ///             \"reduction\": 15\n    ///         },\n    ///         {\n    ///             \"group\": \"Alice\",\n    ///             \"reduction\": 7\n    ///         }\n    ///     ]);\n    ///     let response = r.table(\"games\")\n    ///         .group(\"player\")\n    ///         .max(args!(\"points\"))\n    ///         .g(\"points\")\n    ///         .ungroup()\n    ///         .order_by(r.desc(\"reduction\"))\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap();\n    ///\n    ///     assert!(response == expected_data);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// A shorter way to execute this query is to use [count](Self::count).\n    ///\n    /// ## Examples\n    ///\n    /// Suppose that each `post` has a field `comments` that is an array of comments.\n    /// Return the maximum number comments per post.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"posts\")\n    ///         .map(func!(|post| post.g(\"comments\").count(())))\n    ///         .reduce(func!(|left, right| r.branch(\n    ///             left.clone().gt(right.clone()),\n    ///             args!(left, right)\n    ///         )))\n    ///         .default(0)\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// A shorter way to execute this query is to use [max](Self::max).\n    ///\n    /// # Related commands\n    /// - [group](Self::group)\n    pub fn ungroup(self) -\u003e Self {\n        ungroup::new().with_parent(self)\n    }\n\n    /// Produce a single value from a sequence through\n    /// repeated application of a reduction function.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// sequence.fold(base, func) → value\n    /// ```\n    ///\n    /// Where:\n    /// - base, value: impl Serialize\n    /// - func: func!(...)\n    /// - sequence: [Command](crate::Command)\n    ///\n    /// # Description\n    ///\n    /// The reduction function can be called on:\n    ///\n    /// - two elements of the sequence\n    /// - one element of the sequence and one result of a previous reduction\n    /// - two results of previous reductions\n    ///\n    /// The reduction function can be called on the results of\n    /// two previous reductions because the `reduce` command is\n    /// distributed and parallelized across shards and CPU cores.\n    /// A common mistaken when using the `reduce` command is to\n    /// suppose that the reduction is executed from left to right.\n    /// [Read the map-reduce in RethinkDB](https://rethinkdb.com/docs/map-reduce/)\n    /// article to see an example.\n    ///\n    /// If the sequence is empty, the server will produce a\n    /// `ReqlRuntimeError` that can be caught with default.\n    /// If the sequence has only one element, the first element will be returned.\n    ///\n    /// ## Examples\n    ///\n    /// Return the number of documents in the table posts.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"posts\")\n    ///         .map(func!(|| r.expr(1)))\n    ///         .reduce(func!(|left, right| left + right))\n    ///         .default(0)\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// A shorter way to execute this query is to use [count](Self::count).\n    ///\n    /// ## Examples\n    ///\n    /// Suppose that each `post` has a field `comments` that is an array of comments.\n    /// Return the maximum number comments per post.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"posts\")\n    ///         .map(func!(|post| post.g(\"comments\").count(())))\n    ///         .reduce(func!(|left, right| r.branch(\n    ///             left.clone().gt(right.clone()),\n    ///             args!(left, right)\n    ///         )))\n    ///         .default(0)\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// A shorter way to execute this query is to use [max](Self::max).\n    ///\n    /// # Related commands\n    /// - [group](Self::group)\n    /// - [map](Self::map)\n    /// - [concat_map](Self::concat_map)\n    /// - [sum](Self::sum)\n    /// - [avg](Self::avg)\n    /// - [min](Self::min)\n    /// - [max](Self::max)\n    pub fn reduce(self, func: Func) -\u003e Self {\n        reduce::new(func).with_parent(self)\n    }\n\n    /// Apply a function to a sequence in order,\n    /// maintaining state via an accumulator.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// sequence.fold(base, func) → value\n    /// ```\n    ///\n    /// Where:\n    /// - base, value: impl Serialize\n    /// - func: func!(...)\n    /// - sequence: [Command](crate::Command)\n    ///\n    /// # Description\n    ///\n    /// The `fold` command returns either a single value or a new sequence.\n    ///\n    /// In its first form, `fold` operates like [reduce](Self::reduce), returning a value\n    /// by applying a combining function to each element in a sequence.\n    /// The combining function takes two parameters: the previous reduction\n    /// result (the accumulator) and the current element. However, `fold` has\n    /// the following differences from `reduce`:\n    /// - it is guaranteed to proceed through the sequence from first element to last.\n    /// - it passes an initial base value to the function with the first element in\n    /// place of the previous reduction result.\n    ///\n    /// ```text\n    /// combining_function(accumulator | base, element) → new_accumulator\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Concatenate words from a list.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"words\")\n    ///         .order_by(r.expr(\"id\"))\n    ///         .fold(\n    ///             \"\",\n    ///             func!(|acc, word| acc.clone()\n    ///                 + r.branch(acc.eq(\"\"), args!(r.expr(\"\"), r.expr(\", \")))\n    ///                 + word),\n    ///         )\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// (This example could be implemented with `reduce`,\n    /// but `fold` will preserve the order when `words` is\n    /// a RethinkDB table or other stream, which is\n    /// not guaranteed with `reduce`.)\n    ///\n    /// # Related commands\n    /// - [reduce](Self::reduce)\n    /// - [concat_map](Self::concat_map)\n    pub fn fold\u003cT\u003e(self, base: T, func: Func) -\u003e Self\n    where\n        T: Serialize,\n    {\n        fold::new(base, func).with_parent(self)\n    }\n\n    /// Count the number of elements in sequence or key/value pairs in an object,\n    /// or returns the size of a string or binary object.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// binary.count(()) → number\n    /// string.count(()) → number\n    /// object.count(()) → number\n    /// sequence.count(()) → number\n    /// sequence.count(args!(value)) → number\n    /// sequence.count(func) → number\n    /// r.count(query_cmd) → number\n    /// r.count(query_cmd, args!(value)) → number\n    /// r.count(query_cmd, func) → number\n    /// ```\n    ///\n    /// Where:\n    /// - value: impl Serialize\n    /// - func: func!(...)\n    /// - sequence, binary, string, object, query_cmd: [Command](crate::Command)\n    ///\n    /// # Description\n    ///\n    /// When `count` is called on a sequence with a predicate value or function,\n    /// it returns the number of elements in the sequence equal to that value or\n    /// where the function returns `true`. On a [binary](crate::r::binary) object, `count`\n    /// returns the size of the object in bytes; on strings, `count` returns the string’s length.\n    /// This is determined by counting the number of Unicode codepoints in the string,\n    /// counting combining codepoints separately.\n    ///\n    /// ## Examples\n    ///\n    /// Count the number of users.\n    ///\n    /// ```\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"users\")\n    ///         .count(())\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Count the number of 18 year old users.\n    ///\n    /// ```\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"users\")\n    ///         .g(\"age\")\n    ///         .count(args!(18))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Count the number of users over 18.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"users\")\n    ///         .g(\"age\")\n    ///         .count(func!(|age| age.gt(18)))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Return the length of a Unicode string.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: usize = r.expr(\"こんにちは\")\n    ///         .count(())\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == 5);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Return the length of an array.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: usize = r.expr(['0','1','2'])\n    ///         .count(())\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == 3);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [map](Self::map)\n    /// - [reduce](Self::reduce)\n    /// - [sum](Self::sum)\n    /// - [avg](Self::avg)\n    /// - [min](Self::min)\n    /// - [max](Self::max)\n    /// - [group](Self::group)\n    pub fn count(self, args: impl count::CountArg) -\u003e Self {\n        count::new(args).with_parent(self)\n    }\n\n    /// Sum all the elements of sequence.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// sequence.sum(()) → number\n    /// sequence.sum(field) → number\n    /// sequence.sum(func) → number\n    /// r.sum(sequence) → number\n    /// r.sum(sequence, field) → number\n    /// r.sum(sequence, func) → number\n    /// ```\n    ///\n    /// Where:\n    /// - field: \u0026str, String, Cow\u003c'static, str\u003e\n    /// - func: func!(...)\n    /// - sequence: [Command](crate::Command)\n    ///\n    /// # Description\n    ///\n    /// If called with a field name, sums all the values of that field in\n    /// the sequence, skipping elements of the sequence that lack that field.\n    /// If called with a function, calls that function on every element of the\n    /// sequence and sums the results, skipping elements of the sequence\n    /// where that function returns `None` or non-existence error.\n    ///\n    /// Returns `0` when called on an empty sequence.\n    ///\n    /// ## Examples\n    ///\n    /// What's 3 + 5 + 7?\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: u8 = r.expr([3, 5, 7])\n    ///         .sum(())\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == 15);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// How many points have been scored across all games?\n    ///\n    /// ```\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"games\")\n    ///         .sum(\"points\")\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// How many points have been scored across all games, counting bonus points?\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"games\")\n    ///         .sum(func!(|game| game.clone().g(\"points\") + game.g(\"bonus_points\")))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [map](Self::map)\n    /// - [reduce](Self::reduce)\n    /// - [count](Self::count)\n    /// - [avg](Self::avg)\n    /// - [min](Self::min)\n    /// - [max](Self::max)\n    /// - [group](Self::group)\n    pub fn sum(self, args: impl sum::SumArg) -\u003e Self {\n        sum::new(args).with_parent(self)\n    }\n\n    /// Averages all the elements of sequence.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// sequence.avg(()) → Option\u003cf64\u003e\n    /// sequence.avg(field) → Option\u003cf64\u003e\n    /// sequence.avg(func) → Option\u003cf64\u003e\n    /// r.avg(sequence) → Option\u003cf64\u003e\n    /// r.avg(sequence, field) → Option\u003cf64\u003e\n    /// r.avg(sequence, func) → Option\u003cf64\u003e\n    /// ```\n    ///\n    /// Where:\n    /// - field: \u0026str, String, Cow\u003c'static, str\u003e\n    /// - func: func!(...)\n    /// - sequence: [Command](crate::Command)\n    ///\n    /// # Description\n    ///\n    /// If called with a field name, averages all the values of that field in\n    /// the sequence, skipping elements of the sequence that lack that field.\n    /// If called with a function, calls that function on every element of the\n    /// sequence and averages the results, skipping elements of the sequence\n    /// where that function returns `None` or non-existence error.\n    ///\n    /// Produces a non-existence error when called on an empty sequence.\n    /// You can handle this case with `default`.\n    ///\n    /// ## Examples\n    ///\n    /// What's the average of 3, 5 and 7?\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: Option\u003cf64\u003e = r.expr([3, 5, 7])\n    ///         .avg(())\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == Some(5.));\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// What's the average number of points scored in a games?\n    ///\n    /// ```\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"games\")\n    ///         .avg(\"points\")\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// What's the average number of points scored in a games, counting bonus points?\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"games\")\n    ///         .avg(func!(|game| game.clone().g(\"points\") + game.g(\"bonus_points\")))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [map](Self::map)\n    /// - [reduce](Self::reduce)\n    /// - [count](Self::count)\n    /// - [sum](Self::sum)\n    /// - [min](Self::min)\n    /// - [max](Self::max)\n    /// - [group](Self::group)\n    pub fn avg(self, args: impl avg::AvgArg) -\u003e Self {\n        avg::new(args).with_parent(self)\n    }\n\n    /// Finds the minimum element of a sequence.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// sequence.min(()) → element\n    /// sequence.min(args!(field)) → element\n    /// sequence.min(func) → element\n    /// sequence.min(options) → element\n    /// r.min(sequence) → element\n    /// r.min(sequence, args!(field)) → element\n    /// r.min(sequence, func) → element\n    /// r.min(sequence, options) → element\n    /// ```\n    ///\n    /// Where:\n    /// - field: \u0026str, String, Cow\u003c'static, str\u003e\n    /// - func: func!(...)\n    /// - options: [MinOption](crate::cmd::min::MinOption)\n    /// - sequence: [Command](crate::Command)\n    ///\n    /// # Description\n    ///\n    /// The `min` command can be called with:\n    /// - a `field name`, to return the element of the sequence\n    /// with the largest value in that field;\n    /// - a `function`, to apply the function to every element within the sequence\n    /// and return the element which returns the largest value from the function,\n    /// ignoring any elements where the function produces a non-existence error;\n    /// - an `index` (the primary key or a secondary index), to return the element\n    /// of the sequence with the largest value in that index;\n    ///\n    /// For more information on RethinkDB’s sorting order, read the section in\n    /// [ReQL data types](https://rethinkdb.com/docs/data-types/#sorting-order).\n    ///\n    /// Calling `min` on an empty sequence will throw a non-existence error;\n    /// this can be handled using the [default](Self::default) command.\n    ///\n    /// ## Examples\n    ///\n    /// Return the minimum value in the list [3, 5, 7].\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: u8 = r.expr([3, 5, 7])\n    ///         .min(())\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == 3);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Return the user who has scored the fewest points.\n    ///\n    /// ```\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"users\")\n    ///         .min(args!(\"points\"))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// The same as above, but using a secondary index on the `points` field.\n    ///\n    /// ```\n    /// use reql_rust::cmd::min::MinOption;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"users\")\n    ///         .min(MinOption::default().index(\"points\"))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Return the user who has scored the fewest points,\n    /// adding in bonus points from a separate field using a function.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"users\")\n    ///         .min(func!(|user| user.clone().g(\"points\") + user.g(\"bonus_points\")))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Return the highest number of points any user has ever scored.\n    /// This returns the value of that `points` field, not a document.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: u8 = r.table(\"users\")\n    ///         .min(args!(\"points\"))\n    ///         .g(\"points\")\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == 2);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [map](Self::map)\n    /// - [reduce](Self::reduce)\n    /// - [count](Self::count)\n    /// - [sum](Self::sum)\n    /// - [avg](Self::avg)\n    /// - [max](Self::max)\n    /// - [group](Self::group)\n    pub fn min(self, args: impl min::MinArg) -\u003e Self {\n        min::new(args).with_parent(self)\n    }\n\n    /// Finds the maximum element of a sequence.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// sequence.max(()) → element\n    /// sequence.max(args!(field)) → element\n    /// sequence.max(func) → element\n    /// sequence.max(options) → element\n    /// r.max(sequence) → element\n    /// r.max(sequence, args!(field)) → element\n    /// r.max(sequence, func) → element\n    /// r.max(sequence, options) → element\n    /// ```\n    ///\n    /// Where:\n    /// - field: \u0026str, String, Cow\u003c'static, str\u003e\n    /// - func: func!(...)\n    /// - options: [MaxOption](crate::cmd::max::MaxOption)\n    /// - sequence: [Command](crate::Command)\n    ///\n    /// # Description\n    ///\n    /// The `max` command can be called with:\n    /// - a `field name`, to return the element of the sequence\n    /// with the largest value in that field;\n    /// - a `function`, to apply the function to every element within the sequence\n    /// and return the element which returns the largest value from the function,\n    /// ignoring any elements where the function produces a non-existence error;\n    /// - an `index` (the primary key or a secondary index), to return the element\n    /// of the sequence with the largest value in that index;\n    ///\n    /// For more information on RethinkDB’s sorting order, read the section in\n    /// [ReQL data types](https://rethinkdb.com/docs/data-types/#sorting-order).\n    ///\n    /// Calling `max` on an empty sequence will throw a non-existence error;\n    /// this can be handled using the [default](Self::default) command.\n    ///\n    /// ## Examples\n    ///\n    /// Return the maximum value in the list [3, 5, 7].\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: u8 = r.expr([3, 5, 7])\n    ///         .max(())\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == 7);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Return the user who has scored the most points.\n    ///\n    /// ```\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"users\")\n    ///         .max(args!(\"points\"))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// The same as above, but using a secondary index on the `points` field.\n    ///\n    /// ```\n    /// use reql_rust::cmd::max::MaxOption;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"users\")\n    ///         .max(MaxOption::default().index(\"points\"))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Return the user who has scored the most points,\n    /// adding in bonus points from a separate field using a function.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"users\")\n    ///         .max(func!(|user| user.clone().g(\"points\") + user.g(\"bonus_points\")))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Return the highest number of points any user has ever scored.\n    /// This returns the value of that `points` field, not a document.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: u8 = r.table(\"users\")\n    ///         .max(args!(\"points\"))\n    ///         .g(\"points\")\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == 15);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [map](Self::map)\n    /// - [reduce](Self::reduce)\n    /// - [count](Self::count)\n    /// - [sum](Self::sum)\n    /// - [avg](Self::avg)\n    /// - [min](Self::min)\n    /// - [group](Self::group)\n    pub fn max(self, args: impl max::MaxArg) -\u003e Self {\n        max::new(args).with_parent(self)\n    }\n\n    /// Removes duplicate elements from a sequence.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// sequence.distinct(()) → array\n    /// table.distinct(options) → stream\n    /// r.distinct(sequence) → array\n    /// r.distinct(table, options) → stream\n    /// ```\n    ///\n    /// Where:\n    /// - options: [DistinctOption](crate::cmd::distinct::DistinctOption)\n    /// - sequence: [Command](crate::Command)\n    ///\n    /// # Description\n    ///\n    /// The `distinct` command can be called on any sequence or table with an index.\n    ///\n    /// ```text\n    /// While `distinct` can be called on a table without an index,\n    /// the only effect will be to convert the table into a stream;\n    /// the content of the stream will not be affected.\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Which unique villains have been vanquished by Marvel heroes?\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"marvel\")\n    ///         .concat_map(func!(|hero| hero.g(\"villain_list\")))\n    ///         .distinct(())\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Topics in a table of messages have a secondary index on them,\n    /// and more than one message can have the same topic.\n    /// What are the unique topics in the table?\n    ///\n    /// ```\n    /// use reql_rust::cmd::distinct::DistinctOption;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"messages\")\n    ///         .distinct(DistinctOption::default().index(\"topics\"))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// The above structure is functionally identical to:\n    ///\n    /// ```\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"messages\")\n    ///         .g(\"topics\")\n    ///         .distinct(())\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// However, the first form (passing the index as an argument to `distinct`) is faster,\n    /// and won’t run into array limit issues since it’s returning a stream.\n    ///\n    /// # Related commands\n    /// - [map](Self::map)\n    /// - [concat_map](Self::concat_map)\n    /// - [group](Self::group)\n    pub fn distinct(self, args: impl distinct::DistinctArg) -\u003e Self {\n        distinct::new(args).with_parent(self)\n    }\n\n    /// When called with values, returns `true`\n    /// if a sequence contains all the specified values.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// query.contains(value) → bool\n    /// r.contains(sequence, value) → bool\n    /// ```\n    ///\n    /// Where:\n    /// - value: impl Serialize | [Command](crate::Command)\n    /// - sequence: [Command](crate::Command)\n    ///\n    /// # Description\n    ///\n    /// When called with predicate functions, returns `true`\n    /// if for each predicate there exists at least one element\n    /// of the stream where that predicate returns `true`.\n    ///\n    /// Values and predicates may be mixed freely in the argument list.\n    ///\n    /// ## Examples\n    ///\n    /// Has Iron Man ever fought Superman?\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: bool = r.table(\"marvel\")\n    ///         .get(\"ironman\")\n    ///         .g(\"opponents\")\n    ///         .contains(\"superman\")\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Has Iron Man ever defeated Superman in battle?\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: bool = r.table(\"marvel\")\n    ///         .get(\"ironman\")\n    ///         .g(\"battles\")\n    ///         .contains(func!(|battle| battle.clone().g(\"winner\").eq(\"ironman\").and(\n    ///             battle.g(\"loser\").eq(\"superman\")\n    ///         )))\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Return all heroes who have fought both Loki and the Hulk.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: bool = r.table(\"marvel\")\n    ///         .filter(func!(|hero| hero.g(\"opponents\").contains([\"loki\", \"hulk\"])))\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Use contains with a predicate function to simulate an or.\n    /// Return the Marvel superheroes who live in Detroit, Chicago or Hoboken.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: bool = r.table(\"marvel\")\n    ///         .filter(func!(|hero| r.expr([\"Detroit\", \"Chicago\", \"Hoboken\"]).contains(hero.g(\"city\"))))\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [map](Self::map)\n    /// - [concat_map](Self::concat_map)\n    /// - [group](Self::group)\n    pub fn contains(self, args: impl contains::ContainsArg) -\u003e Self {\n        contains::new(args).with_parent(self)\n    }\n\n    /// Plucks out one or more attributes from either\n    /// an object or a sequence of objects (projection).\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// query.pluck(selectors) → any\n    /// ```\n    ///\n    /// Where:\n    /// - selectors: impl Serialize | [Command](crate::Command) |\n    /// args!(Vec\u003cCommand\u003e) | args!([Command; N]) | args!(\u0026[Command])\n    ///\n    /// ## Examples\n    ///\n    /// We just need information about IronMan’s\n    /// reactor and not the rest of the document.\n    ///\n    /// ```\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"marvel\")\n    ///         .get(\"IronMan\")\n    ///         .pluck([\"reactorState\", \"reactorPower\"])\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// For the hero beauty contest we only care about certain qualities.\n    ///\n    /// ```\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"marvel\")\n    ///         .pluck([\"beauty\", \"muscleTone\", \"charm\"])\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Pluck can also be used on nested objects.\n    ///\n    /// ```\n    /// use reql_rust::{r, Result};\n    /// use serde_json::json;\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"marvel\")\n    ///         .pluck(json!({\n    ///             \"abilities\": {\"damage\": true, \"mana_cost\": true},\n    ///             \"weapons\": true\n    ///         }))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// The nested syntax can quickly become overly\n    /// verbose so there’s a shorthand for it.\n    ///\n    /// ```\n    /// use reql_rust::{args, r, Result};\n    /// use serde_json::json;\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"marvel\")\n    ///         .pluck(args!([\n    ///             r.expr(json!({\"abilities\": [\"damage\", \"mana_cost\"]})),\n    ///             r.expr(\"weapons\")\n    ///         ]))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// For more information read the\n    /// [nested field documentation](https://rethinkdb.com/docs/nested-fields/python/).\n    ///\n    /// # Related commands\n    /// - [without](Self::without)\n    /// - [map](Self::map)\n    pub fn pluck(self, args: impl pluck::PluckArg) -\u003e Self {\n        pluck::new(args).with_parent(self)\n    }\n\n    /// The opposite of pluck; takes an object or a sequence of objects,\n    /// and returns them with the specified paths removed.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// query.without(selectors) → any\n    /// ```\n    ///\n    /// Where:\n    /// - selectors: impl Serialize | [Command](crate::Command) |\n    /// args!(Vec\u003cCommand\u003e) | args!([Command; N]) | args!(\u0026[Command])\n    ///\n    /// ## Examples\n    ///\n    /// Since we don’t need it for this computation we’ll save bandwidth\n    /// and leave out the list of IronMan’s romantic conquests.\n    ///\n    /// ```\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"marvel\")\n    ///         .get(\"IronMan\")\n    ///         .without(\"personalVictoriesList\")\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Without their prized weapons, our enemies will quickly be vanquished.\n    ///\n    /// ```\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"enemies\")\n    ///         .without(\"weapons\")\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Nested objects can be used to remove the damage\n    /// subfield from the weapons and abilities fields.\n    ///\n    /// ```\n    /// use reql_rust::{r, Result};\n    /// use serde_json::json;\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"marvel\")\n    ///         .without(json!({\n    ///             \"weapons\": { \"damage\": true },\n    ///             \"abilities\": { \"damage\": true }\n    ///         }))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// The nested syntax can quickly become overly verbose so there’s a shorthand for it.\n    ///\n    /// ```\n    /// use reql_rust::{r, Result};\n    /// use serde_json::json;\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"marvel\")\n    ///         .without(json!({\n    ///             \"weapons\": \"damage\",\n    ///             \"abilities\": \"damage\"\n    ///         }))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [pluck](Self::pluck)\n    /// - [map](Self::map)\n    pub fn without(self, args: impl without::WithoutArg) -\u003e Self {\n        without::new(args).with_parent(self)\n    }\n\n    /// Merge two or more objects together to construct\n    /// a new object with properties from all.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// query.merge(params) → any\n    /// ```\n    ///\n    /// Where:\n    /// - params: impl Serialize | func!(...) |\n    /// [Command](crate::Command) | Vec\u003cCommand\u003e, Vec\u003cFunc\u003e |\n    /// [Command; N] | [Func; N] | \u0026[Command] | \u0026[Func]\n    ///\n    /// # Description\n    ///\n    /// When there is a conflict between field names, preference is\n    /// given to fields in the rightmost object in the argument list\n    /// `merge` also accepts a subquery function that returns an object,\n    /// which will be used similarly to a [map](Self::map) function.\n    ///\n    /// ## Examples\n    ///\n    /// Equip Thor for battle.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"marvel\")\n    ///         .get(\"thor\")\n    ///         .merge(args!([\n    ///             r.table(\"equipment\").get(\"hammer\"),\n    ///             r.table(\"equipment\").get(\"pimento_sandwich\"),\n    ///         ]))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Equip every hero for battle, using a subquery\n    /// function to retrieve their weapons.\n    ///\n    /// ```\n    /// use std::collections::HashMap;\n    ///\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"marvel\")\n    ///         .get(\"thor\")\n    ///         .merge(func!(|hero| {\n    ///             let mut weapons = HashMap::new();\n    ///             weapons.insert(\"weapons\", r.table(\"weapons\").get(hero.g(\"weapon_id\")));\n    ///             r.hash_map(weapons)\n    ///         }))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Use `merge` to join each blog post with its comments.\n    ///\n    /// Note that the sequence being merged—in this example,\n    /// the comments—must be coerced from a selection to an array.\n    /// Without `coerce_to` the operation will throw an error\n    /// (“Expected type DATUM but found SELECTION”).\n    ///\n    /// ```\n    /// use std::collections::HashMap;\n    ///\n    /// use reql_rust::cmd::get_all::GetAllOption;\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"posts\")\n    ///         .merge(func!(|post| {\n    ///             let mut comments = HashMap::new();\n    ///             comments.insert(\"comments\", r.table(\"comments\")\n    ///                 .get_all(args!(\n    ///                     post.g(\"id\"),\n    ///                     GetAllOption::default().index(\"title\")\n    ///                 ))\n    ///                 .coerce_to(\"array\")\n    ///             );\n    ///             r.hash_map(comments)\n    ///         }))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Merge can be used recursively to modify object within objects.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    /// use serde_json::json;\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.expr(json!({\n    ///             \"weapons\": {\n    ///                 \"spectacular graviton beam\": {\n    ///                     \"dmg\": 10,\n    ///                     \"cooldown\": 20\n    ///                 }\n    ///             }\n    ///         }))\n    ///         .merge(json!({\n    ///             \"weapons\": {\n    ///                 \"spectacular graviton beam\": {\n    ///                     \"dmg\": 10\n    ///                 }\n    ///             }\n    ///         }))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [pluck](Self::pluck)\n    /// - [without](Self::without)\n    /// - [map](Self::map)\n    pub fn merge(self, args: impl merge::MergeArg) -\u003e Self {\n        merge::new(args).with_parent(self)\n    }\n\n    /// Append a value to an array.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// query.append(value) → array\n    /// ```\n    ///\n    /// Where:\n    /// - value: impl Serialize | [Command](crate::Command)\n    ///\n    /// ## Examples\n    ///\n    /// Retrieve Simon's colours list with the addition of yellow\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     // [\"green\", \"pink\", \"red\", \"blue\", \"purple\"]\n    ///     let response: [String; 6] = r.table(\"simbad\")\n    ///         .get(1)\n    ///         .g(\"colour\")\n    ///         .append(\"yellow\")\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == [\"green\", \"pink\", \"red\", \"blue\", \"purple\", \"yellow\"]);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [prepend](Self::prepend)\n    /// - [merge](Self::merge)\n    /// - [insert_at](Self::insert_at)\n    /// - [delete_at](Self::delete_at)\n    /// - [change_at](Self::change_at)\n    pub fn append(self, args: impl append::AppendArg) -\u003e Self {\n        append::new(args).with_parent(self)\n    }\n\n    /// Prepend a value to an array.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// query.prepend(value) → array\n    /// ```\n    ///\n    /// Where:\n    /// - value: impl Serialize | [Command](crate::Command)\n    ///\n    /// ## Examples\n    ///\n    /// Retrieve Simon's colours list with the addition of yellow\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     // [\"green\", \"pink\", \"red\", \"blue\", \"purple\"]\n    ///     let response: [String; 6] = r.table(\"simbad\")\n    ///         .get(1)\n    ///         .g(\"colour\")\n    ///         .prepend(\"yellow\")\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == [\"yellow\", \"green\", \"pink\", \"red\", \"blue\", \"purple\"]);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [append](Self::append)\n    /// - [merge](Self::merge)\n    /// - [insert_at](Self::insert_at)\n    /// - [delete_at](Self::delete_at)\n    /// - [change_at](Self::change_at)\n    pub fn prepend(self, args: impl prepend::PrependArg) -\u003e Self {\n        prepend::new(args).with_parent(self)\n    }\n\n    /// Remove the elements of one array from another array\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// query.difference(attr) → array\n    /// ```\n    ///\n    /// Where:\n    /// - attr: vec![...] | [...] | \u0026[...]\n    ///\n    /// ## Examples\n    ///\n    /// Retrieve Simon's colour list without pink and purple\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     // [\"green\", \"pink\", \"red\", \"blue\", \"purple\"]\n    ///     let response: [String; 3] = r.table(\"simbad\")\n    ///         .get(1)\n    ///         .g(\"colour\")\n    ///         .difference([\"pink\", \"purple\", \"yellow\"])\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == [\"green\", \"red\", \"blue\"]);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [union](Self::union)\n    /// - [set_insert](Self::set_insert)\n    /// - [set_union](Self::set_union)\n    /// - [set_intersection](Self::set_intersection)\n    /// - [set_difference](Self::set_difference)\n    pub fn difference(self, args: impl difference::DifferenceArg) -\u003e Self {\n        difference::new(args).with_parent(self)\n    }\n\n    /// Add a value to an array and return it as a set\n    /// (an array with distinct values).\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// query.set_insert(value) → array\n    /// ```\n    ///\n    /// Where:\n    /// - value: impl Serialize\n    ///\n    /// ## Examples\n    ///\n    /// Retrieve Simon's colours list with the addition of yellow\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     // [\"green\", \"pink\", \"red\", \"blue\", \"purple\"]\n    ///     let response: [String; 6] = r.table(\"simbad\")\n    ///         .get(1)\n    ///         .g(\"colour\")\n    ///         .set_insert(\"yellow\")\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == [\"green\", \"pink\", \"red\", \"blue\", \"purple\", \"yellow\"]);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [union](Self::union)\n    /// - [difference](Self::difference)\n    /// - [set_union](Self::set_union)\n    /// - [set_intersection](Self::set_intersection)\n    /// - [set_difference](Self::set_difference)\n    pub fn set_insert(self, value: impl Serialize) -\u003e Self {\n        set_insert::new(value).with_parent(self)\n    }\n\n    /// Add a several values to an array and return\n    /// it as a set (an array with distinct values).\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// query.set_union(attr) → array\n    /// ```\n    ///\n    /// Where:\n    /// - attr: vec![...] | [...] | \u0026[...]\n    ///\n    /// ## Examples\n    ///\n    /// Retrieve Simon's colours list with the addition of yellow\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     // [\"green\", \"pink\", \"red\", \"blue\", \"purple\"]\n    ///     let response: [String; 6] = r.table(\"simbad\")\n    ///         .get(1)\n    ///         .g(\"colour\")\n    ///         .set_union([\"purple\", \"pink\", \"yellow\"])\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == [\"green\", \"pink\", \"red\", \"blue\", \"purple\", \"yellow\"]);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [union](Self::union)\n    /// - [difference](Self::difference)\n    /// - [set_insert](Self::set_insert)\n    /// - [set_intersection](Self::set_intersection)\n    /// - [set_difference](Self::set_difference)\n    pub fn set_union(self, args: impl set_union::SetUnionArg) -\u003e Self {\n        set_union::new(args).with_parent(self)\n    }\n\n    /// Intersect two arrays returning values that occur in\n    /// both of them as a set (an array with distinct values).\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// query.set_intersection(attr) → array\n    /// ```\n    ///\n    /// Where:\n    /// - attr: vec![...] | [...] | \u0026[...]\n    ///\n    /// ## Examples\n    ///\n    /// Check which colour Simon likes from a fixed list.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     // [\"green\", \"pink\", \"red\", \"blue\", \"purple\"]\n    ///     let response: [String; 2] = r.table(\"simbad\")\n    ///         .get(1)\n    ///         .g(\"colour\")\n    ///         .set_intersection([\"purple\", \"pink\", \"yellow\"])\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == [\"purple\", \"pink\"]);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [union](Self::union)\n    /// - [difference](Self::difference)\n    /// - [set_insert](Self::set_insert)\n    /// - [set_union](Self::set_union)\n    /// - [set_difference](Self::set_difference)\n    pub fn set_intersection(self, args: impl set_intersection::SetIntersectionArg) -\u003e Self {\n        set_intersection::new(args).with_parent(self)\n    }\n\n    /// Remove the elements of one array from another and\n    /// return them as set (an array with distinct values)\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// query.set_difference(attr) → array\n    /// ```\n    ///\n    /// Where:\n    /// - attr: vec![...] | [...] | \u0026[...]\n    ///\n    /// ## Examples\n    ///\n    /// Check which colour Simon likes,\n    /// excluding a fixed list.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     // [\"green\", \"pink\", \"red\", \"blue\", \"purple\"]\n    ///     let response: [String; 3] = r.table(\"simbad\")\n    ///         .get(1)\n    ///         .g(\"colour\")\n    ///         .set_difference([\"purple\", \"pink\"])\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == [\"green\", \"red\", \"blue\"]);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [union](Self::union)\n    /// - [difference](Self::difference)\n    /// - [set_insert](Self::set_insert)\n    /// - [set_union](Self::set_union)\n    /// - [set_intersection](Self::set_intersection)\n    pub fn set_difference(self, args: impl set_difference::SetDifferenceArg) -\u003e Self {\n        set_difference::new(args).with_parent(self)\n    }\n\n    /// Get a single field from an object.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// query.get_field(attr) → value\n    /// ```\n    ///\n    /// Where:\n    /// - attr: String, \u0026str\n    ///\n    /// # Description\n    ///\n    /// If called on a sequence, gets that field from every object\n    /// in the sequence, skipping objects that lack it.\n    ///\n    /// ``` text\n    /// Under most circumstances, you’ll want to use [get_field](Self::get_field)\n    /// (or its shorthand g) or [nth](Self::nth) rather than `bracket`.\n    /// The `bracket` term may be useful in situations where you are unsure of the\n    /// data type returned by the term you are calling `bracket` on.\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// How old is Moussa\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: u8 = r.table(\"simbad\")\n    ///         .get(1)\n    ///         .bracket(\"age\")\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == 15);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// The `bracket` command also accepts integer arguments\n    /// as array offsets, like the [nth](Self::nth) command.\n    ///\n    /// ## Examples\n    ///\n    /// How old is Moussa\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: u8 = r.expr([10, 20, 30, 40, 50])\n    ///         .bracket(3)\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == 40);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [get_field](Self::get_field)\n    /// - [nth](Self::nth)\n    pub fn bracket(self, attr: impl Serialize) -\u003e Self {\n        bracket::new(attr).with_parent(self)\n    }\n\n    /// Get a single field from an object.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// query.get_field(attr) → value\n    /// ```\n    ///\n    /// Where:\n    /// - attr: String, \u0026str\n    ///\n    /// # Description\n    ///\n    /// If called on a sequence, gets that field from every object\n    /// in the sequence, skipping objects that lack it.\n    ///\n    /// You may use either `get_field` or its shorthand, `g`.\n    ///\n    /// ## Examples\n    ///\n    /// How old is Moussa\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: u8 = r.table(\"simbad\")\n    ///         .get(1)\n    ///         .get_field(\"age\")\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == 15);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [bracket](Self::bracket)\n    /// - [nth](Self::nth)\n    pub fn get_field(self, attr: impl Into\u003cString\u003e) -\u003e Self {\n        get_field::new(attr).with_parent(self)\n    }\n\n    /// Get a single field from an object.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// query.g(attr) → value\n    /// ```\n    ///\n    /// Where:\n    /// - attr: String, \u0026str\n    ///\n    /// # Description\n    ///\n    /// If called on a sequence, gets that field from every object\n    /// in the sequence, skipping objects that lack it.\n    ///\n    /// You may use either `get_field` or its shorthand, `g`.\n    ///\n    /// ## Examples\n    ///\n    /// How old is Moussa\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: u8 = r.table(\"simbad\")\n    ///         .get(1)\n    ///         .g(\"age\")\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == 15);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [bracket](Self::bracket)\n    /// - [nth](Self::nth)\n    pub fn g(self, attr: impl Into\u003cString\u003e) -\u003e Self {\n        get_field::new(attr).with_parent(self)\n    }\n\n    /// Test if an object has one or more fields.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// query.has_fields(selector) → response\n    /// ```\n    ///\n    /// Where:\n    /// - selector: impl Serialize\n    /// - response: array | bool\n    ///\n    /// # Description\n    ///\n    /// An object has a field if it has that key and the key has a non-null value.\n    /// For instance, the object `{'a': 1,'b': 2,'c': null}` has the fields `a` and `b`.\n    ///\n    /// When applied to a single object, `has_fields` returns `true` if the object has\n    /// the fields and `false` if it does not. When applied to a sequence, it will return\n    /// a new sequence (an array or stream) containing the elements that have the specified fields.\n    ///\n    /// ## Examples\n    ///\n    /// Return the players who have won games.\n    ///\n    /// ```\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"players\")\n    ///         .has_fields(\"games_won\")\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Return the players who have not won games.\n    /// To do this, use `has_fields` with [not](crate::r::not),\n    /// wrapped with [filter](Self::filter).\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"players\")\n    ///         .filter(func!(|player| !player.has_fields(\"games_won\")))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Test if a specific player has won any games.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: bool = r.table(\"players\")\n    ///         .get(1)\n    ///         .has_fields(\"games_won\")\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Nested Fields\n    ///\n    /// `has_fields` lets you test for nested fields in objects.\n    /// If the value of a field is itself a set of key/value pairs,\n    /// you can test for the presence of specific keys.\n    ///\n    /// ## Examples\n    ///\n    /// In the `players` table, the `games_won` field contains one\n    /// or more fields for kinds of games won:\n    ///\n    /// ```text\n    /// {\n    ///     'games_won': {\n    ///         'playoffs': 2,\n    ///         'championships': 1\n    ///     }\n    /// }\n    /// ```\n    ///\n    /// Return players who have the “championships” field.\n    ///\n    /// ```\n    /// use reql_rust::{r, Result};\n    /// use serde_json::json;\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"players\")\n    ///         .has_fields(json!({\"games_won\": {\"championships\": true}}))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// Note that `true` in the example above is testing for the existence of `championships`\n    /// as a field, not testing to see if the value of the `championships` field is set to `true`.\n    /// There’s a more convenient shorthand form available.\n    /// (See [pluck](Self::pluck) for more details on this.)\n    ///\n    /// ```\n    /// use reql_rust::{r, Result};\n    /// use serde_json::json;\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"players\")\n    ///         .has_fields(json!({\"games_won\": \"championships\"}))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [get_field](Self::get_field)\n    /// - [with_fields](Self::with_fields)\n    pub fn has_fields(self, selector: impl Serialize) -\u003e Self {\n        has_fields::new(selector).with_parent(self)\n    }\n\n    /// Insert a value in to an array at a given index. Returns the modified array.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// array.insert_at(offset, value) → array\n    /// ```\n    ///\n    /// Where:\n    /// - offset: isize\n    /// - value: impl Serialize\n    ///\n    /// ## Examples\n    ///\n    /// Alima decide to join Simbad.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: [String; 4] = r.expr([\"Moussa\", \"Ali\", \"Fati\"])\n    ///         .insert_at(1, \"Alima\")\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == [\"Moussa\", \"Alima\", \"Ali\", \"Fati\"]);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [splice_at](Self::splice_at)\n    /// - [change_at](Self::change_at)\n    /// - [delete_at](Self::delete_at)\n    pub fn insert_at(self, offset: isize, value: impl Serialize) -\u003e Self {\n        insert_at::new(offset, value).with_parent(self)\n    }\n\n    /// Insert several values into an array at the given index.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// array.splice_at(args!(offset, list)) → array\n    /// ```\n    ///\n    /// Where:\n    /// - offset: isize | [Command](crate::Command)\n    /// - value: vec![...] | [...] | \u0026[...] | [Command](crate::Command)\n    ///\n    /// ## Examples\n    ///\n    /// Fati and Alima decide to join Simbad.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: [String; 4] = r.expr([\"Moussa\", \"Ali\"])\n    ///         .splice_at(args!(1, [\"Fati\", \"Alima\"]))\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == [\"Moussa\", \"Fati\", \"Alima\", \"Ali\"]);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [insert_at](Self::insert_at)\n    /// - [delete_at](Self::delete_at)\n    /// - [change_at](Self::change_at)\n    pub fn splice_at(self, args: impl splice_at::SpliceAtArg) -\u003e Self {\n        splice_at::new(args).with_parent(self)\n    }\n\n    /// Remove one or more elements from an array at a given index.\n    /// (Note: `delete_at` operates on arrays, not documents;\n    /// to delete documents, see the [delete](Self::delete) command.)\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// array.delete_at(offset) → array\n    /// array.delete_at(args!(offset, end_offset)) → array\n    /// ```\n    ///\n    /// # Description\n    ///\n    /// If only `offset` is specified, `delete_at` removes the element at that index.\n    /// If both `offset` and `end_offset` are specified, `delete_at` removes the range\n    /// of elements between `offset` and `end_offset`, inclusive of `offset` but not\n    /// inclusive of `end_offset`.\n    ///\n    /// If `end_offset` is specified, it must not be less than `offset`.\n    /// Both `offset` and `end_offset` must be within the array’s bounds\n    /// (i.e., if the array has 10 elements, an `offset` or `end_offset`\n    /// of 10 or higher is invalid).\n    ///\n    /// By using a negative `offset` you can delete from the end of the array.\n    /// `-1` is the last element in the array, `-2` is the second-to-last element, and so on.\n    /// You may specify a negative `end_offset`, although just as with a positive value,\n    /// this will not be inclusive. The range `(2,-1)` specifies the third element through\n    /// the next-to-last element.\n    ///\n    /// ## Examples\n    ///\n    /// Delete the second element of an array.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: [char; 5] = r.expr(['a', 'b', 'c', 'd', 'e', 'f'])\n    ///         .delete_at(1)\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == ['a', 'c', 'd', 'e', 'f']);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Delete the second and third elements of an array.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: [char; 4] = r.expr(['a', 'b', 'c', 'd', 'e', 'f'])\n    ///         .delete_at(args!(1, 3))\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == ['a', 'd', 'e', 'f']);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Delete the next-to-last element of an array.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: [char; 5] = r.expr(['a', 'b', 'c', 'd', 'e', 'f'])\n    ///         .delete_at(-2)\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == ['a', 'b', 'c', 'd', 'f']);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Delete a comment on a post.\n    ///\n    /// Given a post document such as:\n    ///\n    /// ```text\n    ///\n    /// ```\n    /// {\n    ///     \"id\": 1,\n    ///     \"title\": \"Post title\",\n    ///     \"author\": \"Ali\",\n    ///     \"comments\": [\n    ///         { \"author\": \"Agatha\", \"text\": \"Comment 1\" },\n    ///         { \"author\": \"Fatima\", \"text\": \"Comment 2\" }\n    ///     ]\n    /// }\n    ///\n    /// The second comment can be deleted by using `update` and `delete_at` together.\n    ///\n    /// ```\n    /// use std::collections::HashMap;\n    ///\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: [char; 5] = r.table(\"posts\")\n    ///         .get(1)\n    ///         .update(func!(|post| {\n    ///             let mut comments = HashMap::new();\n    ///             comments.insert(\"comments\", post.g(\"comments\").delete_at(1));\n    ///             r.hash_map(comments)\n    ///         }))\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == ['a', 'b', 'c', 'd', 'f']);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [insert_at](Self::insert_at)\n    /// - [splice_at](Self::splice_at)\n    /// - [change_at](Self::change_at)\n    pub fn delete_at(self, args: impl delete_at::DeleteAtArg) -\u003e Self {\n        delete_at::new(args).with_parent(self)\n    }\n\n    /// Change a value in an array at a given index.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// array.change_at(offset, value) → array\n    /// ```\n    ///\n    /// Where:\n    /// - offset: isize\n    /// - value: impl Serialize\n    ///\n    /// ## Examples\n    ///\n    /// Replace Ali by Alima in array.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: [String; 3] = r.expr([\"Moussa\", \"Ali\", \"Fati\"])\n    ///         .change_at(1, \"Alima\")\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == [\"Moussa\", \"Alima\", \"Fati\"]);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [insert_at](Self::insert_at)\n    /// - [splice_at](Self::splice_at)\n    /// - [delete_at](Self::delete_at)\n    pub fn change_at(self, offset: isize, value: impl Serialize) -\u003e Self {\n        change_at::new(offset, value).with_parent(self)\n    }\n\n    /// Return an array containing all of an object’s keys.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// string.keys() → array\n    /// ```\n    ///\n    /// # Description\n    ///\n    /// Note that the keys will be sorted as described in\n    /// [ReQL data types](https://rethinkdb.com/docs/data-types/#sorting-order)\n    /// (for strings, lexicographically).\n    ///\n    /// ## Examples\n    ///\n    /// Get all the keys from a table row.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     // row: { \"id\": \"1\", \"mail\": \"fred@example.com\", \"name\": \"fred\" }\n    ///     let response: [String; 3] = r.table(\"users\")\n    ///         .get(1)\n    ///         .keys()\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == [\"id\", \"mail\", \"name\"]);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [values](Self::values)\n    pub fn keys(self) -\u003e Self {\n        keys::new().with_parent(self)\n    }\n\n    /// Return an array containing all of an object’s values.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// string.values() → array\n    /// ```\n    ///\n    /// # Description\n    ///\n    /// `values()` guarantees the values will\n    /// come out in the same order as [keys](Self::keys).\n    ///\n    /// ## Examples\n    ///\n    /// Get all of the values from a table row.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     // row: { \"id\": \"1\", \"mail\": \"fred@example.com\", \"name\": \"fred\" }\n    ///     let response: [String; 3] = r.table(\"users\")\n    ///         .get(1)\n    ///         .values()\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == [\"1\", \"fred@example.com\", \"fred\"]);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [keys](Self::keys)\n    pub fn values(self) -\u003e Self {\n        values::new().with_parent(self)\n    }\n\n    /// Match a string against a regular expression.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// string.match(regexp) → response\n    /// ```\n    ///\n    /// Where:\n    /// - regexp: [Regex](regex::Regex)\n    /// - response: Option\u003c[MatchResponse](crate::types::MatchResponse)\u003e\n    ///\n    /// ## Examples\n    ///\n    /// ```\n    /// use regex::Regex;\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::types::MatchResponse;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let regexp = Regex::new(\".*@(.*)\")?;\n    ///     let response: String = r.expr(\"name@domain.com\")\n    ///         .match_(regexp.clone())\n    ///         .g(\"groups\")\n    ///         .nth(0)\n    ///         .g(\"str\")\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///     let response2: Option\u003cMatchResponse\u003e = r.expr(\"name[at]domain.com\")\n    ///         .match_(regexp)\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == \"domain.com\");\n    ///     assert!(response2 == None);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [upcase](Self::upcase)\n    /// - [downcase](Self::downcase)\n    /// - [split](Self::split)\n    pub fn match_(self, regexp: Regex) -\u003e Self {\n        match_::new(regexp).with_parent(self)\n    }\n\n    /// Split a string into substrings.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// string.split(()) → string\n    /// string.split(\u0026str) → string\n    /// string.split(args!(\u0026str, usize)) → string\n    /// ```\n    ///\n    /// # Description\n    ///\n    /// With no arguments, will split on whitespace;\n    /// when called with a string as the first argument,\n    /// will split using that string as a separator.\n    /// A maximum number of splits can also be specified.\n    ///\n    /// ## Examples\n    ///\n    /// Split on whitespace.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let data = [\n    ///         String::from(\"foo\"),\n    ///         String::from(\"bar\"),\n    ///         String::from(\"bax\"),\n    ///     ];\n    ///     let response: [String; 3] = r.expr(\"foo  bar bax\")\n    ///         .split(())\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == data);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Split the entries in a CSV file.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let data = [\n    ///         String::from(\"12\"),\n    ///         String::from(\"37\"),\n    ///         String::new(),\n    ///         String::from(\"22\"),\n    ///         String::new(),\n    ///     ];\n    ///     let response: [String; 5] = r.expr(\"12,37,,22,\")\n    ///         .split(\",\")\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == data);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Split a string into characters.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let data = [\n    ///         String::from(\"t\"),\n    ///         String::from(\"o\"),\n    ///         String::from(\"t\"),\n    ///         String::from(\"o\"),\n    ///     ];\n    ///     let response: [String; 4] = r.expr(\"toto\")\n    ///         .split(\"\")\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == data);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Split the entries in a CSV file, but only at most 3 times.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let data = [\n    ///         String::from(\"12\"),\n    ///         String::from(\"37\"),\n    ///         String::new(),\n    ///         String::from(\"22,\"),\n    ///     ];\n    ///     let response: [String; 4] = r.expr(\"12,37,,22,\")\n    ///         .split(args!(\",\", 3))\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == data);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Split on whitespace at most once (i.e. get the first word).\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let data = [\n    ///         String::from(\"foo\"),\n    ///         String::from(\"bar bax\"),\n    ///     ];\n    ///     let response: [String; 2] = r.expr(\"foo  bar bax\")\n    ///         .split(args!(\" \", 1))\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == data);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [upcase](Self::upcase)\n    /// - [downcase](Self::downcase)\n    /// - [match](Self::match_)\n    pub fn split(self, args: impl split::SplitArg) -\u003e Self {\n        split::new(args).with_parent(self)\n    }\n\n    /// Uppercases a string.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// string.upcase() → string\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: String = r.expr(\"Sentence about LaTeX.\")\n    ///         .upcase()\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == \"SENTENCE ABOUT LATEX.\");\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Note\n    ///\n    /// `upcase` and `downcase` only affect ASCII characters.\n    ///\n    /// # Related commands\n    /// - [downcase](Self::downcase)\n    /// - [match](Self::match_)\n    /// - [split](Self::split)\n    pub fn upcase(self) -\u003e Self {\n        upcase::new().with_parent(self)\n    }\n\n    /// Lowercase a string.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// string.downcase() → string\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: String = r.expr(\"Sentence about LaTeX.\")\n    ///         .downcase()\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == \"sentence about latex.\");\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Note\n    ///\n    /// `upcase` and `downcase` only affect ASCII characters.\n    ///\n    /// # Related commands\n    /// - [upcase](Self::upcase)\n    /// - [match](Self::match_)\n    /// - [split](Self::split)\n    pub fn downcase(self) -\u003e Self {\n        downcase::new().with_parent(self)\n    }\n\n    /// Compute the logical “and” of one or more values.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// cmd_value.and(value) → bool\n    /// cmd_value.and(args!(values)) → bool\n    /// r.and(args!(values)) → bool\n    /// ```\n    ///\n    /// Where:\n    /// - value: [Command](crate::Command) | bool\n    /// - values: [Command](crate::Command) | vec![...] | [...] | \u0026[...]\n    ///\n    /// # Description\n    ///\n    /// The `and` command can be used as an infix operator after its\n    /// first argument (`r.expr(true).and(false)`) or given all of\n    /// its arguments as parameters (`r.and(args!([true, false]))`).\n    ///\n    /// Calling `or` with zero arguments will return `false`.\n    ///\n    /// ## Examples\n    ///\n    /// Return whether either true or false evaluate to true.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: bool = r.expr(true)\n    ///         .or(false)\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == false);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Return whether any of true, true or true evaluate to true.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: bool = r.or(args!([true, true, true]))\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == true);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [eq](Self::eq)\n    /// - [ne](Self::ne)\n    /// - [or](Self::or)\n    pub fn and(self, args: impl and::AndArg) -\u003e Self {\n        and::new(args).with_parent(self)\n    }\n\n    /// Compute the logical “or” of one or more values.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// cmd_value.or(value) → bool\n    /// cmd_value.or(args!(values)) → bool\n    /// r.or(args!(values)) → bool\n    /// ```\n    ///\n    /// Where:\n    /// - value: [Command](crate::Command) | bool\n    /// - values: [Command](crate::Command) | vec![...] | [...] | \u0026[...]\n    ///\n    /// # Description\n    ///\n    /// The `or` command can be used as an infix operator after\n    /// its first argument (`r.expr(true).or(false)`) or given all\n    /// of its arguments as parameters (`r.or(args!([true, false]))`).\n    ///\n    /// Calling `or` with zero arguments will return `false`.\n    ///\n    /// ## Examples\n    ///\n    /// Return whether either true or false evaluate to true.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: bool = r.expr(true)\n    ///         .or(false)\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == true);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Return whether any of false, false or false evaluate to false.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: bool = r.or(args!([false, false, false]))\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == false);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Note\n    ///\n    /// When using `or` inside a `filter` predicate to test the values of\n    /// fields that may not exist on the documents being tested,\n    /// you should use the `default` command with those fields so\n    /// they explicitly return `false`.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"table\")\n    ///         .filter(func!(|post| post.clone()\n    ///             .g(\"category\").default(\"foo\").eq(\"article\")\n    ///             .or(post.g(\"genre\").default(\"foo\").eq(\"mystery\"))\n    ///         ))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [eq](Self::eq)\n    /// - [ne](Self::ne)\n    /// - [and](Self::and)\n    pub fn or(self, args: impl or::OrArg) -\u003e Self {\n        or::new(args).with_parent(self)\n    }\n\n    /// Test if two or more values are equal.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// cmd_value.eq(value) → bool\n    /// cmd_value.eq(args!(values)) → bool\n    /// r.eq(args!(values)) → bool\n    /// ```\n    ///\n    /// Where:\n    /// - value: [Command](crate::Command) | impl Serialize\n    /// - values: [Command](crate::Command) | vec![...] | [...] | \u0026[...]\n    ///\n    /// ## Examples\n    ///\n    /// See if a user’s `role` field is set to `administrator`.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: bool = r.table(\"users\")\n    ///         .get(1)\n    ///         .g(\"role\")\n    ///         .eq(\"administrator\")\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == true);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// See if three variables contain equal values.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: bool = r.eq(args!([20, 10, 15]))\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == true);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [ne](Self::ne)\n    /// - [and](Self::and)\n    /// - [or](Self::or)\n    pub fn eq(self, args: impl eq::EqArg) -\u003e Self {\n        eq::new(args).with_parent(self)\n    }\n\n    /// Test if two or more values are not equal.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// cmd_value.ne(value) → bool\n    /// cmd_value.ne(args!(values)) → bool\n    /// r.ne(args!(values)) → bool\n    /// ```\n    ///\n    /// Where:\n    /// - value: [Command](crate::Command) | impl Serialize\n    /// - values: [Command](crate::Command) | vec![...] | [...] | \u0026[...]\n    ///\n    /// ## Examples\n    ///\n    /// See if a user’s `role` field is not set to `administrator`.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: bool = r.table(\"users\")\n    ///         .get(1)\n    ///         .g(\"role\")\n    ///         .ne(\"administrator\")\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == true);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// See if three variables do not contain equal values.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: bool = r.ne(args!([20, 10, 15]))\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == true);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [eq](Self::eq)\n    /// - [and](Self::and)\n    /// - [or](Self::or)\n    pub fn ne(self, args: impl ne::NeArg) -\u003e Self {\n        ne::new(args).with_parent(self)\n    }\n\n    /// Compare values, testing if the left-hand value is greater than the right-hand.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// cmd_value.gt(value) → bool\n    /// cmd_value.gt(args!(values)) → bool\n    /// r.gt(args!(values)) → bool\n    /// ```\n    ///\n    /// Where:\n    /// - value: [Command](crate::Command) | impl Serialize\n    /// - values: [Command](crate::Command) | vec![...] | [...] | \u0026[...]\n    ///\n    /// ## Examples\n    ///\n    /// Test if a player has scored more than 10 points.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: bool = r.table(\"players\")\n    ///         .get(1)\n    ///         .g(\"score\")\n    ///         .gt(10)\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == true);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Test if variables are ordered from lowest to highest,\n    /// with no values being equal to one another.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: bool = r.gt(args!([20, 10, 15]))\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == true);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [eq](Self::eq)\n    /// - [ne](Self::ne)\n    /// - [ge](Self::ge)\n    /// - [lt](Self::lt)\n    /// - [le](Self::le)\n    pub fn gt(self, args: impl gt::GtArg) -\u003e Self {\n        gt::new(args).with_parent(self)\n    }\n\n    /// Compare values, testing if the left-hand value is greater than the right-hand.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// cmd_value.ge(value) → bool\n    /// cmd_value.ge(args!(values)) → bool\n    /// r.ge(args!(values)) → bool\n    /// ```\n    ///\n    /// Where:\n    /// - value: [Command](crate::Command) | impl Serialize\n    /// - values: [Command](crate::Command) | vec![...] | [...] | \u0026[...]\n    ///\n    /// ## Examples\n    ///\n    /// Test if a player has scored more than 10 points.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: bool = r.table(\"players\")\n    ///         .get(1)\n    ///         .g(\"score\")\n    ///         .ge(10)\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == true);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Test if variables are ordered from lowest to highest,\n    /// with no values being equal to one another.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: bool = r.ge(args!([20, 10, 15]))\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == true);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [eq](Self::eq)\n    /// - [ne](Self::ne)\n    /// - [gt](Self::gt)\n    /// - [lt](Self::lt)\n    /// - [le](Self::le)\n    pub fn ge(self, args: impl ge::GeArg) -\u003e Self {\n        ge::new(args).with_parent(self)\n    }\n\n    /// Compare values, testing if the left-hand value is less than the right-hand.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// cmd_value.lt(value) → bool\n    /// cmd_value.lt(args!(values)) → bool\n    /// r.lt(args!(values)) → bool\n    /// ```\n    ///\n    /// Where:\n    /// - value: [Command](crate::Command) | impl Serialize\n    /// - values: [Command](crate::Command) | vec![...] | [...] | \u0026[...]\n    ///\n    /// ## Examples\n    ///\n    /// Test if a player has scored less than 10 points.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: bool = r.table(\"players\")\n    ///         .get(1)\n    ///         .g(\"score\")\n    ///         .lt(10)\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == true);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Test if variables are ordered from highest to lowest,\n    /// with no values being equal to one another.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: bool = r.lt(args!([20, 10, 15]))\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == true);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [eq](Self::eq)\n    /// - [ne](Self::ne)\n    /// - [gt](Self::gt)\n    /// - [ge](Self::ge)\n    /// - [le](Self::le)\n    pub fn lt(self, args: impl lt::LtArg) -\u003e Self {\n        lt::new(args).with_parent(self)\n    }\n\n    /// Compare values, testing if the left-hand value is\n    /// less than or equal to the right-hand.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// cmd_value.ne(value) → bool\n    /// cmd_value.ne(args!(values)) → bool\n    /// r.ne(args!(values)) → bool\n    /// ```\n    ///\n    /// Where:\n    /// - value: [Command](crate::Command) | impl Serialize\n    /// - values: [Command](crate::Command) | vec![...] | [...] | \u0026[...]\n    ///\n    /// ## Examples\n    ///\n    /// Test if a player has scored 10 points or less.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: bool = r.table(\"players\")\n    ///         .get(1)\n    ///         .g(\"score\")\n    ///         .le(10)\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == true);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Test if variables are ordered from highest to lowest.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: bool = r.le(args!([20, 10, 15]))\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == true);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [eq](Self::eq)\n    /// - [ne](Self::ne)\n    /// - [gt](Self::gt)\n    /// - [ge](Self::ge)\n    /// - [lt](Self::lt)\n    pub fn le(self, args: impl le::LeArg) -\u003e Self {\n        le::new(args).with_parent(self)\n    }\n\n    /// Rounds the given value to the nearest whole integer.\n    ///\n    /// # Command syntax\n    /// ```text\n    /// r.round(param_number) → number\n    /// cmd_number.round() → number\n    /// ```\n    ///\n    /// Where:\n    /// - param_number: f64 | [Command](crate::Command)\n    /// - cmd_number: [Command](crate::Command)\n    ///\n    /// # Description\n    ///\n    /// For example, values of 1.0 up to but not including 1.5\n    /// will return 1.0, similar to [floor](Self::floor); values\n    /// of 1.5 up to 2.0 will return 2.0, similar to [ceil](Self::ceil).\n    ///\n    /// ## Examples\n    ///\n    /// Round 12.345 to the nearest integer.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: i32 = r.round(12.345)\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == 12);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// The `round` command can also be chained after an expression.\n    ///\n    /// ## Examples\n    ///\n    /// Round -12.345 to the nearest integer.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: i32 = r.expr(-12.345)\n    ///         .round()\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == -12);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [ceil](Self::ceil)\n    /// - [round](Self::round)\n    pub fn round(self) -\u003e Self {\n        round::new(()).with_parent(self)\n    }\n\n    /// Rounds the given value up, returning the smallest integer value\n    /// greater than or equal to the given value (the value’s ceiling).\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// r.ceil(param_number) → number\n    /// cmd_number.ceil() → number\n    /// ```\n    ///\n    /// Where:\n    /// - param_number: f64 | [Command](crate::Command)\n    /// - cmd_number: [Command](crate::Command)\n    ///\n    /// ## Examples\n    ///\n    /// Return the ceiling of 12.345.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: i32 = r.ceil(12.345)\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == 13);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// The `ceil` command can also be chained after an expression.\n    ///\n    /// ## Examples\n    ///\n    /// Return the ceiling of -12.345.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: i32 = r.expr(-12.345)\n    ///         .ceil()\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == -13);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [floor](Self::floor)\n    /// - [round](Self::round)\n    pub fn ceil(self) -\u003e Self {\n        ceil::new(()).with_parent(self)\n    }\n\n    /// Rounds the given value down, returning the largest integer\n    /// value less than or equal to the given value (the value’s floor).\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// r.floor(param_number) → number\n    /// cmd_number.floor() → number\n    /// ```\n    ///\n    /// Where:\n    /// - param_number: f64 | [Command](crate::Command)\n    /// - cmd_number: [Command](crate::Command)\n    ///\n    /// ## Examples\n    ///\n    /// Return the floor of 12.345.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: i32 = r.floor(12.345)\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == 13);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// The `floor` command can also be chained after an expression.\n    ///\n    /// ## Examples\n    ///\n    /// Return the floor of -12.345.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: i32 = r.expr(-12.345)\n    ///         .floor()\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == -13);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [ceil](Self::ceil)\n    /// - [round](Self::round)\n    pub fn floor(self) -\u003e Self {\n        floor::new(()).with_parent(self)\n    }\n\n    /// Compute the arithmetic \"and\" of one or more values.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// cmd_number \u0026 cmd_number\n    /// number.bitand(cmd_number) → number\n    /// number.bit_and(param_number) → number\n    /// r.bit_and(cmd_number, param_number) → number\n    /// ```\n    ///\n    /// Where:\n    /// - param_number: i32 | [Command](crate::Command)\n    /// - cmd_number: [Command](crate::Command)\n    ///\n    /// # Description\n    ///\n    /// A bitwise AND is a binary operation that takes two equal-length binary\n    /// representations and performs the logical AND operation on each pair of\n    /// the corresponding bits, which is equivalent to multiplying them.\n    /// Thus, if both bits in the compared position are 1,\n    /// the bit in the resulting binary representation is 1 (1 × 1 = 1);\n    /// otherwise, the result is 0 (1 × 0 = 0 and 0 × 0 = 0).\n    ///\n    /// ## Examples\n    ///\n    /// Compute the arithmetic \"and\" of 5 and 3\n    ///\n    /// ```\n    /// use std::ops::BitAnd;\n    ///\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: i32 = r.expr(5)\n    ///         .bit_and(3)\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     let response2: i32 = r.bit_and(r.expr(5), 3)\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     let response3: i32 = (r.expr(5) \u0026 r.expr(3))\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     let response4: i32 = r.expr(5)\n    ///         .bitand(r.expr(3))\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(\n    ///         response == 1 \u0026\u0026\n    ///         response == response2 \u0026\u0026\n    ///         response == response3 \u0026\u0026\n    ///         response == response4\n    ///     );\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [bit_or](Self::bit_or)\n    /// - [bit_not](Self::bit_not)\n    /// - [bit_xor](Self::bit_xor)\n    /// - [bit_sal](Self::bit_sal)\n    /// - [bit_sar](Self::bit_sar)\n    pub fn bit_and(self, args: impl bit_and::BitAndArg) -\u003e Self {\n        self.bitand(args)\n    }\n\n    /// Compute the arithmetic \"or\" of one or more values.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// cmd_number | cmd_number\n    /// number.bitor(cmd_number) → number\n    /// number.bit_or(param_number) → number\n    /// r.bit_or(cmd_number, param_number) → number\n    /// ```\n    ///\n    /// Where:\n    /// - param_number: i32 | [Command](crate::Command)\n    /// - cmd_number: [Command](crate::Command)\n    ///\n    /// # Description\n    ///\n    /// A bitwise OR is a binary operation that takes two bit patterns\n    /// of equal length and performs the logical inclusive OR operation\n    /// on each pair of corresponding bits. The result in each position\n    /// is 0 if both bits are 0, while otherwise the result is 1.\n    ///\n    /// ## Examples\n    ///\n    /// Compute the arithmetic \"or\" of 6 and 4\n    ///\n    /// ```\n    /// use std::ops::BitOr;\n    ///\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: i32 = r.expr(5)\n    ///         .bit_or(3)\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     let response2: i32 = r.bit_or(r.expr(5), 3)\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     let response3: i32 = (r.expr(5) ^ r.expr(3))\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     let response4: i32 = r.expr(5)\n    ///         .bitor(r.expr(3))\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(\n    ///         response == 7 \u0026\u0026\n    ///         response == response2 \u0026\u0026\n    ///         response == response3 \u0026\u0026\n    ///         response == response4\n    ///     );\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [bit_and](Self::bit_and)\n    /// - [bit_not](Self::bit_not)\n    /// - [bit_xor](Self::bit_xor)\n    /// - [bit_sal](Self::bit_sal)\n    /// - [bit_sar](Self::bit_sar)\n    pub fn bit_or(self, args: impl bit_or::BitOrArg) -\u003e Self {\n        self.bitor(args)\n    }\n\n    /// Compute the arithmetic \"and\" of one or more values.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// cmd_number ^ cmd_number\n    /// number.bitxor(cmd_number) → number\n    /// number.bit_xor(param_number) → number\n    /// r.bit_xor(cmd_number, param_number) → number\n    /// ```\n    ///\n    /// Where:\n    /// - param_number: i32 | [Command](crate::Command)\n    /// - cmd_number: [Command](crate::Command)\n    ///\n    /// # Description\n    ///\n    /// A bitwise XOR is a binary operation that takes two bit patterns\n    /// of equal length and performs the logical exclusive OR operation\n    /// on each pair of corresponding bits. The result in each position\n    /// is 1 if only the first bit is 1 or only the second bit is 1,\n    /// but will be 0 if both are 0 or both are 1.\n    /// In this we perform the comparison of two bits, being 1 if the\n    /// two bits are different, and 0 if they are the same.\n    ///\n    /// ## Examples\n    ///\n    /// Compute the arithmetic \"and\" of 6 and 4\n    ///\n    /// ```\n    /// use std::ops::BitXor;\n    ///\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: i32 = r.expr(6)\n    ///         .bit_xor(4)\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     let response2: i32 = r.bit_xor(r.expr(6), 4)\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     let response3: i32 = (r.expr(6) ^ r.expr(4))\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     let response4: i32 = r.expr(6)\n    ///         .bitxor(r.expr(4))\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(\n    ///         response == 2 \u0026\u0026\n    ///         response == response2 \u0026\u0026\n    ///         response == response3 \u0026\u0026\n    ///         response == response4\n    ///     );\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [bit_and](Self::bit_and)\n    /// - [bit_not](Self::bit_not)\n    /// - [bit_or](Self::bit_or)\n    /// - [bit_sal](Self::bit_sal)\n    /// - [bit_sar](Self::bit_sar)\n    pub fn bit_xor(self, args: impl bit_xor::BitXorArg) -\u003e Self {\n        self.bitxor(args)\n    }\n\n    /// Compute the arithmetic inverse (not) of an expression.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// number.bit_not() → number\n    /// r.bit_not(cmd_number) → number\n    /// ```\n    ///\n    /// Where:\n    /// - cmd_number: [Command](crate::Command)\n    ///\n    /// # Description\n    ///\n    /// A bitwise NOT, or complement, is a unary operation that performs logical\n    /// negation on each bit, forming the ones’ complement of the given binary value.\n    /// Bits that are 0 become 1, and those that are 1 become 0.\n    ///\n    /// ## Examples\n    ///\n    /// Negate the arithmetice expression\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: i32 = r.expr(7)\n    ///         .bit_not()\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     let response2: i32 = r.bit_not(r.expr(7))\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == -8 \u0026\u0026 response == response2);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [bit_and](Self::bit_and)\n    /// - [bit_or](Self::bit_or)\n    /// - [bit_sal](Self::bit_sal)\n    /// - [bit_sar](Self::bit_sar)\n    /// - [bit_xor](Self::bit_xor)\n    pub fn bit_not(self) -\u003e Self {\n        bit_not::new().with_parent(self)\n    }\n\n    /// Compute the left arithmetic shift (left logical shift) of one or more values.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// number.bit_sal(param_number) → number\n    /// r.bit_sal(cmd_number, param_number) → number\n    /// ```\n    ///\n    /// Where:\n    /// - param_number: i32 | [Command](crate::Command)\n    /// - cmd_number: [Command](crate::Command)\n    ///\n    /// # Description\n    ///\n    /// In an arithmetic shift (also referred to as signed shift),\n    /// like a logical shift, the bits that slide off the end disappear\n    /// (except for the last, which goes into the carry flag).\n    /// But in an arithmetic shift, the spaces are filled in such a way\n    /// to preserve the sign of the number being slid. For this reason,\n    /// arithmetic shifts are better suited for signed numbers in two’s\n    /// complement format.\n    ///\n    /// ## Note\n    ///\n    /// SHL and SAL are the same, and differentiation only happens because\n    /// SAR and SHR (right shifting) has differences in their implementation.\n    ///\n    /// ## Examples\n    ///\n    /// Compute the left arithmetic shift of 5 and 4\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: u8 = r.expr(5)\n    ///         .bit_sar(4)\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     let response2: u8 = r.bit_sar(r.expr(5), r.expr(4))\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == 80 \u0026\u0026 response == response2);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [bit_and](Self::bit_and)\n    /// - [bit_not](Self::bit_not)\n    /// - [bit_or](Self::bit_or)\n    /// - [bit_sar](Self::bit_sar)\n    /// - [bit_xor](Self::bit_xor)\n    pub fn bit_sal(self, args: impl bit_sal::BitSalArg) -\u003e Self {\n        bit_sal::new(args).with_parent(self)\n    }\n\n    /// Compute the right arithmetic shift of one or more values.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// number.bit_sar(param_number) → number\n    /// r.bit_sar(cmd_number, param_number) → number\n    /// ```\n    ///\n    /// Where:\n    /// - param_number: i32 | [Command](crate::Command)\n    /// - cmd_number: [Command](crate::Command)\n    ///\n    /// # Description\n    ///\n    /// In an arithmetic shift (also referred to as signed shift),\n    /// like a logical shift, the bits that slide off the end disappear\n    /// (except for the last, which goes into the carry flag).\n    /// But in an arithmetic shift, the spaces are filled in such\n    /// a way to preserve the sign of the number being slid.\n    /// For this reason, arithmetic shifts are better suited for\n    /// signed numbers in two’s complement format.\n    ///\n    /// ## Examples\n    ///\n    /// Compute the right arithmetic shift of 32 and 3\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: u8 = r.expr(32)\n    ///         .bit_sar(3)\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     let response2: u8 = r.bit_sar(r.expr(32), r.expr(3))\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == 4 \u0026\u0026 response == response2);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [bit_and](Self::bit_and)\n    /// - [bit_not](Self::bit_not)\n    /// - [bit_or](Self::bit_or)\n    /// - [bit_sal](Self::bit_sal)\n    /// - [bit_xor](Self::bit_xor)\n    pub fn bit_sar(self, args: impl bit_sar::BitSarArg) -\u003e Self {\n        bit_sar::new(args).with_parent(self)\n    }\n\n    /// Return a new time object with a different timezone.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// time.in_timezone(timezone) → time\n    /// ```\n    ///\n    /// Where:\n    /// - timezone: [UtcOffset](UtcOffset)\n    /// - time: [Time](crate::types::Time)\n    ///\n    /// # Description\n    ///\n    /// While the time stays the same, the results returned by methods such\n    /// as hours() will change since they take the timezone into account.\n    /// The timezone argument has to be of the ISO 8601 format.\n    ///\n    /// ## Examples\n    ///\n    /// Hour of the day in San Francisco (UTC/GMT -8, without daylight saving time).\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::types::Time;\n    /// use reql_rust::{r, Result};\n    /// use time::macros::offset;\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let date_time = r.now().in_timezone(offset!(-08:00));\n    ///     let time1: Time = date_time.clone().value();\n    ///     let time2: Time = date_time.cmd()\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(time1.is_valid());\n    ///     assert!(time2.is_valid());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [timezone](Self::timezone)\n    /// - [now](crate::r::now)\n    /// - [time](crate::r::time)\n    pub fn in_timezone(self, timezone: UtcOffset) -\u003e Self {\n        in_timezone::new(timezone).with_parent(self)\n    }\n\n    /// Return the timezone of the time object.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// time.timezone() → String\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Return all the users in the “-07:00” timezone.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"users\")\n    ///         .filter(func!(|user| user.g(\"subscription_date\").timezone().lt(\"-07:00\")))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [now](crate::r::now)\n    /// - [time](crate::r::time)\n    /// - [in_timezone](Self::in_timezone)\n    pub fn timezone(self) -\u003e Self {\n        timezone::new().with_parent(self)\n    }\n\n    /// Return whether a time is between two other times.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// time.during(args!(start_time, end_time)) -\u003e bool\n    /// time.during(args!(start_time, end_time, options)) -\u003e bool\n    /// ```\n    ///\n    /// Where:\n    /// - start_time, end_time: [DateTime](crate::types::DateTime), [Command](crate::Command)\n    /// - options: [DuringOption](crate::cmd::during::DuringOption)\n    ///\n    /// ## Examples\n    ///\n    /// Retrieve all the posts that were posted between December 1st,\n    /// 2013 (inclusive) and December 10th, 2013 (exclusive).\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{args, r, Result};\n    /// use time::macros::{date, offset};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let start_date = r.time(args!(date!(2013 - 12 - 01), offset!(UTC)));\n    ///     let end_date = r.time(args!(date!(2013 - 12 - 10), offset!(UTC)));\n    ///     let response = r.table(\"posts\")\n    ///         .filter(func!(|post| post.g(\"date\").during(args!(start_date, end_date))))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Retrieve all the posts that were posted between December 1st,\n    /// 2013 (exclusive) and December 10th, 2013 (inclusive).\n    ///\n    /// ```\n    /// use reql_rust::arguments::Status;\n    /// use reql_rust::cmd::during::DuringOption;\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{args, r, Result};\n    /// use time::macros::{date, offset};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let start_date = r.time(args!(date!(2013 - 12 - 01), offset!(UTC)));\n    ///     let end_date = r.time(args!(date!(2013 - 12 - 10), offset!(UTC)));\n    ///     let during_options = DuringOption::default()\n    ///         .left_bound(Status::Open)\n    ///         .right_bound(Status::Closed);\n    ///     let response = r.table(\"posts\")\n    ///         .filter(func!(|post| post.g(\"date\").during(args!(\n    ///             start_date,\n    ///             end_date,\n    ///             during_options\n    ///         ))))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [now](crate::r::now)\n    /// - [time](crate::r::time)\n    /// - [in_timezone](Self::in_timezone)\n    pub fn during(self, args: impl during::DuringArg) -\u003e Self {\n        during::new(args).with_parent(self)\n    }\n\n    /// Return a new time struct only based on the day,\n    /// month and year (ie. the same day at 00:00).\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// time.date() → time\n    /// ```\n    ///\n    /// Where:\n    /// - time: [Time](crate::types::Time)\n    ///\n    /// ## Examples\n    ///\n    /// Retrieve all the users whose birthday is today.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"users\")\n    ///         .filter(func!(|user| user.g(\"birthdate\").date().eq(r.now().cmd().date())))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// Note that the [now](crate::r::now) command always returns UTC time, so the\n    /// comparison may fail if `user.g(\"birthdate\")` isn’t also in UTC.\n    /// You can use the [in_timezone](Self::in_timezone) command to adjust for this:\n    ///\n    /// ```\n    /// use time::macros::offset;\n    ///\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"users\")\n    ///         .filter(func!(|user| user.g(\"birthdate\").date().eq(\n    ///             r.now().cmd().in_timezone(offset!(-08:00)).date()\n    ///         )))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [now](crate::r::now)\n    /// - [time](crate::r::time)\n    /// - [in_timezone](Self::in_timezone)\n    pub fn date(self) -\u003e Self {\n        date::new().with_parent(self)\n    }\n\n    /// Return the number of seconds elapsed since the\n    /// beginning of the day stored in the time object.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// time.time_of_day() → f64\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Retrieve posts that were submitted before noon.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"posts\")\n    ///         .filter(func!(|post| post.g(\"date\").time_of_day().le(12*60*60)))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [now](crate::r::now)\n    /// - [time](crate::r::time)\n    /// - [in_timezone](Self::in_timezone)\n    pub fn time_of_day(self) -\u003e Self {\n        time_of_day::new().with_parent(self)\n    }\n\n    /// Return the year of a time object.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// time.year() → i32\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Retrieve all the users born in 1986.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"users\")\n    ///         .filter(func!(|user| user.g(\"birthdate\").year().eq(r.expr(1986))))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [now](crate::r::now)\n    /// - [time](crate::r::time)\n    pub fn year(self) -\u003e Self {\n        year::new().with_parent(self)\n    }\n\n    /// Return the month of a time object as a number between 1 and 12.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// time.month() → u8\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Retrieve all the users who were born in November.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"users\")\n    ///         .filter(func!(|user| user.g(\"birthdate\").month().eq(r.expr(11))))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [now](crate::r::now)\n    /// - [time](crate::r::time)\n    pub fn month(self) -\u003e Self {\n        month::new().with_parent(self)\n    }\n\n    /// Return the day of a time object as a number between 1 and 31.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// time.day() → u8\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Return the users born on the 24th of any month.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"users\")\n    ///         .filter(func!(|user| user.g(\"birthdate\").day().eq(r.expr(24))))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [now](crate::r::now)\n    /// - [time](crate::r::time)\n    pub fn day(self) -\u003e Self {\n        day::new().with_parent(self)\n    }\n\n    /// Return the day of week of a time object as a number\n    /// between 1 and 7 (following ISO 8601 standard).\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// time.day_of_week() → u8\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Return today’s day of week.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let day_of_week = r.now().day_of_week();\n    ///     let day_of_week1 = day_of_week.clone().value();\n    ///     let day_of_week2: u8 = day_of_week.cmd()\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(day_of_week1 == day_of_week2);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Retrieve all the users who were born on a Tuesday.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"users\")\n    ///         .filter(func!(|user| user.g(\"birthdate\").day_of_week().eq(r.expr(2))))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [now](crate::r::now)\n    /// - [time](crate::r::time)\n    pub fn day_of_week(self) -\u003e Self {\n        day_of_week::new().with_parent(self)\n    }\n\n    /// Return the day of the year of a time object as a number\n    /// between 1 and 366 (following ISO 8601 standard).\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// time.day_of_year() → u16\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Retrieve all the users who were born the first day of a year.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"users\")\n    ///         .filter(func!(|user| user.g(\"birthdate\").day_of_year().eq(r.expr(1))))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [now](crate::r::now)\n    /// - [time](crate::r::time)\n    pub fn day_of_year(self) -\u003e Self {\n        day_of_year::new().with_parent(self)\n    }\n\n    /// Return the hour in a time object as a number between 0 and 23.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// time.hours() → u8\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Return all the posts submitted after midnight and before 4am.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"posts\")\n    ///         .filter(func!(|post| post.g(\"date\").hours().lt(4)))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [now](crate::r::now)\n    /// - [time](crate::r::time)\n    /// - [in_timezone](Self::in_timezone)\n    pub fn hours(self) -\u003e Self {\n        hours::new().with_parent(self)\n    }\n\n    /// Return the minute in a time object as a number between 0 and 59.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// time.minutes() → u8\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Return all the posts submitted during the first 10 minutes of every hour.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"posts\")\n    ///         .filter(func!(|post| post.g(\"date\").minutes().lt(10)))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [now](crate::r::now)\n    /// - [time](crate::r::time)\n    /// - [in_timezone](Self::in_timezone)\n    pub fn minutes(self) -\u003e Self {\n        minutes::new().with_parent(self)\n    }\n\n    /// Return the seconds in a time object as a number between 0 and 59.999.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// time.seconds() → f64\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Return the post submitted during the first 30 seconds of every minute.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"posts\")\n    ///         .filter(func!(|post| post.g(\"date\").seconds().lt(30)))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [now](crate::r::now)\n    /// - [time](crate::r::time)\n    /// - [in_timezone](Self::in_timezone)\n    pub fn seconds(self) -\u003e Self {\n        seconds::new().with_parent(self)\n    }\n\n    /// Convert a time object to a string in ISO 8601 format.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// time.to_iso8601() → String\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Return the current ISO 8601 time.\n    ///\n    /// ```\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let iso8601 = r.now().to_iso8601();\n    ///     let iso8601_1 = iso8601.clone().value();\n    ///     let iso8601_2: String = iso8601.cmd()\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(!iso8601_1.is_empty());\n    ///     assert!(!iso8601_2.is_empty());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [now](crate::r::now)\n    /// - [time](crate::r::time)\n    pub fn to_iso8601(self) -\u003e Self {\n        to_iso8601::new().with_parent(self)\n    }\n\n    /// Convert a time object to its epoch time.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// time.to_epoch_time() → f64\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Return the current time in seconds since\n    /// the Unix Epoch with millisecond-precision.\n    ///\n    /// ```\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let time = r.now().to_epoch_time();\n    ///     let time1: f64 = time.clone().value();\n    ///     let time2: f64 = time.cmd()\n    ///         .run(\u0026conn)\n    ///         .await?.unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(time1.is_normal());\n    ///     assert!(time2.is_normal());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [now](crate::r::now)\n    /// - [time](crate::r::time)\n    /// - [to_iso8601](Self::to_iso8601)\n    pub fn to_epoch_time(self) -\u003e Self {\n        to_epoch_time::new().with_parent(self)\n    }\n\n    // FIXME Command no work\n    pub fn do_(self, args: impl do_::DoArg) -\u003e Self {\n        do_::new(args).with_parent(self)\n    }\n\n    /// Perform a branching conditional equivalent to `if-then-else`.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// r.branch(test, args!(true_action, false_action)) → any\n    /// r.branch(test, args!(true_action, [(test2, test2_action), N], false_action)) → any\n    /// query.branch(args!(true_action, false_action)) -\u003e any\n    /// query.branch(args!(true_action, [(test2, test2_action), N], false_action)) → any\n    /// ```\n    ///\n    /// Where:\n    /// - test, true_action, false_action, test2, test2_action: r.expr(...)\n    ///\n    /// # Description\n    ///\n    /// The `branch` command takes 2n+1 arguments: pairs of conditional expressions\n    /// and commands to be executed if the conditionals return any value but `false`\n    /// or `None` i.e., “truthy” values), with a final “else” command to be evaluated\n    /// if all of the conditionals are `false` or `None`.\n    ///\n    /// You may call `branch` infix style on the first test.\n    /// (See the second example for an illustration.)\n    ///\n    /// ```text\n    /// r.branch(test1, args!(val1, [(test2, val2)], elseval))\n    /// ```\n    ///\n    /// is the equivalent of the Rust statement\n    ///\n    /// ```text\n    /// if (test1) {\n    ///     val1\n    /// } else if (test2) {\n    ///     val2\n    /// } else {\n    ///     elseval\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Test the value of x.\n    ///\n    /// ```\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let x = 10;\n    ///     let conn = r.connection().connect().await?;\n    ///\n    ///     let response: String = r.branch(\n    ///             r.expr(x \u003e 5),\n    ///             args!(r.expr(\"big\"), r.expr(\"small\"))\n    ///         ).run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response.eq(\"big\"));\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// As above, infix-style.\n    ///\n    /// ```\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let x = 10;\n    ///     let conn = r.connection().connect().await?;\n    ///\n    ///     let response: String = r.expr(x \u003e 5)\n    ///         .branch(args!(r.expr(\"big\"), r.expr(\"small\")))\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response.eq(\"big\"));\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Categorize heroes by victory counts.\n    ///\n    /// ```\n    /// use std::ops::Add;\n    ///\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///\n    ///     let response = r.table(\"pricings\")\n    ///         .map(func!(|offer| r.branch(\n    ///             offer.clone().g(\"price\").gt(100),\n    ///             args!(\n    ///                 offer.clone().g(\"offer\").add(\"premium\"),\n    ///                 [(\n    ///                     offer.clone().g(\"price\").gt(10),\n    ///                     offer.clone().g(\"offer\").add(\"standard\")\n    ///                 )],\n    ///                 offer.g(\"offer\").add(\"freemium\")\n    ///         ))))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [do_](Self::do_)\n    pub fn branch(self, args: impl branch::BranchArg) -\u003e Self {\n        branch::new(args).with_parent(self)\n    }\n\n    /// Loop over a sequence, evaluating the given write query for each element.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// sequence.for_each(write_function) → response\n    /// ```\n    ///\n    /// Where:\n    /// - write_function: func!(...)\n    /// - response: [MutationResponse](crate::types::MutationResponse)\n    ///\n    /// ## Examples\n    ///\n    /// Get information about a table such as primary key, or cache size.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::types::MutationResponse;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///\n    ///     let response: MutationResponse = r.table(\"models\")\n    ///         .for_each(func!(|model| r.table(\"cars\")\n    ///             .get(model.get(\"car_model\"))\n    ///             .delete(())\n    ///         ))\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response.deleted == 5);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [map](Self::map)\n    pub fn for_each(self, write_function: Func) -\u003e Self {\n        for_each::new(write_function).with_parent(self)\n    }\n\n    /// Provide a default value in case of non-existence errors.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// value.default(default_value) → any\n    /// sequence.default(default_value) → any\n    /// ```\n    ///\n    /// # Description\n    ///\n    /// The `default` command evaluates its first argument (the value it’s chained to).\n    /// If that argument returns `None` or a non-existence error is thrown in evaluation,\n    /// then `default` returns its second argument. The second argument is usually a default value,\n    /// but it can be a function that returns a value.\n    ///\n    /// ## Examples\n    ///\n    /// Suppose we want to retrieve the titles and authors of the table posts.\n    /// In the case where the author field is missing or null,\n    /// we want to retrieve the string Anonymous.\n    ///\n    /// ```\n    /// use std::collections::HashMap;\n    ///\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    /// use serde::{Deserialize, Serialize};\n    ///\n    /// #[derive(Debug, Serialize, Deserialize)]\n    /// struct Post {\n    ///     title: String,\n    ///     author: String,\n    /// }\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///\n    ///     let response: Vec\u003cPost\u003e = r.table(\"posts\")\n    ///         .map(func!(|doc| {\n    ///             let mut post = HashMap::new();\n    ///             post.insert(\"title\", doc.clone().g(\"title\"));\n    ///             post.insert(\"author\", doc.clone().g(\"author\").default(\"Anonymous\"));\n    ///             r.hash_map(post)\n    ///         }))\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response.len() \u003e 0);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// The `default` command can also be used to filter documents.\n    /// Suppose we want to retrieve all our users who are not grown-ups or\n    /// whose age is unknown (i.e., the field `age` is missing or equals `None`).\n    /// We can do it with this query:\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///\n    ///     let response = r.table(\"users\")\n    ///         .filter(func!(|user| user.g(\"age\").lt(18).default(true)))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// One more way to write the previous query is\n    /// to set the age to be `-1` when the field is missing.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///\n    ///     let response = r.table(\"users\")\n    ///         .filter(func!(|user| user.g(\"age\").default(-1).lt(18)))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// Another way to do the same query is to use hasFields.\n    ///\n    /// ```\n    /// use std::ops::Not;\n    ///\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///\n    ///     let response = r.table(\"users\")\n    ///         .filter(func!(|user| user.clone().has_fields(\"age\").not().or(user.g(\"age\").lt(18))))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// Another way to do the same query is to use hasFields.\n    ///\n    /// ```\n    /// use reql_rust::cmd::filter::FilterOption;\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///\n    ///     let response = r.table(\"users\")\n    ///         .filter(args!(\n    ///             func!(|user| user.g(\"age\").lt(18).default(true)),\n    ///             FilterOption::default().default_(true)\n    ///         ))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    pub fn default(self, default_value: impl Serialize) -\u003e Self {\n        default::new(default_value).with_parent(self)\n    }\n\n    /// Convert a value of one type into another.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// sequence.coerce_to('array') → array\n    /// value.coerce_to('string') → string\n    /// string.coerce_to('number') → number\n    /// array.coerce_to('object') → object\n    /// sequence.coerce_to('object') → object\n    /// object.coerce_to('array') → array\n    /// binary.coerce_to('string') → string\n    /// string.coerce_to('binary') → binary\n    /// ```\n    ///\n    /// # Description\n    ///\n    /// - a sequence, selection or object can be coerced to an array\n    /// - a sequence, selection or an array of key-value pairs can be coerced to an object\n    /// - a string can be coerced to a number\n    /// - any datum (single value) can be coerced to a string\n    /// - a binary object can be coerced to a string and vice-versa\n    ///\n    /// ## Examples\n    ///\n    /// Coerce an array of pairs into an object.\n    ///\n    /// ```\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///\n    ///     let response = r.expr([[\"name\", \"Malika\"], [\"genre\", \"woman\"]])\n    ///         .coerce_to(\"object\")\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Coerce a number to a string.\n    ///\n    /// ```\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///\n    ///     let response: char = r.expr(1)\n    ///         .coerce_to(\"string\")\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == '1');\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [object](crate::r::object)\n    pub fn coerce_to(self, value: impl Serialize) -\u003e Self {\n        coerce_to::new(value).with_parent(self)\n    }\n\n    /// Gets the type of a ReQL query’s return value.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// any.type_of() → response\n    /// ```\n    ///\n    /// Where:\n    /// - response: [TypeOf](crate::types::TypeOf)\n    ///\n    /// # Description\n    ///\n    /// Read the article on [ReQL data types](https://rethinkdb.com/docs/data-types/)\n    /// for a more detailed discussion.\n    /// Note that some possible return values from `type_of` are internal values,\n    /// such as `TypeOf::MAXVAL`, and unlikely to be returned from queries in standard practice.\n    ///\n    /// ## Examples\n    ///\n    /// Get the type of a TypeOf.\n    ///\n    /// ```\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::types::TypeOf;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///\n    ///     let response: TypeOf = r.expr(\"foo\")\n    ///         .type_of()\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == TypeOf::String);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    pub fn type_of(self) -\u003e Self {\n        type_of::new().with_parent(self)\n    }\n\n    /// Get information about a ReQL value.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// any.info() → response\n    /// r.info(any) → response\n    /// ```\n    ///\n    /// Where:\n    /// - response: [InfoResponse](crate::types::InfoResponse)\n    ///\n    /// ## Examples\n    ///\n    /// Get information about a table such as primary key, or cache size.\n    ///\n    /// ```\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::types::{InfoResponse, TypeOf};\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///\n    ///     let response: InfoResponse = r.table(\"simbad\")\n    ///         .info()\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response.typ == TypeOf::Table);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    pub fn info(self) -\u003e Self {\n        info::new().with_parent(self)\n    }\n\n    /// Convert a ReQL value or object to a JSON string.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// value.to_json() → String\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Get a ReQL document as a JSON string.\n    ///\n    /// ```\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///\n    ///     let response: String = r.table(\"simbad\")\n    ///         .get(1)\n    ///         .to_json()\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(!response.is_empty());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    pub fn to_json(self) -\u003e Self {\n        to_json::new().with_parent(self)\n    }\n\n    /// Compute the distance between a point and another geometry object.\n    /// At least one of the geometry objects specified must be a point.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// geometry.distance(geometry) → f64\n    /// geometry.distance(args!(geometry, options)) → f64\n    /// r.distance(geometry.cmd(), geometry) → f64\n    /// r.distance(geometry.cmd(), args!(geometry, options)) → f64\n    /// ```\n    ///\n    /// Where:\n    /// - geometry: [r.point(...)](crate::r::point) |\n    /// [r.line(...)](crate::r::line) |\n    /// [r.polygon(...)](crate::r::polygon)\n    /// - options: [DistanceOption](crate::cmd::distance::DistanceOption)\n    ///\n    /// # Description\n    ///\n    /// If one of the objects is a polygon or a line, the point will be projected\n    /// into the line or polygon assuming a perfect sphere model before the distance\n    /// is computed (using the model specified with `geo_system`).\n    /// As a consequence, if the polygon or line is extremely large compared\n    /// to Earth’s radius and the distance is being computed with the default\n    ///  WGS84 model, the results of `distance` should be considered approximate\n    /// due to the deviation between the ellipsoid and spherical models.\n    ///\n    /// ## Examples\n    ///\n    /// Compute the distance between two points on the Earth in kilometers.\n    ///\n    /// ```\n    /// use reql_rust::arguments::Unit;\n    /// use reql_rust::cmd::distance::DistanceOption;\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let point1 = r.point(-122.423246, 37.779388);\n    ///     let point2 = r.point(-117.220406, 32.719464);\n    ///     let distance_option = DistanceOption::default().unit(Unit::Kilometer);\n    ///\n    ///     let response: f64 = point1.cmd()\n    ///         .distance(point2)\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == 734.125249602186);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [polygon](crate::r::polygon)\n    /// - [line](crate::r::line)\n    pub fn distance(self, args: impl distance::DistanceArg) -\u003e Self {\n        distance::new(args).with_parent(self)\n    }\n\n    /// Convert a ReQL geometry object to a [GeoJSON](https://geojson.org/) object.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// geometry.to_geojson() → response\n    /// ```\n    ///\n    /// Where:\n    /// - geometry: [r.point(...)](crate::r::point) |\n    /// [r.line(...)](crate::r::line) |\n    /// [r.polygon(...)](crate::r::polygon)\n    /// command\n    /// - response: [GeoJson\u003cT\u003e](crate::types::GeoJson)\n    ///\n    /// ## Examples\n    ///\n    /// Convert a ReQL geometry object to a GeoJSON object.\n    ///\n    /// ```\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::types::{GeoJson, GeoType};\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///\n    ///     let response: GeoJson\u003c[f64; 2]\u003e = r.table(\"simbad\")\n    ///         .get(\"sfo\")\n    ///         .g(\"location\")\n    ///         .to_geojson()\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response.typ == GeoType::Point);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [geojson](crate::r::geojson)\n    pub fn to_geojson(self) -\u003e Self {\n        to_geojson::new().with_parent(self)\n    }\n\n    /// Get all documents where the given geometry object intersects\n    /// the geometry object of the requested geospatial index.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// table.get_intersecting(geometry, options) → selection\u003cstream\u003e\n    /// ```\n    ///\n    /// Where:\n    /// - geometry: [r.point(...)](crate::r::point) |\n    /// [r.line(...)](crate::r::line) |\n    /// [r.polygon(...)](crate::r::polygon)\n    /// command\n    /// - sequence: command\n    /// - options: [GetIntersectingOption](crate::cmd::get_intersecting::GetIntersectingOption)\n    ///\n    /// # Description\n    ///\n    /// The `index` argument is mandatory. This command returns the same\n    ///  results as `|row| row.g(index).intersects(geometry)`.\n    /// The total number of results is limited to the array size limit\n    /// which defaults to 100,000, but can be changed with the `array_limit`\n    /// option to [run](Self::run).\n    ///\n    /// ## Examples\n    ///\n    /// Which of the locations in a list of parks intersect `circle`?\n    ///\n    /// ```\n    /// use reql_rust::arguments::Unit;\n    /// use reql_rust::cmd::circle::CircleOption;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let point = r.point(-117.220406, 32.719464);\n    ///     let circle_opts = CircleOption::default()\n    ///         .unit(Unit::InternationalMile);\n    ///     let circle = r.circle(args!(point, 10., circle_opts));\n    ///\n    ///     let response = r.table(\"simbad\")\n    ///         .get_intersecting(circle, \"area\")\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [get_nearest](Self::get_nearest)\n    pub fn get_intersecting(\n        self,\n        geometry: impl get_intersecting::GetIntersectingArg,\n        index: \u0026'static str,\n    ) -\u003e Self {\n        get_intersecting::new(geometry, index).with_parent(self)\n    }\n\n    /// Return a list of documents closest to a\n    /// specified point based on a geospatial index,\n    /// sorted in order of increasing distance.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// table.get_nearest(args!(geometry, \u0026str)) → array\n    /// table.get_nearest(args!(geometry, \u0026str, options)) → array\n    /// ```\n    ///\n    /// Where:\n    /// - geometry: [r.point(...)](crate::r::point) |\n    /// [r.line(...)](crate::r::line) |\n    /// [r.polygon(...)](crate::r::polygon) |\n    /// command\n    /// - sequence: command\n    /// - options: [GetNearestOption](crate::cmd::get_nearest::GetNearestOption)\n    ///\n    /// # Description\n    ///\n    /// The return value will be an array of two-item objects\n    /// with the keys `dist` and `doc`, set to the distance\n    /// between the specified point and the document\n    /// (in the units specified with `unit`, defaulting to meters)\n    /// and the document itself, respectively.\n    /// The array will be sorted by the values of `dist`.\n    ///\n    /// ## Examples\n    ///\n    /// Return a list of the closest 25 enemy hideouts to the secret base.\n    ///\n    /// ```\n    /// use reql_rust::cmd::get_nearest::GetNearestOption;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let secret_base = r.point(-122.422876, 37.777128);\n    ///     let opts = GetNearestOption::default().max_results(25);\n    ///\n    ///     let response = r.table(\"simbad\")\n    ///         .get_nearest(args!(secret_base, \"location\"))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [get_intersecting](Self::get_intersecting)\n    pub fn get_nearest(self, args: impl get_nearest::GetNearestArg) -\u003e Self {\n        get_nearest::new(args).with_parent(self)\n    }\n\n    /// Tests whether a geometry object is completely contained within another.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// geometry.includes(geometry) → bool\n    /// sequence.includes(geometry) → sequence\n    /// ```\n    ///\n    /// Where:\n    /// - geometry: [r.point(...)](crate::r::point) |\n    /// [r.line(...)](crate::r::line) |\n    /// [r.polygon(...)](crate::r::polygon) |\n    /// command\n    /// - sequence: command\n    ///\n    /// # Description\n    ///\n    /// When applied to a sequence of geometry objects,\n    /// `includes` acts as a [filter](Self::filter),\n    /// returning a sequence of objects from the sequence\n    /// that include the argument.\n    ///\n    /// ## Examples\n    ///\n    /// Is `point2` included within a 2000-meter circle around `point1`?\n    ///\n    /// ```\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let point1 = r.point(-117.220406, 32.719464);\n    ///     let point2 = r.point(-117.206201, 32.725186);\n    ///\n    ///     let response: bool = r.circle(args!(point1, 2000.))\n    ///         .includes(point2)\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Which of the locations in a list of parks include `circle`?\n    ///\n    /// ```\n    /// use reql_rust::arguments::Unit;\n    /// use reql_rust::cmd::circle::CircleOption;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let point = r.point(-117.220406, 32.719464);\n    ///     let circle_opts = CircleOption::default().unit(Unit::InternationalMile);\n    ///     let circle = r.circle(args!(point, 10., circle_opts));\n    ///\n    ///     let response = r.table(\"parks\")\n    ///         .g(\"area\")\n    ///         .includes(circle)\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Rewrite the previous example with `get_intersecting`.\n    ///\n    /// ```\n    /// use reql_rust::arguments::Unit;\n    /// use reql_rust::cmd::circle::CircleOption;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let point = r.point(-117.220406, 32.719464);\n    ///     let circle_opts = CircleOption::default()\n    ///         .unit(Unit::InternationalMile);\n    ///     let circle = r.circle(args!(point, 10., circle_opts));\n    ///\n    ///     let response = r.table(\"parks\")\n    ///         .get_intersecting(circle.clone(), \"area\")\n    ///         .g(\"area\")\n    ///         .includes(circle)\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [intersects](Self::intersects)\n    pub fn includes(self, args: impl includes::IncludesArg) -\u003e Self {\n        includes::new(args).with_parent(self)\n    }\n\n    /// Tests whether two geometry objects intersect with one another.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// geometry.intersects(geometry) → bool\n    /// r.intersects(geometry_command, geometry) → bool\n    /// sequence.intersects(geometry) → sequence_response\n    /// r.intersects(sequence, geometry) → sequence_response\n    /// ```\n    ///\n    /// Where:\n    /// - geometry: [r.point(...)](crate::r::point) |\n    /// [r.line(...)](crate::r::line) |\n    /// [r.polygon(...)](crate::r::polygon) |\n    /// command\n    /// - sequence, geometry_command: [Command](crate::Command)\n    ///\n    /// # Description\n    ///\n    /// When applied to a sequence of geometry objects, `intersects` acts as a\n    /// [filter](Self::filter), returning a sequence of objects from\n    /// the sequence that intersect with the argument.\n    ///\n    /// ## Examples\n    ///\n    /// Is `point2` within a 2000-meter circle around `point1`?\n    ///\n    /// ```\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let point1 = r.point(-117.220406, 32.719464);\n    ///     let point2 = r.point(-117.206201, 32.725186);\n    ///\n    ///     let response: bool = r.circle(args!(point1, 2000.))\n    ///         .intersects(point2)\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Which of the locations in a list of parks intersect `circle`?\n    ///\n    /// ```\n    /// use reql_rust::arguments::Unit;\n    /// use reql_rust::cmd::circle::CircleOption;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let point = r.point(-117.220406, 32.719464);\n    ///     let circle_opts = CircleOption::default().unit(Unit::InternationalMile);\n    ///     let circle = r.circle(args!(point, 10., circle_opts));\n    ///\n    ///     let response = r.table(\"parks\")\n    ///         .g(\"area\")\n    ///         .intersects(circle)\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [includes](Self::includes)\n    /// - [get_intersecting](Self::get_intersecting)\n    pub fn intersects(self, geometry: impl intersects::IntersectsArg) -\u003e Self {\n        intersects::new(geometry).with_parent(self)\n    }\n\n    /// Grant or deny access permissions for a user account,\n    /// globally or on a per-database or per-table basis.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// r.grant(username, permission) → response\n    /// table.grant(username, permission) → response\n    /// db.grant(username, permission) → response\n    /// ```\n    ///\n    /// Where:\n    /// - table: [r.table(...)](crate::r::table) |\n    /// [query.table(...)](Self::table)\n    /// - db: [r.db(...)](crate::r::db)\n    /// - response: [GrantResponse](crate::types::GrantResponse)\n    ///\n    /// # Description\n    ///\n    /// Permissions that are not defined on a local scope will\n    /// be inherited from the next largest scope.\n    /// For example, a write operation on a table will first\n    /// check if `write` permissions are explicitly set to `true` or `false`\n    /// for that table and account combination; if they are not,\n    /// the `write` permissions for the database will be used\n    /// if those are explicitly set; and if neither table nor database\n    /// permissions are set for that account, the global `write`\n    /// permissions for that account will be used.\n    ///\n    /// ## Note\n    ///\n    /// For all accounts other than the special, system-defined `admin` account,\n    /// permissions that are not explicitly set in any scope will effectively be `false`.\n    /// When you create a new user account by inserting a record into the\n    /// [system table](https://rethinkdb.com/docs/system-tables/#users),\n    /// that account will have **no** permissions until they are explicitly granted.\n    ///\n    /// For a full description of permissions, read\n    /// [Permissions and user accounts](https://rethinkdb.com/docs/permissions-and-accounts/).\n    ///\n    /// ## Examples\n    ///\n    /// Grant the `alima` user account read and write permissions on the `users` database.\n    ///\n    /// ```\n    /// use reql_rust::arguments::Permission;\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::types::GrantResponse;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let permission = Permission::default().read(true).write(true);\n    ///\n    ///     let response: GrantResponse = r.db(\"users\")\n    ///         .grant(\"alima\", permission)\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response.granted == 1);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Deny write permissions from the `alima` account for the `simbad` table.\n    ///\n    /// ```\n    /// use reql_rust::arguments::Permission;\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::types::GrantResponse;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let permission = Permission::default().write(false);\n    ///\n    ///     let response: GrantResponse = r.db(\"users\")\n    ///         .table(\"simbad\")\n    ///         .grant(\"alima\", permission)\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response.granted == 1);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Grant `alima` the ability to use HTTP connections.\n    ///\n    /// ```\n    /// use reql_rust::arguments::Permission;\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::types::GrantResponse;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let permission = Permission::default().connect(true);\n    ///\n    ///     let response: GrantResponse = r.grant(\"alima\", permission)\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response.granted == 1);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Grant a `monitor` account read-only access to all databases.\n    ///\n    /// ```\n    /// use reql_rust::arguments::Permission;\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::types::GrantResponse;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let permission = Permission::default().read(true);\n    ///\n    ///     let response: GrantResponse = r.grant(\"monitor\", permission)\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response.granted == 1);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    pub fn grant(self, username: \u0026str, permission: Permission) -\u003e Self {\n        grant::new(username, permission).with_parent(self)\n    }\n\n    /// Query (read and/or update) the configurations for individual tables or databases.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// table.config() → response\n    /// db.config() → response\n    /// ```\n    ///\n    /// Where:\n    /// - table: [r.table(...)](crate::r::table) |\n    /// [query.table(...)](Self::table)\n    /// - db: [r.db(...)](crate::r::db)\n    /// - response: [ConfigResponse](crate::types::ConfigResponse)\n    ///\n    /// # Description\n    ///\n    /// The config command is a shorthand way to access the `table_config` or `db_config`\n    /// [System tables](https://rethinkdb.com/docs/system-tables/#configuration-tables).\n    /// It will return the single row from the system that corresponds to the database\n    /// or table configuration, as if [get](Self::get) had been called on the system\n    /// table with the UUID of the database or table in question.\n    ///\n    /// ## Examples\n    ///\n    /// Rebalance a table.\n    ///\n    /// ```\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::types::ConfigResponse;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///\n    ///     let response: ConfigResponse = r.table(\"simbad\")\n    ///         .config()\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response.name == \"simbad\");\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    pub fn config(self) -\u003e Self {\n        config::new().with_parent(self)\n    }\n\n    /// Rebalances the shards of a table. When called on a database,\n    /// all the tables in that database will be rebalanced.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// table.rebalance() → response\n    /// db.rebalance() → response\n    /// ```\n    ///\n    /// Where:\n    /// - table: [r.table(...)](crate::r::table) |\n    /// [query.table(...)](Self::table)\n    /// - db: [r.db(...)](crate::r::db)\n    /// - response: [RebalanceResponse](crate::types::RebalanceResponse)\n    ///\n    /// # Description\n    ///\n    /// The `rebalance` command operates by measuring the distribution of\n    /// primary keys within a table and picking split points that will\n    /// give each shard approximately the same number of documents.\n    /// It won’t change the number of shards within a table,\n    /// or change any other configuration aspect for the table or the database.\n    ///\n    /// A table will lose availability temporarily after `rebalance` is called;\n    /// use the [wait](Self::wait) command to wait for the table to become available again,\n    /// or [status](Self::status) to check if the table is available for writing.\n    ///\n    /// RethinkDB automatically rebalances tables when the number of shards are increased,\n    /// and as long as your documents have evenly distributed primary keys—such as\n    /// the default UUIDs—it is rarely necessary to call `rebalance` manually.\n    /// Cases where `rebalance` may need to be called include:\n    /// - Tables with unevenly distributed primary keys, such as incrementing integers\n    /// - Changing a table’s primary key type\n    /// - Increasing the number of shards on an empty table,\n    /// then using non-UUID primary keys in that table\n    ///\n    /// The [web UI](https://rethinkdb.com/docs/administration-tools/)\n    /// (and the [info](Self::info) command)\n    /// can be used to tell you when a table’s shards need to be rebalanced.\n    ///\n    /// See the [status](Self::status) command for an explanation of\n    /// the objects returned in the `old_val` and `new_val` fields.\n    ///\n    /// ## Examples\n    ///\n    /// Rebalance a table.\n    ///\n    /// ```\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::types::RebalanceResponse;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///\n    ///     let response: RebalanceResponse = r.table(\"simbad\")\n    ///         .rebalance()\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response.rebalanced == 1);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    pub fn rebalance(self) -\u003e Self {\n        rebalance::new().with_parent(self)\n    }\n\n    /// Reconfigure a table’s sharding and replication.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// table.reconfigure(options) → response\n    /// db.reconfigure(options) → response\n    /// ```\n    ///\n    /// Where:\n    /// - table: [r.table(...)](crate::r::table) |\n    /// [query.table(...)](Self::table)\n    /// - db: [r.db(...)](crate::r::db)\n    /// - options: [ReconfigureOption](crate::cmd::reconfigure::ReconfigureOption)\n    /// - response: [ReconfigureResponse](crate::types::ReconfigureResponse)\n    ///\n    /// # Description\n    ///\n    /// A table will lose availability temporarily after `reconfigure` is called;\n    /// use the [wait](Self::wait) command to wait for the table to become available again,\n    /// or [status](Self::wait) to check if the table is available for writing.\n    ///\n    /// ## Note\n    ///\n    /// Whenever you call `reconfigure`, the write durability will be set to\n    /// `Durability::Hard` and the write\n    /// acknowledgments will be set to `ReadMode::Majority`;\n    /// these can be changed by using the `config` command on the table.\n    ///\n    ///\n    /// If `reconfigure` is called on a database,\n    /// all the tables in the database will have their configurations affected.\n    /// The return value will be an array of the objects described above, one per table.\n    ///\n    /// Read [Sharding and replication](https://rethinkdb.com/docs/sharding-and-replication/)\n    /// for a complete discussion of the subject, including advanced topics.\n    ///\n    /// ## Examples\n    ///\n    /// Reconfigure a table.\n    ///\n    /// ```\n    /// use reql_rust::arguments::Replicas;\n    /// use reql_rust::cmd::reconfigure::ReconfigureOption;\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::types::ReconfigureResponse;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let opts = ReconfigureOption::default()\n    ///         .shards(1)\n    ///         .replicas(Replicas::Int(1));\n    ///\n    ///     let response: ReconfigureResponse = r.table(\"simbad\")\n    ///         .reconfigure(opts)\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response.reconfigured == 1);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Reconfigure a table, specifying replicas by server tags.\n    ///\n    /// ```\n    /// use std::collections::HashMap;\n    ///\n    /// use reql_rust::arguments::Replicas;\n    /// use reql_rust::cmd::reconfigure::ReconfigureOption;\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::types::ReconfigureResponse;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let mut replicas = HashMap::new();\n    ///\n    ///     replicas.insert(\"malika\".static_string(), 1);\n    ///     replicas.insert(\"malika\".static_string(), 1);\n    ///\n    ///     let opts = ReconfigureOption::default()\n    ///         .shards(2)\n    ///         .replicas(Replicas::Map {\n    ///             replicas,\n    ///             primary_replica_tag: \"malika\".static_string()\n    ///         });\n    ///\n    ///     let response: ReconfigureResponse = r.table(\"simbad\")\n    ///         .reconfigure(opts)\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response.reconfigured == 1);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Perform an emergency repair on a table.\n    ///\n    /// ```\n    /// use reql_rust::arguments::EmergencyRepair;\n    /// use reql_rust::cmd::reconfigure::ReconfigureOption;\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::types::ReconfigureResponse;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let opts = ReconfigureOption::default()\n    ///         .emergency_repair(EmergencyRepair::UnsafeRollback);\n    ///\n    ///     let response: ReconfigureResponse = r.table(\"simbad\")\n    ///         .reconfigure(opts)\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response.reconfigured == 1);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    pub fn reconfigure(self, opts: reconfigure::ReconfigureOption) -\u003e Self {\n        reconfigure::new(opts).with_parent(self)\n    }\n\n    /// Return the status of a table.\n    ///\n    /// The return value is an object providing information about\n    /// the table’s shards, replicas and replica readiness states.\n    /// For a more complete discussion of the object fields,\n    /// read about the table_status table in\n    /// [System tables](https://rethinkdb.com/docs/system-tables/#status-tables).\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// table.status() → response\n    /// ```\n    ///\n    /// Where:\n    /// - table: [r.table(...)](crate::r::table) |\n    /// [query.table(...)](Self::table)\n    /// - response: [StatusResponse](crate::types::StatusResponse)\n    ///\n    /// ## Examples\n    ///\n    /// Get a table’s status.\n    ///\n    /// ```\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::types::StatusResponse;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///\n    ///     let response: StatusResponse = r.table(\"simbad\")\n    ///         .status()\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response.name.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    pub fn status(self) -\u003e Self {\n        status::new().with_parent(self)\n    }\n\n    /// Wait for a table or all the tables in a database to be ready.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// table.wait(()) → response\n    /// db.wait(()) → response\n    /// r.wait(table) → response\n    /// r.wait(database) → response\n    /// table.wait(options) → response\n    /// db.wait(options) → response\n    /// r.wait(args!(table, options)) → response\n    /// r.wait(args!(database, options)) → response\n    /// ```\n    ///\n    /// Where:\n    /// - table: [r.table(...)](crate::r::table) |\n    /// [query.table(...)](Self::table)\n    /// - db: [r.db(...)](crate::r::db)\n    /// - options: [WaitOption](crate::cmd::wait::WaitOption)\n    /// - response: [WaitResponse](crate::types::WaitResponse)\n    ///\n    /// # Description\n    ///\n    /// A table may be temporarily unavailable after creation,\n    /// rebalancing or reconfiguring.\n    /// The `wait` command blocks until the given\n    /// table (or database) is fully up to date.\n    ///\n    /// ## Examples\n    ///\n    /// Wait on a table to be ready.\n    ///\n    /// ```\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::types::WaitResponse;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///\n    ///     let response: WaitResponse = r.table(\"simbad\")\n    ///         .wait(())\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response.ready == 1);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Wait on a table with timeout to be ready for reads.\n    ///\n    /// ```\n    /// use reql_rust::arguments::WaitFor;\n    /// use reql_rust::cmd::wait::WaitOption;\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::types::WaitResponse;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let table_command = r.db(\"anim\").table(\"simbad\");\n    ///     let opts = WaitOption::default()\n    ///         .wait_for(WaitFor::ReadyForReads)\n    ///         .timeout(8000f64);\n    ///\n    ///     let response: WaitResponse =  r.wait(args!(table_command, opts))\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response.ready == 1);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    pub fn wait(self, args: impl wait::WaitArg) -\u003e Self {\n        wait::new(args).with_parent(self)\n    }\n\n    /// Run a query on a connection,\n    /// returning either a single JSON result or a cursor,\n    /// depending on the query.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// query.run(\u0026session) → value\n    /// query.run(connection) → value\n    /// query.run(args!(\u0026session, options)) → value\n    /// query.run(args!(connection, options)) → value\n    /// query.run(\u0026mut session) → value\n    /// query.run(args!(\u0026mut session, options)) → value\n    /// ```\n    ///\n    /// Where:\n    /// - session: [Session](crate::connection::Session)\n    /// - connection: [Connection](crate::connection::Connection)\n    /// - options: [RunOption](crate::cmd::run::RunOption)\n    /// - stream: [impl Stream\u003cItem = Result\u003cValue\u003e\u003e](futures::stream::Stream)\n    ///\n    /// ## Examples\n    ///\n    /// If you are OK with potentially out of date data\n    /// from all the tables involved in this query and\n    /// want potentially faster reads,\n    /// pass a flag allowing out of date data in an options object.\n    /// Settings for individual tables will supercede this global\n    /// setting for all tables in the query.\n    ///\n    /// ```\n    /// use reql_rust::arguments::ReadMode;\n    /// use reql_rust::cmd::run::RunOption;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let opts = RunOption::default().read_mode(ReadMode::Outdated);\n    ///\n    ///     r.table(\"simbad\").run(args!(\u0026conn, opts)).await?;\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// If you want to specify whether to wait for a write to be written\n    /// to disk (overriding the table’s default settings),\n    /// you can set `durability` to `Durability::Hard`\n    /// or `Durability::Soft` in the options.\n    ///\n    /// ```\n    /// use reql_rust::arguments::Durability;\n    /// use reql_rust::cmd::run::RunOption;\n    /// use reql_rust::{args, r, Result};\n    /// use serde_json::json;\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let opts = RunOption::default().durability(Durability::Hard);\n    ///     let data = json!({\n    ///         \"name\": \"Pumba\",\n    ///         \"live\": 5\n    ///     });\n    ///\n    ///     r.table(\"simbad\").insert(data).run(args!(\u0026conn, opts)).await?;\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// If you do not want a time object to be converted to a native date object,\n    /// you can pass a time_format flag to prevent it\n    /// (valid flags are `Format::Raw` and `Format::Native`).\n    /// This query returns an object with two fields (epoch_time and $reql_type$)\n    /// instead of a native date object.\n    ///\n    /// ```\n    /// use reql_rust::arguments::Format;\n    /// use reql_rust::cmd::run::RunOption;\n    /// use reql_rust::{args, r, Result};\n    /// use serde_json::json;\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let opts = RunOption::default().time_format(Format::Raw);\n    ///\n    ///     r.now().cmd().run(args!(\u0026conn, opts)).await?;\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Specify the database to use for the query.\n    ///\n    /// ```\n    /// use reql_rust::arguments::Format;\n    /// use reql_rust::cmd::run::RunOption;\n    /// use reql_rust::{args, r, Result};\n    /// use serde_json::json;\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let opts = RunOption::default().db(\"jikoni\");\n    ///\n    ///     r.table(\"simbad\").run(args!(\u0026conn, opts)).await?;\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Change the batching parameters for this query.\n    ///\n    /// ```\n    /// use reql_rust::arguments::Format;\n    /// use reql_rust::cmd::run::RunOption;\n    /// use reql_rust::{args, r, Result};\n    /// use serde_json::json;\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let opts = RunOption::default()\n    ///         .max_batch_rows(16)\n    ///         .max_batch_bytes(2048);\n    ///\n    ///     r.table(\"simbad\").run(args!(\u0026conn, opts)).await?;\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [connection](crate::r::connection)\n    pub async fn run(self, arg: impl run::RunArg) -\u003e Result\u003cOption\u003cValue\u003e\u003e {\n        self.make_query(arg).try_next().await\n    }\n\n    /// Prepare query for execution\n    ///\n    /// See [run](self::run) for more information.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// query.make_query(\u0026session) → stream\n    /// query.make_query(connection) → stream\n    /// query.make_query(args!(\u0026session, options)) → stream\n    /// query.make_query(args!(connection, options)) → stream\n    /// query.make_query(\u0026mut session) → stream\n    /// query.make_query(args!(\u0026mut session, options)) → stream\n    /// ```\n    ///\n    /// Where:\n    /// - session: [Session](crate::connection::Session)\n    /// - connection: [Connection](crate::connection::Connection)\n    /// - options: [RunOption](crate::cmd::run::RunOption)\n    ///\n    /// # Description\n    ///\n    /// This method has the same parameters as `run`.\n    /// The main difference between `make_query` and `run` is that\n    /// `make_query` can be used to execute multiple requests\n    ///\n    /// ## Examples\n    ///\n    /// You can use `query.make_query` to get the same result than `query.run`\n    ///\n    /// ```\n    /// use futures::TryStreamExt;\n    /// use reql_rust::r;\n    ///\n    /// async fn example() -\u003e reql_rust::Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///\n    ///     r.table(\"simbad\").make_query(\u0026conn).try_next().await?;\n    ///     // is same than\n    ///     r.table(\"simbad\").run(\u0026conn).await?;\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Run many queries\n    ///\n    /// ```\n    /// use futures::stream::{select_all, TryStreamExt};\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::r;\n    ///\n    /// async fn example() -\u003e reql_rust::Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let mut streams = Vec::new();\n    ///     let expected_messages: Vec\u003cString\u003e = (0..10_000)\n    ///         .into_iter()\n    ///         .map(|i| format!(\"message {}\", i))\n    ///         .collect();\n    ///\n    ///     for msg in expected_messages.iter() {\n    ///         streams.push(r.expr(msg).make_query(\u0026conn));\n    ///     }\n    ///\n    ///     let mut list = select_all(streams);\n    ///     let mut response = Vec::new();\n    ///\n    ///     while let Some(msg) = list.try_next().await? {\n    ///         let msg: String = msg.parse()?;\n    ///         response.push(msg);\n    ///     }\n    ///\n    ///     assert!(response == expected_messages);\n    ///\n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [run](self::run)\n    pub fn make_query(self, arg: impl run::RunArg) -\u003e impl Stream\u003cItem = Result\u003cValue\u003e\u003e {\n        Box::pin(run::new(self, arg))\n    }\n}\n\npub enum CmdOpts {\n    Single(Command),\n    Many(Vec\u003cCommand\u003e),\n}\n\nimpl CmdOpts {\n    pub(crate) fn add_to_cmd(self, command: Command) -\u003e Command {\n        match self {\n            Self::Single(arg) =\u003e command.with_arg(arg),\n            Self::Many(args) =\u003e args.into_iter().fold(command, |cmd, arg| cmd.with_arg(arg)),\n        }\n    }\n}\n\nimpl From\u003cCmdOpts\u003e for Option\u003cCommand\u003e {\n    fn from(command: CmdOpts) -\u003e Self {\n        if let CmdOpts::Single(arg) = command {\n            Some(arg)\n        } else {\n            None\n        }\n    }\n}\n\n// for debug purposes only\nfn bytes_to_string(bytes: \u0026[u8]) -\u003e String {\n    if let Ok(string) = str::from_utf8(bytes) {\n        return string.to_owned();\n    }\n    format!(\"{:?}\", bytes)\n}\n","traces":[{"line":194,"address":[2006592],"length":1,"stats":{"Line":4},"fn_name":"static_string"},{"line":195,"address":[2006613],"length":1,"stats":{"Line":5},"fn_name":null},{"line":200,"address":[2648720],"length":1,"stats":{"Line":1},"fn_name":"static_string"},{"line":201,"address":[2648732],"length":1,"stats":{"Line":1},"fn_name":null},{"line":206,"address":[2199872],"length":1,"stats":{"Line":0},"fn_name":"static_string"},{"line":207,"address":[2199895],"length":1,"stats":{"Line":0},"fn_name":null},{"line":208,"address":[2199918],"length":1,"stats":{"Line":0},"fn_name":null},{"line":209,"address":[2199959],"length":1,"stats":{"Line":0},"fn_name":null},{"line":215,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":216,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":345,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":346,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":395,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":396,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":436,"address":[2176832,2177024,2176993],"length":1,"stats":{"Line":0},"fn_name":"table_list"},{"line":437,"address":[2176854,2176921],"length":1,"stats":{"Line":0},"fn_name":null},{"line":518,"address":[1488955,1488752,1488986],"length":1,"stats":{"Line":4},"fn_name":"table\u003c\u0026str\u003e"},{"line":519,"address":[1488883,1488816],"length":1,"stats":{"Line":8},"fn_name":null},{"line":675,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":676,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":718,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":719,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":759,"address":[2177232,2177201,2177040],"length":1,"stats":{"Line":1},"fn_name":"index_list"},{"line":760,"address":[2177062,2177129],"length":1,"stats":{"Line":2},"fn_name":null},{"line":820,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":821,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":928,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":929,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":997,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":998,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":1089,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1090,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1144,"address":[2177409,2177248,2177440],"length":1,"stats":{"Line":1},"fn_name":"get_write_hook"},{"line":1145,"address":[2177270,2177337],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1344,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":1345,"address":[],"length":0,"stats":{"Line":32},"fn_name":null},{"line":1664,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1665,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1846,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1847,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":2011,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":2012,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":2060,"address":[2177648,2177456,2177617],"length":1,"stats":{"Line":1},"fn_name":"sync"},{"line":2061,"address":[2177545,2177478],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2127,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":2128,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":2221,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":2222,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":2395,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":2396,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":2766,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":2767,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":2829,"address":[2177951,2177664,2177920],"length":1,"stats":{"Line":1},"fn_name":"inner_join"},{"line":2830,"address":[2177848,2177704],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2892,"address":[2178224,2177968,2178255],"length":1,"stats":{"Line":1},"fn_name":"outer_join"},{"line":2893,"address":[2178152,2178008],"length":1,"stats":{"Line":2},"fn_name":null},{"line":3040,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":3041,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":3078,"address":[2178464,2178272,2178433],"length":1,"stats":{"Line":1},"fn_name":"zip"},{"line":3079,"address":[2178361,2178294],"length":1,"stats":{"Line":2},"fn_name":null},{"line":3226,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":3227,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":3290,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":3291,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":3295,"address":[2178688,2178719,2178480],"length":1,"stats":{"Line":0},"fn_name":"concat_map"},{"line":3296,"address":[2178614,2178515],"length":1,"stats":{"Line":0},"fn_name":null},{"line":3300,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":3301,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":3342,"address":[2178918,2178736,2178949],"length":1,"stats":{"Line":1},"fn_name":"skip"},{"line":3343,"address":[2178846,2178779],"length":1,"stats":{"Line":2},"fn_name":null},{"line":3384,"address":[2179173,2178960,2179142],"length":1,"stats":{"Line":1},"fn_name":"limit"},{"line":3385,"address":[2179070,2179003],"length":1,"stats":{"Line":2},"fn_name":null},{"line":3534,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":3535,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":3624,"address":[2179366,2179397,2179184],"length":1,"stats":{"Line":1},"fn_name":"nth"},{"line":3625,"address":[2179294,2179227],"length":1,"stats":{"Line":2},"fn_name":null},{"line":3690,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":3691,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":3727,"address":[2179408,2179600,2179569],"length":1,"stats":{"Line":1},"fn_name":"is_empty"},{"line":3728,"address":[2179430,2179497],"length":1,"stats":{"Line":2},"fn_name":null},{"line":3765,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":3766,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":3835,"address":[2179829,2179798,2179616],"length":1,"stats":{"Line":1},"fn_name":"sample"},{"line":3836,"address":[2179726,2179659],"length":1,"stats":{"Line":2},"fn_name":null},{"line":3950,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":3951,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":4057,"address":[2180001,2179840,2180032],"length":1,"stats":{"Line":1},"fn_name":"ungroup"},{"line":4058,"address":[2179929,2179862],"length":1,"stats":{"Line":2},"fn_name":null},{"line":4157,"address":[2180048,2180256,2180287],"length":1,"stats":{"Line":1},"fn_name":"reduce"},{"line":4158,"address":[2180182,2180083],"length":1,"stats":{"Line":2},"fn_name":null},{"line":4227,"address":[2396448,2396475,2396208],"length":1,"stats":{"Line":1},"fn_name":"fold\u003c\u0026str\u003e"},{"line":4231,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":4382,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":4383,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":4486,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":4487,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":4591,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":4592,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":4752,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":4753,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":4913,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":4914,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":5013,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":5014,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":5142,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":5143,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":5256,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":5257,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":5367,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":5368,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":5524,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":5525,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":5571,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":5572,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":5618,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":5619,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":5665,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":5666,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":5713,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":5714,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":5761,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":5762,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":5809,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":5810,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":5858,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":5859,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":5938,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":5939,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":5987,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":5988,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":6036,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":6037,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":6192,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":6193,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":6235,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":6236,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":6278,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":6279,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":6431,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":6432,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":6474,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":6475,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":6519,"address":[2180465,2180304,2180496],"length":1,"stats":{"Line":1},"fn_name":"keys"},{"line":6520,"address":[2180326,2180393],"length":1,"stats":{"Line":2},"fn_name":null},{"line":6563,"address":[2180704,2180512,2180673],"length":1,"stats":{"Line":1},"fn_name":"values"},{"line":6564,"address":[2180601,2180534],"length":1,"stats":{"Line":2},"fn_name":null},{"line":6617,"address":[2180720,2180923,2180954],"length":1,"stats":{"Line":1},"fn_name":"match_"},{"line":6618,"address":[2180851,2180784],"length":1,"stats":{"Line":2},"fn_name":null},{"line":6785,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":6786,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":6826,"address":[2180976,2181168,2181137],"length":1,"stats":{"Line":0},"fn_name":"upcase"},{"line":6827,"address":[2180998,2181065],"length":1,"stats":{"Line":0},"fn_name":null},{"line":6867,"address":[2181184,2181345,2181376],"length":1,"stats":{"Line":0},"fn_name":"downcase"},{"line":6868,"address":[2181206,2181273],"length":1,"stats":{"Line":0},"fn_name":null},{"line":6942,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":6943,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":7044,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":7045,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":7113,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":7114,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":7182,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":7183,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":7254,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":7255,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":7326,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":7327,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":7398,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":7399,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":7470,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":7471,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":7542,"address":[2181392,2181557,2181588],"length":1,"stats":{"Line":1},"fn_name":"round"},{"line":7543,"address":[2181414,2181485],"length":1,"stats":{"Line":2},"fn_name":null},{"line":7610,"address":[2181796,2181600,2181765],"length":1,"stats":{"Line":1},"fn_name":"ceil"},{"line":7611,"address":[2181693,2181622],"length":1,"stats":{"Line":2},"fn_name":null},{"line":7678,"address":[2181973,2182004,2181808],"length":1,"stats":{"Line":1},"fn_name":"floor"},{"line":7679,"address":[2181901,2181830],"length":1,"stats":{"Line":2},"fn_name":null},{"line":7761,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":7762,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":7842,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":7843,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":7926,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":7927,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":7983,"address":[2182016,2182177,2182208],"length":1,"stats":{"Line":1},"fn_name":"bit_not"},{"line":7984,"address":[2182105,2182038],"length":1,"stats":{"Line":2},"fn_name":null},{"line":8050,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":8051,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":8112,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":8113,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":8165,"address":[2182465,2182496,2182224],"length":1,"stats":{"Line":0},"fn_name":"in_timezone"},{"line":8166,"address":[2182281,2182393],"length":1,"stats":{"Line":0},"fn_name":null},{"line":8202,"address":[2182512,2182704,2182673],"length":1,"stats":{"Line":0},"fn_name":"timezone"},{"line":8203,"address":[2182534,2182601],"length":1,"stats":{"Line":0},"fn_name":null},{"line":8282,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":8283,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":8348,"address":[2182912,2182720,2182881],"length":1,"stats":{"Line":0},"fn_name":"date"},{"line":8349,"address":[2182809,2182742],"length":1,"stats":{"Line":0},"fn_name":null},{"line":8386,"address":[2183089,2183120,2182928],"length":1,"stats":{"Line":0},"fn_name":"time_of_day"},{"line":8387,"address":[2182950,2183017],"length":1,"stats":{"Line":0},"fn_name":null},{"line":8422,"address":[2183297,2183328,2183136],"length":1,"stats":{"Line":0},"fn_name":"year"},{"line":8423,"address":[2183158,2183225],"length":1,"stats":{"Line":0},"fn_name":null},{"line":8458,"address":[2183536,2183344,2183505],"length":1,"stats":{"Line":0},"fn_name":"month"},{"line":8459,"address":[2183366,2183433],"length":1,"stats":{"Line":0},"fn_name":null},{"line":8494,"address":[2183552,2183744,2183713],"length":1,"stats":{"Line":0},"fn_name":"day"},{"line":8495,"address":[2183641,2183574],"length":1,"stats":{"Line":0},"fn_name":null},{"line":8555,"address":[2183921,2183760,2183952],"length":1,"stats":{"Line":0},"fn_name":"day_of_week"},{"line":8556,"address":[2183782,2183849],"length":1,"stats":{"Line":0},"fn_name":null},{"line":8592,"address":[2183968,2184160,2184129],"length":1,"stats":{"Line":0},"fn_name":"day_of_year"},{"line":8593,"address":[2184057,2183990],"length":1,"stats":{"Line":0},"fn_name":null},{"line":8629,"address":[2184368,2184176,2184337],"length":1,"stats":{"Line":0},"fn_name":"hours"},{"line":8630,"address":[2184265,2184198],"length":1,"stats":{"Line":0},"fn_name":null},{"line":8666,"address":[2184384,2184545,2184576],"length":1,"stats":{"Line":0},"fn_name":"minutes"},{"line":8667,"address":[2184406,2184473],"length":1,"stats":{"Line":0},"fn_name":null},{"line":8703,"address":[2184592,2184784,2184753],"length":1,"stats":{"Line":0},"fn_name":"seconds"},{"line":8704,"address":[2184614,2184681],"length":1,"stats":{"Line":0},"fn_name":null},{"line":8743,"address":[2184992,2184961,2184800],"length":1,"stats":{"Line":0},"fn_name":"to_iso8601"},{"line":8744,"address":[2184889,2184822],"length":1,"stats":{"Line":0},"fn_name":null},{"line":8784,"address":[2185008,2185200,2185169],"length":1,"stats":{"Line":0},"fn_name":"to_epoch_time"},{"line":8785,"address":[2185097,2185030],"length":1,"stats":{"Line":0},"fn_name":null},{"line":8789,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":8790,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":8919,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":8920,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":8965,"address":[2185455,2185216,2185424],"length":1,"stats":{"Line":1},"fn_name":"for_each"},{"line":8966,"address":[2185350,2185251],"length":1,"stats":{"Line":2},"fn_name":null},{"line":9116,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":9117,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":9190,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":9191,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":9236,"address":[2185472,2185633,2185664],"length":1,"stats":{"Line":1},"fn_name":"type_of"},{"line":9237,"address":[2185494,2185561],"length":1,"stats":{"Line":2},"fn_name":null},{"line":9276,"address":[2185872,2185680,2185841],"length":1,"stats":{"Line":1},"fn_name":"info"},{"line":9277,"address":[2185769,2185702],"length":1,"stats":{"Line":2},"fn_name":null},{"line":9312,"address":[2186049,2186080,2185888],"length":1,"stats":{"Line":1},"fn_name":"to_json"},{"line":9313,"address":[2185977,2185910],"length":1,"stats":{"Line":2},"fn_name":null},{"line":9376,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":9377,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":9424,"address":[2186257,2186096,2186288],"length":1,"stats":{"Line":1},"fn_name":"to_geojson"},{"line":9425,"address":[2186118,2186185],"length":1,"stats":{"Line":2},"fn_name":null},{"line":9482,"address":[2408936,2408963,2408704],"length":1,"stats":{"Line":1},"fn_name":"get_intersecting\u003creql_rust::cmd::polygon::Polygon\u003e"},{"line":9487,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":9544,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":9545,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":9655,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":9656,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":9739,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":9740,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":9889,"address":[2186304,2186538,2186569],"length":1,"stats":{"Line":1},"fn_name":"grant"},{"line":9890,"address":[2186381,2186466],"length":1,"stats":{"Line":2},"fn_name":null},{"line":9940,"address":[2186592,2186784,2186753],"length":1,"stats":{"Line":1},"fn_name":"config"},{"line":9941,"address":[2186614,2186681],"length":1,"stats":{"Line":2},"fn_name":null},{"line":10012,"address":[2186800,2186961,2186992],"length":1,"stats":{"Line":1},"fn_name":"rebalance"},{"line":10013,"address":[2186822,2186889],"length":1,"stats":{"Line":2},"fn_name":null},{"line":10151,"address":[2187008,2187250,2187281],"length":1,"stats":{"Line":1},"fn_name":"reconfigure"},{"line":10152,"address":[2187030,2187176],"length":1,"stats":{"Line":2},"fn_name":null},{"line":10198,"address":[2187296,2187457,2187488],"length":1,"stats":{"Line":1},"fn_name":"status"},{"line":10199,"address":[2187318,2187385],"length":1,"stats":{"Line":2},"fn_name":null},{"line":10285,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":10286,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":10429,"address":[1487040,1487412,1486752,1487114,1486801],"length":1,"stats":{"Line":8},"fn_name":"{async_fn#0}\u003creql_rust::arguments::Args\u003c(\u0026reql_rust::connection::Session, reql_rust::cmd::run::RunOption)\u003e\u003e"},{"line":10430,"address":[1487423,1487238,1487306,1487593,1486967,1487061],"length":1,"stats":{"Line":14},"fn_name":null},{"line":10515,"address":[1488368],"length":1,"stats":{"Line":5},"fn_name":"make_query\u003creql_rust::arguments::Args\u003c(\u0026reql_rust::connection::Session, reql_rust::cmd::run::RunOption)\u003e\u003e"},{"line":10516,"address":[1488610,1488386],"length":1,"stats":{"Line":10},"fn_name":null},{"line":10526,"address":[2007048,2006640,2007079],"length":1,"stats":{"Line":1},"fn_name":"add_to_cmd"},{"line":10527,"address":[2006667],"length":1,"stats":{"Line":1},"fn_name":null},{"line":10528,"address":[2006705,2007046],"length":1,"stats":{"Line":2},"fn_name":null},{"line":10529,"address":[2006967,2006845],"length":1,"stats":{"Line":4},"fn_name":null},{"line":10535,"address":[2801472],"length":1,"stats":{"Line":1},"fn_name":"from"},{"line":10536,"address":[2801594,2801494],"length":1,"stats":{"Line":2},"fn_name":null},{"line":10537,"address":[2801548],"length":1,"stats":{"Line":1},"fn_name":null},{"line":10539,"address":[2801601],"length":1,"stats":{"Line":0},"fn_name":null},{"line":10545,"address":[2007104],"length":1,"stats":{"Line":0},"fn_name":"bytes_to_string"},{"line":10546,"address":[2007131],"length":1,"stats":{"Line":0},"fn_name":null},{"line":10547,"address":[2007191],"length":1,"stats":{"Line":0},"fn_name":null},{"line":10549,"address":[2007201],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":217,"coverable":274},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","connection.rs"],"content":"use dashmap::DashMap;\nuse futures::channel::mpsc::{self, UnboundedReceiver, UnboundedSender};\nuse futures::lock::Mutex;\nuse futures::TryFutureExt;\nuse ql2::query::QueryType;\nuse ql2::response::ResponseType;\nuse serde_json::json;\nuse std::borrow::Cow;\nuse std::ops::Drop;\nuse std::sync::atomic::{AtomicBool, AtomicU64, Ordering};\nuse std::sync::Arc;\nuse tokio::time;\nuse tracing::trace;\n\nuse super::cmd::run::Response;\nuse super::cmd::StaticString;\nuse crate::cmd::TcpStreamConnection;\nuse crate::proto::{Payload, Query};\nuse crate::types::ServerInfoResponse;\nuse crate::{err, r, ReqlDriverError, Result};\n\ntype Sender = UnboundedSender\u003cResult\u003c(ResponseType, Response)\u003e\u003e;\ntype Receiver = UnboundedReceiver\u003cResult\u003c(ResponseType, Response)\u003e\u003e;\n\n#[derive(Debug)]\npub(crate) struct InnerSession {\n    pub(crate) db: Mutex\u003cCow\u003c'static, str\u003e\u003e,\n    pub(crate) stream: Mutex\u003cTcpStreamConnection\u003e,\n    pub(crate) channels: DashMap\u003cu64, Sender\u003e,\n    pub(crate) token: AtomicU64,\n    pub(crate) broken: AtomicBool,\n    pub(crate) change_feed: AtomicBool,\n}\n\nimpl InnerSession {\n    pub(crate) fn token(\u0026self) -\u003e u64 {\n        let token = self\n            .token\n            .fetch_update(Ordering::SeqCst, Ordering::SeqCst, |x| Some(x + 1))\n            .unwrap();\n        if token == u64::MAX {\n            self.mark_broken();\n        }\n        token\n    }\n\n    pub(crate) fn mark_broken(\u0026self) {\n        self.broken.store(true, Ordering::SeqCst);\n    }\n\n    pub(crate) fn broken(\u0026self) -\u003e Result\u003c()\u003e {\n        if self.broken.load(Ordering::SeqCst) {\n            return Err(err::ReqlDriverError::ConnectionBroken.into());\n        }\n        Ok(())\n    }\n\n    pub(crate) fn mark_change_feed(\u0026self) {\n        self.change_feed.store(true, Ordering::SeqCst);\n    }\n\n    pub(crate) fn unmark_change_feed(\u0026self) {\n        self.change_feed.store(false, Ordering::SeqCst);\n    }\n\n    pub(crate) fn is_change_feed(\u0026self) -\u003e bool {\n        self.change_feed.load(Ordering::SeqCst)\n    }\n\n    pub(crate) fn change_feed(\u0026self) -\u003e Result\u003c()\u003e {\n        if self.change_feed.load(Ordering::SeqCst) {\n            return Err(err::ReqlDriverError::ConnectionLocked.into());\n        }\n        Ok(())\n    }\n}\n\n/// The connection object returned by `r.connection()`\n#[derive(Debug, Clone)]\npub struct Session {\n    pub(crate) inner: Arc\u003cInnerSession\u003e,\n}\n\nimpl Session {\n    #[doc(hidden)]\n    pub fn connection(\u0026self) -\u003e Result\u003cConnection\u003e {\n        self.inner.broken()?;\n        self.inner.change_feed()?;\n        let token = self.inner.token();\n        let (tx, rx) = mpsc::unbounded();\n        self.inner.channels.insert(token, tx);\n        Ok(Connection::new(self.clone(), rx, token))\n    }\n\n    /// Close and reopen a connection.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// conn.reconnect(noreply_wait, timeout)\n    /// ```\n    ///\n    /// Where\n    /// - noreply_wait: bool\n    /// - timeout: Option\u003c[Duration](std::time::Duration)\u003e\n    ///\n    /// # Description\n    ///\n    /// Closing a connection normally waits until all outstanding requests have\n    /// finished and then frees any open resources associated with the connection.\n    /// By passing `false` to the `noreply_wait` optional argument,\n    /// the connection will be closed immediately,\n    /// possibly aborting any outstanding noreply writes.\n    ///\n    /// A noreply query is executed by passing the `noreply`\n    /// option to the [run](crate::Command::run) command,\n    /// indicating that `run()` should not wait for the query to complete before returning.\n    /// You may also explicitly wait for a noreply query to complete by using\n    /// the [noreply_wait](Self::noreply_wait) command.\n    ///\n    /// ## Examples\n    ///\n    /// Cancel outstanding requests/queries that are no longer needed.\n    ///\n    /// ```\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let mut conn = r.connection().connect().await?;\n    ///     conn.reconnect(true, None).await?;\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [connection](crate::r::connection)\n    /// - [use_](Self::use_)\n    /// - [close](Self::close)\n    pub async fn reconnect(\n        \u0026self,\n        noreply_wait: bool,\n        timeout: Option\u003cstd::time::Duration\u003e,\n    ) -\u003e Result\u003c()\u003e {\n        let future = self\n            .close(noreply_wait)\n            .and_then(|_| async { self.connection() });\n\n        if let Some(timeout) = timeout {\n            time::timeout(timeout, future).await.unwrap()?;\n        } else {\n            future.await?;\n        }\n\n        Ok(())\n    }\n\n    /// Change the default database on this connection.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// conn.use_(db_name)\n    /// ```\n    ///\n    /// Where\n    /// - db_name: \u0026'static str\n    ///\n    /// ## Examples\n    ///\n    /// Change the default database so that we don’t need\n    /// to specify the database when referencing a table.\n    ///\n    /// ```\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let mut conn = r.connection().connect().await?;\n    ///     conn.use_(\"simbad\").await?;\n    ///     \n    ///     r.table(\"simbad\").run(\u0026conn).await?;\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [connection](crate::r::connection)\n    /// - [close](Self::close)\n    /// - [reconnect](Self::reconnect)\n    pub async fn use_(\u0026mut self, db_name: \u0026'static str) -\u003e Result\u003c()\u003e {\n        *self.inner.db.lock().await = db_name.static_string();\n\n        Ok(())\n    }\n\n    /// `noreply_wait` ensures that previous queries with\n    /// the `noreply` flag have been processed by the server.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// result.close()\n    /// ```\n    ///\n    /// ## Note\n    ///\n    /// Note that this guarantee only applies to queries run on the given connection.\n    ///\n    /// ## Examples\n    ///\n    /// We have previously run queries with the `noreply` argument set to `true`.\n    /// Now wait until the server has processed them.\n    ///\n    /// ```\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     \n    ///     conn.noreply_wait().await?;\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [run](crate::Command::run)\n    /// - [sync](crate::Command::sync)\n    pub async fn noreply_wait(\u0026self) -\u003e Result\u003c()\u003e {\n        let mut conn = self.connection()?;\n        let payload = Payload(QueryType::NoreplyWait, None, Default::default());\n        trace!(\n            \"waiting for noreply operations to finish; token: {}\",\n            conn.token\n        );\n        let (typ, _) = conn.request(\u0026payload, false).await?;\n        trace!(\n            \"session.noreply_wait() run; token: {}, response type: {:?}\",\n            conn.token,\n            typ,\n        );\n        Ok(())\n    }\n\n    /// Return information about the server being used by a connection.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// result.server() -\u003e response\n    /// ```\n    ///\n    /// Where:\n    /// - server: [ServerInfoResponse](crate::types::ServerInfoResponse)\n    ///\n    /// ## Examples\n    ///\n    /// Return server information.\n    ///\n    /// ```\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::types::ServerInfoResponse;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: ServerInfoResponse = conn.server().await?;\n    ///\n    ///     assert_eq!(response.id.to_string(), \"404bef53-4b2c-433f-9184-bc3f7bda4a15\");\n    ///     assert_eq!(response.name, Some(\"amadeus\".to_string()));\n    ///     assert_eq!(response.proxy, false);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    pub async fn server(\u0026self) -\u003e Result\u003cServerInfoResponse\u003e {\n        let mut conn = self.connection()?;\n        let payload = Payload(QueryType::ServerInfo, None, Default::default());\n        trace!(\"retrieving server information; token: {}\", conn.token);\n        let (typ, resp) = conn.request(\u0026payload, false).await?;\n        trace!(\n            \"session.server() run; token: {}, response type: {:?}\",\n            conn.token,\n            typ,\n        );\n        let mut vec = serde_json::from_value::\u003cVec\u003cServerInfoResponse\u003e\u003e(resp.r)?;\n        let info = vec\n            .pop()\n            .ok_or_else(|| ReqlDriverError::Other(\"server info is empty\".into()))?;\n        Ok(info)\n    }\n\n    /// Close a cursor.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// result.close()\n    /// ```\n    ///\n    /// # Description\n    ///\n    /// Closing a result cancels the corresponding query and\n    /// frees the memory associated with the open request.\n    ///\n    /// ## Examples\n    ///\n    /// Close a result.\n    ///\n    /// ```\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     \n    ///     conn.close(false).await?;\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    pub async fn close(\u0026self, noreply_wait: bool) -\u003e Result\u003c()\u003e {\n        self.connection()?.close(noreply_wait).await\n    }\n\n    #[doc(hidden)]\n    pub fn is_broken(\u0026self) -\u003e bool {\n        self.inner.broken.load(Ordering::SeqCst)\n    }\n}\n\n#[derive(Debug, Clone)]\npub struct Connection {\n    pub(crate) session: Session,\n    pub(crate) rx: Arc\u003cMutex\u003cReceiver\u003e\u003e,\n    pub(crate) token: u64,\n    pub(crate) closed: Arc\u003cAtomicBool\u003e,\n}\n\nimpl Connection {\n    fn new(session: Session, rx: Receiver, token: u64) -\u003e Connection {\n        Connection {\n            session,\n            token,\n            rx: Arc::new(Mutex::new(rx)),\n            closed: Arc::new(AtomicBool::new(false)),\n        }\n    }\n\n    pub async fn close(\u0026mut self, noreply_wait: bool) -\u003e Result\u003c()\u003e {\n        if !self.session.inner.is_change_feed() {\n            trace!(\n                \"ignoring conn.close() called on a normal connection; token: {}\",\n                self.token\n            );\n            return Ok(());\n        }\n\n        self.set_closed(true);\n\n        let arg = if noreply_wait {\n            Some(r.expr(json!({ \"noreply\": false })))\n        } else {\n            None\n        };\n\n        let payload = Payload(QueryType::Stop, arg.as_ref().map(Query), Default::default());\n        trace!(\"closing a changefeed; token: {}\", self.token);\n        let (typ, _) = self.request(\u0026payload, false).await?;\n        self.session.inner.unmark_change_feed();\n        trace!(\n            \"conn.close() run; token: {}, response type: {:?}\",\n            self.token,\n            typ,\n        );\n        Ok(())\n    }\n\n    pub(crate) fn closed(\u0026self) -\u003e bool {\n        self.closed.load(Ordering::SeqCst)\n    }\n\n    pub(crate) fn set_closed(\u0026self, closed: bool) {\n        self.closed.store(closed, Ordering::SeqCst);\n    }\n}\n\nimpl Drop for Connection {\n    fn drop(\u0026mut self) {\n        self.session.inner.channels.remove(\u0026self.token);\n        if self.session.inner.is_change_feed() {\n            self.session.inner.unmark_change_feed();\n        }\n    }\n}\n","traces":[{"line":36,"address":[2460512],"length":1,"stats":{"Line":5},"fn_name":"token"},{"line":37,"address":[2460526,2460543],"length":1,"stats":{"Line":10},"fn_name":null},{"line":39,"address":[2460533],"length":1,"stats":{"Line":25},"fn_name":null},{"line":41,"address":[2460607],"length":1,"stats":{"Line":10},"fn_name":null},{"line":42,"address":[2460627],"length":1,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[2460640],"length":1,"stats":{"Line":0},"fn_name":"mark_broken"},{"line":48,"address":[2460649],"length":1,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[2460688],"length":1,"stats":{"Line":5},"fn_name":"broken"},{"line":52,"address":[2460718],"length":1,"stats":{"Line":5},"fn_name":null},{"line":53,"address":[2460768],"length":1,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[2460759],"length":1,"stats":{"Line":5},"fn_name":null},{"line":58,"address":[2460832],"length":1,"stats":{"Line":0},"fn_name":"mark_change_feed"},{"line":59,"address":[2460841],"length":1,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[2460880],"length":1,"stats":{"Line":0},"fn_name":"unmark_change_feed"},{"line":63,"address":[2460889],"length":1,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[2460928],"length":1,"stats":{"Line":5},"fn_name":"is_change_feed"},{"line":67,"address":[2460937],"length":1,"stats":{"Line":5},"fn_name":null},{"line":70,"address":[2460992],"length":1,"stats":{"Line":5},"fn_name":"change_feed"},{"line":71,"address":[2461022],"length":1,"stats":{"Line":5},"fn_name":null},{"line":72,"address":[2461072],"length":1,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[2461063],"length":1,"stats":{"Line":5},"fn_name":null},{"line":86,"address":[2461948,2461136],"length":1,"stats":{"Line":5},"fn_name":"connection"},{"line":87,"address":[2461174,2461279],"length":1,"stats":{"Line":5},"fn_name":null},{"line":88,"address":[2461453,2461266,2461374],"length":1,"stats":{"Line":10},"fn_name":null},{"line":89,"address":[2461440,2461541],"length":1,"stats":{"Line":10},"fn_name":null},{"line":90,"address":[2461559],"length":1,"stats":{"Line":10},"fn_name":null},{"line":91,"address":[2461622,2461689],"length":1,"stats":{"Line":20},"fn_name":null},{"line":92,"address":[2461783],"length":1,"stats":{"Line":10},"fn_name":null},{"line":141,"address":[2462000],"length":1,"stats":{"Line":0},"fn_name":"reconnect"},{"line":193,"address":[2462171,2462144],"length":1,"stats":{"Line":0},"fn_name":"use_"},{"line":233,"address":[2462246,2462224],"length":1,"stats":{"Line":0},"fn_name":"noreply_wait"},{"line":280,"address":[2462288,2462310],"length":1,"stats":{"Line":0},"fn_name":"server"},{"line":328,"address":[2462388,2462352],"length":1,"stats":{"Line":0},"fn_name":"close"},{"line":333,"address":[2462448],"length":1,"stats":{"Line":0},"fn_name":"is_broken"},{"line":334,"address":[2462457],"length":1,"stats":{"Line":0},"fn_name":null},{"line":347,"address":[2462528,2462833],"length":1,"stats":{"Line":10},"fn_name":"new"},{"line":351,"address":[2462592,2462649],"length":1,"stats":{"Line":20},"fn_name":null},{"line":352,"address":[2462735,2462682],"length":1,"stats":{"Line":20},"fn_name":null},{"line":356,"address":[2462901,2462864],"length":1,"stats":{"Line":0},"fn_name":"close"},{"line":385,"address":[2462960],"length":1,"stats":{"Line":1},"fn_name":"closed"},{"line":386,"address":[2462969],"length":1,"stats":{"Line":1},"fn_name":null},{"line":389,"address":[2463024],"length":1,"stats":{"Line":0},"fn_name":"set_closed"},{"line":390,"address":[2463046],"length":1,"stats":{"Line":0},"fn_name":null},{"line":395,"address":[2606976],"length":1,"stats":{"Line":5},"fn_name":"drop"},{"line":396,"address":[2606990],"length":1,"stats":{"Line":5},"fn_name":null},{"line":397,"address":[2607049],"length":1,"stats":{"Line":5},"fn_name":null},{"line":398,"address":[2607095],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":27,"coverable":47},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","constants.rs"],"content":"pub(crate) const BUFFER_SIZE: usize = 1024;\npub(crate) const NULL_BYTE: u8 = b'\\0';\npub(crate) const PROTOCOL_VERSION: usize = 0;\npub(crate) const DEFAULT_AUTHENTICATION_METHOD: \u0026str = \"SCRAM-SHA-256\";\npub(crate) const DATA_SIZE: usize = 4;\npub(crate) const TOKEN_SIZE: usize = 8;\npub(crate) const HEADER_SIZE: usize = DATA_SIZE + TOKEN_SIZE;\npub(crate) const NANOS_PER_SEC: i128 = 1_000_000_000;\npub(crate) const NANOS_PER_MSEC: i128 = 1_000_000;\npub(crate) const TIMEZONE_FORMAT: \u0026str = \"[offset_hour sign:mandatory]:[offset_minute]\";\npub(crate) const MINUTE: f64 = 60.;\npub(crate) const HOUR: f64 = 60. * MINUTE;\n\npub const DEFAULT_RETHINKDB_HOSTNAME: \u0026str = \"localhost\";\npub const DEFAULT_RETHINKDB_DBNAME: \u0026str = \"test\";\npub const DEFAULT_RETHINKDB_PORT: u16 = 28015;\npub const DEFAULT_RETHINKDB_USER: \u0026str = \"admin\";\npub const DEFAULT_RETHINKDB_PASSWORD: \u0026str = \"\";\npub const MAX_LONGITUDE_VALUE: f64 = 180.;\npub const MAX_LATITUDE_VALUE: f64 = 90.;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","err.rs"],"content":"use std::sync::Arc;\nuse std::{error, fmt, io};\n\n/// The most generic error message in ReQL\n#[derive(Debug, Clone)]\npub enum ReqlError {\n    Compile(String),\n    Runtime(ReqlRuntimeError),\n    Driver(ReqlDriverError),\n}\n\nimpl error::Error for ReqlError {}\n\nimpl fmt::Display for ReqlError {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        match self {\n            Self::Compile(msg) =\u003e write!(f, \"compile error; {}\", msg),\n            Self::Runtime(msg) =\u003e write!(f, \"runtime error; {}\", msg),\n            Self::Driver(msg) =\u003e write!(f, \"client error; {}\", msg),\n        }\n    }\n}\n\n/// The parent class of all runtime errors\n///\n/// All errors on the server unrelated to compilation. Programs may use this to catch any runtime\n/// error, but the server will always return a more specific error class.\n#[derive(Debug, Clone)]\npub enum ReqlRuntimeError {\n    /// The query contains a logical impossibility, such as adding a number to a string.\n    QueryLogic(String),\n    NonExistence(String),\n    ResourceLimit(String),\n    User(String),\n    Internal(String),\n    Availability(ReqlAvailabilityError),\n    Permission(String),\n}\n\nimpl From\u003cReqlRuntimeError\u003e for ReqlError {\n    fn from(err: ReqlRuntimeError) -\u003e ReqlError {\n        ReqlError::Runtime(err)\n    }\n}\n\nimpl fmt::Display for ReqlRuntimeError {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        match self {\n            Self::QueryLogic(msg) =\u003e write!(f, \"query logic; {}\", msg),\n            Self::NonExistence(msg) =\u003e write!(f, \"non-existence error; {}\", msg),\n            Self::ResourceLimit(msg) =\u003e write!(f, \"resource limit error; {}\", msg),\n            Self::User(msg) =\u003e write!(f, \"user error; {}\", msg),\n            Self::Internal(msg) =\u003e write!(f, \"internal error; {}\", msg),\n            Self::Availability(msg) =\u003e write!(f, \"availability error; {}\", msg),\n            Self::Permission(msg) =\u003e write!(f, \"permission error; {}\", msg),\n        }\n    }\n}\n\n/// A server in the cluster is unavailable\n///\n/// The parent class of `OpFailedError` and `OpIndeterminateError`. Programs may use this\n/// to catch any availability error, but the server will always return one of this class’s\n/// children.\n#[derive(Debug, Clone)]\npub enum ReqlAvailabilityError {\n    OpFailed(String),\n    OpIndeterminate(String),\n}\n\nimpl From\u003cReqlAvailabilityError\u003e for ReqlError {\n    fn from(err: ReqlAvailabilityError) -\u003e ReqlError {\n        ReqlRuntimeError::Availability(err).into()\n    }\n}\n\nimpl fmt::Display for ReqlAvailabilityError {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        match self {\n            Self::OpFailed(msg) =\u003e write!(f, \"operation failed; {}\", msg),\n            Self::OpIndeterminate(msg) =\u003e write!(f, \"operation indeterminate; {}\", msg),\n        }\n    }\n}\n\n/// An error has occurred within the driver\n///\n/// This may be a driver bug, or it may be an unfulfillable command, such as an unserializable\n/// query.\n#[derive(Debug, Clone)]\n#[non_exhaustive]\npub enum ReqlDriverError {\n    Auth(String),\n    ConnectionBroken,\n    ConnectionLocked,\n    Io(io::ErrorKind, String),\n    Json(Arc\u003cserde_json::Error\u003e),\n    Other(String),\n    Time(String),\n    Tls(String),\n    Regex(String),\n}\n\nimpl From\u003cReqlDriverError\u003e for ReqlError {\n    fn from(err: ReqlDriverError) -\u003e ReqlError {\n        ReqlError::Driver(err)\n    }\n}\n\nimpl fmt::Display for ReqlDriverError {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        match self {\n            Self::Auth(msg) =\u003e write!(f, \"auth error; {}\", msg),\n            Self::ConnectionBroken =\u003e write!(f, \"connection broken\"),\n            Self::ConnectionLocked =\u003e write!(\n                f,\n                \"another query is running a changefeed on this connection\"\n            ),\n            Self::Io(_, error) =\u003e write!(f, \"{}\", error),\n            Self::Json(error) =\u003e write!(f, \"{}\", error),\n            Self::Other(msg) =\u003e write!(f, \"{}\", msg),\n            Self::Time(error) =\u003e write!(f, \"{}\", error),\n            Self::Tls(error) =\u003e write!(f, \"{}\", error),\n            Self::Regex(error) =\u003e write!(f, \"{}\", error),\n        }\n    }\n}\n\nimpl From\u003cio::Error\u003e for ReqlError {\n    fn from(err: io::Error) -\u003e ReqlError {\n        ReqlDriverError::Io(err.kind(), err.to_string()).into()\n    }\n}\n\nimpl From\u003cserde_json::Error\u003e for ReqlError {\n    fn from(err: serde_json::Error) -\u003e ReqlError {\n        ReqlDriverError::Json(Arc::new(err)).into()\n    }\n}\n\nimpl From\u003casync_native_tls::Error\u003e for ReqlError {\n    fn from(err: async_native_tls::Error) -\u003e Self {\n        ReqlDriverError::Tls(err.to_string()).into()\n    }\n}\n\nimpl From\u003ctime::error::ComponentRange\u003e for ReqlError {\n    fn from(err: time::error::ComponentRange) -\u003e Self {\n        ReqlDriverError::Time(err.to_string()).into()\n    }\n}\n\nimpl From\u003ctime::error::Parse\u003e for ReqlError {\n    fn from(err: time::error::Parse) -\u003e Self {\n        ReqlDriverError::Time(err.to_string()).into()\n    }\n}\n\nimpl From\u003ctime::error::InvalidFormatDescription\u003e for ReqlError {\n    fn from(err: time::error::InvalidFormatDescription) -\u003e Self {\n        ReqlDriverError::Time(err.to_string()).into()\n    }\n}\n\nimpl From\u003ctime::error::Format\u003e for ReqlError {\n    fn from(err: time::error::Format) -\u003e Self {\n        ReqlDriverError::Time(err.to_string()).into()\n    }\n}\n\nimpl From\u003cregex::Error\u003e for ReqlError {\n    fn from(err: regex::Error) -\u003e Self {\n        ReqlDriverError::Regex(err.to_string()).into()\n    }\n}\n","traces":[{"line":15,"address":[2007552],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":16,"address":[2007585],"length":1,"stats":{"Line":0},"fn_name":null},{"line":17,"address":[2007947,2007622],"length":1,"stats":{"Line":0},"fn_name":null},{"line":18,"address":[2007662,2007857],"length":1,"stats":{"Line":0},"fn_name":null},{"line":19,"address":[2007708],"length":1,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[2008032],"length":1,"stats":{"Line":1},"fn_name":"from"},{"line":42,"address":[2008045],"length":1,"stats":{"Line":1},"fn_name":null},{"line":47,"address":[2008112],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":48,"address":[2008145],"length":1,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[2008187,2009095],"length":1,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[2008233,2008999],"length":1,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[2008903,2008279],"length":1,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[2008807,2008325],"length":1,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[2008371,2008711],"length":1,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[2008618,2008417],"length":1,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[2008463],"length":1,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[2009184],"length":1,"stats":{"Line":0},"fn_name":"from"},{"line":73,"address":[2009196],"length":1,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[2009312],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":79,"address":[2009345],"length":1,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[2009364,2009553],"length":1,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[2009404],"length":1,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[2009632],"length":1,"stats":{"Line":0},"fn_name":"from"},{"line":106,"address":[2009639],"length":1,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[2009728],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":112,"address":[2009761],"length":1,"stats":{"Line":0},"fn_name":null},{"line":113,"address":[2010861,2009803],"length":1,"stats":{"Line":0},"fn_name":null},{"line":114,"address":[2009844,2010823],"length":1,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[2010790,2009886],"length":1,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[2010699,2009933],"length":1,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[2009979,2010603],"length":1,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[2010507,2010025],"length":1,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[2010071,2010411],"length":1,"stats":{"Line":0},"fn_name":null},{"line":123,"address":[2010117,2010318],"length":1,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[2010163],"length":1,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[2010960,2011113],"length":1,"stats":{"Line":0},"fn_name":"from"},{"line":131,"address":[2010983,2011026],"length":1,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[2011152],"length":1,"stats":{"Line":0},"fn_name":"from"},{"line":137,"address":[2011182],"length":1,"stats":{"Line":0},"fn_name":null},{"line":142,"address":[2011374,2011248],"length":1,"stats":{"Line":0},"fn_name":"from"},{"line":143,"address":[2011320,2011267],"length":1,"stats":{"Line":0},"fn_name":null},{"line":148,"address":[2011408],"length":1,"stats":{"Line":0},"fn_name":"from"},{"line":149,"address":[2011421],"length":1,"stats":{"Line":0},"fn_name":null},{"line":154,"address":[2011504],"length":1,"stats":{"Line":0},"fn_name":"from"},{"line":155,"address":[2011517],"length":1,"stats":{"Line":0},"fn_name":null},{"line":160,"address":[2011600,2011726],"length":1,"stats":{"Line":0},"fn_name":"from"},{"line":161,"address":[2011672,2011619],"length":1,"stats":{"Line":0},"fn_name":null},{"line":166,"address":[2011760,2011886],"length":1,"stats":{"Line":0},"fn_name":"from"},{"line":167,"address":[2011779,2011832],"length":1,"stats":{"Line":0},"fn_name":null},{"line":172,"address":[2012046,2011920],"length":1,"stats":{"Line":0},"fn_name":"from"},{"line":173,"address":[2011992,2011939],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":2,"coverable":51},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","lib.rs"],"content":"use std::collections::HashMap;\n\nuse prelude::Func;\nuse serde::Serialize;\n\nuse arguments::Permission;\npub use connection::*;\npub use err::*;\npub use proto::Command;\nuse types::{Binary, DateTime, GeoJson};\n\npub type Result\u003cT\u003e = std::result::Result\u003cT, ReqlError\u003e;\n\nmod constants;\nmod err;\nmod proto;\n#[cfg(test)]\nmod spec;\n\npub mod arguments;\npub mod cmd;\npub mod connection;\npub mod prelude;\npub mod types;\n\n#[macro_export]\nmacro_rules! args {\n    ( $($a:expr),* ) =\u003e {{ $crate::arguments::Args(($($a),*)) }};\n}\n\n#[allow(non_camel_case_types)]\npub struct r;\n\nimpl r {\n    /// Create a new connection to the database server.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// db.db_drop(db_name) → response\n    /// ```\n    ///\n    /// Where:\n    /// - db_name: \u0026str | String | Cow\u003c'static, str\u003e\n    /// - response: [DbResponse](crate::types::DbResponse)\n    ///\n    /// # Description\n    ///\n    /// If the connection cannot be established, a `ReqlDriverError` exception will be thrown.\n    ///\n    /// ## Examples\n    ///\n    /// Open a connection using the default host and port, specifying the default database.\n    ///\n    /// ```\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::types::DbResponse;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().dbname(\"jam\").connect().await?;\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Open a new connection to the database.\n    ///\n    /// ```\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::types::DbResponse;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection()\n    ///         .dbname(\"jam\")\n    ///         .host(\"localhost\")\n    ///         .port(28015)\n    ///         .connect()\n    ///         .await?;\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Open a new connection to the database,\n    /// specifying a user/password combination for authentication.\n    ///\n    /// ```\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::types::DbResponse;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection()\n    ///         .dbname(\"jam\")\n    ///         .host(\"localhost\")\n    ///         .port(28015)\n    ///         .user(\"jam_user\", \"jam_password\")\n    ///         .connect()\n    ///         .await?;\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [use_](crate::connection::Session::use_)\n    /// - [close](crate::connection::Session::close)\n    pub fn connection(self) -\u003e cmd::connect::ConnectionCommand {\n        cmd::connect::ConnectionCommand::default()\n    }\n\n    /// Create a database.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// db.db_drop(db_name) → response\n    /// ```\n    ///\n    /// Where:\n    /// - db_name: \u0026str | String | Cow\u003c'static, str\u003e\n    /// - response: [DbResponse](crate::types::DbResponse)\n    ///\n    /// # Description\n    ///\n    /// A RethinkDB database is a collection of tables, similar to relational databases.\n    ///\n    /// If a database with the same name already exists, the command throws `ReqlRuntimeError`.\n    ///\n    /// ## Note\n    ///\n    /// Only alphanumeric characters, hyphens and underscores are valid for the database name.\n    ///\n    /// ## Examples\n    ///\n    /// Create a database named ‘simbad’.\n    ///\n    /// ```\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::types::DbResponse;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: DbResponse = r.db_create(\"simbad\")\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert_eq!(response.dbs_created, Some(1));\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [db_drop](Self::db_drop)\n    /// - [db_list](Self::db_list)\n    /// - [table_create](Self::table_create)\n    pub fn db_create(self, db_name: impl Into\u003cString\u003e) -\u003e Command {\n        cmd::db_create::new(db_name)\n    }\n\n    /// Drop a database.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// db.db_drop(db_name) → response\n    /// ```\n    ///\n    /// Where:\n    /// - db_name: \u0026str | String | Cow\u003c'static, str\u003e\n    /// - response: [DbResponse](crate::types::DbResponse)\n    ///\n    /// # Description\n    ///\n    /// The database, all its tables, and corresponding data will be deleted.\n    ///\n    /// If the given database does not exist, the command throws `ReqlRuntimeError`.\n    ///\n    /// ## Examples\n    ///\n    /// Drop a database named ‘simbad’.\n    ///\n    /// ```\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::types::DbResponse;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: DbResponse = r.db_drop(\"simbad\")\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert_eq!(response.dbs_dropped, Some(1));\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [db_create](Self::db_create)\n    /// - [db_list](Self::db_list)\n    /// - [table_create](Self::table_create)\n    pub fn db_drop(self, db_name: impl Into\u003cString\u003e) -\u003e Command {\n        cmd::db_drop::new(db_name)\n    }\n\n    /// List all database names in the system.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// db.db_list() → response\n    /// ```\n    ///\n    /// Where:\n    /// - response: Vec\u003cString\u003e\n    ///\n    /// ## Examples\n    ///\n    /// List all databases.\n    ///\n    /// ```\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: Vec\u003cString\u003e = r.db_list().run(\u0026conn).await?.unwrap().parse()?;\n    ///\n    ///     assert!(response.len() \u003e 0);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [db_create](Self::db_create)\n    /// - [db_drop](Self::db_drop)\n    pub fn db_list(self) -\u003e Command {\n        cmd::db_list::new()\n    }\n\n    /// Reference a database.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// r.db(db_name) → db\n    /// ```\n    ///\n    /// Where:\n    /// - db_name: impl Into\u003cString\u003e\n    ///\n    /// # Description\n    ///\n    /// The `db` command is optional. If it is not present in a query,\n    /// the query will run against the database specified in the `db`\n    /// argument given to [run](crate::Command::run) if one was specified.\n    /// Otherwise, the query will run against the default database for the connection,\n    /// specified in the `db` argument to [connection](Self::connection).\n    ///\n    /// ## Examples\n    ///\n    /// Explicitly specify a database for a query.\n    ///\n    /// ```\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.db(\"heroes\").table(\"simbad\").run(\u0026conn).await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [table](crate::Command::table)\n    /// - [db_list](Self::db_list)\n    pub fn db(self, db_name: impl Into\u003cString\u003e) -\u003e Command {\n        cmd::db::new(db_name)\n    }\n\n    /// Create a table.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// db.table_create(table_name) → response\n    /// db.table_create(args!(table_name, options)) → response\n    /// ```\n    ///\n    /// Where:\n    /// - table_name: \u0026str | String | Cow\u003c'static, str\u003e\n    /// - options: [TableCreateOption](crate::cmd::table_create::TableCreateOption)\n    /// - response: [DbResponse](crate::types::DbResponse)\n    ///\n    /// # Description\n    ///\n    /// A RethinkDB table is a collection of JSON documents.\n    ///\n    /// If a table with the same name already exists,\n    /// the command throws `ReqlOpFailedError`.\n    ///\n    /// ```text\n    /// Note: Only alphanumeric characters and underscores are valid for the table name.\n    ///\n    /// Invoking table_create without specifying a database using db creates a table in\n    /// the database specified in connect, or test if no database was specified.\n    /// ```\n    ///\n    /// The [data type](https://rethinkdb.com/docs/data-types/) of a primary key is usually a string\n    /// (like a UUID) or a number, but it can also be a time, binary object, boolean or an array.\n    /// Data types can be mixed in the primary key field, but all values must be unique. Using an array\n    /// as a primary key causes the primary key to behave like a compound index; read the documentation on\n    /// [compound secondary indexes](https://rethinkdb.com/docs/secondary-indexes/python/#compound-indexes)\n    /// for more information, as it applies to primary keys as well.\n    /// (Note that the primary index still only covers a single field,\n    /// while compound secondary indexes can cover multiple fields in a single index.)\n    /// Primary keys cannot be objects.\n    ///\n    /// Tables will be available for writing when the command returns.\n    ///\n    /// ## Examples\n    ///\n    /// Create a table named ‘simbad’ with the default settings.\n    ///\n    /// ```\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::types::DbResponse;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: DbResponse = r.db(\"test\")\n    ///         .table_create(\"simbad\")\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response.tables_created \u003e Some(0));\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Create a table named ‘simbad’ using the field ‘name’ as primary key.\n    ///\n    /// ```\n    /// use reql_rust::cmd::table_create::TableCreateOption;\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::types::DbResponse;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let table_create_option = TableCreateOption::default().primary_key(\"name\");\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: DbResponse = r.db(\"test\")\n    ///         .table_create(args!(\"simbad\", table_create_option))\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response.tables_created \u003e Some(0));\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Create a table set up for two shards and three replicas per shard.\n    /// This requires three available servers.\n    ///\n    /// ```\n    /// use reql_rust::arguments::Replicas;\n    /// use reql_rust::cmd::table_create::TableCreateOption;\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::types::DbResponse;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let table_create_option = TableCreateOption::default()\n    ///         .shards(2)\n    ///         .replicas(Replicas::Int(3));\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: DbResponse = r.db(\"test\")\n    ///         .table_create(args!(\"simbad\", table_create_option))\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response.tables_created \u003e Some(0));\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// Read [Sharding and replication](https://rethinkdb.com/docs/sharding-and-replication/)\n    /// for a complete discussion of the subject, including advanced topics.\n    ///\n    /// # Related commands\n    /// - [table_drop](Self::table_drop)\n    /// - [table_list](Self::table_list)\n    pub fn table_create(self, args: impl cmd::table_create::TableCreateArg) -\u003e Command {\n        cmd::table_create::new(args)\n    }\n\n    /// Drop a table.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// db.table_drop(table_name) → response\n    /// ```\n    ///\n    /// Where:\n    /// - table_name: \u0026str | String | Cow\u003c'static, str\u003e\n    /// - response: [DbResponse](crate::types::DbResponse)\n    ///\n    /// # Description\n    ///\n    /// The table and all its data will be deleted.\n    ///\n    /// If the given table does not exist in the database,\n    /// the command throws `ReqlRuntimeError`.\n    ///\n    /// ## Examples\n    ///\n    /// Drop a table named ‘simbad’.\n    ///\n    /// ```\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::types::DbResponse;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: DbResponse = r.db(\"test\")\n    ///         .table_drop(\"simbad\")\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response.tables_dropped \u003e Some(0));\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [table_create](Self::table_create)\n    /// - [table_list](Self::table_list)\n    pub fn table_drop(self, table_name: \u0026str) -\u003e Command {\n        cmd::table_drop::new(table_name)\n    }\n\n    /// List all table names in a database.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// db.table_list() → response\n    /// ```\n    ///\n    /// Where:\n    /// - response: Vec\u003cString\u003e\n    ///\n    /// ## Examples\n    ///\n    /// List all tables of the ‘test’ database.\n    ///\n    /// ```\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: Vec\u003cString\u003e = r.db(\"test\")\n    ///         .table_list()\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response.len() \u003e 0);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [table_create](Self::table_create)\n    /// - [table_drop](Self::table_drop)\n    pub fn table_list(self) -\u003e Command {\n        cmd::table_list::new()\n    }\n\n    /// Return all documents in a table.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// db.table(name) → table\n    /// db.table(args!(name, options)) → table\n    /// r.table(name) → table\n    /// r.table(args!(name, options)) → table\n    /// ```\n    ///\n    /// Where:\n    /// - name: impl Into\u003cString\u003e | [Command](crate::Command)\n    /// - options: [TableOption](crate::cmd::table::TableOption)\n    ///\n    /// # Description\n    ///\n    /// Other commands may be chained after `table` to return a subset of documents\n    /// (such as [get](crate::Command::get) and [filter](crate::Command::filter))\n    /// or perform further processing.\n    ///\n    /// ## Examples\n    ///\n    /// Return all documents in the table ‘simbad’ of the default database.\n    ///\n    /// ```\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"simbad\").run(\u0026conn).await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Return all documents in the table ‘simbad’ of the database ‘heroes’.\n    ///\n    /// ```\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.db(\"heroes\").table(\"simbad\").run(\u0026conn).await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Allow potentially out-of-date data in exchange for faster reads.\n    ///\n    /// ```\n    /// use reql_rust::cmd::table::TableOption;\n    /// use reql_rust::arguments::ReadMode;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let table_option = TableOption::default().read_mode(ReadMode::Outdated);\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.db(\"heroes\").table(args!(\"simbad\", table_option)).run(\u0026conn).await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [filter](crate::Command::filter)\n    /// - [get](crate::Command::get)\n    pub fn table(self, args: impl cmd::table::TableArg) -\u003e Command {\n        cmd::table::new(args)\n    }\n\n    /// Transform each element of one or more sequences\n    /// by applying a mapping function to them.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// sequence.map(func) → stream\n    /// sequence.map(sequence, func) → stream\n    /// sequence.map(sequences, func) → stream\n    /// r.map(sequence, func) → stream\n    /// r.map(sequence, sequence, func) → stream\n    /// r.map(sequence, sequences, func) → stream\n    /// ```\n    ///\n    /// Where:\n    /// - func: func!(...)\n    /// - sequence: [Command](crate::Command)\n    /// - sequences: [...] | \u0026[...] | vec![...]\n    ///\n    /// # Description\n    ///\n    /// If `map` is run with two or more sequences, it will iterate\n    /// for as many items as there are in the shortest sequence.\n    ///\n    /// Note that `map` can only be applied to sequences, not single values.\n    /// If you wish to apply a function to a single value/selection (including an array),\n    /// use the [do_](Self::do_) command.\n    ///\n    /// ## Examples\n    ///\n    /// Return the first five squares.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: Vec\u003cu8\u003e = r.expr([1, 2, 3, 4, 5])\n    ///         .map(func!(|val| val.clone() * val))\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert_eq!(response, [1, 4, 9, 16, 25]);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Sum the elements of three sequences.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let sequence1 = r.expr([100, 200, 300, 400]);\n    ///     let sequence2 = r.expr([10, 20, 30, 40]);\n    ///     let sequence3 = r.expr([1, 2, 3, 4]);\n    ///\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: Vec\u003cu32\u003e = r.map(sequence1, args!(\n    ///             [sequence2, sequence3],\n    ///             func!(|val1, val2, val3| val1 + val2 + val3)\n    ///         ))\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert_eq!(response, [111, 222, 333, 444]);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Rename a field when retrieving documents\n    /// using `map` and [merge](crate::Command::merge).\n    ///\n    /// This example renames the field `id` to `user_id`\n    /// when retrieving documents from the table `users`.\n    ///\n    /// ```\n    /// use std::collections::HashMap;\n    ///\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"users\")\n    ///         .map(func!(|doc| {\n    ///             let mut user = HashMap::new();\n    ///             user.insert(\"user_id\", doc.clone().g(\"id\"));\n    ///             \n    ///             doc.merge(r.hash_map(user)).without(\"id\")\n    ///         }))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Assign every superhero an archenemy.\n    ///\n    /// ```\n    /// use std::collections::HashMap;\n    ///\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"heroes\")\n    ///         .map(args!(r.table(\"villains\"), func!(|hero, villain| {\n    ///             let mut villain_obj = HashMap::new();\n    ///             villain_obj.insert(\"villain\", villain);\n    ///\n    ///             hero.merge(r.hash_map(villain_obj))\n    ///         })))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [concat_map](crate::Command::concat_map)\n    /// - [reduce](Self::reduce)\n    /// - [do_](Self::do_)\n    pub fn map(self, sequence: Command, args: impl cmd::map::MapArg) -\u003e Command {\n        sequence.map(args)\n    }\n\n    // TODO write Doc\n    pub fn order_by(self, args: impl cmd::order_by::OrderByArg) -\u003e Command {\n        cmd::order_by::new(args)\n    }\n\n    /// Merge two or more sequences.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// stream.union(sequence) → stream\n    /// stream.union(vec![sequence]) → stream\n    /// stream.union(args!(sequence, options)) → stream\n    /// stream.union(args!(vec![sequence], options)) → stream\n    /// ```\n    ///\n    /// Where:\n    /// - sequence: [Command](crate::Command)\n    /// - options: [UnionOption](crate::cmd::union::UnionOption)\n    ///\n    /// ## Examples\n    ///\n    /// Construct a stream of all characters.\n    ///\n    /// ```\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"simbad\")\n    ///         .union(r.table(\"kirikou\"))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    pub fn union(self, stream: Command, args: impl cmd::union::UnionArg) -\u003e Command {\n        stream.union(args)\n    }\n\n    /// Takes a stream and partitions it into multiple\n    /// groups based on the fields or functions provided.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// sequence.group(field) → grouped_stream\n    /// sequence.group(func) → grouped_stream\n    /// sequence.group(args!(field, options)) → grouped_stream\n    /// sequence.group(args!(func, options)) → grouped_stream\n    /// r.group(sequence, field) → grouped_stream\n    /// r.group(sequence, func) → grouped_stream\n    /// r.group(sequence, args!(field, options)) → grouped_stream\n    /// r.group(sequence, args!(func, options)) → grouped_stream\n    /// ```\n    ///\n    /// Where:\n    /// - field: \u0026str | [\u0026str; N]\n    /// - func: func!(...) | [func!(...); N]\n    /// - grouped_stream: [GroupedStream](crate::types::GroupedStream)\n    /// - sequence: [Command](crate::Command)\n    ///\n    /// # Description\n    ///\n    /// With the `multi` flag single documents can be assigned to multiple groups,\n    /// similar to the behavior of\n    /// [multi-indexes](https://rethinkdb.com/docs/secondary-indexes/javascript).\n    /// When `multi` is `true` and the grouping value is an array, documents\n    /// will be placed in each group that corresponds to the elements of the array.\n    /// If the array is empty the row will be ignored.\n    ///\n    /// Suppose that the table games has the following data:\n    ///\n    /// ```text\n    /// [\n    ///     {id: 2, player: \"Moussa\", points: 15, class: \"ranked\"},\n    ///     {id: 5, player: \"Fatou\", points: 7, class: \"free\"},\n    ///     {id: 11, player: \"Moussa\", points: 10, class: \"free\"},\n    ///     {id: 12, player: \"Fatou\", points: 2, class: \"free\"}\n    /// ]\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Group games by player.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::types::{GroupedItem, GroupedStream};\n    /// use reql_rust::{args, r, Result};\n    /// use serde::{Serialize, Deserialize};\n    ///\n    /// #[derive(Serialize, Deserialize, PartialEq, Eq)]\n    /// struct Player {\n    ///     id: u8,\n    ///     player: String,\n    ///     points: u8,\n    ///     class: String,\n    /// }\n    ///\n    /// impl Player {\n    ///     fn new(id: u8, player: \u0026str, points: u8, class: \u0026str) -\u003e Self {\n    ///         Self {\n    ///             id,\n    ///             points,\n    ///             player: player.to_owned(),\n    ///             class: class.to_owned(),\n    ///         }\n    ///     }\n    /// }\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let expected_data = vec![\n    ///         GroupedItem {\n    ///             group: String::from(\"Fatou\"),\n    ///             values: vec![\n    ///                 Player::new(5, \"Fatou\", 7, \"free\"),\n    ///                 Player::new(12, \"Fatou\", 2, \"free\"),\n    ///             ]\n    ///         },\n    ///         GroupedItem {\n    ///             group: String::from(\"Moussa\"),\n    ///             values: vec![\n    ///                 Player::new(2, \"Moussa\", 15, \"ranked\"),\n    ///                 Player::new(11, \"Moussa\", 10, \"free\"),\n    ///             ]\n    ///         },\n    ///     ];\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: GroupedStream\u003cString, Player\u003e = r.table(\"games\")\n    ///         .group(\"player\")\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response.collect() == expected_data);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [ungroup](crate::Command::ungroup)\n    /// - [map](Self::map)\n    /// - [reduce](Self::reduce)\n    /// - [count](Self::count)\n    /// - [sum](Self::sum)\n    /// - [avg](Self::avg)\n    /// - [min](Self::min)\n    /// - [max](Self::max)\n    pub fn group(self, sequence: Command, args: impl cmd::group::GroupArg) -\u003e Command {\n        sequence.group(args)\n    }\n\n    /// Produce a single value from a sequence through\n    /// repeated application of a reduction function.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// sequence.fold(base, func) → value\n    /// ```\n    ///\n    /// Where:\n    /// - base, value: impl Serialize\n    /// - func: func!(...)\n    /// - sequence: [Command](crate::Command)\n    ///\n    /// # Description\n    ///\n    /// The reduction function can be called on:\n    ///\n    /// - two elements of the sequence\n    /// - one element of the sequence and one result of a previous reduction\n    /// - two results of previous reductions\n    ///\n    /// The reduction function can be called on the results of\n    /// two previous reductions because the `reduce` command is\n    /// distributed and parallelized across shards and CPU cores.\n    /// A common mistaken when using the `reduce` command is to\n    /// suppose that the reduction is executed from left to right.\n    /// [Read the map-reduce in RethinkDB](https://rethinkdb.com/docs/map-reduce/)\n    /// article to see an example.\n    ///\n    /// If the sequence is empty, the server will produce a\n    /// `ReqlRuntimeError` that can be caught with default.\n    /// If the sequence has only one element, the first element will be returned.\n    ///\n    /// ## Examples\n    ///\n    /// Return the number of documents in the table posts.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"posts\")\n    ///         .map(func!(|| r.expr(1)))\n    ///         .reduce(func!(|left, right| left + right))\n    ///         .default(0)\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// A shorter way to execute this query is to use [count](Self::count).\n    ///\n    /// ## Examples\n    ///\n    /// Suppose that each `post` has a field `comments` that is an array of comments.\n    /// Return the maximum number comments per post.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"posts\")\n    ///         .map(func!(|post| post.g(\"comments\").count(())))\n    ///         .reduce(func!(|left, right| r.branch(\n    ///             left.clone().gt(right.clone()),\n    ///             args!(left, right)\n    ///         )))\n    ///         .default(0)\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// A shorter way to execute this query is to use [max](Self::max).\n    ///\n    /// # Related commands\n    /// - [group](crate::Command::group)\n    /// - [map](Self::map)\n    /// - [concat_map](crate::Command::concat_map)\n    /// - [sum](Self::sum)\n    /// - [avg](Self::avg)\n    /// - [min](Self::min)\n    /// - [max](Self::max)\n    pub fn reduce(self, sequence: Command, func: Func) -\u003e Command {\n        sequence.reduce(func)\n    }\n\n    /// Count the number of elements in sequence or key/value pairs in an object,\n    /// or returns the size of a string or binary object.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// binary.count(()) → number\n    /// string.count(()) → number\n    /// object.count(()) → number\n    /// sequence.count(()) → number\n    /// sequence.count(args!(value)) → number\n    /// sequence.count(func) → number\n    /// r.count(query_cmd) → number\n    /// r.count(query_cmd, args!(value)) → number\n    /// r.count(query_cmd, func) → number\n    /// ```\n    ///\n    /// Where:\n    /// - value: impl Serialize\n    /// - func: func!(...)\n    /// - sequence, binary, string, object, query_cmd: [Command](crate::Command)\n    ///\n    /// # Description\n    ///\n    /// When `count` is called on a sequence with a predicate value or function,\n    /// it returns the number of elements in the sequence equal to that value or\n    /// where the function returns `true`. On a [binary](Self::binary) object, `count`\n    /// returns the size of the object in bytes; on strings, `count` returns the string’s length.\n    /// This is determined by counting the number of Unicode codepoints in the string,\n    /// counting combining codepoints separately.\n    ///\n    /// ## Examples\n    ///\n    /// Count the number of users.\n    ///\n    /// ```\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"users\")\n    ///         .count(())\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Count the number of 18 year old users.\n    ///\n    /// ```\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"users\")\n    ///         .g(\"age\")\n    ///         .count(args!(18))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Count the number of users over 18.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"users\")\n    ///         .g(\"age\")\n    ///         .count(func!(|age| age.gt(18)))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Return the length of a Unicode string.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: usize = r.expr(\"こんにちは\")\n    ///         .count(())\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == 5);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Return the length of an array.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: usize = r.expr(['0','1','2'])\n    ///         .count(())\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == 3);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [map](Self::map)\n    /// - [reduce](Self::reduce)\n    /// - [sum](Self::sum)\n    /// - [avg](Self::avg)\n    /// - [min](Self::min)\n    /// - [max](Self::max)\n    /// - [group](crate::Command::group)\n    pub fn count(self, query: Command, args: impl cmd::count::CountArg) -\u003e Command {\n        query.count(args)\n    }\n\n    /// Sum all the elements of sequence.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// sequence.sum(()) → number\n    /// sequence.sum(field) → number\n    /// sequence.sum(func) → number\n    /// r.sum(sequence) → number\n    /// r.sum(sequence, field) → number\n    /// r.sum(sequence, func) → number\n    /// ```\n    ///\n    /// Where:\n    /// - field: \u0026str, String, Cow\u003c'static, str\u003e\n    /// - func: func!(...)\n    /// - sequence: [Command](crate::Command)\n    ///\n    /// # Description\n    ///\n    /// If called with a field name, sums all the values of that field in\n    /// the sequence, skipping elements of the sequence that lack that field.\n    /// If called with a function, calls that function on every element of the\n    /// sequence and sums the results, skipping elements of the sequence\n    /// where that function returns `None` or non-existence error.\n    ///\n    /// Returns `0` when called on an empty sequence.\n    ///\n    /// ## Examples\n    ///\n    /// What's 3 + 5 + 7?\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: u8 = r.expr([3, 5, 7])\n    ///         .sum(())\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == 15);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// How many points have been scored across all games?\n    ///\n    /// ```\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"games\")\n    ///         .sum(\"points\")\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// How many points have been scored across all games, counting bonus points?\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"games\")\n    ///         .sum(func!(|game| game.clone().g(\"points\") + game.g(\"bonus_points\")))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [map](Self::map)\n    /// - [reduce](Self::reduce)\n    /// - [count](Self::count)\n    /// - [avg](Self::avg)\n    /// - [min](Self::min)\n    /// - [max](Self::max)\n    /// - [group](crate::Command::group)\n    pub fn sum(self, sequence: Command, args: impl cmd::sum::SumArg) -\u003e Command {\n        sequence.sum(args)\n    }\n\n    /// Averages all the elements of sequence.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// sequence.avg(()) → Option\u003cf64\u003e\n    /// sequence.avg(field) → Option\u003cf64\u003e\n    /// sequence.avg(func) → Option\u003cf64\u003e\n    /// r.avg(sequence) → Option\u003cf64\u003e\n    /// r.avg(sequence, field) → Option\u003cf64\u003e\n    /// r.avg(sequence, func) → Option\u003cf64\u003e\n    /// ```\n    ///\n    /// Where:\n    /// - field: \u0026str, String, Cow\u003c'static, str\u003e\n    /// - func: func!(...)\n    /// - sequence: [Command](crate::Command)\n    ///\n    /// # Description\n    ///\n    /// If called with a field name, averages all the values of that field in\n    /// the sequence, skipping elements of the sequence that lack that field.\n    /// If called with a function, calls that function on every element of the\n    /// sequence and averages the results, skipping elements of the sequence\n    /// where that function returns `None` or non-existence error.\n    ///\n    /// Produces a non-existence error when called on an empty sequence.\n    /// You can handle this case with `default`.\n    ///\n    /// ## Examples\n    ///\n    /// What's the average of 3, 5 and 7?\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: Option\u003cf64\u003e = r.expr([3, 5, 7])\n    ///         .avg(())\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == Some(5.));\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// What's the average number of points scored in a games?\n    ///\n    /// ```\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"games\")\n    ///         .avg(\"points\")\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// What's the average number of points scored in a games, counting bonus points?\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"games\")\n    ///         .avg(func!(|game| game.clone().g(\"points\") + game.g(\"bonus_points\")))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [map](Self::map)\n    /// - [reduce](Self::reduce)\n    /// - [count](Self::count)\n    /// - [sum](Self::sum)\n    /// - [min](Self::min)\n    /// - [max](Self::max)\n    /// - [group](crate::Command::group)\n    pub fn avg(self, sequence: Command, args: impl cmd::avg::AvgArg) -\u003e Command {\n        sequence.avg(args)\n    }\n\n    /// Finds the minimum element of a sequence.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// sequence.min(()) → element\n    /// sequence.min(args!(field)) → element\n    /// sequence.min(func) → element\n    /// sequence.min(options) → element\n    /// r.min(sequence) → element\n    /// r.min(sequence, args!(field)) → element\n    /// r.min(sequence, func) → element\n    /// r.min(sequence, options) → element\n    /// ```\n    ///\n    /// Where:\n    /// - field: \u0026str, String, Cow\u003c'static, str\u003e\n    /// - func: func!(...)\n    /// - options: [MinOption](crate::cmd::min::MinOption)\n    /// - sequence: [Command](crate::Command)\n    ///\n    /// # Description\n    ///\n    /// The `min` command can be called with:\n    /// - a `field name`, to return the element of the sequence\n    /// with the largest value in that field;\n    /// - a `function`, to apply the function to every element within the sequence\n    /// and return the element which returns the largest value from the function,\n    /// ignoring any elements where the function produces a non-existence error;\n    /// - an `index` (the primary key or a secondary index), to return the element\n    /// of the sequence with the largest value in that index;\n    ///\n    /// For more information on RethinkDB’s sorting order, read the section in\n    /// [ReQL data types](https://rethinkdb.com/docs/data-types/#sorting-order).\n    ///\n    /// Calling `min` on an empty sequence will throw a non-existence error;\n    /// this can be handled using the [default](crate::Command::default) command.\n    ///\n    /// ## Examples\n    ///\n    /// Return the minimum value in the list [3, 5, 7].\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: u8 = r.expr([3, 5, 7])\n    ///         .min(())\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == 3);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Return the user who has scored the fewest points.\n    ///\n    /// ```\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"users\")\n    ///         .min(args!(\"points\"))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// The same as above, but using a secondary index on the `points` field.\n    ///\n    /// ```\n    /// use reql_rust::cmd::min::MinOption;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"users\")\n    ///         .min(MinOption::default().index(\"points\"))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Return the user who has scored the fewest points,\n    /// adding in bonus points from a separate field using a function.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"users\")\n    ///         .min(func!(|user| user.clone().g(\"points\") + user.g(\"bonus_points\")))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Return the highest number of points any user has ever scored.\n    /// This returns the value of that `points` field, not a document.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: u8 = r.table(\"users\")\n    ///         .min(args!(\"points\"))\n    ///         .g(\"points\")\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == 2);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [map](Self::map)\n    /// - [reduce](Self::reduce)\n    /// - [count](Self::count)\n    /// - [sum](Self::sum)\n    /// - [avg](Self::avg)\n    /// - [max](Self::max)\n    /// - [group](crate::Command::group)\n    pub fn min(self, sequence: Command, args: impl cmd::min::MinArg) -\u003e Command {\n        sequence.min(args)\n    }\n\n    /// Finds the maximum element of a sequence.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// sequence.max(()) → element\n    /// sequence.max(args!(field)) → element\n    /// sequence.max(func) → element\n    /// sequence.max(options) → element\n    /// r.max(sequence) → element\n    /// r.max(sequence, args!(field)) → element\n    /// r.max(sequence, func) → element\n    /// r.max(sequence, options) → element\n    /// ```\n    ///\n    /// Where:\n    /// - field: \u0026str, String, Cow\u003c'static, str\u003e\n    /// - func: func!(...)\n    /// - options: [MaxOption](crate::cmd::max::MaxOption)\n    /// - sequence: [Command](crate::Command)\n    ///\n    /// # Description\n    ///\n    /// The `max` command can be called with:\n    /// - a `field name`, to return the element of the sequence\n    /// with the largest value in that field;\n    /// - a `function`, to apply the function to every element within the sequence\n    /// and return the element which returns the largest value from the function,\n    /// ignoring any elements where the function produces a non-existence error;\n    /// - an `index` (the primary key or a secondary index), to return the element\n    /// of the sequence with the largest value in that index;\n    ///\n    /// For more information on RethinkDB’s sorting order, read the section in\n    /// [ReQL data types](https://rethinkdb.com/docs/data-types/#sorting-order).\n    ///\n    /// Calling `max` on an empty sequence will throw a non-existence error;\n    /// this can be handled using the [default](crate::Command::default) command.\n    ///\n    /// ## Examples\n    ///\n    /// Return the maximum value in the list [3, 5, 7].\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: u8 = r.expr([3, 5, 7])\n    ///         .max(())\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == 7);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Return the user who has scored the most points.\n    ///\n    /// ```\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"users\")\n    ///         .max(args!(\"points\"))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// The same as above, but using a secondary index on the `points` field.\n    ///\n    /// ```\n    /// use reql_rust::cmd::max::MaxOption;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"users\")\n    ///         .max(MaxOption::default().index(\"points\"))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Return the user who has scored the most points,\n    /// adding in bonus points from a separate field using a function.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"users\")\n    ///         .max(func!(|user| user.clone().g(\"points\") + user.g(\"bonus_points\")))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Return the highest number of points any user has ever scored.\n    /// This returns the value of that `points` field, not a document.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: u8 = r.table(\"users\")\n    ///         .max(args!(\"points\"))\n    ///         .g(\"points\")\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == 15);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [map](Self::map)\n    /// - [reduce](Self::reduce)\n    /// - [count](Self::count)\n    /// - [sum](Self::sum)\n    /// - [avg](Self::avg)\n    /// - [min](Self::min)\n    /// - [group](crate::Command::group)\n    pub fn max(self, sequence: Command, args: impl cmd::max::MaxArg) -\u003e Command {\n        sequence.max(args)\n    }\n\n    /// Removes duplicate elements from a sequence.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// sequence.distinct(()) → array\n    /// table.distinct(options) → stream\n    /// r.distinct(sequence) → array\n    /// r.distinct(table, options) → stream\n    /// ```\n    ///\n    /// Where:\n    /// - options: [DistinctOption](crate::cmd::distinct::DistinctOption)\n    /// - sequence: [Command](crate::Command)\n    ///\n    /// # Description\n    ///\n    /// The `distinct` command can be called on any sequence or table with an index.\n    ///\n    /// ```text\n    /// While `distinct` can be called on a table without an index,\n    /// the only effect will be to convert the table into a stream;\n    /// the content of the stream will not be affected.\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Which unique villains have been vanquished by Marvel heroes?\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"marvel\")\n    ///         .concat_map(func!(|hero| hero.g(\"villain_list\")))\n    ///         .distinct(())\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Topics in a table of messages have a secondary index on them,\n    /// and more than one message can have the same topic.\n    /// What are the unique topics in the table?\n    ///\n    /// ```\n    /// use reql_rust::cmd::distinct::DistinctOption;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"messages\")\n    ///         .distinct(DistinctOption::default().index(\"topics\"))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// The above structure is functionally identical to:\n    ///\n    /// ```\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"messages\")\n    ///         .g(\"topics\")\n    ///         .distinct(())\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// However, the first form (passing the index as an argument to `distinct`) is faster,\n    /// and won’t run into array limit issues since it’s returning a stream.\n    ///\n    /// # Related commands\n    /// - [map](Self::map)\n    /// - [concat_map](crate::Command::concat_map)\n    /// - [group](crate::Command::group)\n    pub fn distinct(self, seq_or_table: Command, args: impl cmd::distinct::DistinctArg) -\u003e Command {\n        seq_or_table.distinct(args)\n    }\n\n    /// When called with values, returns `true`\n    /// if a sequence contains all the specified values.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// query.contains(value) → bool\n    /// r.contains(sequence, value) → bool\n    /// ```\n    ///\n    /// Where:\n    /// - value: impl Serialize | [Command](crate::Command)\n    /// - sequence: [Command](crate::Command)\n    ///\n    /// # Description\n    ///\n    /// When called with predicate functions, returns `true`\n    /// if for each predicate there exists at least one element\n    /// of the stream where that predicate returns `true`.\n    ///\n    /// Values and predicates may be mixed freely in the argument list.\n    ///\n    /// ## Examples\n    ///\n    /// Has Iron Man ever fought Superman?\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: bool = r.table(\"marvel\")\n    ///         .get(\"ironman\")\n    ///         .g(\"opponents\")\n    ///         .contains(\"superman\")\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Has Iron Man ever defeated Superman in battle?\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: bool = r.table(\"marvel\")\n    ///         .get(\"ironman\")\n    ///         .g(\"battles\")\n    ///         .contains(func!(|battle| battle.clone().g(\"winner\").eq(\"ironman\").and(\n    ///             battle.g(\"loser\").eq(\"superman\")\n    ///         )))\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Return all heroes who have fought both Loki and the Hulk.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: bool = r.table(\"marvel\")\n    ///         .filter(func!(|hero| hero.g(\"opponents\").contains([\"loki\", \"hulk\"])))\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Use contains with a predicate function to simulate an or.\n    /// Return the Marvel superheroes who live in Detroit, Chicago or Hoboken.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: bool = r.table(\"marvel\")\n    ///         .filter(func!(|hero| r.expr([\"Detroit\", \"Chicago\", \"Hoboken\"]).contains(hero.g(\"city\"))))\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [map](Self::map)\n    /// - [concat_map](crate::Command::concat_map)\n    /// - [group](crate::Command::group)\n    pub fn contains(self, sequence: Command, args: impl cmd::contains::ContainsArg) -\u003e Command {\n        sequence.contains(args)\n    }\n\n    /// TODO Write docs\n    pub fn literal(self, value: impl Serialize) -\u003e Command {\n        cmd::literal::new(value)\n    }\n\n    /// Creates an object from a list of key-value pairs,\n    /// where the keys must be strings.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// r.object(values) → object\n    /// ```\n    ///\n    /// Where:\n    /// - values: vec![...] | [...] | \u0026[...]\n    ///\n    /// ## Examples\n    ///\n    /// Create a simple object.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    /// use serde::{Deserialize, Serialize};\n    ///\n    /// #[derive(Debug, PartialEq, Eq, Serialize, Deserialize)]\n    /// struct Post {\n    ///     id: String,\n    ///     title: String,\n    /// }\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let post = Post {\n    ///         id: \"id1\".to_string(),\n    ///         title: \"title1\".to_string(),\n    ///     };\n    ///     let response: Post = r.object([\"id\", \"id1\", \"title\", \"title1\"])\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == post);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [coerce_to](crate::Command::coerce_to)\n    /// - [merge](crate::Command::merge)\n    /// - [keys](crate::Command::keys)\n    pub fn object\u003cS, T\u003e(self, values: T) -\u003e Command\n    where\n        S: Serialize,\n        T: IntoIterator\u003cItem = S\u003e,\n    {\n        cmd::object::new(values)\n    }\n\n    /// Compute the logical “and” of one or more values.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// cmd_value.and(value) → bool\n    /// cmd_value.and(args!(values)) → bool\n    /// r.and(args!(values)) → bool\n    /// ```\n    ///\n    /// Where:\n    /// - value: [Command](crate::Command) | bool\n    /// - values: [Command](crate::Command) | vec![...] | [...] | \u0026[...]\n    ///\n    /// # Description\n    ///\n    /// The `and` command can be used as an infix operator after its\n    /// first argument (`r.expr(true).and(false)`) or given all of\n    /// its arguments as parameters (`r.and(args!([true, false]))`).\n    ///\n    /// Calling `or` with zero arguments will return `false`.\n    ///\n    /// ## Examples\n    ///\n    /// Return whether either true or false evaluate to true.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: bool = r.expr(true)\n    ///         .or(false)\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == false);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Return whether any of true, true or true evaluate to true.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: bool = r.or(args!([true, true, true]))\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == true);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [eq](Self::eq)\n    /// - [ne](Self::ne)\n    /// - [or](Self::or)\n    pub fn and(self, args: impl cmd::and::AndArg) -\u003e Command {\n        cmd::and::new(args)\n    }\n\n    /// Compute the logical “or” of one or more values.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// cmd_value.or(value) → bool\n    /// cmd_value.or(args!(values)) → bool\n    /// r.or(args!(values)) → bool\n    /// ```\n    ///\n    /// Where:\n    /// - value: [Command](crate::Command) | bool\n    /// - values: [Command](crate::Command) | vec![...] | [...] | \u0026[...]\n    ///\n    /// # Description\n    ///\n    /// The `or` command can be used as an infix operator after\n    /// its first argument (`r.expr(true).or(false)`) or given all\n    /// of its arguments as parameters (`r.or(args!([true, false]))`).\n    ///\n    /// Calling `or` with zero arguments will return `false`.\n    ///\n    /// ## Examples\n    ///\n    /// Return whether either true or false evaluate to true.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: bool = r.expr(true)\n    ///         .or(false)\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == true);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Return whether any of false, false or false evaluate to false.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: bool = r.or(args!([false, false, false]))\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == false);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Note\n    ///\n    /// When using `or` inside a `filter` predicate to test the values of\n    /// fields that may not exist on the documents being tested,\n    /// you should use the `default` command with those fields so\n    /// they explicitly return `false`.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"table\")\n    ///         .filter(func!(|post| post.clone()\n    ///             .g(\"category\").default(\"foo\").eq(\"article\")\n    ///             .or(post.g(\"genre\").default(\"foo\").eq(\"mystery\"))\n    ///         ))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [eq](Self::eq)\n    /// - [ne](Self::ne)\n    /// - [and](Self::and)\n    pub fn or(self, args: impl cmd::or::OrArg) -\u003e Command {\n        cmd::or::new(args)\n    }\n\n    /// Test if two or more values are equal.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// cmd_value.eq(value) → bool\n    /// cmd_value.eq(args!(values)) → bool\n    /// r.eq(args!(values)) → bool\n    /// ```\n    ///\n    /// Where:\n    /// - value: [Command](crate::Command) | impl Serialize\n    /// - values: [Command](crate::Command) | vec![...] | [...] | \u0026[...]\n    ///\n    /// ## Examples\n    ///\n    /// See if a user’s `role` field is set to `administrator`.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: bool = r.table(\"users\")\n    ///         .get(1)\n    ///         .g(\"role\")\n    ///         .eq(\"administrator\")\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == true);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// See if three variables contain equal values.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: bool = r.eq(args!([20, 10, 15]))\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == true);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [ne](Self::ne)\n    /// - [and](Self::and)\n    /// - [or](Self::or)\n    pub fn eq(self, args: impl cmd::eq::EqArg) -\u003e Command {\n        cmd::eq::new(args)\n    }\n\n    /// Test if two or more values are not equal.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// cmd_value.ne(value) → bool\n    /// cmd_value.ne(args!(values)) → bool\n    /// r.ne(args!(values)) → bool\n    /// ```\n    ///\n    /// Where:\n    /// - value: [Command](crate::Command) | impl Serialize\n    /// - values: [Command](crate::Command) | vec![...] | [...] | \u0026[...]\n    ///\n    /// ## Examples\n    ///\n    /// See if a user’s `role` field is not set to `administrator`.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: bool = r.table(\"users\")\n    ///         .get(1)\n    ///         .g(\"role\")\n    ///         .ne(\"administrator\")\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == true);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// See if three variables do not contain equal values.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: bool = r.ne(args!([20, 10, 15]))\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == true);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [eq](Self::eq)\n    /// - [and](Self::and)\n    /// - [or](Self::or)\n    pub fn ne(self, args: impl cmd::ne::NeArg) -\u003e Command {\n        cmd::ne::new(args)\n    }\n\n    /// Compare values, testing if the left-hand value is greater than the right-hand.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// cmd_value.gt(value) → bool\n    /// cmd_value.gt(args!(values)) → bool\n    /// r.gt(args!(values)) → bool\n    /// ```\n    ///\n    /// Where:\n    /// - value: [Command](crate::Command) | impl Serialize\n    /// - values: [Command](crate::Command) | vec![...] | [...] | \u0026[...]\n    ///\n    /// ## Examples\n    ///\n    /// Test if a player has scored more than 10 points.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: bool = r.table(\"players\")\n    ///         .get(1)\n    ///         .g(\"score\")\n    ///         .gt(10)\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == true);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Test if variables are ordered from lowest to highest,\n    /// with no values being equal to one another.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: bool = r.gt(args!([20, 10, 15]))\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == true);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [eq](Self::eq)\n    /// - [ne](Self::ne)\n    /// - [ge](Self::ge)\n    /// - [lt](Self::lt)\n    /// - [le](Self::le)\n    pub fn gt(self, args: impl cmd::gt::GtArg) -\u003e Command {\n        cmd::gt::new(args)\n    }\n\n    /// Compare values, testing if the left-hand value is greater than the right-hand.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// cmd_value.ge(value) → bool\n    /// cmd_value.ge(args!(values)) → bool\n    /// r.ge(args!(values)) → bool\n    /// ```\n    ///\n    /// Where:\n    /// - value: [Command](crate::Command) | impl Serialize\n    /// - values: [Command](crate::Command) | vec![...] | [...] | \u0026[...]\n    ///\n    /// ## Examples\n    ///\n    /// Test if a player has scored more than 10 points.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: bool = r.table(\"players\")\n    ///         .get(1)\n    ///         .g(\"score\")\n    ///         .ge(10)\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == true);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Test if variables are ordered from lowest to highest,\n    /// with no values being equal to one another.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: bool = r.ge(args!([20, 10, 15]))\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == true);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [eq](Self::eq)\n    /// - [ne](Self::ne)\n    /// - [gt](Self::gt)\n    /// - [lt](Self::lt)\n    /// - [le](Self::le)\n    pub fn ge(self, args: impl cmd::ge::GeArg) -\u003e Command {\n        cmd::ge::new(args)\n    }\n\n    /// Compare values, testing if the left-hand value is less than the right-hand.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// cmd_value.lt(value) → bool\n    /// cmd_value.lt(args!(values)) → bool\n    /// r.lt(args!(values)) → bool\n    /// ```\n    ///\n    /// Where:\n    /// - value: [Command](crate::Command) | impl Serialize\n    /// - values: [Command](crate::Command) | vec![...] | [...] | \u0026[...]\n    ///\n    /// ## Examples\n    ///\n    /// Test if a player has scored less than 10 points.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: bool = r.table(\"players\")\n    ///         .get(1)\n    ///         .g(\"score\")\n    ///         .lt(10)\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == true);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Test if variables are ordered from highest to lowest,\n    /// with no values being equal to one another.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: bool = r.lt(args!([20, 10, 15]))\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == true);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [eq](Self::eq)\n    /// - [ne](Self::ne)\n    /// - [gt](Self::gt)\n    /// - [ge](Self::ge)\n    /// - [le](Self::le)\n    pub fn lt(self, args: impl cmd::lt::LtArg) -\u003e Command {\n        cmd::lt::new(args)\n    }\n\n    /// Compare values, testing if the left-hand value is\n    /// less than or equal to the right-hand.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// cmd_value.le(value) → bool\n    /// cmd_value.le(args!(values)) → bool\n    /// r.le(args!(values)) → bool\n    /// ```\n    ///\n    /// Where:\n    /// - value: [Command](crate::Command) | impl Serialize\n    /// - values: [Command](crate::Command) | vec![...] | [...] | \u0026[...]\n    ///\n    /// ## Examples\n    ///\n    /// Test if a player has scored 10 points or less.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: bool = r.table(\"players\")\n    ///         .get(1)\n    ///         .g(\"score\")\n    ///         .le(10)\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == true);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Test if variables are ordered from highest to lowest.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: bool = r.le(args!([20, 10, 15]))\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == true);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [eq](Self::eq)\n    /// - [ne](Self::ne)\n    /// - [gt](Self::gt)\n    /// - [ge](Self::ge)\n    /// - [lt](Self::lt)\n    pub fn le(self, args: impl cmd::le::LeArg) -\u003e Command {\n        cmd::le::new(args)\n    }\n\n    /// Compute the logical inverse (not) of an expression.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// !cmd_bool\n    /// cmd_bool.not() → bool\n    /// r.not(cmd_bool) → bool\n    /// ```\n    ///\n    /// Where:\n    /// - cmd_bool: [Command](crate::Command)\n    ///\n    /// # Description\n    ///\n    /// `not` can be called either via method chaining, immediately after\n    /// an expression that evaluates as a boolean value, or by passing\n    /// the expression as a parameter to `not`. All values that are not\n    /// `false` or `None` will be converted to `true`.\n    ///\n    /// ## Examples\n    ///\n    /// Not true is false.\n    ///\n    /// ```\n    /// use std::ops::Not;\n    ///\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: bool = r.expr(true)\n    ///         .not()\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     let response2: bool = r.not(r.expr(true))\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     let response3: bool = (!r.expr(true))\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(\n    ///         response == false \u0026\u0026\n    ///         response == response2 \u0026\u0026\n    ///         response == response3\n    ///     );\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [eq](Self::eq)\n    /// - [ne](Self::ne)\n    pub fn not(self, cmd_bool: Command) -\u003e Command {\n        !cmd_bool\n    }\n\n    /// Generate a random number between given (or implied) bounds.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// r.random(()) → number\n    /// r.round(param_number) → number\n    /// r.round(args!(param_number, param_number)) → number\n    /// r.round(args!(param_number, param_number, options)) → number\n    /// ```\n    ///\n    /// Where:\n    /// - param_number: f64 | [Command](crate::Command)\n    /// - cmd_number: [Command](crate::Command)\n    /// - options: [RandomOption](crate::cmd::random::RandomOption)\n    ///\n    /// # Description\n    ///\n    /// `random` takes zero, one or two arguments.\n    ///\n    /// - With *zero* arguments, the result will be a floating-point\n    /// number in the range `[0,1)` (from 0 up to but not including 1).\n    /// - With *one* argument x, the result will be in the range `[0,x)`, and will\n    /// be integer unless `RandomOption::default().float(true)` is given as an option.\n    /// Specifying a floating point number without the float option will raise an error.\n    /// - With *two* arguments x and y, the result will be in the range\n    /// `[x,y)`, and will be integer unless `RandomOption::default().float(true)` is given\n    /// as an option. If x and y are equal an error will occur, unless the floating-point\n    /// option has been specified, in which case x will be returned.\n    /// Specifying a floating point number without the float option will raise an error.\n    ///\n    /// ## Note\n    ///\n    /// The last argument given will always be the ‘open’ side of the range, but when\n    /// generating a floating-point number, the ‘open’ side may be less than the ‘closed’ side.\n    ///\n    /// ## Examples\n    ///\n    /// Generate a random number in the range `[0,1)`\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: u8 = r.random(())\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == 3);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Generate a random integer in the range `[0,100)`\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: u8 = r.random(100.)\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == 3);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Generate a random number in the range `(-2.24,1.59]`\n    ///\n    /// ```\n    /// use reql_rust::cmd::random::RandomOption;\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: f64 = r.random(args!(\n    ///             1.59, -2.24,\n    ///             RandomOption::default().float(true)\n    ///         ))\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == 0.);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [sample](crate::Command::sample)\n    pub fn random(self, args: impl cmd::random::RandomArg) -\u003e Command {\n        cmd::random::new(args)\n    }\n\n    /// Rounds the given value to the nearest whole integer.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// r.round(param_number) → number\n    /// cmd_number.round() → number\n    /// ```\n    ///\n    /// Where:\n    /// - param_number: f64 | [Command](crate::Command)\n    /// - cmd_number: [Command](crate::Command)\n    ///\n    /// # Description\n    ///\n    /// For example, values of 1.0 up to but not including 1.5\n    /// will return 1.0, similar to [floor](Self::floor); values\n    /// of 1.5 up to 2.0 will return 2.0, similar to [ceil](Self::ceil).\n    ///\n    /// ## Examples\n    ///\n    /// Round 12.345 to the nearest integer.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: i32 = r.round(12.345)\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == 12);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// The `round` command can also be chained after an expression.\n    ///\n    /// ## Examples\n    ///\n    /// Round -12.345 to the nearest integer.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: i32 = r.expr(-12.345)\n    ///         .round()\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == -12);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [ceil](Self::ceil)\n    /// - [round](Self::round)\n    pub fn round(self, args: impl cmd::round::RoundArg) -\u003e Command {\n        cmd::round::new(args)\n    }\n\n    /// Rounds the given value up, returning the smallest integer value\n    /// greater than or equal to the given value (the value’s ceiling).\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// r.ceil(param_number) → number\n    /// cmd_number.ceil() → number\n    /// ```\n    ///\n    /// Where:\n    /// - param_number: f64 | [Command](crate::Command)\n    /// - cmd_number: [Command](crate::Command)\n    ///\n    /// ## Examples\n    ///\n    /// Return the ceiling of 12.345.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: i32 = r.ceil(12.345)\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == 13);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// The `ceil` command can also be chained after an expression.\n    ///\n    /// ## Examples\n    ///\n    /// Return the ceiling of -12.345.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: i32 = r.expr(-12.345)\n    ///         .ceil()\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == -13);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [floor](Self::floor)\n    /// - [round](Self::round)\n    pub fn ceil(self, args: impl cmd::ceil::CeilArg) -\u003e Command {\n        cmd::ceil::new(args)\n    }\n\n    /// Rounds the given value down, returning the largest integer\n    /// value less than or equal to the given value (the value’s floor).\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// r.floor(param_number) → number\n    /// cmd_number.floor() → number\n    /// ```\n    ///\n    /// Where:\n    /// - param_number: f64 | [Command](crate::Command)\n    /// - cmd_number: [Command](crate::Command)\n    ///\n    /// ## Examples\n    ///\n    /// Return the floor of 12.345.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: i32 = r.floor(12.345)\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == 13);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// The `floor` command can also be chained after an expression.\n    ///\n    /// ## Examples\n    ///\n    /// Return the floor of -12.345.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: i32 = r.expr(-12.345)\n    ///         .floor()\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == -13);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [ceil](Self::ceil)\n    /// - [round](Self::round)\n    pub fn floor(self, args: impl cmd::floor::FloorArg) -\u003e Command {\n        cmd::floor::new(args)\n    }\n\n    /// Compute the arithmetic \"and\" of one or more values.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// cmd_number \u0026 cmd_number\n    /// number.bitand(cmd_number) → number\n    /// number.bit_and(param_number) → number\n    /// r.bit_and(cmd_number, param_number) → number\n    /// ```\n    ///\n    /// Where:\n    /// - param_number: i32 | [Command](crate::Command)\n    /// - cmd_number: [Command](crate::Command)\n    ///\n    /// # Description\n    ///\n    /// A bitwise AND is a binary operation that takes two equal-length binary\n    /// representations and performs the logical AND operation on each pair of\n    /// the corresponding bits, which is equivalent to multiplying them.\n    /// Thus, if both bits in the compared position are 1,\n    /// the bit in the resulting binary representation is 1 (1 × 1 = 1);\n    /// otherwise, the result is 0 (1 × 0 = 0 and 0 × 0 = 0).\n    ///\n    /// ## Examples\n    ///\n    /// Compute the arithmetic \"and\" of 5 and 3\n    ///\n    /// ```\n    /// use std::ops::BitAnd;\n    ///\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: i32 = r.expr(5)\n    ///         .bit_and(3)\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     let response2: i32 = r.bit_and(r.expr(5), 3)\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     let response3: i32 = (r.expr(5) \u0026 r.expr(3))\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     let response4: i32 = r.expr(5)\n    ///         .bitand(r.expr(3))\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(\n    ///         response == 1 \u0026\u0026\n    ///         response == response2 \u0026\u0026\n    ///         response == response3 \u0026\u0026\n    ///         response == response4\n    ///     );\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [bit_or](Self::bit_or)\n    /// - [bit_not](Self::bit_not)\n    /// - [bit_xor](Self::bit_xor)\n    /// - [bit_sal](Self::bit_sal)\n    /// - [bit_sar](Self::bit_sar)\n    pub fn bit_and(self, cmd_number: Command, args: impl cmd::bit_and::BitAndArg) -\u003e Command {\n        cmd_number.bit_and(args)\n    }\n\n    /// Compute the arithmetic \"or\" of one or more values.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// cmd_number | cmd_number\n    /// number.bitor(cmd_number) → number\n    /// number.bit_or(param_number) → number\n    /// r.bit_or(cmd_number, param_number) → number\n    /// ```\n    ///\n    /// Where:\n    /// - param_number: i32 | [Command](crate::Command)\n    /// - cmd_number: [Command](crate::Command)\n    ///\n    /// # Description\n    ///\n    /// A bitwise OR is a binary operation that takes two bit patterns\n    /// of equal length and performs the logical inclusive OR operation\n    /// on each pair of corresponding bits. The result in each position\n    /// is 0 if both bits are 0, while otherwise the result is 1.\n    ///\n    /// ## Examples\n    ///\n    /// Compute the arithmetic \"or\" of 6 and 4\n    ///\n    /// ```\n    /// use std::ops::BitOr;\n    ///\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: i32 = r.expr(5)\n    ///         .bit_or(3)\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     let response2: i32 = r.bit_xor(r.expr(5), 3)\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     let response3: i32 = (r.expr(5) ^ r.expr(3))\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     let response4: i32 = r.expr(5)\n    ///         .bitor(r.expr(3))\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(\n    ///         response == 7 \u0026\u0026\n    ///         response == response2 \u0026\u0026\n    ///         response == response3 \u0026\u0026\n    ///         response == response4\n    ///     );\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [bit_and](Self::bit_and)\n    /// - [bit_not](Self::bit_not)\n    /// - [bit_xor](Self::bit_xor)\n    /// - [bit_sal](Self::bit_sal)\n    /// - [bit_sar](Self::bit_sar)\n    pub fn bit_or(self, cmd_number: Command, args: impl cmd::bit_or::BitOrArg) -\u003e Command {\n        cmd_number.bit_or(args)\n    }\n\n    /// Compute the arithmetic \"and\" of one or more values.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// cmd_number ^ cmd_number\n    /// number.bitxor(cmd_number) → number\n    /// number.bit_xor(param_number) → number\n    /// r.bit_xor(cmd_number, param_number) → number\n    /// ```\n    ///\n    /// Where:\n    /// - param_number: i32 | [Command](crate::Command)\n    /// - cmd_number: [Command](crate::Command)\n    ///\n    /// # Description\n    ///\n    /// A bitwise XOR is a binary operation that takes two bit patterns\n    /// of equal length and performs the logical exclusive OR operation\n    /// on each pair of corresponding bits. The result in each position\n    /// is 1 if only the first bit is 1 or only the second bit is 1,\n    /// but will be 0 if both are 0 or both are 1.\n    /// In this we perform the comparison of two bits, being 1 if the\n    /// two bits are different, and 0 if they are the same.\n    ///\n    /// ## Examples\n    ///\n    /// Compute the arithmetic \"and\" of 6 and 4\n    ///\n    /// ```\n    /// use std::ops::BitXor;\n    ///\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: i32 = r.expr(6)\n    ///         .bit_xor(4)\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     let response2: i32 = r.bit_xor(r.expr(6), 4)\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     let response3: i32 = (r.expr(6) ^ r.expr(4))\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     let response4: i32 = r.expr(6)\n    ///         .bitxor(r.expr(4))\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(\n    ///         response == 2 \u0026\u0026\n    ///         response == response2 \u0026\u0026\n    ///         response == response3 \u0026\u0026\n    ///         response == response4\n    ///     );\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [bit_and](Self::bit_and)\n    /// - [bit_not](Self::bit_not)\n    /// - [bit_or](Self::bit_or)\n    /// - [bit_sal](Self::bit_sal)\n    /// - [bit_sar](Self::bit_sar)\n    pub fn bit_xor(self, cmd_number: Command, args: impl cmd::bit_xor::BitXorArg) -\u003e Command {\n        cmd_number.bit_xor(args)\n    }\n\n    /// Compute the arithmetic inverse (not) of an expression.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// number.bit_not() → number\n    /// r.bit_not(cmd_number) → number\n    /// ```\n    ///\n    /// Where:\n    /// - cmd_number: [Command](crate::Command)\n    ///\n    /// # Description\n    ///\n    /// A bitwise NOT, or complement, is a unary operation that performs logical\n    /// negation on each bit, forming the ones’ complement of the given binary value.\n    /// Bits that are 0 become 1, and those that are 1 become 0.\n    ///\n    /// ## Examples\n    ///\n    /// Negate the arithmetice expression\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: i32 = r.expr(7)\n    ///         .bit_not()\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     let response2: i32 = r.bit_not(r.expr(7))\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == -8 \u0026\u0026 response == response2);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [bit_and](Self::bit_and)\n    /// - [bit_or](Self::bit_or)\n    /// - [bit_sal](Self::bit_sal)\n    /// - [bit_sar](Self::bit_sar)\n    /// - [bit_xor](Self::bit_xor)\n    pub fn bit_not(self, cmd_number: Command) -\u003e Command {\n        cmd_number.bit_not()\n    }\n\n    /// Compute the left arithmetic shift (left logical shift) of one or more values.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// number.bit_sal(param_number) → number\n    /// r.bit_sal(cmd_number, param_number) → number\n    /// ```\n    ///\n    /// Where:\n    /// - param_number: i32 | [Command](crate::Command)\n    /// - cmd_number: [Command](crate::Command)\n    ///\n    /// # Description\n    ///\n    /// In an arithmetic shift (also referred to as signed shift),\n    /// like a logical shift, the bits that slide off the end disappear\n    /// (except for the last, which goes into the carry flag).\n    /// But in an arithmetic shift, the spaces are filled in such a way\n    /// to preserve the sign of the number being slid. For this reason,\n    /// arithmetic shifts are better suited for signed numbers in two’s\n    /// complement format.\n    ///\n    /// ## Note\n    ///\n    /// SHL and SAL are the same, and differentiation only happens because\n    /// SAR and SHR (right shifting) has differences in their implementation.\n    ///\n    /// ## Examples\n    ///\n    /// Compute the left arithmetic shift of 5 and 4\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: u8 = r.expr(5)\n    ///         .bit_sar(4)\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     let response2: u8 = r.bit_sar(r.expr(5), r.expr(4))\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == 80 \u0026\u0026 response == response2);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [bit_and](Self::bit_and)\n    /// - [bit_not](Self::bit_not)\n    /// - [bit_or](Self::bit_or)\n    /// - [bit_sar](Self::bit_sar)\n    /// - [bit_xor](Self::bit_xor)\n    pub fn bit_sal(self, cmd_number: Command, args: impl cmd::bit_sal::BitSalArg) -\u003e Command {\n        cmd_number.bit_sal(args)\n    }\n\n    /// Compute the right arithmetic shift of one or more values.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// number.bit_sar(param_number) → number\n    /// r.bit_sar(cmd_number, param_number) → number\n    /// ```\n    ///\n    /// Where:\n    /// - param_number: i32 | [Command](crate::Command)\n    /// - cmd_number: [Command](crate::Command)\n    ///\n    /// # Description\n    ///\n    /// In an arithmetic shift (also referred to as signed shift),\n    /// like a logical shift, the bits that slide off the end disappear\n    /// (except for the last, which goes into the carry flag).\n    /// But in an arithmetic shift, the spaces are filled in such\n    /// a way to preserve the sign of the number being slid.\n    /// For this reason, arithmetic shifts are better suited for\n    /// signed numbers in two’s complement format.\n    ///\n    /// ## Examples\n    ///\n    /// Compute the right arithmetic shift of 32 and 3\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: u8 = r.expr(32)\n    ///         .bit_sar(3)\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     let response2: u8 = r.bit_sar(r.expr(32), r.expr(3))\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == 4 \u0026\u0026 response == response2);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [bit_and](Self::bit_and)\n    /// - [bit_not](Self::bit_not)\n    /// - [bit_or](Self::bit_or)\n    /// - [bit_sal](Self::bit_sal)\n    /// - [bit_xor](Self::bit_xor)\n    pub fn bit_sar(self, cmd_number: Command, args: impl cmd::bit_sar::BitSarArg) -\u003e Command {\n        cmd_number.bit_sar(args)\n    }\n\n    /// Return a time object representing the current time in UTC.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// r.now() → time\n    /// ```\n    ///\n    /// Where:\n    /// - time: [Time](crate::types::Time)\n    ///\n    /// # Description\n    ///\n    /// The command now() is computed once when the server receives the query,\n    /// so multiple instances of r.now() will always return the same time inside a query.\n    ///\n    /// ## Examples\n    ///\n    /// Create a time\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::types::Time;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///\n    ///     let time1: Time = r.now().value();\n    ///     let time2: Time = r.now()\n    ///         .cmd()\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(time1.is_valid());\n    ///     assert!(time2.is_valid());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [time](Self::time)\n    /// - [epoch_time](Self::epoch_time)\n    /// - [iso8601](Self::iso8601)\n    pub fn now(self) -\u003e DateTime {\n        DateTime::now()\n    }\n\n    /// Create a time object for a specific time.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// r.time(args!(date, timezone)) → time\n    /// r.time(args!(date, time_, timezone)) → time\n    /// ```\n    ///\n    /// Where:\n    /// - date: [time::Date](time::Date)\n    /// - time_: [time::Time](time::Time)\n    /// - timezone: [time::UtcOffset](time::UtcOffset)\n    /// - time: [Time](crate::types::Time)\n    ///\n    /// ## Examples\n    ///\n    /// Create a time\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::types::Time;\n    /// use reql_rust::{args, r, Result};\n    /// use time::macros::{date, offset, time};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let date = date!(1986 - 11 - 3);\n    ///     let time = time!(09:30:40);\n    ///     let timezone = offset!(+01:00);\n    ///\n    ///     let date_time = r.time(args!(date, time, timezone));\n    ///     let time1 = date_time.clone().value();\n    ///     let time2: Time = date_time.cmd()\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(time2 == time1);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [now](Self::now)\n    /// - [time](Self::time)\n    /// - [iso8601](Self::iso8601)\n    pub fn time(self, args: impl cmd::time::TimeArg) -\u003e DateTime {\n        DateTime::time(args)\n    }\n\n    /// Create a time object based on seconds since epoch.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// r.epoch_time(i64) → time\n    /// ```\n    ///\n    /// Where:\n    /// - time: [Time](crate::types::Time)\n    ///\n    /// ## Examples\n    ///\n    /// Create a time\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::types::Time;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let date_time = r.epoch_time(531360000)?;\n    ///     let time1 = date_time.clone().value();\n    ///     let time2: Time = date_time.cmd()\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(time2 == time1);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [now](Self::now)\n    /// - [time](Self::time)\n    /// - [iso8601](Self::iso8601)\n    pub fn epoch_time(self, timestamp: i64) -\u003e Result\u003cDateTime\u003e {\n        DateTime::epoch_time(timestamp)\n    }\n\n    /// Create a time object based on an ISO 8601\n    /// date-time string (e.g. ‘2013-01-01T01:01:01+00:00’).\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// r.iso8601(string) → time\n    /// r.iso8601(args!(string, default_timezone)) → time\n    /// ```\n    ///\n    /// Where:\n    /// - time: [Time](crate::types::Time)\n    /// - default_timezone: UtcOffset\n    ///\n    /// # Description\n    ///\n    /// RethinkDB supports all valid ISO 8601 formats except for week dates.\n    /// Read more about the ISO 8601 format at\n    /// [Wikipedia](http://en.wikipedia.org/wiki/ISO_8601).\n    ///\n    /// If you pass an ISO 8601 string without a time zone,\n    /// you must specify the time zone with the default_timezone argument.\n    ///\n    /// ## Examples\n    ///\n    /// Create a time\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::types::Time;\n    /// use reql_rust::{args, r, Result};\n    /// use time::macros::offset;\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let date_time = r.iso8601(args!(\"1986-11-03T08:30:00\", offset!(+01:00)))?;\n    ///     let time1 = date_time.clone().value();\n    ///     let time2: Time = date_time.cmd()\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(time2 == time1);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [now](Self::now)\n    /// - [time](Self::time)\n    /// - [epoch_time](Self::epoch_time)\n    pub fn iso8601(self, args: impl cmd::iso8601::Iso8601) -\u003e Result\u003cDateTime\u003e {\n        DateTime::iso8601(args)\n    }\n\n    /// Convert `HashMap` to `Command`\n    pub fn hash_map\u003cT\u003e(self, value: HashMap\u003cT, Command\u003e) -\u003e Command\n    where\n        T: Into\u003cString\u003e,\n    {\n        cmd::hash_map::new(value)\n    }\n\n    /// `r.args` is a special term that’s used to splice\n    /// an array of arguments into another term.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// r.args(array) → special\n    /// ```\n    /// Where:\n    /// - array: [Type; usize], Vec\u003cType\u003e, \u0026\\[Type]\n    ///\n    /// # Description\n    ///\n    /// This is useful when you want to call a variadic term such as\n    /// [get_all](crate::Command::get_all)\n    /// with a set of arguments produced at runtime.\n    ///\n    /// Note that `args` evaluates all its arguments before passing them\n    /// into the parent term, even if the parent term otherwise allows lazy evaluation.\n    ///\n    /// ## Examples\n    ///\n    /// Unpack array\n    ///\n    /// ```\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let data = vec![1, 2, 3];\n    ///\n    ///     let response: Vec\u003cu8\u003e = r.args(\u0026data)\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == data);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    pub fn args\u003cT, S\u003e(self, values: T) -\u003e Command\n    where\n        S: Serialize,\n        T: AsRef\u003c[S]\u003e + Serialize,\n    {\n        cmd::args::new(values)\n    }\n\n    /// Encapsulate binary data within a query.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// r.binary(data) → binary\n    /// ```\n    ///\n    /// Where:\n    /// - data: \u0026[u8]\n    /// - binary: [Binary](crate::types::Binary)\n    ///\n    /// # Description\n    ///\n    /// Binary struct returned to the client in Rust.\n    /// This can be changed with the `binary_format` option\n    /// provided to [run](crate::Command::run) to return “raw” objects.\n    ///\n    /// Only a limited subset of ReQL commands may be chained after `binary`:\n    /// - [coerce_to](crate::Command::coerce_to) can coerce binary objects to string types\n    /// - [count](Self::count) will return the number of bytes in the object\n    /// - [slice](crate::Command::slice) will treat bytes like array indexes\n    /// (i.e., slice(args!(10,20)) will return bytes 10–19)\n    /// - [type_of](crate::Command::type_of) returns `TypeOf::PtypeBinary`\n    /// - [info](Self::info) will return information on a binary struct.\n    ///\n    /// ## Examples\n    ///\n    /// Save an avatar image to a existing user record.\n    ///\n    /// ```\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let avatar_img = std::fs::read(\"default_avatar.png\")?;\n    ///     let conn = r.connection().connect().await?;\n    ///\n    ///     let response = r.table(\"images\")\n    ///         .insert(r.binary(\u0026avatar_img))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Get the size of an existing avatar image.\n    ///\n    /// ```\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///\n    ///     let response: usize = r.table(\"images\")\n    ///         .get(100)\n    ///         .g(\"avatar\")\n    ///         .count(())\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == 14156);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// Read more details about RethinkDB’s binary object support:\n    /// [Storing binary objects](\"https://rethinkdb.com/docs/storing-binary/python/\").\n    pub fn binary(self, data: \u0026[u8]) -\u003e Binary {\n        cmd::binary::new(data)\n    }\n\n    // FIXME Command no work\n    pub fn do_(self, args: impl cmd::do_::DoArg) -\u003e Command {\n        cmd::do_::new(args)\n    }\n\n    /// Perform a branching conditional equivalent to `if-then-else`.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// r.branch(test, args!(true_action, false_action)) → any\n    /// r.branch(test, args!(true_action, [(test2, test2_action), N], false_action)) → any\n    /// query.branch(args!(true_action, false_action)) -\u003e any\n    /// query.branch(args!(true_action, [(test2, test2_action), N], false_action)) → any\n    /// ```\n    ///\n    /// Where:\n    /// - test, true_action, false_action, test2, test2_action: r.expr(...)\n    ///\n    /// # Description\n    ///\n    /// The `branch` command takes 2n+1 arguments: pairs of conditional expressions\n    /// and commands to be executed if the conditionals return any value but `false`\n    /// or `None` i.e., “truthy” values), with a final “else” command to be evaluated\n    /// if all of the conditionals are `false` or `None`.\n    ///\n    /// You may call `branch` infix style on the first test.\n    /// (See the second example for an illustration.)\n    ///\n    /// ```text\n    /// r.branch(test1, args!(val1, [(test2, val2)], elseval))\n    /// ```\n    ///\n    /// is the equivalent of the Rust statement\n    ///\n    /// ```text\n    /// if (test1) {\n    ///     val1\n    /// } else if (test2) {\n    ///     val2\n    /// } else {\n    ///     elseval\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Test the value of x.\n    ///\n    /// ```\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let x = 10;\n    ///     let conn = r.connection().connect().await?;\n    ///\n    ///     let response: String = r.branch(\n    ///             r.expr(x \u003e 5),\n    ///             args!(r.expr(\"big\"), r.expr(\"small\"))\n    ///         ).run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response.eq(\"big\"));\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// As above, infix-style.\n    ///\n    /// ```\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let x = 10;\n    ///     let conn = r.connection().connect().await?;\n    ///\n    ///     let response: String = r.expr(x \u003e 5)\n    ///         .branch(args!(r.expr(\"big\"), r.expr(\"small\")))\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response.eq(\"big\"));\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Categorize heroes by victory counts.\n    ///\n    /// ```\n    /// use std::ops::Add;\n    ///\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///\n    ///     let response = r.table(\"pricings\")\n    ///         .map(func!(|offer| r.branch(\n    ///             offer.clone().g(\"price\").gt(100),\n    ///             args!(\n    ///                 offer.clone().g(\"offer\").add(\"premium\"),\n    ///                 [(\n    ///                     offer.clone().g(\"price\").gt(10),\n    ///                     offer.clone().g(\"offer\").add(\"standard\")\n    ///                 )],\n    ///                 offer.g(\"offer\").add(\"freemium\")\n    ///         ))))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [do_](Self::do_)\n    pub fn branch(self, test: Command, args: impl cmd::branch::BranchArg) -\u003e Command {\n        test.branch(args)\n    }\n\n    /// Generate a stream of sequential integers in a specified range.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// r.range(()) → stream\n    /// r.range(end_value) → stream\n    /// r.range(args!(start_value, end_value)) → stream\n    /// ```\n    ///\n    /// Where\n    /// - start_value, end_value: isize\n    ///\n    /// # Description\n    ///\n    /// `range` takes 0, 1 or 2 arguments:\n    /// - With no arguments, `range` returns an “infinite” stream\n    /// from 0 up to and including the maximum integer value;\n    /// - With one argument, `range` returns a stream from\n    /// 0 up to but not including the end value;\n    /// - With two arguments, `range` returns a stream from\n    /// the start value up to but not including the end value.\n    ///\n    /// Note that the left bound (including the implied left\n    /// bound of 0 in the 0- and 1-argument form)\n    /// is always closed and the right bound is always open:\n    /// the start value will always be included in the returned range\n    /// and the end value will **not** be included in the returned range.\n    ///\n    /// Any specified arguments must be integers, or a `ReqlRuntimeError` will be thrown.\n    /// If the start value is equal or to higher than the end value,\n    /// no error will be thrown but a zero-element stream will be returned.\n    ///\n    /// ## Examples\n    ///\n    /// Return a four-element range of `[0, 1, 2, 3]`.\n    ///\n    /// ```\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///\n    ///     let response: [u8; 4] = r.range(4)\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == [0, 1, 2, 3]);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// You can also use the [limit](crate::Command::limit)\n    /// command with the no-argument\n    /// variant to achieve the same result in this case:\n    ///\n    /// ```\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///\n    ///     let response: [u8; 4] = r.range(())\n    ///         .limit(4)\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == [0, 1, 2, 3]);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Return a range from -5 through 5.\n    ///\n    /// ```\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///\n    ///     let response: [i8; 11] = r.range(args!(-5, 6))\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == [-5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5]);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    pub fn range(self, args: impl cmd::range::RangeArg) -\u003e Command {\n        cmd::range::new(args)\n    }\n\n    /// Throw a runtime error.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// r.expr(value) → value\n    /// ```\n    ///\n    /// # Description\n    ///\n    /// If called with no arguments inside the second\n    /// argument to default, re-throw the current error.\n    ///\n    /// ## Examples\n    ///\n    /// Get Error\n    ///\n    /// ```\n    /// use reql_rust::{r, ReqlError, ReqlRuntimeError, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let msg = \"Error\";\n    ///\n    ///     let err = r.error(msg).run(\u0026conn).await.err().unwrap();\n    ///\n    ///     if let ReqlError::Runtime(err) = err {\n    ///         if let ReqlRuntimeError::User(err) = err {\n    ///             assert!(err == msg);\n    ///     \n    ///             return Ok(());\n    ///         }\n    ///     }\n    ///\n    ///     assert!(false);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    pub fn error(self, message: impl Into\u003cString\u003e) -\u003e Command {\n        cmd::error::new(message)\n    }\n\n    /// Construct a ReQL JSON object from a native object.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// r.expr(value) → value\n    /// ```\n    ///\n    /// # Description\n    ///\n    /// If the native object is of the `Binary` type,\n    /// then expr will return a binary object.\n    /// See [binary](Self::binary) for more information.\n    ///\n    /// ## Examples\n    ///\n    /// Objects wrapped with `expr` can then be manipulated by ReQL API functions.\n    ///\n    /// ```\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let data = [1, 2, 3];\n    ///\n    ///     let response: [u8; 3] = r.expr(data)\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == data);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    pub fn expr(self, value: impl Serialize) -\u003e Command {\n        cmd::expr::new(value)\n    }\n\n    /// Create a javascript expression.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// r.uuid(()) → String\n    /// r.uuid(\u0026str) → String\n    /// ```\n    ///\n    /// # Description\n    ///\n    /// ```text\n    /// Whenever possible, you should use native ReQL\n    /// commands rather than r.js for better performance.\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Concatenate two strings using JavaScript.\n    ///\n    /// ```\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///\n    ///     let response: String = r.js(\"'str1' + 'str2'\")\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response.eq(\"str1str2\"));\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// You may also specify a timeout in seconds (defaults to 5).\n    ///\n    /// ```\n    /// use reql_rust::cmd::js::JsOption;\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::{args, r, Result};\n    /// use serde_json::json;\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///\n    ///     let response = r.js(args!(\n    ///             \"while(true) {}\",\n    ///             JsOption::default().timeout(1.3)\n    ///             ))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    pub fn js(self, args: impl cmd::js::JsArg) -\u003e Command {\n        cmd::js::new(args)\n    }\n\n    /// Get information about a ReQL value.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// any.info() → response\n    /// r.info(any) → response\n    /// ```\n    ///\n    /// Where:\n    /// - response: [InfoResponse](crate::types::InfoResponse)\n    ///\n    /// ## Examples\n    ///\n    /// Get information about a table such as primary key, or cache size.\n    ///\n    /// ```\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::types::{InfoResponse, TypeOf};\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///\n    ///     let response: InfoResponse = r.table(\"simbad\")\n    ///         .info()\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response.typ == TypeOf::Table);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    pub fn info(self, any: Command) -\u003e Command {\n        any.info()\n    }\n\n    /// Parse a JSON string on the server.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// r.json(json_string) → value\n    /// ```\n    ///\n    /// Where:\n    /// - json_string: impl Into\u003cString\u003e\n    ///\n    /// ## Examples\n    ///\n    /// Send an array to the server.\n    ///\n    /// ```\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///\n    ///     let response: [u8; 3] = r.json(\"[1,2,3]\")\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == [1, 2, 3]);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    pub fn json(self, value: impl Into\u003cString\u003e) -\u003e Command {\n        cmd::json::new(value)\n    }\n\n    /// Retrieve data from the specified URL over HTTP.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// r.http(string) → value\n    /// r.http(args!(string, options)) → value\n    /// ```\n    ///\n    /// Where:\n    /// - string: impl Into\u003cString\u003e\n    /// - options: impl Serialize\n    ///\n    /// # Description\n    ///\n    /// The return type depends on the `result_format` option,\n    /// which checks the `Content-Type` of the response by default.\n    ///\n    /// See [External API access](https://rethinkdb.com/docs/external-api-access/)\n    /// for more informations\n    ///\n    /// ## Examples\n    ///\n    /// Perform an HTTP GET and store the result in a table.\n    ///\n    /// ```\n    /// use reql_rust::types::MutationResponse;\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///\n    ///     let response: MutationResponse = r.table(\"simbad\")\n    ///         .insert(r.http(\"http://httpbin.org/get\"))\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response.inserted == 1);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Perform request with parameters.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{args, r, Result};\n    /// use serde_json::json;\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///\n    ///     let response = r.http(args!(\"http://httpbin.org/get\", json!({\n    ///             \"params\": {\n    ///                 \"user\": 1\n    ///             }\n    ///         })))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Perform a `POST` request with accompanying data.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{args, r, Result};\n    /// use serde_json::json;\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///\n    ///     let response = r.http(args!(\"http://httpbin.org/get\", json!({\n    ///             \"method\": \"method\",\n    ///             \"data\": {\n    ///                 \"player\": \"Moussa\",\n    ///                 \"game\": \"AURION\"\n    ///             }\n    ///         })))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Perform a GitHub search and collect up to 3 pages of results.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{args, r, Result};\n    /// use serde_json::json;\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///\n    ///     let response = r.http(args!(\"https://api.github.com/search/code?q=addClass+user:mozilla\", json!({\n    ///             \"page\": \"link-next\",\n    ///             \"page_limit\": 3\n    ///         })))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    pub fn http\u003cT\u003e(self, args: impl cmd::http::HttpArg\u003cT\u003e) -\u003e Command\n    where\n        T: Serialize,\n    {\n        cmd::http::new(args)\n    }\n\n    /// Return a UUID (universally unique identifier),\n    /// a string that can be used as a unique ID.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// r.uuid(()) → String\n    /// r.uuid(\u0026str) → String\n    /// ```\n    ///\n    /// # Description\n    ///\n    /// If a string is passed to uuid as an argument,\n    /// the UUID will be deterministic,\n    /// derived from the string’s SHA-1 hash.\n    ///\n    /// RethinkDB’s UUIDs are standards-compliant.\n    /// Without the optional argument,\n    /// a version 4 random UUID will be generated;\n    /// with that argument, a version 5 UUID will be generated,\n    /// using a fixed namespace UUID of `91461c99-f89d-49d2-af96-d8e2e14e9b58`.\n    /// For more information, read\n    /// [Wikipedia’s UUID article](https://en.wikipedia.org/wiki/Universally_unique_identifier).\n    ///\n    /// ## Examples\n    ///\n    /// Generate a UUID.\n    ///\n    /// ```\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::{args, r, Result};\n    /// use serde_json::json;\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///\n    ///     let response: String = r.uuid(())\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response.eq(\"27961a0e-f4e8-4eb3-bf95-c5203e1d87b9\"));\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Generate a UUID based on a String.\n    ///\n    /// ```\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::{args, r, Result};\n    /// use serde_json::json;\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///\n    ///     let response: String = r.uuid(\"malik@example.com\")\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response.eq(\"3461d115-2c05-5af4-9906-9f6882c58a15\"));\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    pub fn uuid(self, args: impl cmd::uuid::UuidArg) -\u003e Command {\n        cmd::uuid::new(args)\n    }\n\n    /// Construct a circular line or polygon.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// r.circle(args!(point, radius)) → polygon\n    /// r.circle(args!(point, radius, options)) → polygon\n    /// ```\n    ///\n    /// Where:\n    /// - radius: f64,\n    /// - point: [Point](crate::cmd::point::Point)\n    /// - polygon: [Polygon](crate::cmd::polygon::Polygon)\n    ///\n    /// # Description\n    ///\n    /// A circle in RethinkDB is a polygon or line **approximating**\n    /// a circle of a given radius around a given center,\n    /// consisting of a specified number of vertices (default 32).\n    ///\n    /// The center may be specified either by two floating point numbers, the longitude\n    /// (−180 to 180) and latitude (−90 to 90) of the point on a perfect sphere\n    /// (See [Geospatial support](https://rethinkdb.com/docs/geo-support/python/)\n    /// for more information on ReQL’s coordinate system), or by a point object.\n    /// The radius is a floating point number whose units are meters by default,\n    /// although that may be changed with the `unit` argument.\n    ///\n    /// ## Examples\n    ///\n    /// Define a point.\n    ///\n    /// ```\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::types::Polygon;\n    /// use reql_rust::{args, r, Result};\n    /// use serde_json::json;\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let circle: Polygon = r.circle(args!(r.point(-122.423246, 37.779388), 50.5))\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     let response = r.table(\"geo\")\n    ///         .insert(json!({\n    ///             \"id\": 300,\n    ///             \"name\": \"Douala\",\n    ///             \"location\": circle\n    ///         }))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [line](Self::line)\n    /// - [polygon](Self::polygon)\n    /// - [point](Self::point)\n    /// - [distance](crate::Command::distance)\n    pub fn circle(self, args: impl cmd::circle::CircleArg) -\u003e Command {\n        cmd::circle::new(args)\n    }\n\n    /// Compute the distance between a point and another geometry object.\n    /// At least one of the geometry objects specified must be a point.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// geometry.distance(geometry) → f64\n    /// geometry.distance(args!(geometry, options)) → f64\n    /// r.distance(geometry.cmd(), geometry) → f64\n    /// r.distance(geometry.cmd(), args!(geometry, options)) → f64\n    /// ```\n    ///\n    /// Where:\n    /// - geometry: [r.point(...)](crate::r::point) |\n    /// [r.line(...)](crate::r::line) |\n    /// [r.polygon(...)](crate::r::polygon)\n    /// command\n    /// - options: [DistanceOption](crate::cmd::distance::DistanceOption)\n    ///\n    /// # Description\n    ///\n    /// If one of the objects is a polygon or a line, the point will be projected\n    /// into the line or polygon assuming a perfect sphere model before the distance\n    /// is computed (using the model specified with `geo_system`).\n    /// As a consequence, if the polygon or line is extremely large compared\n    /// to Earth’s radius and the distance is being computed with the default\n    ///  WGS84 model, the results of `distance` should be considered approximate\n    /// due to the deviation between the ellipsoid and spherical models.\n    ///\n    /// ## Examples\n    ///\n    /// Compute the distance between two points on the Earth in kilometers.\n    ///\n    /// ```\n    /// use reql_rust::arguments::Unit;\n    /// use reql_rust::cmd::distance::DistanceOption;\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let point1 = r.point(-122.423246, 37.779388);\n    ///     let point2 = r.point(-117.220406, 32.719464);\n    ///     let distance_option = DistanceOption::default().unit(Unit::Kilometer);\n    ///\n    ///     let response: f64 = r.distance(point1.cmd(), point2)\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == 734.125249602186);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [polygon](crate::r::polygon)\n    /// - [line](crate::r::line)\n    pub fn distance(self, geometry: Command, args: impl cmd::distance::DistanceArg) -\u003e Command {\n        geometry.distance(args)\n    }\n\n    /// Convert a [GeoJSON](https://geojson.org/) object to a ReQL geometry object.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// r.geojson(geojson) → geometry\n    /// ```\n    ///\n    /// Where:\n    /// - geojson: [GeoJson](crate::types::GeoJson),\n    /// - geometry: [ReqlGeoJson](crate::types::ReqlGeoJson)\n    ///\n    /// # Description\n    ///\n    /// RethinkDB only allows conversion of GeoJSON objects\n    /// which have ReQL equivalents: Point, LineString, and Polygon.\n    ///  MultiPoint, MultiLineString, and MultiPolygon are not supported.\n    /// (You could, however, store multiple points, lines and polygons\n    /// in an array and use a geospatial multi index with them.)\n    ///\n    /// Only longitude/latitude coordinates are supported.\n    /// GeoJSON objects that use Cartesian coordinates,\n    /// specify an altitude, or specify their own coordinate\n    /// reference system will be rejected.\n    ///\n    /// ## Examples\n    ///\n    /// Convert a GeoJSON object to a ReQL geometry object.\n    ///\n    /// ```\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::types::{GeoJson, GeoType};\n    /// use reql_rust::{args, r, Result};\n    /// use serde_json::json;\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let geo_json = GeoJson {\n    ///         typ: GeoType::Point,\n    ///         coordinates: [-122.423246, 37.779388],\n    ///     };\n    ///\n    ///     let response = r.table(\"geo\")\n    ///         .insert(json!({\n    ///             \"id\": 1,\n    ///             \"name\": \"Yaoundé\",\n    ///             \"location\": r.geojson(geo_json)\n    ///         }))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [to_geojson](crate::Command::to_geojson)\n    pub fn geojson\u003cT: Serialize\u003e(self, geojson: GeoJson\u003cT\u003e) -\u003e cmd::geojson::ReqlGeoJson\u003cT\u003e {\n        cmd::geojson::ReqlGeoJson::new(geojson)\n    }\n\n    /// Construct a geometry object of type Polygon.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// r.line(points) → line\n    /// ```\n    ///\n    /// Where:\n    /// - points: \u0026[[Point](crate::types::Point)]\n    /// - line: [Polygon](crate::types::Line)\n    ///\n    /// # Description\n    ///\n    /// The line can be specified in one of two ways:\n    /// - Two or more two-item arrays, specifying latitude\n    /// and longitude numbers of the line’s vertices;\n    /// - Two or more [Point](crate::types::Point)\n    /// objects specifying the line’s vertices.\n    ///\n    /// Longitude (−180 to 180) and latitude (−90 to 90)\n    /// of vertices are plotted on a perfect sphere.\n    /// See [Geospatial support](https://rethinkdb.com/docs/geo-support/python/)\n    /// for more information on ReQL’s coordinate system.\n    ///\n    /// ## Examples\n    ///\n    /// Define a line.\n    ///\n    /// ```\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::{args, r, Result};\n    /// use serde_json::json;\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///\n    ///     let response = r.table(\"geo\")\n    ///         .insert(json!({\n    ///             \"id\": 101,\n    ///             \"route\": r.line(\u0026[\n    ///                 r.point(-122.423246, 37.779388),\n    ///                 r.point(-121.886420, 37.329898),\n    ///             ])\n    ///         }))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [point](Self::point)\n    /// - [polygon](Self::polygon)\n    /// - [circle](Self::circle)\n    pub fn line(self, points: \u0026[cmd::point::Point]) -\u003e cmd::line::Line {\n        cmd::line::Line::new(points)\n    }\n\n    /// Construct a geometry object of type Point.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// r.point(longitude, latitude) → point\n    /// ```\n    ///\n    /// Where:\n    /// - latitude: f64,\n    /// - longitude: f64,\n    /// - points: \u0026[[Point](crate::cmd::point::Point)]\n    ///\n    /// # Description\n    ///\n    /// The point is specified by two floating point numbers, the longitude\n    /// (−180 to 180) and latitude (−90 to 90) of the point on a perfect sphere.\n    /// See [Geospatial support](https://rethinkdb.com/docs/geo-support/python/)\n    /// for more information on ReQL’s coordinate system.\n    ///\n    /// ## Examples\n    ///\n    /// Define a point.\n    ///\n    /// ```\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::{args, r, Result};\n    /// use serde_json::json;\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///\n    ///     let response = r.table(\"geo\")\n    ///         .insert(json!({\n    ///             \"id\": 1,\n    ///             \"name\": \"Yaoundé\",\n    ///             \"location\": r.point(-122.423246, 37.779388)\n    ///         }))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [line](Self::line)\n    /// - [polygon](Self::polygon)\n    /// - [circle](Self::circle)\n    pub fn point(self, longitude: f64, latitude: f64) -\u003e cmd::point::Point {\n        cmd::point::Point::new(longitude, latitude)\n    }\n\n    /// Construct a geometry object of type Polygon.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// r.polygon(points) → polygon\n    /// ```\n    ///\n    /// Where:\n    /// - points: \u0026[[Point](crate::cmd::point::Point)]\n    /// - polygon: [Polygon](crate::cmd::polygon::Polygon)\n    ///\n    /// # Description\n    ///\n    /// The Polygon can be specified in one of two ways:\n    /// - Three or more two-item arrays, specifying latitude\n    /// and longitude numbers of the polygon’s vertices;\n    /// - Three or more [Point](crate::cmd::point::Point)\n    /// objects specifying the polygon’s vertices.\n    ///\n    /// Longitude (−180 to 180) and latitude (−90 to 90)\n    /// of vertices are plotted on a perfect sphere.\n    /// See [Geospatial support](https://rethinkdb.com/docs/geo-support/python/)\n    /// for more information on ReQL’s coordinate system.\n    ///\n    /// If the last point does not specify the same coordinates as\n    /// the first point, `polygon` will close the polygon by connecting them.\n    /// You cannot directly construct a polygon with holes in it using `polygon`,\n    /// but you can use [polygon_sub](crate::types::Polygon::polygon_sub)\n    /// to use a second polygon within the interior of the first to define a hole.\n    ///\n    /// ## Examples\n    ///\n    /// Define a polygon.\n    ///\n    /// ```\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::{args, r, Result};\n    /// use serde_json::json;\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///\n    ///     let response = r.table(\"geo\")\n    ///         .insert(json!({\n    ///             \"id\": 101,\n    ///             \"rectangle\": r.polygon(\u0026[\n    ///                 r.point(-122.423246, 37.779388),\n    ///                 r.point(-122.423246, 37.329898),\n    ///                 r.point(-121.886420, 37.329898),\n    ///                 r.point(-121.886420, 37.779388),\n    ///             ])\n    ///         }))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [point](Self::point)\n    /// - [line](Self::line)\n    /// - [circle](Self::circle)\n    pub fn polygon(self, points: \u0026[cmd::point::Point]) -\u003e cmd::polygon::Polygon {\n        cmd::polygon::Polygon::new(points)\n    }\n\n    /// Tests whether two geometry objects intersect with one another.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// geometry.intersects(geometry) → bool\n    /// r.intersects(geometry_command, geometry) → bool\n    /// sequence.intersects(geometry) → sequence_response\n    /// r.intersects(sequence, geometry) → sequence_response\n    /// ```\n    ///\n    /// Where:\n    /// - geometry: [r.point(...)](crate::r::point) |\n    /// [r.line(...)](crate::r::line) |\n    /// [r.polygon(...)](crate::r::polygon) |\n    /// command\n    /// - sequence, geometry_command: [Command](crate::Command)\n    ///\n    /// # Description\n    ///\n    /// When applied to a sequence of geometry objects, `intersects` acts as a\n    /// [filter](crate::Command::filter), returning a sequence of objects from\n    /// the sequence that intersect with the argument.\n    ///\n    /// ## Examples\n    ///\n    /// Is `point2` within a 2000-meter circle around `point1`?\n    ///\n    /// ```\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let point1 = r.point(-117.220406, 32.719464);\n    ///     let point2 = r.point(-117.206201, 32.725186);\n    ///     let circle_cmd = r.circle(args!(point1, 2000.));\n    ///\n    ///     let response: bool = r.intersects(circle_cmd, point2)\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Which of the locations in a list of parks intersect `circle`?\n    ///\n    /// ```\n    /// use reql_rust::arguments::Unit;\n    /// use reql_rust::cmd::circle::CircleOption;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let point = r.point(-117.220406, 32.719464);\n    ///     let circle_opts = CircleOption::default().unit(Unit::InternationalMile);\n    ///     let circle = r.circle(args!(point, 10., circle_opts));\n    ///\n    ///     let response = r.intersects(r.table(\"parks\").g(\"area\"), circle)\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [includes](crate::Command::includes)\n    /// - [get_intersecting](crate::Command::get_intersecting)\n    pub fn intersects(\n        self,\n        geometry: Command,\n        args: impl cmd::intersects::IntersectsArg,\n    ) -\u003e Command {\n        geometry.intersects(args)\n    }\n\n    /// Grant or deny access permissions for a user account,\n    /// globally or on a per-database or per-table basis.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// r.grant(username, permission) → response\n    /// table.grant(username, permission) → response\n    /// db.grant(username, permission) → response\n    /// ```\n    ///\n    /// Where:\n    /// - table: [r.table(...)](crate::r::table) |\n    /// [query.table(...)](Self::table)\n    /// - db: [r.db(...)](crate::r::db)\n    /// - response: [GrantResponse](crate::types::GrantResponse)\n    ///\n    /// # Description\n    ///\n    /// Permissions that are not defined on a local scope will\n    /// be inherited from the next largest scope.\n    /// For example, a write operation on a table will first\n    /// check if `write` permissions are explicitly set to `true` or `false`\n    /// for that table and account combination; if they are not,\n    /// the `write` permissions for the database will be used\n    /// if those are explicitly set; and if neither table nor database\n    /// permissions are set for that account, the global `write`\n    /// permissions for that account will be used.\n    ///\n    /// ## Note\n    ///\n    /// For all accounts other than the special, system-defined `admin` account,\n    /// permissions that are not explicitly set in any scope will effectively be `false`.\n    /// When you create a new user account by inserting a record into the\n    /// [system table](https://rethinkdb.com/docs/system-tables/#users),\n    /// that account will have **no** permissions until they are explicitly granted.\n    ///\n    /// For a full description of permissions, read\n    /// [Permissions and user accounts](https://rethinkdb.com/docs/permissions-and-accounts/).\n    ///\n    /// ## Examples\n    ///\n    /// Grant the `alima` user account read and write permissions on the `users` database.\n    ///\n    /// ```\n    /// use reql_rust::arguments::Permission;\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::types::GrantResponse;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let permission = Permission::default().read(true).write(true);\n    ///\n    ///     let response: GrantResponse = r.db(\"users\")\n    ///         .grant(\"alima\", permission)\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response.granted == 1);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Deny write permissions from the `alima` account for the `simbad` table.\n    ///\n    /// ```\n    /// use reql_rust::arguments::Permission;\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::types::GrantResponse;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let permission = Permission::default().write(false);\n    ///\n    ///     let response: GrantResponse = r.db(\"users\")\n    ///         .table(\"simbad\")\n    ///         .grant(\"alima\", permission)\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response.granted == 1);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Grant `alima` the ability to use HTTP connections.\n    ///\n    /// ```\n    /// use reql_rust::arguments::Permission;\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::types::GrantResponse;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let permission = Permission::default().connect(true);\n    ///\n    ///     let response: GrantResponse = r.grant(\"alima\", permission)\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response.granted == 1);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Grant a `monitor` account read-only access to all databases.\n    ///\n    /// ```\n    /// use reql_rust::arguments::Permission;\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::types::GrantResponse;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let permission = Permission::default().read(true);\n    ///\n    ///     let response: GrantResponse = r.grant(\"monitor\", permission)\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response.granted == 1);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    pub fn grant(self, username: \u0026str, permission: Permission) -\u003e Command {\n        cmd::grant::new(username, permission)\n    }\n\n    /// Wait for a table or all the tables in a database to be ready.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// table.wait(()) → response\n    /// db.wait(()) → response\n    /// r.wait(table) → response\n    /// r.wait(database) → response\n    /// table.wait(options) → response\n    /// db.wait(options) → response\n    /// r.wait(args!(table, options)) → response\n    /// r.wait(args!(database, options)) → response\n    /// ```\n    ///\n    /// Where:\n    /// - table: [r.table(...)](crate::r::table) |\n    /// [query.table(...)](Self::table)\n    /// - db: [r.db(...)](crate::r::db)\n    /// - options: [WaitOption](crate::cmd::wait::WaitOption)\n    /// - response: [WaitResponse](crate::types::WaitResponse)\n    ///\n    /// # Description\n    ///\n    /// A table may be temporarily unavailable after creation,\n    /// rebalancing or reconfiguring.\n    /// The `wait` command blocks until the given\n    /// table (or database) is fully up to date.\n    ///\n    /// ## Examples\n    ///\n    /// Wait on a table to be ready.\n    ///\n    /// ```\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::types::WaitResponse;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///\n    ///     let response: WaitResponse = r.table(\"simbad\")\n    ///         .wait(())\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response.ready == 1);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Wait on a table with timeout to be ready for reads.\n    ///\n    /// ```\n    /// use reql_rust::arguments::WaitFor;\n    /// use reql_rust::cmd::wait::WaitOption;\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::types::WaitResponse;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let table_command = r.db(\"anim\").table(\"simbad\");\n    ///     let opts = WaitOption::default()\n    ///         .wait_for(WaitFor::ReadyForReads)\n    ///         .timeout(8000f64);\n    ///\n    ///     let response: WaitResponse =  r.wait(args!(table_command, opts))\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response.ready == 1);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    pub fn wait(self, args: impl cmd::wait::WaitArg) -\u003e Command {\n        cmd::wait::new(args)\n    }\n\n    /// To specify the descending ordering.\n    ///\n    /// # Command syntax\n    /// ```text\n    /// r.asc(field)\n    /// r.asc(func)\n    /// ```\n    ///\n    /// Where:\n    /// - field: String, \u0026str\n    /// - func: func!(...)\n    ///\n    /// ## Example\n    ///\n    /// ```\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"simbad\")\n    ///         .order_by(args!(r.expr(\"id\"), r.asc(\"character\")))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///\n    ///     Ok(())\n    /// }\n    /// ```\n    pub fn asc(self, args: impl cmd::asc::AscArg) -\u003e Command {\n        cmd::asc::new(args)\n    }\n\n    /// To specify the descending ordering.\n    ///\n    /// # Command syntax\n    /// ```text\n    /// r.desc(field)\n    /// r.desc(func)\n    /// ```\n    ///\n    /// Where:\n    /// - field: String, \u0026str\n    /// - func: func!(...)\n    ///\n    /// ## Example\n    ///\n    /// ```\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"simbad\")\n    ///         .order_by(args!(r.expr(\"id\"), r.desc(\"character\")))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///\n    ///     Ok(())\n    /// }\n    /// ```\n    pub fn desc(self, args: impl cmd::desc::DescArg) -\u003e Command {\n        cmd::desc::new(args)\n    }\n\n    /// max_val are used with some commands such as `between`\n    /// to specify absolute upper bounds.\n    ///\n    /// # Command syntax\n    /// ```text\n    /// r::min_val()\n    /// ```\n    ///\n    /// ## Example\n    ///\n    /// ```\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"simbad\")\n    ///         .between(args!(r::min_val(), r.expr(20)))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///\n    ///     Ok(())\n    /// }\n    /// ```\n    pub fn min_val() -\u003e Command {\n        Command::new(ql2::term::TermType::Minval)\n    }\n\n    /// max_val are used with some commands such as `between`\n    /// to specify absolute upper bounds.\n    ///\n    /// # Command syntax\n    /// ```text\n    /// r::max_val()\n    /// ```\n    ///\n    /// ## Example\n    ///\n    /// ```\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"simbad\")\n    ///         .between(args!(r.expr(10), r::max_val()))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///\n    ///     Ok(())\n    /// }\n    /// ```\n    pub fn max_val() -\u003e Command {\n        Command::new(ql2::term::TermType::Maxval)\n    }\n}\n\n// Helper for making writing examples less verbose\n#[doc(hidden)]\npub fn example\u003c'a, Q, F, S\u003e(_query: Q)\nwhere\n    Q: FnOnce(r, \u0026'a mut Session) -\u003e async_stream::AsyncStream\u003c(), F\u003e,\n    F: futures::Future\u003cOutput = S\u003e,\n    S: futures::Stream\u003cItem = Result\u003cserde_json::Value\u003e\u003e,\n{\n}\n","traces":[{"line":114,"address":[1999392],"length":1,"stats":{"Line":4},"fn_name":"connection"},{"line":115,"address":[1999404],"length":1,"stats":{"Line":4},"fn_name":null},{"line":167,"address":[7727296],"length":1,"stats":{"Line":1},"fn_name":"db_create\u003c\u0026str\u003e"},{"line":168,"address":[7727318],"length":1,"stats":{"Line":1},"fn_name":null},{"line":216,"address":[7727392,7727344],"length":1,"stats":{"Line":2},"fn_name":"db_drop\u003c\u0026str\u003e"},{"line":217,"address":[7727366,7727408],"length":1,"stats":{"Line":2},"fn_name":null},{"line":252,"address":[1999424],"length":1,"stats":{"Line":1},"fn_name":"db_list"},{"line":253,"address":[1999436],"length":1,"stats":{"Line":1},"fn_name":null},{"line":295,"address":[2155504],"length":1,"stats":{"Line":3},"fn_name":"db\u003c\u0026str\u003e"},{"line":296,"address":[2155526],"length":1,"stats":{"Line":3},"fn_name":null},{"line":425,"address":[7727472],"length":1,"stats":{"Line":5},"fn_name":"table_create\u003c\u0026str\u003e"},{"line":426,"address":[7727494],"length":1,"stats":{"Line":5},"fn_name":null},{"line":475,"address":[1999456],"length":1,"stats":{"Line":1},"fn_name":"table_drop"},{"line":476,"address":[1999478],"length":1,"stats":{"Line":1},"fn_name":null},{"line":516,"address":[1999504],"length":1,"stats":{"Line":1},"fn_name":"table_list"},{"line":517,"address":[1999516],"length":1,"stats":{"Line":1},"fn_name":null},{"line":598,"address":[7727568,7727520],"length":1,"stats":{"Line":6},"fn_name":"table\u003c\u0026str\u003e"},{"line":599,"address":[7727542,7727584],"length":1,"stats":{"Line":6},"fn_name":null},{"line":1004,"address":[1999536],"length":1,"stats":{"Line":0},"fn_name":"reduce"},{"line":1005,"address":[1999558],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1974,"address":[7727600],"length":1,"stats":{"Line":1},"fn_name":"object\u003c\u0026str, alloc::vec::Vec\u003c\u0026str, alloc::alloc::Global\u003e\u003e"},{"line":1979,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":2053,"address":[7727664],"length":1,"stats":{"Line":1},"fn_name":"and\u003creql_rust::arguments::Args\u003c[bool; 3]\u003e\u003e"},{"line":2054,"address":[7727712],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2155,"address":[7727760],"length":1,"stats":{"Line":1},"fn_name":"or\u003creql_rust::arguments::Args\u003c[bool; 2]\u003e\u003e"},{"line":2156,"address":[7727790],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2224,"address":[7727824],"length":1,"stats":{"Line":1},"fn_name":"eq\u003creql_rust::arguments::Args\u003c[i32; 3]\u003e\u003e"},{"line":2225,"address":[7727836],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2293,"address":[7727872],"length":1,"stats":{"Line":1},"fn_name":"ne\u003creql_rust::arguments::Args\u003c[i32; 3]\u003e\u003e"},{"line":2294,"address":[7727884],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2365,"address":[7727920],"length":1,"stats":{"Line":1},"fn_name":"gt\u003creql_rust::arguments::Args\u003c[i32; 3]\u003e\u003e"},{"line":2366,"address":[7727932],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2437,"address":[7727968],"length":1,"stats":{"Line":1},"fn_name":"ge\u003creql_rust::arguments::Args\u003c[i32; 3]\u003e\u003e"},{"line":2438,"address":[7727980],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2509,"address":[7728016],"length":1,"stats":{"Line":1},"fn_name":"lt\u003creql_rust::arguments::Args\u003c[i32; 3]\u003e\u003e"},{"line":2510,"address":[7728028],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2581,"address":[7728064],"length":1,"stats":{"Line":1},"fn_name":"le\u003creql_rust::arguments::Args\u003c[i32; 3]\u003e\u003e"},{"line":2582,"address":[7728076],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2649,"address":[1999648],"length":1,"stats":{"Line":1},"fn_name":"not"},{"line":2650,"address":[1999665],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2761,"address":[7728144,7728112,7728208],"length":1,"stats":{"Line":3},"fn_name":"random\u003c()\u003e"},{"line":2762,"address":[7728225,7728155,7728123],"length":1,"stats":{"Line":3},"fn_name":null},{"line":2834,"address":[7728240,7728272],"length":1,"stats":{"Line":2},"fn_name":"round\u003cf64\u003e"},{"line":2835,"address":[7728257,7728289],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2902,"address":[7728336,7728368],"length":1,"stats":{"Line":2},"fn_name":"ceil\u003cf64\u003e"},{"line":2903,"address":[7728385,7728353],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2970,"address":[7728432,7728496],"length":1,"stats":{"Line":2},"fn_name":"floor\u003creql_rust::proto::Command\u003e"},{"line":2971,"address":[7728449,7728513],"length":1,"stats":{"Line":2},"fn_name":null},{"line":3053,"address":[7728528],"length":1,"stats":{"Line":1},"fn_name":"bit_and\u003creql_rust::proto::Command\u003e"},{"line":3054,"address":[7728550],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3134,"address":[7728624],"length":1,"stats":{"Line":1},"fn_name":"bit_or\u003creql_rust::proto::Command\u003e"},{"line":3135,"address":[7728646],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3218,"address":[7728720],"length":1,"stats":{"Line":1},"fn_name":"bit_xor\u003creql_rust::proto::Command\u003e"},{"line":3219,"address":[7728742],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3275,"address":[1999712],"length":1,"stats":{"Line":1},"fn_name":"bit_not"},{"line":3276,"address":[1999729],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3342,"address":[7728816],"length":1,"stats":{"Line":1},"fn_name":"bit_sal\u003creql_rust::proto::Command\u003e"},{"line":3343,"address":[7728838],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3404,"address":[7728912],"length":1,"stats":{"Line":1},"fn_name":"bit_sar\u003creql_rust::proto::Command\u003e"},{"line":3405,"address":[7728934],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3455,"address":[1999776],"length":1,"stats":{"Line":1},"fn_name":"now"},{"line":3456,"address":[1999788],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3508,"address":[7729008,7729072],"length":1,"stats":{"Line":2},"fn_name":"time\u003creql_rust::arguments::Args\u003c(time::date::Date, time::time::Time, time::utc_offset::UtcOffset)\u003e\u003e"},{"line":3509,"address":[7729020,7729098],"length":1,"stats":{"Line":2},"fn_name":null},{"line":3552,"address":[1999808],"length":1,"stats":{"Line":1},"fn_name":"epoch_time"},{"line":3553,"address":[1999824],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3609,"address":[7729136,7729200],"length":1,"stats":{"Line":2},"fn_name":"iso8601\u003creql_rust::arguments::Args\u003c(\u0026str, time::utc_offset::UtcOffset)\u003e\u003e"},{"line":3610,"address":[7729147,7729222],"length":1,"stats":{"Line":2},"fn_name":null},{"line":3614,"address":[7729248],"length":1,"stats":{"Line":1},"fn_name":"hash_map\u003c\u0026str\u003e"},{"line":3618,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":3664,"address":[7729312],"length":1,"stats":{"Line":1},"fn_name":"args\u003c\u0026alloc::vec::Vec\u003cu8, alloc::alloc::Global\u003e, u8\u003e"},{"line":3669,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":3748,"address":[1999840],"length":1,"stats":{"Line":1},"fn_name":"binary"},{"line":3749,"address":[1999862],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3883,"address":[7729344],"length":1,"stats":{"Line":1},"fn_name":"branch\u003creql_rust::arguments::Args\u003c(reql_rust::proto::Command, reql_rust::proto::Command)\u003e\u003e"},{"line":3884,"address":[7729365],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3989,"address":[7729440,7729488,7729520],"length":1,"stats":{"Line":3},"fn_name":"range\u003creql_rust::arguments::Args\u003c(isize, isize)\u003e\u003e"},{"line":3990,"address":[7729462,7729504,7729531],"length":1,"stats":{"Line":3},"fn_name":null},{"line":4032,"address":[7729552],"length":1,"stats":{"Line":1},"fn_name":"error\u003c\u0026str\u003e"},{"line":4033,"address":[7729574],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4073,"address":[1479520],"length":1,"stats":{"Line":12},"fn_name":"expr\u003c\u0026alloc::string::String\u003e"},{"line":4074,"address":[1479536],"length":1,"stats":{"Line":12},"fn_name":null},{"line":4141,"address":[7730176],"length":1,"stats":{"Line":1},"fn_name":"js\u003c\u0026str\u003e"},{"line":4142,"address":[7730198],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4181,"address":[1999888],"length":1,"stats":{"Line":0},"fn_name":"info"},{"line":4182,"address":[1999905],"length":1,"stats":{"Line":0},"fn_name":null},{"line":4218,"address":[7730224],"length":1,"stats":{"Line":1},"fn_name":"json\u003c\u0026str\u003e"},{"line":4219,"address":[7730246],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4346,"address":[7730336,7730272],"length":1,"stats":{"Line":2},"fn_name":"http\u003cserde_json::value::Value, reql_rust::arguments::Args\u003c(\u0026str, serde_json::value::Value)\u003e\u003e"},{"line":4350,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":4424,"address":[7730384],"length":1,"stats":{"Line":1},"fn_name":"uuid\u003c()\u003e"},{"line":4425,"address":[7730395],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4493,"address":[7730416],"length":1,"stats":{"Line":1},"fn_name":"circle\u003creql_rust::arguments::Args\u003c(reql_rust::cmd::point::Point, f64)\u003e\u003e"},{"line":4494,"address":[7730428],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4557,"address":[7730496],"length":1,"stats":{"Line":1},"fn_name":"distance\u003creql_rust::arguments::Args\u003c(reql_rust::cmd::point::Point, reql_rust::cmd::distance::DistanceOption)\u003e\u003e"},{"line":4558,"address":[7730517],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4620,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":4621,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":4682,"address":[1999952],"length":1,"stats":{"Line":1},"fn_name":"line"},{"line":4683,"address":[1999974],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4737,"address":[2000000],"length":1,"stats":{"Line":1},"fn_name":"point"},{"line":4738,"address":[2000024],"length":1,"stats":{"Line":1},"fn_name":null},{"line":4807,"address":[2000048],"length":1,"stats":{"Line":1},"fn_name":"polygon"},{"line":4808,"address":[2000070],"length":1,"stats":{"Line":1},"fn_name":null},{"line":5043,"address":[2000096],"length":1,"stats":{"Line":0},"fn_name":"grant"},{"line":5044,"address":[2000130],"length":1,"stats":{"Line":0},"fn_name":null},{"line":5164,"address":[7730688],"length":1,"stats":{"Line":1},"fn_name":"asc\u003c\u0026str\u003e"},{"line":5165,"address":[7730710],"length":1,"stats":{"Line":1},"fn_name":null},{"line":5198,"address":[7730736],"length":1,"stats":{"Line":1},"fn_name":"desc\u003c\u0026str\u003e"},{"line":5199,"address":[7730758],"length":1,"stats":{"Line":1},"fn_name":null},{"line":5227,"address":[2000160],"length":1,"stats":{"Line":1},"fn_name":"min_val"},{"line":5228,"address":[2000172],"length":1,"stats":{"Line":1},"fn_name":null},{"line":5256,"address":[2000208],"length":1,"stats":{"Line":1},"fn_name":"max_val"},{"line":5257,"address":[2000220],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":108,"coverable":114},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","prelude.rs"],"content":"use std::sync::atomic::{AtomicU64, Ordering};\n\npub use futures::stream::select_all;\npub use futures::TryStreamExt;\n#[doc(hidden)]\npub use reql_macros::func;\npub use reql_macros::Geometry;\nuse serde::de::DeserializeOwned;\nuse serde::Serialize;\n\npub use crate::cmd::func::Func;\npub use crate::cmd::StaticString;\npub use crate::proto::Command;\npub use crate::Result;\n\n#[doc(hidden)]\npub static VAR_COUNTER: AtomicU64 = AtomicU64::new(1);\n\n#[doc(hidden)]\npub fn var_counter() -\u003e u64 {\n    VAR_COUNTER.fetch_add(1, Ordering::SeqCst)\n}\n\npub trait Converter {\n    fn parse\u003cT: Unpin + Serialize + DeserializeOwned\u003e(self) -\u003e Result\u003cT\u003e;\n}\n\nimpl Converter for serde_json::Value {\n    fn parse\u003cT: Unpin + Serialize + DeserializeOwned\u003e(self) -\u003e Result\u003cT\u003e {\n        Ok(serde_json::from_value(self)?)\n    }\n}\n\npub trait Geometry: Into\u003cCommand\u003e {\n    fn cmd(self) -\u003e Command {\n        self.into()\n    }\n}\n","traces":[{"line":20,"address":[2826944],"length":1,"stats":{"Line":1},"fn_name":"var_counter"},{"line":21,"address":[2745300],"length":1,"stats":{"Line":1},"fn_name":null},{"line":29,"address":[2346624,2336576,2336144,2337744,2350288,2334272,2344240,2334816,2345248,2339904,2347616,2345920,2348512,2335888,2335632,2338272,2344672,2340544,2339056,2344928,2345504,2346176,2335088,2340224,2343344,2339584,2342160,2336416,2347792,2340704,2348960,2342736,2346352,2343920,2342416,2343600,2348784,2338016,2349216,2343760,2337488,2343072,2350016,2335360,2347968,2338528,2342912,2341376,2349760,2337056,2339312,2341120,2346800,2347072,2337232,2334016,2341840,2344080,2344496,2341568,2350560,2336800,2347344,2348240,2349488,2345728,2338800,2334544,2340864],"length":1,"stats":{"Line":70},"fn_name":"parse\u003creql_rust::types::DbResponse\u003e"},{"line":30,"address":[],"length":0,"stats":{"Line":70},"fn_name":null},{"line":35,"address":[2766656],"length":1,"stats":{"Line":2},"fn_name":"cmd\u003creql_rust::cmd::polygon::Polygon\u003e"},{"line":36,"address":[2574683],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":6,"coverable":6},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","proto.rs"],"content":"use std::collections::{HashMap, VecDeque};\nuse std::{fmt, str};\n\nuse ql2::query::QueryType;\nuse ql2::term::TermType;\nuse serde::ser::{self, Serialize, Serializer};\nuse serde_json::value::{Number, Value};\n\nuse crate::cmd::run::{Db, RunOption};\n// use crate::prelude::ReqlOps;\nuse crate::{err, r};\n\n#[derive(Debug, Clone, Eq, PartialEq)]\npub(crate) enum Datum {\n    Null,\n    Bool(bool),\n    Number(Number),\n    String(String),\n    Array(Vec\u003cDatum\u003e),\n    Object(HashMap\u003cString, Datum\u003e),\n}\n\nimpl Default for Datum {\n    fn default() -\u003e Self {\n        Self::Null\n    }\n}\n\nimpl Serialize for Datum {\n    fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    where\n        S: Serializer,\n    {\n        match self {\n            Self::Null =\u003e serializer.serialize_none(),\n            Self::Bool(boolean) =\u003e boolean.serialize(serializer),\n            Self::Number(num) =\u003e num.serialize(serializer),\n            Self::String(string) =\u003e string.serialize(serializer),\n            Self::Array(arr) =\u003e (TermType::MakeArray as i32, arr).serialize(serializer),\n            Self::Object(map) =\u003e map.serialize(serializer),\n        }\n    }\n}\n\nimpl From\u003cValue\u003e for Datum {\n    fn from(value: Value) -\u003e Self {\n        match value {\n            Value::Null =\u003e Self::Null,\n            Value::Bool(boolean) =\u003e Self::Bool(boolean),\n            Value::Number(num) =\u003e Self::Number(num),\n            Value::String(string) =\u003e Self::String(string),\n            Value::Array(arr) =\u003e Self::Array(arr.into_iter().map(Into::into).collect()),\n            Value::Object(map) =\u003e Self::Object(\n                map.into_iter()\n                    .map(|(key, value)| (key, value.into()))\n                    .collect(),\n            ),\n        }\n    }\n}\n\n/// The query that will be sent to RethinkDB\n#[derive(Debug, Clone)]\npub struct Command {\n    typ: TermType,\n    datum: Option\u003csuper::Result\u003cDatum\u003e\u003e,\n    #[doc(hidden)]\n    pub args: VecDeque\u003csuper::Result\u003cCommand\u003e\u003e,\n    opts: Option\u003csuper::Result\u003cDatum\u003e\u003e,\n    change_feed: bool,\n}\n\nimpl Command {\n    #[doc(hidden)]\n    pub fn new(typ: TermType) -\u003e Self {\n        Self {\n            typ,\n            datum: None,\n            args: VecDeque::new(),\n            opts: None,\n            change_feed: false,\n        }\n    }\n\n    #[doc(hidden)]\n    pub fn var(id: u64) -\u003e Self {\n        let index = Self::from_json(id);\n        Self::new(TermType::Var).with_arg(index)\n    }\n\n    pub(crate) fn with_parent(mut self, parent: Command) -\u003e Self {\n        self.change_feed = self.change_feed || parent.change_feed;\n        self.args.push_front(Ok(parent));\n        self\n    }\n\n    #[doc(hidden)]\n    pub fn with_arg(mut self, arg: impl Into\u003cCommand\u003e) -\u003e Self {\n        let arg = arg.into();\n        self.args.push_back(Ok(arg));\n        self\n    }\n\n    pub(crate) fn with_opts\u003cT\u003e(mut self, opts: T) -\u003e Self\n    where\n        T: Serialize,\n    {\n        let opts = serde_json::to_value(\u0026opts)\n            .map(Into::into)\n            .map_err(Into::into);\n        self.opts = Some(opts);\n        self\n    }\n\n    #[doc(hidden)]\n    pub fn from_json\u003cT\u003e(arg: T) -\u003e Self\n    where\n        T: Serialize,\n    {\n        serde_json::to_value(arg)\n            .map_err(super::ReqlError::from)\n            .into()\n    }\n\n    pub(crate) fn mark_change_feed(mut self) -\u003e Self {\n        self.change_feed = true;\n        self\n    }\n\n    pub(crate) fn change_feed(\u0026self) -\u003e bool {\n        self.change_feed\n    }\n}\n\nimpl From\u003cDatum\u003e for Command {\n    fn from(datum: Datum) -\u003e Self {\n        Ok(datum).into()\n    }\n}\n\nimpl From\u003csuper::Result\u003cDatum\u003e\u003e for Command {\n    fn from(result: super::Result\u003cDatum\u003e) -\u003e Self {\n        let mut query = Self::new(TermType::Datum);\n        query.datum = Some(result);\n        query\n    }\n}\n\n#[doc(hidden)]\nimpl From\u003cValue\u003e for Command {\n    fn from(value: Value) -\u003e Self {\n        Datum::from(value).into()\n    }\n}\n\n#[doc(hidden)]\nimpl From\u003csuper::Result\u003cValue\u003e\u003e for Command {\n    fn from(result: super::Result\u003cValue\u003e) -\u003e Self {\n        match result {\n            Ok(value) =\u003e Datum::from(value).into(),\n            Err(error) =\u003e (Err(error) as super::Result\u003cDatum\u003e).into(),\n        }\n    }\n}\n\n#[derive(Debug, Clone)]\npub(crate) struct Query\u003c'a\u003e(pub(crate) \u0026'a Command);\n\nimpl Serialize for Query\u003c'_\u003e {\n    fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    where\n        S: Serializer,\n    {\n        let Query(cmd) = self;\n        match cmd.typ {\n            TermType::Datum =\u003e match \u0026cmd.datum {\n                Some(Ok(datum)) =\u003e datum.serialize(serializer),\n                Some(Err(error)) =\u003e Err(ser::Error::custom(error)),\n                _ =\u003e (None as Option\u003cDatum\u003e).serialize(serializer),\n            },\n            _ =\u003e {\n                let typ = cmd.typ as i32;\n                match \u0026cmd.opts {\n                    Some(Ok(map)) =\u003e (\n                        typ,\n                        to_query_result(\u0026cmd.args).map_err(ser::Error::custom)?,\n                        map,\n                    )\n                        .serialize(serializer),\n                    None =\u003e (typ, to_query_result(\u0026cmd.args).map_err(ser::Error::custom)?)\n                        .serialize(serializer),\n                    Some(Err(error)) =\u003e Err(ser::Error::custom(error)),\n                }\n            }\n        }\n    }\n}\n\nfn to_query_result(args: \u0026VecDeque\u003csuper::Result\u003cCommand\u003e\u003e) -\u003e super::Result\u003cVec\u003cQuery\u003c'_\u003e\u003e\u003e {\n    let mut vec = Vec::with_capacity(args.len());\n    for result in args {\n        let arg = result.as_ref().map_err(|error| error.clone())?;\n        vec.push(Query(arg));\n    }\n    Ok(vec)\n}\n\n#[derive(Debug, Clone)]\npub(crate) struct Payload\u003c'a\u003e(\n    pub(crate) QueryType,\n    pub(crate) Option\u003cQuery\u003c'a\u003e\u003e,\n    pub(crate) RunOption,\n);\n\nimpl Serialize for Payload\u003c'_\u003e {\n    fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    where\n        S: Serializer,\n    {\n        let Payload(typ, qry, opts) = self;\n        let typ = *typ as i32;\n        match qry {\n            Some(query) =\u003e (typ, query, opts).serialize(serializer),\n            None =\u003e (typ,).serialize(serializer),\n        }\n    }\n}\n\nimpl Payload\u003c'_\u003e {\n    pub(crate) fn to_bytes(\u0026self) -\u003e Result\u003cVec\u003cu8\u003e, err::ReqlError\u003e {\n        Ok(serde_json::to_vec(self)?)\n    }\n}\n\n// for debugging purposes only\nimpl fmt::Display for Payload\u003c'_\u003e {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        // print the serialised string if we can\n        if let Ok(payload) = self.to_bytes() {\n            if let Ok(payload) = str::from_utf8(\u0026payload) {\n                return write!(f, \"{}\", payload);\n            }\n        }\n        // otherwise just print the debug form\n        write!(f, \"{:?}\", self)\n    }\n}\n\nimpl Serialize for Db {\n    fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    where\n        S: Serializer,\n    {\n        let Self(name) = self;\n        let cmd = r.db(name.as_ref());\n        Query(\u0026cmd).serialize(serializer)\n    }\n}\n","traces":[{"line":24,"address":[2165776],"length":1,"stats":{"Line":0},"fn_name":"default"},{"line":25,"address":[2165779],"length":1,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[2033600,2034053],"length":1,"stats":{"Line":10},"fn_name":"serialize\u003c\u0026mut serde_json::ser::Serializer\u003c\u0026mut alloc::vec::Vec\u003cu8, alloc::alloc::Global\u003e, serde_json::ser::CompactFormatter\u003e\u003e"},{"line":34,"address":[2033627],"length":1,"stats":{"Line":10},"fn_name":null},{"line":35,"address":[2034046,2033673],"length":1,"stats":{"Line":2},"fn_name":null},{"line":36,"address":[2033707,2034034],"length":1,"stats":{"Line":2},"fn_name":null},{"line":37,"address":[2034022,2033753],"length":1,"stats":{"Line":4},"fn_name":null},{"line":38,"address":[2034010,2033799],"length":1,"stats":{"Line":14},"fn_name":null},{"line":39,"address":[2033845,2033998],"length":1,"stats":{"Line":4},"fn_name":null},{"line":40,"address":[2033975,2033906],"length":1,"stats":{"Line":14},"fn_name":null},{"line":46,"address":[2165792],"length":1,"stats":{"Line":10},"fn_name":"from"},{"line":47,"address":[2165814],"length":1,"stats":{"Line":10},"fn_name":null},{"line":48,"address":[2165850],"length":1,"stats":{"Line":1},"fn_name":null},{"line":49,"address":[2165868],"length":1,"stats":{"Line":1},"fn_name":null},{"line":50,"address":[2165909],"length":1,"stats":{"Line":2},"fn_name":null},{"line":51,"address":[2165972],"length":1,"stats":{"Line":7},"fn_name":null},{"line":52,"address":[2166049,2166339],"length":1,"stats":{"Line":4},"fn_name":null},{"line":54,"address":[2166195],"length":1,"stats":{"Line":7},"fn_name":null},{"line":55,"address":[2034080,2034104],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":75,"address":[2166640,2166416],"length":1,"stats":{"Line":11},"fn_name":"new"},{"line":79,"address":[2166453],"length":1,"stats":{"Line":11},"fn_name":null},{"line":86,"address":[2166914,2166672,2166883],"length":1,"stats":{"Line":1},"fn_name":"var"},{"line":87,"address":[2166697],"length":1,"stats":{"Line":1},"fn_name":null},{"line":88,"address":[2166724,2166795],"length":1,"stats":{"Line":2},"fn_name":null},{"line":91,"address":[2167177,2166928],"length":1,"stats":{"Line":3},"fn_name":"with_parent"},{"line":92,"address":[2166955],"length":1,"stats":{"Line":3},"fn_name":null},{"line":93,"address":[2167008],"length":1,"stats":{"Line":3},"fn_name":null},{"line":94,"address":[2167154],"length":1,"stats":{"Line":3},"fn_name":null},{"line":98,"address":[2034610,2034336],"length":1,"stats":{"Line":8},"fn_name":"with_arg\u003creql_rust::proto::Command\u003e"},{"line":99,"address":[2034396],"length":1,"stats":{"Line":8},"fn_name":null},{"line":100,"address":[2034465],"length":1,"stats":{"Line":8},"fn_name":null},{"line":101,"address":[2034587],"length":1,"stats":{"Line":8},"fn_name":null},{"line":104,"address":[1489008,1489533,1489490],"length":1,"stats":{"Line":39},"fn_name":"with_opts\u003creql_rust::cmd::table::TableOption\u003e"},{"line":108,"address":[1489121,1489042],"length":1,"stats":{"Line":78},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[1489171],"length":1,"stats":{"Line":39},"fn_name":null},{"line":112,"address":[1489409],"length":1,"stats":{"Line":39},"fn_name":null},{"line":116,"address":[2036144,2036432,2036816,2037008,2036528,2037168,2037296,2036224,2035952,2036336,2036896,2036032,2036704,2037088,2035872,2036608],"length":1,"stats":{"Line":45},"fn_name":"from_json\u003cisize\u003e"},{"line":120,"address":[2036366,2037185,2036720,2036836,2036639,2036547,2037026,2036925,2036048,2036240,2035890,2037106,2036162,2035970,2037313,2036457],"length":1,"stats":{"Line":45},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":125,"address":[2167216],"length":1,"stats":{"Line":0},"fn_name":"mark_change_feed"},{"line":126,"address":[2167224],"length":1,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[2167231],"length":1,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[2167248],"length":1,"stats":{"Line":10},"fn_name":"change_feed"},{"line":131,"address":[2167253],"length":1,"stats":{"Line":10},"fn_name":null},{"line":136,"address":[2167280],"length":1,"stats":{"Line":9},"fn_name":"from"},{"line":137,"address":[2167296],"length":1,"stats":{"Line":11},"fn_name":null},{"line":142,"address":[2167376,2167704],"length":1,"stats":{"Line":11},"fn_name":"from"},{"line":143,"address":[2167400],"length":1,"stats":{"Line":11},"fn_name":null},{"line":144,"address":[2167489,2167676],"length":1,"stats":{"Line":22},"fn_name":null},{"line":151,"address":[2167760],"length":1,"stats":{"Line":0},"fn_name":"from"},{"line":152,"address":[2167773],"length":1,"stats":{"Line":0},"fn_name":null},{"line":158,"address":[2167856],"length":1,"stats":{"Line":3},"fn_name":"from"},{"line":159,"address":[2167878],"length":1,"stats":{"Line":4},"fn_name":null},{"line":160,"address":[2167897,2168132],"length":1,"stats":{"Line":19},"fn_name":null},{"line":161,"address":[2168005],"length":1,"stats":{"Line":0},"fn_name":null},{"line":170,"address":[2038154,2037376,2038741],"length":1,"stats":{"Line":10},"fn_name":"serialize\u003c\u0026mut serde_json::ser::Serializer\u003c\u0026mut alloc::vec::Vec\u003cu8, alloc::alloc::Global\u003e, serde_json::ser::CompactFormatter\u003e\u003e"},{"line":174,"address":[2037404],"length":1,"stats":{"Line":10},"fn_name":null},{"line":175,"address":[2037436],"length":1,"stats":{"Line":10},"fn_name":null},{"line":176,"address":[2037453,2038567],"length":1,"stats":{"Line":15},"fn_name":null},{"line":177,"address":[2038642,2038731],"length":1,"stats":{"Line":18},"fn_name":null},{"line":178,"address":[2038683],"length":1,"stats":{"Line":0},"fn_name":null},{"line":179,"address":[2038584],"length":1,"stats":{"Line":0},"fn_name":null},{"line":181,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":182,"address":[2037506],"length":1,"stats":{"Line":10},"fn_name":null},{"line":183,"address":[2037602,2037526],"length":1,"stats":{"Line":17},"fn_name":null},{"line":184,"address":[2037979,2037924,2038130,2037624],"length":1,"stats":{"Line":28},"fn_name":null},{"line":185,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":186,"address":[2037641,2037770,2038003,2038074],"length":1,"stats":{"Line":14},"fn_name":null},{"line":187,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":189,"address":[2037971,2038084,2038135,2038042,2038165],"length":1,"stats":{"Line":21},"fn_name":null},{"line":190,"address":[2038533,2038170,2038464,2038366,2037568],"length":1,"stats":{"Line":18},"fn_name":null},{"line":191,"address":[2038358,2038487,2038538,2038432],"length":1,"stats":{"Line":10},"fn_name":null},{"line":192,"address":[2037746,2037672],"length":1,"stats":{"Line":0},"fn_name":null},{"line":199,"address":[2168160,2168841],"length":1,"stats":{"Line":5},"fn_name":"to_query_result"},{"line":200,"address":[2168198],"length":1,"stats":{"Line":5},"fn_name":null},{"line":201,"address":[2168287,2168487,2168230],"length":1,"stats":{"Line":30},"fn_name":null},{"line":202,"address":[2038784,2038768],"length":1,"stats":{"Line":10},"fn_name":"{closure#0}"},{"line":203,"address":[2168836,2168623],"length":1,"stats":{"Line":20},"fn_name":null},{"line":205,"address":[2168400],"length":1,"stats":{"Line":10},"fn_name":null},{"line":216,"address":[2038800],"length":1,"stats":{"Line":10},"fn_name":"serialize\u003c\u0026mut serde_json::ser::Serializer\u003c\u0026mut alloc::vec::Vec\u003cu8, alloc::alloc::Global\u003e, serde_json::ser::CompactFormatter\u003e\u003e"},{"line":220,"address":[2038822],"length":1,"stats":{"Line":10},"fn_name":null},{"line":221,"address":[2038866],"length":1,"stats":{"Line":10},"fn_name":null},{"line":222,"address":[2038880],"length":1,"stats":{"Line":10},"fn_name":null},{"line":223,"address":[2038950],"length":1,"stats":{"Line":10},"fn_name":null},{"line":224,"address":[2038909],"length":1,"stats":{"Line":0},"fn_name":null},{"line":230,"address":[2168880],"length":1,"stats":{"Line":10},"fn_name":"to_bytes"},{"line":231,"address":[2168905,2169060],"length":1,"stats":{"Line":10},"fn_name":null},{"line":237,"address":[2169755,2169776,2169104],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":239,"address":[2169129],"length":1,"stats":{"Line":0},"fn_name":null},{"line":240,"address":[2169202,2169302],"length":1,"stats":{"Line":0},"fn_name":null},{"line":241,"address":[2169364,2169643],"length":1,"stats":{"Line":0},"fn_name":null},{"line":245,"address":[2169488,2169538],"length":1,"stats":{"Line":0},"fn_name":null},{"line":250,"address":[2732816,2733063,2733087],"length":1,"stats":{"Line":0},"fn_name":"serialize\u003c\u0026mut serde_json::ser::Serializer\u003c\u0026mut alloc::vec::Vec\u003cu8, alloc::alloc::Global\u003e, serde_json::ser::CompactFormatter\u003e\u003e"},{"line":254,"address":[2732844],"length":1,"stats":{"Line":0},"fn_name":null},{"line":255,"address":[2732940,2732868],"length":1,"stats":{"Line":0},"fn_name":null},{"line":256,"address":[2732966],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":71,"coverable":98},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","spec.rs"],"content":"use serde::{Deserialize, Serialize};\nuse serde_json::json;\nuse uuid::Uuid;\n\nuse crate::arguments::Durability;\nuse crate::cmd::insert::InsertOption;\nuse crate::{args, r, Command, Result, Session};\n\npub async fn set_up(with_data: bool) -\u003e Result\u003c(Session, Command, String)\u003e {\n    let table_name = Uuid::new_v4().to_string();\n    let user_rethinkdb = json!({\n        \"id\": \"malik\",\n        \"password\": \"malik\"\n    });\n    let conn = r.connection().connect().await?;\n    let table = r.table(table_name.as_str());\n\n    r.table_create(table_name.as_str()).run(\u0026conn).await?;\n    r.db(\"rethinkdb\")\n        .table(\"users\")\n        .insert(user_rethinkdb)\n        .run(\u0026conn)\n        .await?;\n\n    if with_data {\n        let data = Post::get_many_data();\n        let insert_option = InsertOption::default().durability(Durability::Soft);\n\n        table.clone().index_create(\"title\").run(\u0026conn).await?;\n        table.clone().index_wait(()).run(\u0026conn).await?;\n        table\n            .clone()\n            .insert(args!(data, insert_option))\n            .run(\u0026conn)\n            .await?;\n    }\n\n    Ok((conn, table, table_name))\n}\n\npub async fn tear_down(conn: Session, table_name: \u0026str) -\u003e Result\u003c()\u003e {\n    r.table_drop(table_name).run(\u0026conn).await?;\n    r.db(\"rethinkdb\")\n        .table(\"users\")\n        .get(\"malik\")\n        .delete(())\n        .run(\u0026conn)\n        .await?;\n    Ok(())\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]\npub struct Post {\n    pub id: u8,\n    pub title: String,\n    pub content: Option\u003cString\u003e,\n    pub view: u8,\n}\n\nimpl Post {\n    pub fn new(id: u8, title: \u0026str, content: Option\u003c\u0026str\u003e, view: u8) -\u003e Self {\n        Self {\n            id,\n            view,\n            title: title.to_string(),\n            content: content.map(String::from),\n        }\n    }\n\n    pub fn get_many_data() -\u003e Vec\u003cSelf\u003e {\n        vec![\n            Self::new(1, \"title1\", Some(\"content1\"), 10),\n            Self::new(2, \"title2\", Some(\"content2\"), 2),\n            Self::new(3, \"title3\", None, 0),\n            Self::new(4, \"title4\", Some(\"content4\"), 2),\n            Self::new(5, \"title4\", None, 0),\n        ]\n    }\n\n    pub fn get_one_data() -\u003e Self {\n        Self::new(1, \"title1\", Some(\"content1\"), 0)\n    }\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]\npub struct Comment {\n    pub id: u8,\n    pub text: String,\n    pub post_id: u8,\n}\n\nimpl Comment {\n    pub fn new(id: u8, content: \u0026str, post_id: u8) -\u003e Self {\n        Self {\n            id,\n            post_id,\n            text: content.to_string(),\n        }\n    }\n\n    pub fn get_many_data() -\u003e Vec\u003cSelf\u003e {\n        vec![\n            Self::new(1, \"comment1\", 1),\n            Self::new(2, \"comment2\", 2),\n            Self::new(3, \"comment3\", 3),\n            Self::new(4, \"comment4\", 2),\n            Self::new(5, \"comment4\", 1),\n        ]\n    }\n\n    pub async fn own_set_up() -\u003e Result\u003c(Session, Command, Command, String, String)\u003e {\n        let comment_tablename = Uuid::new_v4().to_string();\n        let (conn, post_table, post_tablename) = set_up(true).await?;\n        let comment_table = r.table(\u0026comment_tablename);\n\n        r.table_create(comment_tablename.as_str())\n            .run(\u0026conn)\n            .await?;\n        comment_table\n            .clone()\n            .insert(Self::get_many_data())\n            .run(\u0026conn)\n            .await?;\n\n        Ok((\n            conn,\n            comment_table,\n            post_table,\n            comment_tablename,\n            post_tablename,\n        ))\n    }\n\n    pub async fn own_tear_down(\n        conn: Session,\n        comment_tablename: String,\n        post_tablename: String,\n    ) -\u003e Result\u003c()\u003e {\n        r.table_drop(\u0026comment_tablename).run(\u0026conn).await?;\n        tear_down(conn, \u0026post_tablename).await\n    }\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]\npub struct CommentWithPost {\n    pub id: u8,\n    pub text: String,\n    pub post_id: u8,\n    pub title: String,\n    pub content: Option\u003cString\u003e,\n    pub view: u8,\n}\n","traces":[{"line":9,"address":[5071028,5064946,5063824,5063893,5064022,5064459],"length":1,"stats":{"Line":5},"fn_name":"{async_fn#0}"},{"line":10,"address":[5064000,5064587],"length":1,"stats":{"Line":2},"fn_name":null},{"line":11,"address":[5065048,5065233,5064982,5064602,5064657,5064720,5064927],"length":1,"stats":{"Line":11},"fn_name":null},{"line":15,"address":[5065878,5065335,5064052,5065406,5064419],"length":1,"stats":{"Line":11},"fn_name":null},{"line":16,"address":[5066121,5065858],"length":1,"stats":{"Line":10},"fn_name":null},{"line":18,"address":[5066140,5066202,5064371,5064073],"length":1,"stats":{"Line":16},"fn_name":null},{"line":19,"address":[5066997,5067253,5067327,5067095,5066924,5067736,5067528,5067130],"length":1,"stats":{"Line":7},"fn_name":null},{"line":21,"address":[5067040],"length":1,"stats":{"Line":1},"fn_name":null},{"line":22,"address":[5064323,5067283,5067110,5067455,5064094,5067153],"length":1,"stats":{"Line":6},"fn_name":null},{"line":23,"address":[5067618,5067766],"length":1,"stats":{"Line":1},"fn_name":null},{"line":25,"address":[5067806,5070747],"length":1,"stats":{"Line":2},"fn_name":null},{"line":26,"address":[5067828],"length":1,"stats":{"Line":1},"fn_name":null},{"line":27,"address":[5067967,5067892],"length":1,"stats":{"Line":2},"fn_name":null},{"line":29,"address":[5068112,5068066,5064272,5064115],"length":1,"stats":{"Line":4},"fn_name":null},{"line":30,"address":[5064136,5068877,5064221,5068939],"length":1,"stats":{"Line":4},"fn_name":null},{"line":31,"address":[5070094,5070503,5070017,5069894,5070295,5069653,5069859],"length":1,"stats":{"Line":6},"fn_name":null},{"line":33,"address":[5069707],"length":1,"stats":{"Line":1},"fn_name":null},{"line":34,"address":[5070050,5064154,5069917,5070222,5069874],"length":1,"stats":{"Line":5},"fn_name":null},{"line":35,"address":[5070533,5070385],"length":1,"stats":{"Line":1},"fn_name":null},{"line":38,"address":[5070808],"length":1,"stats":{"Line":1},"fn_name":null},{"line":41,"address":[5072066,5072914,5072112,5073017,5071182,5071602,5071083,5071040,5071315],"length":1,"stats":{"Line":5},"fn_name":"{async_fn#0}"},{"line":42,"address":[5071172,5071277,5071407,5071613,5071206],"length":1,"stats":{"Line":4},"fn_name":null},{"line":43,"address":[5072150,5072080,5072379,5072450,5072639,5072268,5072847],"length":1,"stats":{"Line":6},"fn_name":null},{"line":47,"address":[5071221,5072248,5072578,5072291,5072409],"length":1,"stats":{"Line":5},"fn_name":null},{"line":48,"address":[5072729,5072877],"length":1,"stats":{"Line":1},"fn_name":null},{"line":49,"address":[5073005],"length":1,"stats":{"Line":1},"fn_name":null},{"line":61,"address":[7359328,7359583],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":65,"address":[7359427],"length":1,"stats":{"Line":3},"fn_name":null},{"line":66,"address":[7359451],"length":1,"stats":{"Line":1},"fn_name":null},{"line":70,"address":[7359616,7360373],"length":1,"stats":{"Line":3},"fn_name":"get_many_data"},{"line":71,"address":[7359961,7359633,7360191,7359855,7359737,7360082],"length":1,"stats":{"Line":1},"fn_name":null},{"line":72,"address":[7359663],"length":1,"stats":{"Line":3},"fn_name":null},{"line":73,"address":[7359769],"length":1,"stats":{"Line":3},"fn_name":null},{"line":74,"address":[7359887],"length":1,"stats":{"Line":1},"fn_name":null},{"line":75,"address":[7359990],"length":1,"stats":{"Line":3},"fn_name":null},{"line":76,"address":[7360114],"length":1,"stats":{"Line":1},"fn_name":null},{"line":80,"address":[7360416],"length":1,"stats":{"Line":1},"fn_name":"get_one_data"},{"line":81,"address":[7360428],"length":1,"stats":{"Line":1},"fn_name":null},{"line":93,"address":[7360512],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":97,"address":[7360580],"length":1,"stats":{"Line":1},"fn_name":null},{"line":101,"address":[7360656,7361294],"length":1,"stats":{"Line":1},"fn_name":"get_many_data"},{"line":102,"address":[7360878,7360741,7360950,7360673,7360811,7361025],"length":1,"stats":{"Line":1},"fn_name":null},{"line":103,"address":[7360703],"length":1,"stats":{"Line":1},"fn_name":null},{"line":104,"address":[7360773],"length":1,"stats":{"Line":1},"fn_name":null},{"line":105,"address":[7360840],"length":1,"stats":{"Line":1},"fn_name":null},{"line":106,"address":[7360907],"length":1,"stats":{"Line":1},"fn_name":null},{"line":107,"address":[7360979],"length":1,"stats":{"Line":1},"fn_name":null},{"line":111,"address":[5073109,5073426,5076762,5073805,5073040,5073196],"length":1,"stats":{"Line":5},"fn_name":"{async_fn#0}"},{"line":112,"address":[5073554,5073166],"length":1,"stats":{"Line":2},"fn_name":null},{"line":113,"address":[5073383,5073226,5074209,5073816,5073638,5073574],"length":1,"stats":{"Line":4},"fn_name":null},{"line":114,"address":[5074189],"length":1,"stats":{"Line":1},"fn_name":null},{"line":116,"address":[5074955,5074754,5074445,5075163,5074677,5074554,5074519],"length":1,"stats":{"Line":6},"fn_name":null},{"line":117,"address":[5074882,5073332,5073247,5074534,5074577,5074710],"length":1,"stats":{"Line":6},"fn_name":null},{"line":118,"address":[5075193,5075045],"length":1,"stats":{"Line":1},"fn_name":null},{"line":119,"address":[5075912,5076120,5075394,5075255,5075469,5075634,5075711],"length":1,"stats":{"Line":6},"fn_name":null},{"line":121,"address":[5075353,5075484,5075302,5075441],"length":1,"stats":{"Line":2},"fn_name":null},{"line":122,"address":[5073265,5075537,5075667,5075839,5075449],"length":1,"stats":{"Line":5},"fn_name":null},{"line":123,"address":[5076002,5076150],"length":1,"stats":{"Line":1},"fn_name":null},{"line":125,"address":[5076553],"length":1,"stats":{"Line":1},"fn_name":null},{"line":126,"address":[5076396],"length":1,"stats":{"Line":1},"fn_name":null},{"line":127,"address":[5076405],"length":1,"stats":{"Line":1},"fn_name":null},{"line":128,"address":[5076438],"length":1,"stats":{"Line":1},"fn_name":null},{"line":129,"address":[5076473],"length":1,"stats":{"Line":1},"fn_name":null},{"line":130,"address":[5076508],"length":1,"stats":{"Line":1},"fn_name":null},{"line":134,"address":[7361408],"length":1,"stats":{"Line":1},"fn_name":"own_tear_down"},{"line":139,"address":[5077038,5077181,5076923,5077399,5076967],"length":1,"stats":{"Line":4},"fn_name":null},{"line":140,"address":[5078100,5078295,5078168,5076982],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":67,"coverable":67},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","types","binary.rs"],"content":"use serde::{Deserialize, Serialize};\n\nuse super::ReqlType;\n\n#[derive(Debug, Serialize, Deserialize, Clone)]\npub struct Binary {\n    #[serde(rename = \"$reql_type$\")]\n    reql_type: ReqlType,\n    pub data: String,\n}\n\nimpl Binary {\n    pub fn new(bytes: \u0026[u8]) -\u003e Self {\n        Self {\n            reql_type: ReqlType::Binary,\n            data: base64::encode(bytes),\n        }\n    }\n}\n","traces":[{"line":13,"address":[2775088],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":16,"address":[2775117],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":2,"coverable":2},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","types","datetime.rs"],"content":"use std::fmt::Debug;\nuse std::hash::Hash;\nuse std::ops::Deref;\n\nuse serde::{de, Deserialize, Deserializer, Serialize, Serializer};\nuse time::format_description::well_known::Iso8601;\nuse time::macros::time;\nuse time::{format_description, OffsetDateTime, UtcOffset};\n\nuse crate::arguments::Args;\nuse crate::constants::{HOUR, MINUTE, NANOS_PER_MSEC, NANOS_PER_SEC, TIMEZONE_FORMAT};\nuse crate::{cmd, Command};\n\nuse super::response_with_cmd::ResponseWithCmd;\nuse super::Time;\n\n#[derive(Clone)]\npub struct DateTime(pub OffsetDateTime, pub Option\u003cCommand\u003e);\n\nimpl DateTime {\n    pub(crate) fn now() -\u003e Self {\n        let offset_datetime = OffsetDateTime::now_utc();\n\n        Self::default().create_datetime_command(Some(offset_datetime), Some(cmd::now::new()))\n    }\n\n    pub(crate) fn time(args: impl cmd::time::TimeArg) -\u003e Self {\n        let (offset_datetime, timezone_formated, with_time) = args.into_time_opts();\n\n        Self::default().create_datetime_command(\n            Some(offset_datetime),\n            Some(cmd::time::new(\n                offset_datetime,\n                timezone_formated,\n                with_time,\n            )),\n        )\n    }\n\n    pub(crate) fn epoch_time(timestamp: i64) -\u003e crate::Result\u003cSelf\u003e {\n        let offset_datetime = OffsetDateTime::from_unix_timestamp(timestamp)?;\n\n        Ok(Self::default().create_datetime_command(\n            Some(offset_datetime),\n            Some(cmd::epoch_time::epoch_time(timestamp)),\n        ))\n    }\n\n    pub(crate) fn iso8601(args: impl cmd::iso8601::Iso8601) -\u003e crate::Result\u003cSelf\u003e {\n        let datetime = args.into_iso8601_opts()?;\n        let command = cmd::iso8601::new(\u0026datetime);\n        let datetime = OffsetDateTime::parse(\u0026datetime, \u0026Iso8601::DEFAULT)?;\n\n        Ok(Self::default().create_datetime_command(Some(datetime), Some(command)))\n    }\n\n    pub fn in_timezone(self, timezone: UtcOffset) -\u003e Self {\n        let datetime = self.0.replace_offset(timezone);\n\n        self.clone().create_datetime_command(\n            Some(datetime),\n            Some(cmd::in_timezone::new(timezone).with_parent(self.cmd())),\n        )\n    }\n\n    pub fn timezone(self) -\u003e ResponseWithCmd\u003cUtcOffset\u003e {\n        ResponseWithCmd(\n            self.0.offset(),\n            cmd::timezone::new().with_parent(self.cmd()),\n        )\n    }\n\n    pub fn during(\n        self,\n        start_time: DateTime,\n        end_time: DateTime,\n        during_option: Option\u003ccmd::during::DuringOption\u003e,\n    ) -\u003e ResponseWithCmd\u003cbool\u003e {\n        let is_verified = self.le(\u0026end_time) \u0026\u0026 self.gt(\u0026start_time);\n\n        ResponseWithCmd(\n            is_verified,\n            cmd::during::new(Args((start_time, end_time, during_option))).with_parent(self.cmd()),\n        )\n    }\n\n    pub fn date(self) -\u003e Self {\n        let datetime = self.0.replace_time(time!(00:00));\n\n        self.clone().create_datetime_command(\n            Some(datetime),\n            Some(cmd::date::new().with_parent(self.cmd())),\n        )\n    }\n\n    pub fn time_of_day(self) -\u003e ResponseWithCmd\u003cf64\u003e {\n        let time_ = self.0.time();\n        let milliseconds = get_milliseconds(\u0026time_);\n        let hours: f64 = time_.hour().into();\n        let minutes: f64 = time_.minute().into();\n        let seconds: f64 = time_.second().into();\n        let seconds: f64 = hours * HOUR + minutes * MINUTE + seconds;\n\n        ResponseWithCmd(\n            seconds + milliseconds,\n            cmd::time_of_day::new().with_parent(self.cmd()),\n        )\n    }\n\n    pub fn year(self) -\u003e ResponseWithCmd\u003ci32\u003e {\n        ResponseWithCmd(\n            self.0.date().year(),\n            cmd::year::new().with_parent(self.cmd()),\n        )\n    }\n\n    pub fn month(self) -\u003e ResponseWithCmd\u003cu8\u003e {\n        ResponseWithCmd(\n            self.0.date().month().into(),\n            cmd::month::new().with_parent(self.cmd()),\n        )\n    }\n\n    pub fn day(self) -\u003e ResponseWithCmd\u003cu8\u003e {\n        ResponseWithCmd(self.0.date().day(), cmd::day::new().with_parent(self.cmd()))\n    }\n\n    pub fn day_of_week(self) -\u003e ResponseWithCmd\u003cu8\u003e {\n        ResponseWithCmd(\n            self.0.date().weekday().number_from_monday(),\n            cmd::day_of_week::new().with_parent(self.cmd()),\n        )\n    }\n\n    pub fn day_of_year(self) -\u003e ResponseWithCmd\u003cu16\u003e {\n        ResponseWithCmd(\n            self.0.date().ordinal(),\n            cmd::day_of_year::new().with_parent(self.cmd()),\n        )\n    }\n\n    pub fn hours(self) -\u003e ResponseWithCmd\u003cu8\u003e {\n        ResponseWithCmd(\n            self.0.time().hour(),\n            cmd::hours::new().with_parent(self.cmd()),\n        )\n    }\n\n    pub fn minutes(self) -\u003e ResponseWithCmd\u003cu8\u003e {\n        ResponseWithCmd(\n            self.0.time().minute(),\n            cmd::minutes::new().with_parent(self.cmd()),\n        )\n    }\n\n    pub fn seconds(self) -\u003e ResponseWithCmd\u003cf64\u003e {\n        let time = self.0.time();\n        let second: f64 = time.second().into();\n\n        ResponseWithCmd(\n            second + get_milliseconds(\u0026time),\n            cmd::seconds::new().with_parent(self.cmd()),\n        )\n    }\n\n    pub fn to_iso8601(self) -\u003e ResponseWithCmd\u003cString\u003e {\n        let iso8601 = self.0.format(\u0026Iso8601::DEFAULT).unwrap();\n\n        ResponseWithCmd(iso8601, cmd::to_iso8601::new().with_parent(self.cmd()))\n    }\n\n    pub fn to_epoch_time(self) -\u003e ResponseWithCmd\u003cf64\u003e {\n        let milliseconds = get_milliseconds(\u0026self.0.time());\n        let current_time = self.0.unix_timestamp().to_string();\n        let current_time: f64 = current_time.parse().unwrap_or_default();\n\n        ResponseWithCmd(\n            current_time + milliseconds,\n            cmd::to_epoch_time::new().with_parent(self.cmd()),\n        )\n    }\n\n    fn create_datetime_command(\n        mut self,\n        offset_datetime: Option\u003cOffsetDateTime\u003e,\n        command: Option\u003cCommand\u003e,\n    ) -\u003e Self {\n        if let Some(command) = command {\n            self.1 = Some(command);\n        }\n\n        if let Some(offset_datetime) = offset_datetime {\n            self.0 = offset_datetime\n        }\n\n        self\n    }\n\n    pub fn cmd(self) -\u003e Command {\n        Command::from(self)\n    }\n\n    pub fn value(self) -\u003e Time {\n        Time::from(self)\n    }\n}\n\nimpl\u003c'de\u003e Deserialize\u003c'de\u003e for DateTime {\n    fn deserialize\u003cD\u003e(deserializer: D) -\u003e Result\u003cSelf, D::Error\u003e\n    where\n        D: Deserializer\u003c'de\u003e,\n    {\n        let time = Time::deserialize(deserializer)?;\n        let epoch_time = time.epoch_time.to_string();\n        let format = match format_description::parse(\"[offset_hour]:[offset_minute]\") {\n            Ok(fmt) =\u003e fmt,\n            Err(error) =\u003e {\n                return Err(de::Error::custom(error));\n            }\n        };\n        let offset = match UtcOffset::parse(\u0026time.timezone, \u0026format) {\n            Ok(offset) =\u003e offset,\n            Err(error) =\u003e {\n                return Err(de::Error::custom(error));\n            }\n        };\n        let (secs, msecs) = match epoch_time.split_once('.') {\n            Some(parts) =\u003e parts,\n            None =\u003e (epoch_time.as_str(), \"0\"),\n        };\n        let secs = match secs.parse::\u003ci128\u003e() {\n            Ok(secs) =\u003e match secs.checked_mul(NANOS_PER_SEC) {\n                Some(secs) =\u003e secs,\n                None =\u003e {\n                    return Err(de::Error::custom(\"seconds to nanosecond overflow\"));\n                }\n            },\n            Err(..) =\u003e {\n                return Err(de::Error::custom(\"invalid epoch time seconds\"));\n            }\n        };\n        // RethinkDB timestamps have millisecond precision so we need\n        // to convert the milliseconds to nanoseconds first\n        let msecs = match msecs.parse::\u003ci128\u003e() {\n            Ok(int) =\u003e {\n                let msecs = match msecs.len() {\n                    3 =\u003e int,\n                    2 =\u003e int * 10,\n                    1 =\u003e int * 100,\n                    _ =\u003e {\n                        return Err(de::Error::custom(\"invalid epoch milliseconds\"));\n                    }\n                };\n                match msecs.checked_mul(NANOS_PER_MSEC) {\n                    Some(msecs) =\u003e msecs,\n                    None =\u003e {\n                        return Err(de::Error::custom(\"millisecond to nanosecond overflow\"));\n                    }\n                }\n            }\n            Err(..) =\u003e {\n                return Err(de::Error::custom(\"invalid epoch time milliseconds\"));\n            }\n        };\n        let timestamp = match secs.checked_add(msecs) {\n            Some(timestamp) =\u003e timestamp,\n            None =\u003e {\n                return Err(de::Error::custom(\"timestamp addition overflow\"));\n            }\n        };\n        let dt = match OffsetDateTime::from_unix_timestamp_nanos(timestamp) {\n            Ok(date_time) =\u003e date_time.to_offset(offset),\n            Err(error) =\u003e {\n                return Err(de::Error::custom(error));\n            }\n        };\n        Ok(DateTime(dt, None))\n    }\n}\n\nimpl Serialize for DateTime {\n    fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    where\n        S: Serializer,\n    {\n        Time::from(self.to_owned()).serialize(serializer)\n    }\n}\n\nimpl Default for DateTime {\n    fn default() -\u003e Self {\n        let offset_datetime = OffsetDateTime::now_utc();\n\n        Self(offset_datetime, None)\n    }\n}\n\nimpl Debug for DateTime {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        f.debug_tuple(\"DateTime\").field(\u0026self.0).finish()\n    }\n}\n\nimpl Deref for DateTime {\n    type Target = OffsetDateTime;\n\n    fn deref(\u0026self) -\u003e \u0026Self::Target {\n        \u0026self.0\n    }\n}\n\nimpl PartialEq for DateTime {\n    fn eq(\u0026self, other: \u0026Self) -\u003e bool {\n        self.0.eq(\u0026other.0)\n    }\n}\n\nimpl PartialOrd for DateTime {\n    fn partial_cmp(\u0026self, other: \u0026Self) -\u003e Option\u003cstd::cmp::Ordering\u003e {\n        self.0.partial_cmp(\u0026other.0)\n    }\n}\n\nimpl Eq for DateTime {}\n\nimpl Ord for DateTime {\n    fn cmp(\u0026self, other: \u0026Self) -\u003e std::cmp::Ordering {\n        self.0.cmp(\u0026other.0)\n    }\n}\n\nimpl Hash for DateTime {\n    fn hash\u003cH: std::hash::Hasher\u003e(\u0026self, state: \u0026mut H) {\n        self.0.hash(state);\n    }\n}\n\nimpl From\u003cOffsetDateTime\u003e for DateTime {\n    fn from(dt: OffsetDateTime) -\u003e Self {\n        Self(dt, None)\n    }\n}\n\nimpl From\u003cDateTime\u003e for OffsetDateTime {\n    fn from(DateTime(dt, _): DateTime) -\u003e Self {\n        dt\n    }\n}\n\nimpl From\u003cDateTime\u003e for Command {\n    fn from(date_time: DateTime) -\u003e Self {\n        date_time.1.unwrap()\n    }\n}\n\nimpl From\u003cDateTime\u003e for Time {\n    fn from(date_time: DateTime) -\u003e Self {\n        Self::from(date_time.0)\n    }\n}\n\npub fn timezone_to_string(timezone: UtcOffset) -\u003e String {\n    if timezone.is_utc() {\n        String::from(\"Z\")\n    } else {\n        let format = format_description::parse(TIMEZONE_FORMAT).unwrap();\n        timezone.format(\u0026format).unwrap()\n    }\n}\n\nfn get_milliseconds(time: \u0026time::Time) -\u003e f64 {\n    let milliseconds: f64 = time.millisecond().into();\n\n    milliseconds / 1000.\n}\n","traces":[{"line":21,"address":[2446441,2446472,2446208],"length":1,"stats":{"Line":1},"fn_name":"now"},{"line":22,"address":[2446225],"length":1,"stats":{"Line":1},"fn_name":null},{"line":24,"address":[2446244,2446456],"length":1,"stats":{"Line":1},"fn_name":null},{"line":27,"address":[1765792,1766256,1766782,1766304],"length":1,"stats":{"Line":2},"fn_name":"time\u003creql_rust::arguments::Args\u003c(time::date::Date, time::time::Time, time::utc_offset::UtcOffset)\u003e\u003e"},{"line":28,"address":[1765809,1766336],"length":1,"stats":{"Line":2},"fn_name":null},{"line":30,"address":[1766178,1765921,1766704,1766447],"length":1,"stats":{"Line":4},"fn_name":null},{"line":31,"address":[1766499,1765973],"length":1,"stats":{"Line":2},"fn_name":null},{"line":32,"address":[1766583,1766167,1766057,1766693],"length":1,"stats":{"Line":4},"fn_name":null},{"line":33,"address":[1766010,1766536],"length":1,"stats":{"Line":2},"fn_name":null},{"line":34,"address":[1766023,1766549],"length":1,"stats":{"Line":2},"fn_name":null},{"line":40,"address":[2447001,2446496,2446967],"length":1,"stats":{"Line":1},"fn_name":"epoch_time"},{"line":41,"address":[2446652,2446526],"length":1,"stats":{"Line":1},"fn_name":null},{"line":43,"address":[2446872,2446928,2446628],"length":1,"stats":{"Line":3},"fn_name":null},{"line":44,"address":[2446749],"length":1,"stats":{"Line":1},"fn_name":null},{"line":45,"address":[2446786,2446866],"length":1,"stats":{"Line":2},"fn_name":null},{"line":49,"address":[1767840,1766832,1767801,1768782],"length":1,"stats":{"Line":2},"fn_name":"iso8601\u003creql_rust::arguments::Args\u003c(\u0026str, time::utc_offset::UtcOffset)\u003e\u003e"},{"line":50,"address":[1768008,1767873,1767027,1766849],"length":1,"stats":{"Line":2},"fn_name":null},{"line":51,"address":[1767007,1768160,1767179,1767988],"length":1,"stats":{"Line":4},"fn_name":null},{"line":52,"address":[1768180,1767199,1767382,1767264,1768245,1768363],"length":1,"stats":{"Line":4},"fn_name":null},{"line":54,"address":[1767367,1768348,1767571,1768552],"length":1,"stats":{"Line":4},"fn_name":null},{"line":57,"address":[2447636,2447687,2447024],"length":1,"stats":{"Line":1},"fn_name":"in_timezone"},{"line":58,"address":[2447081],"length":1,"stats":{"Line":1},"fn_name":null},{"line":60,"address":[2447582,2447230],"length":1,"stats":{"Line":2},"fn_name":null},{"line":61,"address":[2447245],"length":1,"stats":{"Line":1},"fn_name":null},{"line":62,"address":[2447380,2447614,2447274],"length":1,"stats":{"Line":2},"fn_name":null},{"line":66,"address":[2447728,2448147],"length":1,"stats":{"Line":1},"fn_name":"timezone"},{"line":68,"address":[2447851,2447750],"length":1,"stats":{"Line":2},"fn_name":null},{"line":69,"address":[2448125,2447904],"length":1,"stats":{"Line":1},"fn_name":null},{"line":73,"address":[2448192,2448904,2448971],"length":1,"stats":{"Line":1},"fn_name":"during"},{"line":79,"address":[2448390,2448268],"length":1,"stats":{"Line":2},"fn_name":null},{"line":82,"address":[2448449],"length":1,"stats":{"Line":1},"fn_name":null},{"line":83,"address":[2448460,2448882],"length":1,"stats":{"Line":1},"fn_name":null},{"line":87,"address":[2449517,2449008,2449568],"length":1,"stats":{"Line":1},"fn_name":"date"},{"line":88,"address":[2449030],"length":1,"stats":{"Line":1},"fn_name":null},{"line":90,"address":[2449160,2449463],"length":1,"stats":{"Line":2},"fn_name":null},{"line":91,"address":[2449175],"length":1,"stats":{"Line":1},"fn_name":null},{"line":92,"address":[2449212,2449262,2449495],"length":1,"stats":{"Line":2},"fn_name":null},{"line":96,"address":[2449600,2450322],"length":1,"stats":{"Line":1},"fn_name":"time_of_day"},{"line":97,"address":[2449725,2449622],"length":1,"stats":{"Line":2},"fn_name":null},{"line":98,"address":[2449751],"length":1,"stats":{"Line":1},"fn_name":null},{"line":99,"address":[2449779],"length":1,"stats":{"Line":1},"fn_name":null},{"line":100,"address":[2449854],"length":1,"stats":{"Line":1},"fn_name":null},{"line":101,"address":[2449929],"length":1,"stats":{"Line":1},"fn_name":null},{"line":102,"address":[2450030],"length":1,"stats":{"Line":1},"fn_name":null},{"line":105,"address":[2450063],"length":1,"stats":{"Line":1},"fn_name":null},{"line":106,"address":[2450081,2450300],"length":1,"stats":{"Line":1},"fn_name":null},{"line":110,"address":[2450368,2450741],"length":1,"stats":{"Line":1},"fn_name":"year"},{"line":112,"address":[2450491,2450390],"length":1,"stats":{"Line":2},"fn_name":null},{"line":113,"address":[2450719,2450514],"length":1,"stats":{"Line":1},"fn_name":null},{"line":117,"address":[2451179,2450784],"length":1,"stats":{"Line":1},"fn_name":"month"},{"line":119,"address":[2450806,2450907],"length":1,"stats":{"Line":2},"fn_name":null},{"line":120,"address":[2450952,2451157],"length":1,"stats":{"Line":1},"fn_name":null},{"line":124,"address":[2451605,2451232],"length":1,"stats":{"Line":1},"fn_name":"day"},{"line":125,"address":[2451583,2451355,2451254],"length":1,"stats":{"Line":2},"fn_name":null},{"line":128,"address":[2452043,2451648],"length":1,"stats":{"Line":1},"fn_name":"day_of_week"},{"line":130,"address":[2451771,2451670],"length":1,"stats":{"Line":2},"fn_name":null},{"line":131,"address":[2451816,2452021],"length":1,"stats":{"Line":1},"fn_name":null},{"line":135,"address":[2452096,2452472],"length":1,"stats":{"Line":1},"fn_name":"day_of_year"},{"line":137,"address":[2452219,2452118],"length":1,"stats":{"Line":2},"fn_name":null},{"line":138,"address":[2452450,2452243],"length":1,"stats":{"Line":1},"fn_name":null},{"line":142,"address":[2452528,2452931],"length":1,"stats":{"Line":1},"fn_name":"hours"},{"line":144,"address":[2452653,2452550],"length":1,"stats":{"Line":2},"fn_name":null},{"line":145,"address":[2452702,2452909],"length":1,"stats":{"Line":1},"fn_name":null},{"line":149,"address":[2452976,2453379],"length":1,"stats":{"Line":1},"fn_name":"minutes"},{"line":151,"address":[2453101,2452998],"length":1,"stats":{"Line":2},"fn_name":null},{"line":152,"address":[2453357,2453150],"length":1,"stats":{"Line":1},"fn_name":null},{"line":156,"address":[2453918,2453424],"length":1,"stats":{"Line":1},"fn_name":"seconds"},{"line":157,"address":[2453446,2453549],"length":1,"stats":{"Line":2},"fn_name":null},{"line":158,"address":[2453570],"length":1,"stats":{"Line":1},"fn_name":null},{"line":161,"address":[2453644],"length":1,"stats":{"Line":1},"fn_name":null},{"line":162,"address":[2453687,2453896],"length":1,"stats":{"Line":1},"fn_name":null},{"line":166,"address":[2453968,2454451],"length":1,"stats":{"Line":1},"fn_name":"to_iso8601"},{"line":167,"address":[2454095,2453990],"length":1,"stats":{"Line":2},"fn_name":null},{"line":169,"address":[2454429,2454123],"length":1,"stats":{"Line":1},"fn_name":null},{"line":172,"address":[2455160,2455184,2454496],"length":1,"stats":{"Line":1},"fn_name":"to_epoch_time"},{"line":173,"address":[2454518,2454621],"length":1,"stats":{"Line":2},"fn_name":null},{"line":174,"address":[2454680],"length":1,"stats":{"Line":1},"fn_name":null},{"line":175,"address":[2454761,2454829],"length":1,"stats":{"Line":2},"fn_name":null},{"line":178,"address":[2454894],"length":1,"stats":{"Line":1},"fn_name":null},{"line":179,"address":[2455138,2454912],"length":1,"stats":{"Line":1},"fn_name":null},{"line":183,"address":[2455778,2455216,2455809],"length":1,"stats":{"Line":1},"fn_name":"create_datetime_command"},{"line":188,"address":[2455248,2455537],"length":1,"stats":{"Line":2},"fn_name":null},{"line":189,"address":[2455381,2455456,2455511],"length":1,"stats":{"Line":2},"fn_name":null},{"line":192,"address":[2455568,2455429],"length":1,"stats":{"Line":2},"fn_name":null},{"line":193,"address":[2455591],"length":1,"stats":{"Line":1},"fn_name":null},{"line":196,"address":[2455663],"length":1,"stats":{"Line":1},"fn_name":null},{"line":199,"address":[2455824],"length":1,"stats":{"Line":1},"fn_name":"cmd"},{"line":200,"address":[2455840],"length":1,"stats":{"Line":1},"fn_name":null},{"line":203,"address":[2455888],"length":1,"stats":{"Line":1},"fn_name":"value"},{"line":204,"address":[2455904],"length":1,"stats":{"Line":1},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":215,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":216,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":217,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":218,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":221,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":222,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":223,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":224,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":227,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":228,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":229,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":231,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":232,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":233,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":234,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":235,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":238,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":239,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":244,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":245,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":246,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":247,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":248,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":249,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":250,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":251,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":254,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":255,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":256,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":257,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":261,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":262,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":265,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":266,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":267,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":268,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":271,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":272,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":273,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":274,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":277,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":286,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":291,"address":[2455952],"length":1,"stats":{"Line":1},"fn_name":"default"},{"line":292,"address":[2455968],"length":1,"stats":{"Line":1},"fn_name":null},{"line":294,"address":[2455983],"length":1,"stats":{"Line":1},"fn_name":null},{"line":299,"address":[2456064],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":300,"address":[2456083],"length":1,"stats":{"Line":0},"fn_name":null},{"line":307,"address":[2456176],"length":1,"stats":{"Line":0},"fn_name":"deref"},{"line":308,"address":[2456184],"length":1,"stats":{"Line":0},"fn_name":null},{"line":313,"address":[2456192],"length":1,"stats":{"Line":0},"fn_name":"eq"},{"line":314,"address":[2456206],"length":1,"stats":{"Line":0},"fn_name":null},{"line":319,"address":[2456256],"length":1,"stats":{"Line":1},"fn_name":"partial_cmp"},{"line":320,"address":[2456270],"length":1,"stats":{"Line":1},"fn_name":null},{"line":327,"address":[2456304],"length":1,"stats":{"Line":0},"fn_name":"cmp"},{"line":328,"address":[2456318],"length":1,"stats":{"Line":0},"fn_name":null},{"line":333,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":334,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":339,"address":[2456352],"length":1,"stats":{"Line":0},"fn_name":"from"},{"line":340,"address":[2456367],"length":1,"stats":{"Line":0},"fn_name":null},{"line":345,"address":[2199680,2199705],"length":1,"stats":{"Line":0},"fn_name":"from"},{"line":351,"address":[2187504],"length":1,"stats":{"Line":1},"fn_name":"from"},{"line":352,"address":[2187520],"length":1,"stats":{"Line":1},"fn_name":null},{"line":357,"address":[2793280,2793367],"length":1,"stats":{"Line":1},"fn_name":"from"},{"line":358,"address":[2793296],"length":1,"stats":{"Line":1},"fn_name":null},{"line":362,"address":[2456448,2456785],"length":1,"stats":{"Line":1},"fn_name":"timezone_to_string"},{"line":363,"address":[2456500],"length":1,"stats":{"Line":1},"fn_name":null},{"line":364,"address":[2456585],"length":1,"stats":{"Line":1},"fn_name":null},{"line":366,"address":[2456556,2456615],"length":1,"stats":{"Line":2},"fn_name":null},{"line":367,"address":[2456746,2456638],"length":1,"stats":{"Line":2},"fn_name":null},{"line":371,"address":[2456816],"length":1,"stats":{"Line":1},"fn_name":"get_milliseconds"},{"line":372,"address":[2456825],"length":1,"stats":{"Line":1},"fn_name":null},{"line":374,"address":[2456879],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":107,"coverable":164},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","types","group_stream.rs"],"content":"use std::fmt::Debug;\n\nuse serde::{de::DeserializeOwned, Deserialize, Serialize};\nuse serde_json::Value;\n\nuse super::ReqlType;\n\n#[derive(Debug, Default, Clone, Serialize, Eq, PartialEq, Ord, PartialOrd, Hash)]\npub struct GroupedStream\u003cG: DeserializeOwned + Serialize, V: DeserializeOwned + Serialize\u003e(\n    Vec\u003cGroupedItem\u003cG, V\u003e\u003e,\n);\n\n#[derive(Debug, Default, Clone, Serialize, Deserialize, Eq, PartialEq, Ord, PartialOrd, Hash)]\npub struct GroupedItem\u003cG, V\u003e {\n    pub group: G,\n    pub values: Vec\u003cV\u003e,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize, Eq, PartialEq)]\nstruct InnerGroup {\n    #[serde(rename = \"$reql_type$\")]\n    reql_type: ReqlType,\n    data: Vec\u003c[Value; 2]\u003e,\n}\n\nimpl\u003c'de, G, V\u003e Deserialize\u003c'de\u003e for GroupedStream\u003cG, V\u003e\nwhere\n    G: DeserializeOwned + Serialize,\n    V: DeserializeOwned + Serialize,\n{\n    fn deserialize\u003cD: serde::Deserializer\u003c'de\u003e\u003e(deserializer: D) -\u003e Result\u003cSelf, D::Error\u003e {\n        Deserialize::deserialize(deserializer).map(|item| {\n            let inner: InnerGroup = item;\n\n            let data: Vec\u003cGroupedItem\u003cG, V\u003e\u003e = inner\n                .data\n                .into_iter()\n                .map(|item| {\n                    let group: G = serde_json::from_value(item[0].clone()).unwrap();\n                    let values: Vec\u003cV\u003e = serde_json::from_value(item[1].clone()).unwrap();\n\n                    GroupedItem { group, values }\n                })\n                .collect();\n\n            GroupedStream(data)\n        })\n    }\n}\n\nimpl\u003cG, V\u003e GroupedStream\u003cG, V\u003e\nwhere\n    G: DeserializeOwned + Serialize,\n    V: DeserializeOwned + Serialize,\n{\n    pub fn collect(self) -\u003e Vec\u003cGroupedItem\u003cG, V\u003e\u003e {\n        self.0\n    }\n}\n\nimpl Default for InnerGroup {\n    fn default() -\u003e Self {\n        Self {\n            reql_type: ReqlType::GroupedData,\n            data: Default::default(),\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use serde::{Deserialize, Serialize};\n\n    use super::GroupedStream;\n\n    #[derive(Serialize, Deserialize, Debug)]\n    struct Posts {\n        id: u8,\n        title: String,\n        content: String,\n        user_id: u8,\n    }\n\n    #[test]\n    fn test_group_stream() {\n        let data = r#\"\n        {\n            \"$reql_type$\": \"GROUPED_DATA\",\n            \"data\": [\n                [\n                    1,\n                    [\n                        {\n                            \"content\": \"content 5\",\n                            \"id\": 5,\n                            \"title\":\"title 5\",\n                            \"user_id\": 1\n                        },\n                        {\n                            \"content\": \"content 3\",\n                            \"id\": 3,\n                            \"title\": \"title 3\",\n                            \"user_id\": 1\n                        },\n                        {\n                            \"content\": \"content 1\",\n                            \"id\": 1,\n                            \"title\": \"title 1\",\n                            \"user_id\": 1\n                        }\n                    ]\n                ],\n                [\n                    2,\n                    [\n                        {\n                            \"content\": \"content 4\",\n                            \"id\": 4,\n                            \"title\": \"title 4\",\n                            \"user_id\": 2\n                        },\n                        {\n                            \"content\": \"content 2\",\n                            \"id\": 2,\n                            \"title\": \"title 2\",\n                            \"user_id\": 2\n                        }\n                    ]\n                ]\n            ]\n        }\n        \"#;\n\n        let elememt: GroupedStream\u003cu8, Posts\u003e = serde_json::from_str(data).unwrap();\n        dbg!(elememt);\n    }\n}\n","traces":[{"line":31,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":33,"address":[2932609,2932369],"length":1,"stats":{"Line":2},"fn_name":null},{"line":35,"address":[2932404,2932644],"length":1,"stats":{"Line":2},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":62,"address":[2800112],"length":1,"stats":{"Line":0},"fn_name":"default"},{"line":65,"address":[2800131],"length":1,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[7335248,7335942],"length":1,"stats":{"Line":3},"fn_name":"test_group_stream"},{"line":86,"address":[7335255],"length":1,"stats":{"Line":1},"fn_name":null},{"line":134,"address":[7335282],"length":1,"stats":{"Line":1},"fn_name":null},{"line":135,"address":[7335335],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":15,"coverable":20},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","types","mod.rs"],"content":"use std::borrow::Cow;\n\nuse serde::{Deserialize, Serialize};\nuse serde_json::Value;\nuse uuid::Uuid;\n\nuse crate::arguments::{Durability, ReadMode};\npub use crate::cmd::geojson::ReqlGeoJson;\npub use crate::cmd::line::Line;\npub use crate::cmd::point::Point;\npub use crate::cmd::polygon::Polygon;\npub use binary::Binary;\npub use datetime::DateTime;\npub use group_stream::{GroupedItem, GroupedStream};\npub use time_::Time;\n\npub(crate) use datetime::timezone_to_string;\n\npub use crate::Command;\n\nmod binary;\nmod datetime;\nmod group_stream;\nmod response_with_cmd;\nmod time_;\n\n#[derive(Debug, Clone, Copy, Serialize, Deserialize, PartialEq, PartialOrd, Eq, Ord)]\n#[non_exhaustive]\n#[serde(rename_all = \"SCREAMING_SNAKE_CASE\")]\npub enum ReqlType {\n    Geometry,\n    GroupedStream,\n    GroupedData,\n    Binary,\n    Time,\n}\n\n#[derive(Debug, Clone, Copy, Serialize, Deserialize, PartialEq, PartialOrd)]\npub enum GeoType {\n    LineString,\n    Point,\n    Polygon,\n}\n\n#[derive(Debug, Default, Clone, Deserialize, Serialize, PartialEq, PartialOrd)]\npub struct ServerInfoResponse {\n    /// the UUID of the server the client is connected to.\n    pub id: Uuid,\n    /// a boolean indicating whether the server is a\n    /// [RethinkDB proxy node](https://rethinkdb.com/docs/sharding-and-replication/#running-a-proxy-node).\n    pub proxy: bool,\n    /// the server name. If `proxy` is `true`, this field will not be returned.\n    pub name: Option\u003cString\u003e,\n}\n\n/// Structure of return data in `db` table\n#[derive(Debug, Default, Clone, Deserialize, Serialize, PartialEq, PartialOrd)]\n#[non_exhaustive]\npub struct DbResponse {\n    pub config_changes: Vec\u003cConfigChange\u003cConfigResponse\u003e\u003e,\n    pub dbs_created: Option\u003cusize\u003e,\n    pub dbs_dropped: Option\u003cusize\u003e,\n    pub tables_created: Option\u003cusize\u003e,\n    pub tables_dropped: Option\u003cusize\u003e,\n}\n\n/// Structure of return data in `db` table\n#[derive(Debug, Default, Clone, Deserialize, Serialize, PartialEq)]\n#[non_exhaustive]\npub struct MutationResponse {\n    pub inserted: usize,\n    pub replaced: usize,\n    pub unchanged: usize,\n    pub skipped: usize,\n    pub deleted: usize,\n    pub errors: usize,\n    pub first_error: Option\u003cString\u003e,\n    pub generated_keys: Option\u003cVec\u003cUuid\u003e\u003e,\n    pub warnings: Option\u003cVec\u003cString\u003e\u003e,\n    pub changes: Option\u003cVec\u003cConfigChange\u003cValue\u003e\u003e\u003e,\n}\n\n/// Structure of return data in `index` table\n#[derive(Debug, Clone, Deserialize, Serialize, Eq, PartialEq, Ord, PartialOrd, Hash)]\n#[non_exhaustive]\npub struct IndexResponse {\n    pub created: Option\u003cusize\u003e,\n    pub dropped: Option\u003cusize\u003e,\n    pub renamed: Option\u003cusize\u003e,\n}\n\n#[derive(Debug, Clone, Copy, Deserialize, Serialize, Eq, PartialEq, Ord, PartialOrd, Hash)]\npub struct SetWriteHookResponse {\n    pub created: Option\u003cusize\u003e,\n    pub deleted: Option\u003cusize\u003e,\n    pub replaced: Option\u003cusize\u003e,\n}\n\n/// Structure of return data in `index_status` table\n#[derive(Debug, Clone, Deserialize, Serialize)]\n#[non_exhaustive]\npub struct IndexStatusResponse {\n    pub geo: bool,\n    pub ready: bool,\n    pub multi: bool,\n    pub outdated: bool,\n    pub progress: Option\u003cf64\u003e,\n    pub index: Cow\u003c'static, str\u003e,\n    pub query: Cow\u003c'static, str\u003e,\n    pub function: Binary,\n}\n\n/// Structure of return data in `index_status` table\n#[derive(Debug, Clone, Deserialize, Serialize)]\n#[non_exhaustive]\npub struct GetWriteHookResponse {\n    pub function: Binary,\n    pub query: Cow\u003c'static, str\u003e,\n}\n\n#[derive(Debug, Clone, Deserialize, Serialize)]\n#[non_exhaustive]\npub struct UngroupItem\u003cG, V\u003e {\n    pub group: G,\n    pub reduction: Vec\u003cV\u003e,\n}\n\n#[derive(Debug, Clone, Deserialize, Serialize)]\npub struct SyncResponse {\n    pub synced: u8,\n}\n\n#[derive(Debug, Clone, Copy, Deserialize, Serialize)]\npub struct WaitResponse {\n    /// The value is an integer indicating the number of tables waited for.\n    /// It will always be `1` when `wait` is called on a table,\n    /// and the total number of tables when called on a database.\n    pub ready: u8,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, PartialOrd)]\npub struct JoinResponse\u003cL, R\u003e {\n    pub left: Option\u003cL\u003e,\n    pub right: Option\u003cR\u003e,\n}\n\n#[derive(Debug, Default, Clone, Serialize, Deserialize, PartialEq, PartialOrd)]\npub struct GrantResponse {\n    /// The granted field will always be 1,\n    pub granted: u8,\n    /// list will have one object, describing the new permissions values and\n    /// the old values they were changed from (which may be None).\n    pub permissions_changes: Vec\u003cConfigChange\u003cGrantChangeValue\u003e\u003e,\n}\n\n#[derive(Debug, Default, Clone, Serialize, Deserialize, PartialEq, PartialOrd)]\npub struct RebalanceResponse {\n    /// the number of tables rebalanced.\n    pub rebalanced: u8,\n    /// a list of new and old table status values.\n    /// Each element of the list will be an object with two fields:\n    /// - `old_val`: The table’s [status](crate::Command::status)\n    /// value before `rebalance` was executed.\n    /// - `new_val`: The table’s `status` value after `rebalance` was executed.\n    /// (This value will almost always indicate the table is unavailable.)\n    pub status_changes: Vec\u003cConfigChange\u003cStatusResponse\u003e\u003e,\n}\n\n#[derive(Debug, Default, Clone, Serialize, Deserialize, PartialEq, PartialOrd)]\npub struct ReconfigureResponse {\n    /// the number of tables reconfigured.\n    /// This will be `0` if `dry_run` is `true`.\n    pub reconfigured: u8,\n    /// a list of new and old table configuration values.\n    /// Each element of the list will be an object with two fields\n    /// - `old_val`: The table’s [config](crate::Command::config)\n    /// value before reconfigure was executed.\n    /// - `new_val`: The table’s `config` value after `reconfigure` was executed.\n    pub config_changes: Vec\u003cConfigChange\u003cConfigResponse\u003e\u003e,\n    /// a list of new and old table status values.\n    /// Each element of the list will be an object with two fields\n    /// - `old_val`: The table’s [status](crate::Command::status)\n    /// value before reconfigure was executed.\n    /// - `new_val`: The table’s `config` value after `reconfigure` was executed.\n    pub status_changes: Vec\u003cConfigChange\u003cStatusResponse\u003e\u003e,\n}\n\n#[derive(Debug, Default, Clone, Deserialize, Serialize, PartialEq, PartialOrd)]\npub struct ConfigChange\u003cT\u003e {\n    pub new_val: Option\u003cT\u003e,\n    pub old_val: Option\u003cT\u003e,\n}\n\n#[derive(Debug, Clone, Deserialize, Serialize, Eq, PartialEq, Ord, PartialOrd, Hash)]\npub struct ConfigResponse {\n    pub id: Cow\u003c'static, str\u003e,\n    pub name: Cow\u003c'static, str\u003e,\n\n    pub db: Option\u003cCow\u003c'static, str\u003e\u003e,\n    pub durability: Option\u003cDurability\u003e,\n    pub indexes: Option\u003cVec\u003cCow\u003c'static, str\u003e\u003e\u003e,\n    pub primary_key: Option\u003cCow\u003c'static, str\u003e\u003e,\n    pub shards: Option\u003cVec\u003cShardType\u003cCow\u003c'static, str\u003e\u003e\u003e\u003e,\n    pub write_acks: Option\u003cReadMode\u003e,\n    pub write_hook: Option\u003cCow\u003c'static, str\u003e\u003e,\n}\n\n#[derive(Debug, Clone, Deserialize, Serialize, Eq, PartialEq, Ord, PartialOrd, Hash)]\npub struct GrantChangeValue {\n    pub write: Option\u003cbool\u003e,\n    pub read: Option\u003cbool\u003e,\n    pub connect: Option\u003cbool\u003e,\n    pub config: Option\u003cbool\u003e,\n}\n\n#[derive(Debug, Clone, Deserialize, Serialize, Eq, PartialEq, Ord, PartialOrd, Hash)]\npub struct StatusResponse {\n    /// the UUID of the table.\n    pub id: Option\u003cCow\u003c'static, str\u003e\u003e,\n    /// the table’s name.\n    pub name: Option\u003cCow\u003c'static, str\u003e\u003e,\n    /// the database the table is in.\n    pub db: Option\u003cCow\u003c'static, str\u003e\u003e,\n    /// the subfields in this field indicate whether all shards of\n    /// the table are ready to accept the given type of query\n    pub status: Option\u003cStatusResponseStatus\u003e,\n    /// one entry for each shard in `table_config`\n    pub shards: Option\u003cVec\u003cShardType\u003cShardReplicasType\u003e\u003e\u003e,\n    pub raft_leader: Option\u003cCow\u003c'static, str\u003e\u003e,\n}\n\n#[derive(Debug, Clone, Deserialize, Serialize, Eq, PartialEq, Ord, PartialOrd, Hash)]\npub struct InfoResponse {\n    pub db: DbInfo,\n    pub doc_count_estimates: Vec\u003cusize\u003e,\n    pub id: Cow\u003c'static, str\u003e,\n    pub indexes: Vec\u003cCow\u003c'static, str\u003e\u003e,\n    pub name: Cow\u003c'static, str\u003e,\n    pub primary_key: Cow\u003c'static, str\u003e,\n    #[serde(rename = \"type\")]\n    pub typ: TypeOf,\n}\n\n#[derive(Debug, Clone, Deserialize, Serialize, Eq, PartialEq, Ord, PartialOrd, Hash)]\npub struct DbInfo {\n    id: Cow\u003c'static, str\u003e,\n    name: Cow\u003c'static, str\u003e,\n    #[serde(rename = \"type\")]\n    pub typ: TypeOf,\n}\n\n#[derive(Debug, Clone, Deserialize, Serialize, Eq, PartialEq, Ord, PartialOrd, Hash)]\npub struct StatusResponseStatus {\n    pub all_replicas_ready: Option\u003cbool\u003e,\n    pub ready_for_outdated_reads: Option\u003cbool\u003e,\n    pub ready_for_reads: Option\u003cbool\u003e,\n    pub ready_for_writes: Option\u003cbool\u003e,\n}\n\n#[derive(Debug, Clone, Deserialize, Serialize, PartialEq, PartialOrd)]\npub struct ClosestDocumentResponse\u003cT\u003e {\n    pub dist: f64,\n    pub doc: Option\u003cT\u003e,\n}\n\n#[derive(Debug, Clone, Deserialize, Serialize, Eq, PartialEq, Ord, PartialOrd, Hash)]\npub struct ShardType\u003cR\u003e {\n    pub primary_replica: Option\u003cCow\u003c'static, str\u003e\u003e,\n    pub replicas: Vec\u003cR\u003e,\n    pub nonvoting_replicas: Option\u003cVec\u003cCow\u003c'static, str\u003e\u003e\u003e,\n}\n\n#[derive(Debug, Clone, Deserialize, Serialize, Eq, PartialEq, Ord, PartialOrd, Hash)]\npub struct ShardReplicasType {\n    pub server: Cow\u003c'static, str\u003e,\n    pub state: Cow\u003c'static, str\u003e,\n}\n\n#[derive(Debug, Clone, Deserialize, Serialize, PartialEq, PartialOrd)]\npub struct GeoJson\u003cT: Serialize\u003e {\n    #[serde(rename = \"type\")]\n    pub typ: GeoType,\n    pub coordinates: T,\n}\n\nimpl\u003cT: Serialize + Clone\u003e GeoJson\u003cT\u003e {\n    pub fn new(typ: GeoType, coordinates: T) -\u003e Self {\n        Self { typ, coordinates }\n    }\n}\n\n#[derive(Debug, Clone, Deserialize, Serialize, PartialEq, PartialOrd, Eq, Ord, Hash)]\npub struct MatchResponse {\n    /// The matched string’s start\n    pub start: usize,\n    /// The matched string’s end\n    pub end: usize,\n    /// The matched string\n    pub str: Cow\u003c'static, str\u003e,\n    /// The capture groups defined with parentheses\n    pub groups: Vec\u003cMatchItem\u003e,\n}\n\n#[derive(Debug, Clone, Deserialize, Serialize, PartialEq, PartialOrd, Eq, Ord, Hash)]\npub struct MatchItem {\n    pub start: usize,\n    pub end: usize,\n    pub str: Cow\u003c'static, str\u003e,\n}\n\n/// Controls how change notifications are batched\n#[derive(Debug, Clone, Copy, Serialize, Deserialize, PartialEq, PartialOrd)]\n#[non_exhaustive]\n#[serde(untagged)]\npub enum Squash {\n    Bool(bool),\n    Float(f32),\n}\n\n#[derive(Debug, Clone, Copy, Serialize, Deserialize, Eq, PartialEq, Ord, PartialOrd, Hash)]\npub enum GeoSystem {\n    #[serde(rename = \"unit_sphere\")]\n    UnitSphere,\n    WGS84,\n}\n\n#[derive(Debug, Clone, Copy, Serialize, Deserialize, Eq, PartialEq, Ord, PartialOrd, Hash)]\n#[serde(rename_all = \"UPPERCASE\")]\npub enum TypeOf {\n    Array,\n    Bool,\n    Db,\n    Function,\n    GroupedData,\n    GroupedStream,\n    Maxval,\n    Minval,\n    Null,\n    Number,\n    Object,\n\n    #[serde(rename = \"PTYPE\u003cBINARY\u003e\")]\n    PtypeBinary,\n    #[serde(rename = \"PTYPE\u003cGEOMETRY\u003e\")]\n    PtypeGeometry,\n    #[serde(rename = \"PTYPE\u003cTIME\u003e\")]\n    PtypeTime,\n    #[serde(rename = \"SELECTION\u003cARRAY\u003e\")]\n    SelectionArray,\n    #[serde(rename = \"SELECTION\u003cOBJECT\u003e\")]\n    SelectionObject,\n    #[serde(rename = \"SELECTION\u003cSTREAM\u003e\")]\n    SelectionStream,\n\n    Stream,\n    String,\n    TableSlice,\n    Table,\n}\n","traces":[{"line":287,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":1},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","types","response_with_cmd.rs"],"content":"use crate::Command;\n\n#[derive(Debug, Clone)]\npub struct ResponseWithCmd\u003cT\u003e(pub T, pub Command);\n\nimpl\u003cT\u003e ResponseWithCmd\u003cT\u003e {\n    pub fn value(self) -\u003e T {\n        self.0\n    }\n\n    pub fn cmd(self) -\u003e Command {\n        self.1\n    }\n}\n","traces":[{"line":7,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":8,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":11,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":12,"address":[],"length":0,"stats":{"Line":7},"fn_name":null}],"covered":4,"coverable":4},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","types","time_.rs"],"content":"use serde::{Deserialize, Serialize};\nuse time::{format_description, OffsetDateTime, UtcOffset};\n\nuse crate::{\n    constants::{NANOS_PER_MSEC, NANOS_PER_SEC},\n    ReqlDriverError, ReqlError, Result,\n};\n\nuse super::ReqlType;\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[non_exhaustive]\npub struct Time {\n    #[serde(rename = \"$reql_type$\")]\n    pub reql_type: ReqlType,\n    pub epoch_time: f64,\n    pub timezone: String,\n}\n\nimpl Time {\n    pub fn new(epoch_time: f64, timezone: String) -\u003e Self {\n        Self {\n            epoch_time,\n            timezone,\n            reql_type: ReqlType::Time,\n        }\n    }\n\n    pub fn is_valid(\u0026self) -\u003e bool {\n        self.to_offset_date_time().is_ok()\n    }\n\n    pub fn to_offset_date_time(\u0026self) -\u003e Result\u003cOffsetDateTime\u003e {\n        let epoch_time = self.epoch_time.to_string();\n        let format = match format_description::parse(\"[offset_hour]:[offset_minute]\") {\n            Ok(fmt) =\u003e fmt,\n            Err(error) =\u003e {\n                return Err(ReqlError::from(error));\n            }\n        };\n        let offset = match UtcOffset::parse(\u0026self.timezone, \u0026format) {\n            Ok(offset) =\u003e offset,\n            Err(error) =\u003e {\n                return Err(ReqlError::from(error));\n            }\n        };\n        let (secs, msecs) = match epoch_time.split_once('.') {\n            Some(parts) =\u003e parts,\n            None =\u003e (epoch_time.as_str(), \"0\"),\n        };\n        let secs = match secs.parse::\u003ci128\u003e() {\n            Ok(secs) =\u003e match secs.checked_mul(NANOS_PER_SEC) {\n                Some(secs) =\u003e secs,\n                None =\u003e {\n                    return Err(ReqlError::Driver(ReqlDriverError::Time(\n                        \"seconds to nanosecond overflow\".to_owned(),\n                    )));\n                }\n            },\n            Err(..) =\u003e {\n                return Err(ReqlError::Driver(ReqlDriverError::Time(\n                    \"invalid epoch time seconds\".to_owned(),\n                )));\n            }\n        };\n        // RethinkDB timestamps have millisecond precision so we need\n        // to convert the milliseconds to nanoseconds first\n        let msecs = match msecs.parse::\u003ci128\u003e() {\n            Ok(int) =\u003e {\n                let msecs = match msecs.len() {\n                    3 =\u003e int,\n                    2 =\u003e int * 10,\n                    1 =\u003e int * 100,\n                    _ =\u003e {\n                        return Err(ReqlError::Driver(ReqlDriverError::Time(\n                            \"invalid epoch milliseconds\".to_owned(),\n                        )));\n                    }\n                };\n                match msecs.checked_mul(NANOS_PER_MSEC) {\n                    Some(msecs) =\u003e msecs,\n                    None =\u003e {\n                        return Err(ReqlError::Driver(ReqlDriverError::Time(\n                            \"millisecond to nanosecond overflow\".to_owned(),\n                        )));\n                    }\n                }\n            }\n            Err(..) =\u003e {\n                return Err(ReqlError::Driver(ReqlDriverError::Time(\n                    \"invalid epoch time milliseconds\".to_owned(),\n                )));\n            }\n        };\n        let timestamp = match secs.checked_add(msecs) {\n            Some(timestamp) =\u003e timestamp,\n            None =\u003e {\n                return Err(ReqlError::Driver(ReqlDriverError::Time(\n                    \"timestamp addition overflow\".to_owned(),\n                )));\n            }\n        };\n\n        let dt = match OffsetDateTime::from_unix_timestamp_nanos(timestamp) {\n            Ok(date_time) =\u003e date_time.to_offset(offset),\n            Err(error) =\u003e {\n                return Err(ReqlError::from(error));\n            }\n        };\n\n        Ok(dt)\n    }\n}\n\nimpl Eq for Time {}\n\nimpl PartialEq for Time {\n    fn eq(\u0026self, other: \u0026Self) -\u003e bool {\n        let dt = self.to_offset_date_time().unwrap();\n        let dt2 = other.to_offset_date_time().unwrap();\n\n        dt.eq(\u0026dt2)\n    }\n}\n\nimpl PartialOrd for Time {\n    fn partial_cmp(\u0026self, other: \u0026Self) -\u003e Option\u003cstd::cmp::Ordering\u003e {\n        let dt = self.to_offset_date_time().unwrap();\n        let dt2 = other.to_offset_date_time().unwrap();\n\n        dt.partial_cmp(\u0026dt2)\n    }\n}\n\nimpl Ord for Time {\n    fn cmp(\u0026self, other: \u0026Self) -\u003e std::cmp::Ordering {\n        let dt = self.to_offset_date_time().unwrap();\n        let dt2 = other.to_offset_date_time().unwrap();\n\n        dt.cmp(\u0026dt2)\n    }\n}\n\nimpl From\u003cOffsetDateTime\u003e for Time {\n    fn from(dt: OffsetDateTime) -\u003e Self {\n        let offset = dt.offset();\n        let timezone = {\n            let (hours, minutes, _) = offset.as_hms();\n            format!(\n                \"{}{:02}:{:02}\",\n                if offset.is_negative() { '-' } else { '+' },\n                hours.abs(),\n                minutes.abs(),\n            )\n        };\n\n        let epoch_time = format!(\"{}.{:03}\", dt.unix_timestamp(), dt.millisecond())\n            .parse()\n            .unwrap();\n\n        Self::new(epoch_time, timezone)\n    }\n}\n","traces":[{"line":21,"address":[2793408],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":29,"address":[2793488,2793576],"length":1,"stats":{"Line":1},"fn_name":"is_valid"},{"line":30,"address":[2793500],"length":1,"stats":{"Line":1},"fn_name":null},{"line":33,"address":[2797656,2793616],"length":1,"stats":{"Line":1},"fn_name":"to_offset_date_time"},{"line":34,"address":[2793655],"length":1,"stats":{"Line":1},"fn_name":null},{"line":35,"address":[2793669,2793744],"length":1,"stats":{"Line":2},"fn_name":null},{"line":36,"address":[2793771],"length":1,"stats":{"Line":1},"fn_name":null},{"line":37,"address":[2793865],"length":1,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[2793913,2794023],"length":1,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[2793835,2794138],"length":1,"stats":{"Line":2},"fn_name":null},{"line":42,"address":[2794183],"length":1,"stats":{"Line":1},"fn_name":null},{"line":43,"address":[2794277],"length":1,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[2794341],"length":1,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[2794514,2794725,2794251],"length":1,"stats":{"Line":3},"fn_name":null},{"line":48,"address":[2794597],"length":1,"stats":{"Line":1},"fn_name":null},{"line":49,"address":[2794840,2794571],"length":1,"stats":{"Line":2},"fn_name":null},{"line":51,"address":[2794805,2794888],"length":1,"stats":{"Line":2},"fn_name":null},{"line":52,"address":[2794906,2795213],"length":1,"stats":{"Line":2},"fn_name":null},{"line":53,"address":[2795302],"length":1,"stats":{"Line":1},"fn_name":null},{"line":55,"address":[2797483],"length":1,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[2795256],"length":1,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[2795016],"length":1,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[2794981],"length":1,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[2795366],"length":1,"stats":{"Line":1},"fn_name":null},{"line":69,"address":[2795419],"length":1,"stats":{"Line":1},"fn_name":null},{"line":70,"address":[2795695,2795461],"length":1,"stats":{"Line":2},"fn_name":null},{"line":71,"address":[2795779],"length":1,"stats":{"Line":1},"fn_name":null},{"line":72,"address":[2796344,2795805],"length":1,"stats":{"Line":2},"fn_name":null},{"line":73,"address":[2796237,2795928],"length":1,"stats":{"Line":2},"fn_name":null},{"line":75,"address":[2796054],"length":1,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[2795739],"length":1,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[2796287,2796407],"length":1,"stats":{"Line":2},"fn_name":null},{"line":81,"address":[2796496],"length":1,"stats":{"Line":1},"fn_name":null},{"line":83,"address":[2797302],"length":1,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[2796450],"length":1,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[2795514],"length":1,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[2795479],"length":1,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[2796544],"length":1,"stats":{"Line":1},"fn_name":null},{"line":96,"address":[2796652],"length":1,"stats":{"Line":1},"fn_name":null},{"line":98,"address":[2797121],"length":1,"stats":{"Line":0},"fn_name":null},{"line":99,"address":[2796622],"length":1,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[2796700],"length":1,"stats":{"Line":1},"fn_name":null},{"line":105,"address":[2796737],"length":1,"stats":{"Line":1},"fn_name":null},{"line":106,"address":[2796850],"length":1,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[2796898],"length":1,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[2797030],"length":1,"stats":{"Line":1},"fn_name":null},{"line":118,"address":[2797696],"length":1,"stats":{"Line":1},"fn_name":"eq"},{"line":119,"address":[2797730],"length":1,"stats":{"Line":1},"fn_name":null},{"line":120,"address":[2797769],"length":1,"stats":{"Line":1},"fn_name":null},{"line":122,"address":[2797803],"length":1,"stats":{"Line":1},"fn_name":null},{"line":127,"address":[2797840],"length":1,"stats":{"Line":0},"fn_name":"partial_cmp"},{"line":128,"address":[2797874],"length":1,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[2797913],"length":1,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[2797947],"length":1,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[2797984],"length":1,"stats":{"Line":0},"fn_name":"cmp"},{"line":137,"address":[2798018],"length":1,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[2798057],"length":1,"stats":{"Line":0},"fn_name":null},{"line":140,"address":[2798091],"length":1,"stats":{"Line":0},"fn_name":null},{"line":145,"address":[2799423,2798128,2799531],"length":1,"stats":{"Line":1},"fn_name":"from"},{"line":146,"address":[2798159],"length":1,"stats":{"Line":1},"fn_name":null},{"line":148,"address":[2798246],"length":1,"stats":{"Line":1},"fn_name":null},{"line":149,"address":[2798555,2798503,2798607],"length":1,"stats":{"Line":3},"fn_name":null},{"line":151,"address":[2798399],"length":1,"stats":{"Line":1},"fn_name":null},{"line":152,"address":[2798540],"length":1,"stats":{"Line":1},"fn_name":null},{"line":153,"address":[2798592],"length":1,"stats":{"Line":1},"fn_name":null},{"line":157,"address":[2798859,2798940,2799338],"length":1,"stats":{"Line":3},"fn_name":null},{"line":161,"address":[2799448],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":41,"coverable":67},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","tests","make_query.rs"],"content":"use futures::stream::{select_all, TryStreamExt};\nuse reql_rust::arguments::ReadMode;\nuse reql_rust::cmd::run::RunOption;\nuse reql_rust::prelude::Converter;\nuse reql_rust::{args, r, Result};\n\n#[tokio::test]\nasync fn simple() -\u003e Result\u003c()\u003e {\n    let conn = r.connection().connect().await?;\n    let run_option = RunOption::default().read_mode(ReadMode::Outdated);\n    let response = r\n        .db(\"rethinkdb\")\n        .table(\"users\")\n        .make_query(args!(\u0026conn, run_option))\n        .try_next()\n        .await?;\n\n    assert!(response.is_some());\n\n    Ok(())\n}\n\n#[tokio::test]\nasync fn concurrency() -\u003e Result\u003c()\u003e {\n    let conn = r.connection().connect().await?;\n    let expected_messages: Vec\u003cString\u003e = (0..10_000)\n        .into_iter()\n        .map(|i| format!(\"message {}\", i))\n        .collect();\n\n    let mut streams = Vec::new();\n\n    for msg in expected_messages.iter() {\n        streams.push(r.expr(msg).make_query(\u0026conn));\n    }\n\n    let mut list = select_all(streams);\n    let mut response = Vec::new();\n\n    while let Some(msg) = list.try_next().await? {\n        let msg: String = msg.parse()?;\n        response.push(msg);\n    }\n\n    assert!(response == expected_messages);\n\n    Ok(())\n}\n","traces":[{"line":8,"address":[1796183,1796597,1796144,1796549],"length":1,"stats":{"Line":6},"fn_name":"simple"},{"line":9,"address":[1520232,1519732,1519956,1519442,1519581,1519498],"length":1,"stats":{"Line":4},"fn_name":null},{"line":10,"address":[1520493,1520222],"length":1,"stats":{"Line":2},"fn_name":null},{"line":11,"address":[1521026,1521095,1521285,1520548,1521486,1520624,1520845],"length":1,"stats":{"Line":6},"fn_name":null},{"line":14,"address":[1520667],"length":1,"stats":{"Line":1},"fn_name":null},{"line":16,"address":[1548838],"length":1,"stats":{"Line":1},"fn_name":null},{"line":18,"address":[1521700,1521648],"length":1,"stats":{"Line":1},"fn_name":null},{"line":20,"address":[1796280,1796220,1796560,1796175],"length":1,"stats":{"Line":5},"fn_name":null},{"line":24,"address":[1797045,1797093,1796640,1796679],"length":1,"stats":{"Line":6},"fn_name":"concurrency"},{"line":25,"address":[1522101,1522252,1522476,1522018,1522798,1521954],"length":1,"stats":{"Line":4},"fn_name":null},{"line":26,"address":[1523069,1522734],"length":1,"stats":{"Line":2},"fn_name":null},{"line":28,"address":[1525351,1525328],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":31,"address":[1523131],"length":1,"stats":{"Line":1},"fn_name":null},{"line":33,"address":[1523295,1523617,1523202,1523528],"length":1,"stats":{"Line":4},"fn_name":null},{"line":34,"address":[1523544],"length":1,"stats":{"Line":1},"fn_name":null},{"line":37,"address":[1523473],"length":1,"stats":{"Line":1},"fn_name":null},{"line":38,"address":[1523689,1523630],"length":1,"stats":{"Line":2},"fn_name":null},{"line":40,"address":[1525153,1524512,1524422,1524770,1522036,1523747,1525275,1523699],"length":1,"stats":{"Line":6},"fn_name":null},{"line":41,"address":[1524454,1524813,1524988],"length":1,"stats":{"Line":2},"fn_name":null},{"line":42,"address":[1524922],"length":1,"stats":{"Line":1},"fn_name":null},{"line":45,"address":[1524617,1524539,1524658],"length":1,"stats":{"Line":2},"fn_name":null},{"line":47,"address":[1524631],"length":1,"stats":{"Line":5},"fn_name":null}],"covered":22,"coverable":22},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","tests","run.rs"],"content":"use reql_rust::arguments::ReadMode;\nuse reql_rust::cmd::run::RunOption;\nuse reql_rust::{args, r, Result};\n\n#[tokio::test]\nasync fn test_run_ops() -\u003e Result\u003c()\u003e {\n    let conn = r.connection().connect().await?;\n    let run_option = RunOption::default().read_mode(ReadMode::Outdated);\n    let response = r\n        .db(\"rethinkdb\")\n        .table(\"users\")\n        .run(args!(\u0026conn, run_option))\n        .await?;\n\n    assert!(response.is_some());\n\n    Ok(())\n}\n","traces":[{"line":6,"address":[1329072,1329242,1329377,1329104,1329680,1329081,1329161],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":7,"address":[1329337,1329216,1329482,1329952,1329691,1329266],"length":1,"stats":{"Line":4},"fn_name":null},{"line":8,"address":[1330201,1329942],"length":1,"stats":{"Line":2},"fn_name":null},{"line":9,"address":[1331094,1330886,1330519,1330630,1330253,1330326,1330701],"length":1,"stats":{"Line":6},"fn_name":null},{"line":12,"address":[1329281,1330829,1330366,1330542,1330660],"length":1,"stats":{"Line":4},"fn_name":null},{"line":13,"address":[1330998,1331128],"length":1,"stats":{"Line":0},"fn_name":null},{"line":15,"address":[1331230,1331267,1330984],"length":1,"stats":{"Line":2},"fn_name":null},{"line":17,"address":[1331236],"length":1,"stats":{"Line":5},"fn_name":null}],"covered":7,"coverable":8}]};
        var previousData = {"files":[{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","reql-macros","src","func","mod.rs"],"content":"#[cfg(test)]\nmod tests;\n\nuse proc_macro2::{TokenStream, TokenTree};\nuse quote::quote;\nuse std::iter::FromIterator;\nuse syn::Ident;\n\n#[derive(Debug)]\npub(super) struct Func {\n    mv: Option\u003cIdent\u003e,\n    args: Vec\u003cIdent\u003e,\n    body: TokenStream,\n}\n\nimpl Func {\n    pub(super) fn new(input: TokenStream) -\u003e Self {\n        let mut iter = input.into_iter();\n        let mv = iter.next().map(first).unwrap();\n        if mv.is_some() {\n            iter.next().filter(is_pipe).unwrap();\n        }\n        let mut args = Vec::new();\n        while let Some(token) = iter.next() {\n            if is_pipe(\u0026token) {\n                break;\n            }\n            args.push(ident(token));\n            let token = iter.next().unwrap();\n            if is_pipe(\u0026token) {\n                break;\n            }\n            assert_comma(\u0026token);\n        }\n        let body = TokenStream::from_iter(iter);\n        Self { mv, args, body }\n    }\n\n    pub(super) fn process(self) -\u003e TokenStream {\n        let Self { mv, args, body } = self;\n        let mut header = quote!(#mv |);\n        let mut params = TokenStream::new();\n        let func_args = args.len();\n        for (i, arg) in args.into_iter().enumerate() {\n            let var = quote!(Command::var(*ids.get(#i).unwrap()));\n            if i == func_args - 1 {\n                header.extend(quote!(#arg: Command));\n                params.extend(quote!(#var));\n            } else {\n                header.extend(quote!(#arg: Command, ));\n                params.extend(quote!(#var, ));\n            }\n        }\n        header.extend(quote!(|));\n        let closure = quote!(#header #body);\n        quote!({\n            let closure = #closure;\n            let mut ids = Vec::with_capacity(#func_args);\n            for _ in 0..#func_args {\n                let id = var_counter();\n                ids.push(id);\n            }\n            let func = closure(#params);\n            Func::new(ids, func)\n        })\n    }\n}\n\nfn first(token: TokenTree) -\u003e Option\u003cIdent\u003e {\n    if is_pipe(\u0026token) {\n        return None;\n    }\n    match token {\n        TokenTree::Ident(ident) if ident == \"move\" =\u003e Some(ident),\n        _ =\u003e panic!(\"invalid closure\"),\n    }\n}\n\nfn ident(token: TokenTree) -\u003e Ident {\n    match token {\n        TokenTree::Ident(ident) =\u003e ident,\n        _ =\u003e panic!(\"invalid closure\"),\n    }\n}\n\nfn is_pipe(token: \u0026TokenTree) -\u003e bool {\n    matches!(token, TokenTree::Punct(punct) if punct.as_char() == '|')\n}\n\nfn assert_comma(token: \u0026TokenTree) {\n    match token {\n        TokenTree::Punct(punct) if punct.as_char() == ',' =\u003e {}\n        _ =\u003e panic!(\"invalid closure\"),\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","reql-macros","src","func","tests.rs"],"content":"use super::*;\n\n#[test]\nfn with_move() {\n    Func::new(quote!(move |doc| {\n        doc.get_field(\"author\").bracket(\"name\")\n    }))\n    .process();\n}\n\n#[test]\nfn with_no_arg() {\n    Func::new(quote!(|| r.expr(\"Hello world!\"))).process();\n}\n\n#[test]\nfn with_one_arg() {\n    Func::new(quote!(|doc| { doc.get_field(\"author\").bracket(\"name\") })).process();\n}\n\n#[test]\nfn with_multiple_args() {\n    Func::new(quote!(|with, multiple, args| r.expr(with, multiple, args))).process();\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","reql-macros","src","geometry.rs"],"content":"use quote::quote;\nuse syn::{parse_macro_input, DeriveInput};\n\npub(super) fn parse(input: proc_macro::TokenStream) -\u003e proc_macro::TokenStream {\n    let DeriveInput { ident, .. } = parse_macro_input!(input);\n\n    let output = quote! {\n        impl Geometry for #ident {}\n    };\n\n    output.into()\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","reql-macros","src","lib.rs"],"content":"use func::Func;\nuse proc_macro::TokenStream;\n\nmod geometry;\nmod func;\nmod options;\n\n#[proc_macro]\npub fn func(input: TokenStream) -\u003e TokenStream {\n    Func::new(input.into()).process().into()\n}\n\n#[proc_macro_derive(CommandOptions)]\npub fn command_opts(input: TokenStream) -\u003e TokenStream {\n    options::parse(input)\n}\n\n#[proc_macro_derive(Geometry)]\npub fn make_document(input: TokenStream) -\u003e TokenStream {\n    geometry::parse(input)\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","reql-macros","src","options.rs"],"content":"use proc_macro2::TokenStream;\nuse quote::{quote, ToTokens};\nuse syn::{parse_macro_input, Data, DeriveInput, Fields, GenericArgument, PathArguments, Type};\n\npub(super) fn parse(input: proc_macro::TokenStream) -\u003e proc_macro::TokenStream {\n    let input = parse_macro_input!(input as DeriveInput);\n\n    let mut methods = TokenStream::new();\n\n    match input.data {\n        Data::Struct(data) =\u003e match data.fields {\n            Fields::Named(fields) =\u003e {\n                for field in fields.named {\n                    let name = field.ident;\n                    let mut generics = TokenStream::new();\n                    let mut where_clause = TokenStream::new();\n                    let mut value = quote!(#name);\n                    let mut param = param(\u0026field.ty);\n\n                    if param.is_cow || param.is_db {\n                        generics = quote!(\u003cT\u003e);\n                        where_clause = quote!(where T: crate::cmd::StaticString);\n                        param.ty = quote!(T);\n                        value = quote!(#name.static_string());\n                    }\n\n                    if param.is_db {\n                        value = quote!(Db(#value))\n                    }\n\n                    if param.is_option {\n                        value = quote!(Some(#value))\n                    }\n\n                    let ty = param.ty;\n\n                    methods.extend(quote! {\n                        pub fn #name #generics(mut self, #name: #ty) -\u003e Self #where_clause {\n                            self.#name = #value;\n                            self\n                        }\n                    });\n                }\n            }\n            _ =\u003e unimplemented!(),\n        },\n        Data::Enum(_) | Data::Union(_) =\u003e unimplemented!(),\n    }\n\n    let name = input.ident;\n    let generics = input.generics;\n\n    let options = quote! {\n        impl #generics #name #generics {\n            pub fn new() -\u003e Self {\n                Default::default()\n            }\n\n            #methods\n        }\n    };\n\n    options.into()\n}\n\nstruct Param {\n    ty: TokenStream,\n    is_option: bool,\n    is_cow: bool,\n    is_db: bool,\n}\n\nfn param(typ: \u0026Type) -\u003e Param {\n    if let Type::Path(typ) = typ {\n        if let Some(typ) = typ.path.segments.first() {\n            let mut param = Param {\n                ty: typ.to_token_stream(),\n                is_option: typ.ident == \"Option\",\n                is_cow: typ.ident == \"Cow\",\n                is_db: false,\n            };\n            if !param.is_option {\n                return param;\n            } else if let PathArguments::AngleBracketed(path) = \u0026typ.arguments {\n                if let Some(typ) = path.args.first() {\n                    param.ty = typ.to_token_stream();\n                    if let GenericArgument::Type(Type::Path(typ)) = typ {\n                        if let Some(typ) = typ.path.segments.first() {\n                            param.is_cow = typ.ident == \"Cow\";\n                            param.is_db = typ.ident == \"Db\";\n                        }\n                    }\n                    return param;\n                }\n            }\n        }\n    }\n    unimplemented!()\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","arguments","any_param.rs"],"content":"use serde::Serialize;\n\nuse crate::Command;\n\n#[derive(Debug, Clone)]\npub struct AnyParam(Command);\n\nimpl AnyParam {\n    pub fn new(arg: impl Serialize) -\u003e Self {\n        Self(Command::from_json(arg))\n    }\n}\n\nimpl From\u003cAnyParam\u003e for Command {\n    fn from(param: AnyParam) -\u003e Self {\n        param.0\n    }\n}\n","traces":[{"line":9,"address":[4791712,4791584],"length":1,"stats":{"Line":2},"fn_name":"new\u003c[\u0026str; 2]\u003e"},{"line":10,"address":[4791600,4791744],"length":1,"stats":{"Line":2},"fn_name":null},{"line":15,"address":[4037856],"length":1,"stats":{"Line":1},"fn_name":"from"},{"line":16,"address":[4037864],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":4,"coverable":4},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","arguments","mod.rs"],"content":"use std::{borrow::Cow, collections::HashMap};\n\nuse reql_macros::CommandOptions;\nuse serde::{Deserialize, Serialize};\n\npub use any_param::AnyParam;\npub use return_changes::ReturnChanges;\n\nmod any_param;\nmod return_changes;\n\n#[derive(Debug, Clone, Copy, Eq, PartialEq, Ord, PartialOrd, Hash)]\npub struct Args\u003cT\u003e(pub T);\n\n#[derive(Debug, Clone, Copy, Serialize, Default, PartialEq, PartialOrd, CommandOptions)]\npub struct Permission {\n    /// allows reading the data in tables.\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub read: Option\u003cbool\u003e,\n    /// allows modifying data, including inserting, replacing/updating, and deleting.\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub write: Option\u003cbool\u003e,\n    /// allows a user to open HTTP connections via the [http](crate::r::http)\n    /// command. This permission can only be granted in global scope.\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub connect: Option\u003cbool\u003e,\n    /// allows users to create/drop\n    /// [secondary indexes](https://rethinkdb.com/docs/secondary-indexes/python/)\n    /// on a table and changing the cluster configuration;\n    /// to create and drop tables, if granted on a database;\n    /// and to create and drop databases, if granted globally.\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub config: Option\u003cbool\u003e,\n}\n\n#[derive(Debug, Clone, Copy, Serialize, Deserialize, Eq, PartialEq, Ord, PartialOrd, Hash)]\n#[serde(rename_all = \"lowercase\")]\npub enum Status {\n    Open,\n    Closed,\n}\n\n#[derive(Debug, Clone, Copy, Serialize, Deserialize, Eq, PartialEq, Ord, PartialOrd, Hash)]\n#[serde(rename_all = \"lowercase\")]\npub enum Durability {\n    Hard,\n    Soft,\n}\n\n#[derive(Debug, Clone, Copy, Serialize, Deserialize, Eq, PartialEq, Ord, PartialOrd, Hash)]\n#[serde(rename_all = \"lowercase\")]\npub enum ReadMode {\n    /// returns values that are in memory\n    /// (but not necessarily written to disk)\n    /// on the primary replica.\n    /// This is the default.\n    Single,\n    /// will only return values that are safely committed on disk on a majority of replicas.\n    /// This requires sending a message to every replica on each read,\n    /// so it is the slowest but most consistent.\n    Majority,\n    /// will return values that are in memory on an arbitrarily-selected replica.\n    /// This is the fastest but least consistent.\n    Outdated,\n}\n\n#[derive(Debug, Clone, Copy, Serialize, Deserialize, Eq, PartialEq, Ord, PartialOrd, Hash)]\n#[serde(rename_all = \"lowercase\")]\npub enum Format {\n    Native,\n    Raw,\n}\n\n#[derive(Debug, Clone, Copy, Serialize, Deserialize, Eq, PartialEq, Ord, PartialOrd, Hash)]\n#[serde(rename_all = \"lowercase\")]\npub enum Conflict {\n    Error,\n    Replace,\n    Update,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]\n#[non_exhaustive]\npub enum Replicas {\n    Int(usize),\n    Map {\n        replicas: HashMap\u003cCow\u003c'static, str\u003e, usize\u003e,\n        primary_replica_tag: Cow\u003c'static, str\u003e,\n    },\n}\n\n#[derive(Debug, Clone, Copy, Serialize, Deserialize, Eq, PartialEq, Ord, PartialOrd, Hash)]\n#[serde(rename_all = \"snake_case\")]\npub enum EmergencyRepair {\n    UnsafeRollback,\n    UnsafeRollbackOrErase,\n}\n\n#[derive(Debug, Clone, Copy, Serialize, PartialEq, PartialOrd)]\n#[non_exhaustive]\n#[serde(rename_all = \"lowercase\")]\npub enum IdentifierFormat {\n    Name,\n    Uuid,\n}\n\n#[derive(Debug, Clone, Copy, Serialize, Deserialize, Eq, PartialEq, Ord, PartialOrd, Hash)]\n#[serde(rename_all = \"snake_case\")]\npub enum WaitFor {\n    ReadyForOutdatedReads,\n    ReadyForReads,\n    ReadyForWrites,\n    AllReplicasReady,\n}\n\n#[derive(Debug, Clone, Copy, Serialize, Deserialize, Eq, PartialEq, Ord, PartialOrd, Hash)]\npub enum Unit {\n    #[serde(rename = \"m\")]\n    Meter,\n    #[serde(rename = \"km\")]\n    Kilometer,\n    #[serde(rename = \"mi\")]\n    InternationalMile,\n    #[serde(rename = \"nm\")]\n    NauticalMile,\n    #[serde(rename = \"ft\")]\n    InternationalFoot,\n}\n\n#[derive(Debug, Clone, Copy, Serialize, Deserialize, PartialEq, PartialOrd)]\n#[serde(untagged)]\n#[non_exhaustive]\npub enum Interleave {\n    Bool(bool),\n    FieldName(\u0026'static str),\n    // Function\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","arguments","return_changes.rs"],"content":"use serde::{Deserialize, Serialize, Serializer};\n\n#[derive(Debug, Clone, Copy, Deserialize, PartialEq, PartialOrd)]\n#[non_exhaustive]\npub enum ReturnChanges {\n    Bool(bool),\n    Always,\n}\n\nimpl Serialize for ReturnChanges {\n    fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    where\n        S: Serializer,\n    {\n        match self {\n            Self::Bool(boolean) =\u003e boolean.serialize(serializer),\n            Self::Always =\u003e \"always\".serialize(serializer),\n        }\n    }\n}\n","traces":[{"line":11,"address":[7010080],"length":1,"stats":{"Line":1},"fn_name":"serialize\u003cserde_json::value::ser::Serializer\u003e"},{"line":15,"address":[7010104],"length":1,"stats":{"Line":1},"fn_name":null},{"line":16,"address":[7010132],"length":1,"stats":{"Line":1},"fn_name":null},{"line":17,"address":[7010149],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":3,"coverable":4},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","add.rs"],"content":"use std::ops::Add;\n\nuse ql2::term::TermType;\nuse serde::Serialize;\n\nuse crate::Command;\n\nimpl\u003cT: AddArg\u003e Add\u003cT\u003e for Command {\n    type Output = Self;\n\n    fn add(self, arg: T) -\u003e Self {\n        Command::new(TermType::Add)\n            .with_arg(arg.into_add_opts())\n            .with_parent(self)\n    }\n}\n\npub trait AddArg {\n    fn into_add_opts(self) -\u003e Command;\n}\n\nimpl\u003cT: Serialize\u003e AddArg for T {\n    fn into_add_opts(self) -\u003e Command {\n        Command::from_json(self)\n    }\n}\n\nimpl AddArg for Command {\n    fn into_add_opts(self) -\u003e Command {\n        self\n    }\n}\n\n// TODO write test\n","traces":[{"line":11,"address":[2189601,2189553,2189184],"length":1,"stats":{"Line":0},"fn_name":"add\u003creql_rust::proto::Command\u003e"},{"line":12,"address":[2189431,2189211,2189330,2189528],"length":1,"stats":{"Line":0},"fn_name":null},{"line":13,"address":[2189338,2189472,2189543],"length":1,"stats":{"Line":0},"fn_name":null},{"line":14,"address":[2189480],"length":1,"stats":{"Line":0},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[4037888],"length":1,"stats":{"Line":0},"fn_name":"into_add_opts"},{"line":30,"address":[4037896],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":8},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","and.rs"],"content":"use ql2::term::TermType;\n\nuse crate::{arguments::Args, Command};\n\nuse super::CmdOpts;\n\npub(crate) fn new(args: impl AndArg) -\u003e Command {\n    args.into_and_opts().add_to_cmd(Command::new(TermType::And))\n}\n\npub trait AndArg {\n    fn into_and_opts(self) -\u003e CmdOpts;\n}\n\nimpl AndArg for bool {\n    fn into_and_opts(self) -\u003e CmdOpts {\n        CmdOpts::Single(Command::from_json(self))\n    }\n}\n\nimpl AndArg for Command {\n    fn into_and_opts(self) -\u003e CmdOpts {\n        CmdOpts::Single(self)\n    }\n}\n\nimpl\u003cT\u003e AndArg for Args\u003cT\u003e\nwhere\n    T: IntoIterator\u003cItem = bool\u003e,\n{\n    fn into_and_opts(self) -\u003e CmdOpts {\n        let commands = self.0.into_iter().map(Command::from_json).collect();\n\n        CmdOpts::Many(commands)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::Converter;\n    use crate::{args, r, Result};\n\n    #[tokio::test]\n    async fn test_and_ops() -\u003e Result\u003c()\u003e {\n        let conn = r.connection().connect().await?;\n        let data_obtained: bool = r\n            .and(args!([true, true, true]))\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(data_obtained);\n\n        Ok(())\n    }\n}\n","traces":[{"line":7,"address":[4532349,4532144,4532376],"length":1,"stats":{"Line":1},"fn_name":"new\u003calloc::vec::Vec\u003cbool, alloc::alloc::Global\u003e\u003e"},{"line":8,"address":[4532160,4532369],"length":1,"stats":{"Line":1},"fn_name":null},{"line":16,"address":[2672528],"length":1,"stats":{"Line":0},"fn_name":"into_and_opts"},{"line":17,"address":[2698128],"length":1,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[4437289,4437040],"length":1,"stats":{"Line":1},"fn_name":"into_and_opts"},{"line":23,"address":[4437139,4437070],"length":1,"stats":{"Line":2},"fn_name":null},{"line":25,"address":[4437217],"length":1,"stats":{"Line":1},"fn_name":null},{"line":35,"address":[4195312,4195369,4195572,4195289,4195280,4195437,4195871],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":36,"address":[4195427,4195882,4195461,4195693,4195532,4196150],"length":1,"stats":{"Line":4},"fn_name":null},{"line":37,"address":[4197137,4196824,4196425,4197327,4196639,4197043,4196568,4197100,4196457],"length":1,"stats":{"Line":6},"fn_name":null},{"line":38,"address":[4196378,4196135],"length":1,"stats":{"Line":2},"fn_name":null},{"line":39,"address":[4196598,4196767,4196437,4195476,4196480],"length":1,"stats":{"Line":4},"fn_name":null},{"line":40,"address":[4196947],"length":1,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[4197439,4197216],"length":1,"stats":{"Line":1},"fn_name":null},{"line":46,"address":[2253084,2253424,2253039,2253144],"length":1,"stats":{"Line":5},"fn_name":null}],"covered":12,"coverable":15},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","append.rs"],"content":"use ql2::term::TermType;\nuse serde::Serialize;\n\nuse crate::Command;\n\npub(crate) fn new(args: impl AppendArg) -\u003e Command {\n    Command::new(TermType::Append).with_arg(args.into_append_opts())\n}\n\npub trait AppendArg {\n    fn into_append_opts(self) -\u003e Command;\n}\n\nimpl\u003cT\u003e AppendArg for T\nwhere\n    T: Serialize,\n{\n    fn into_append_opts(self) -\u003e Command {\n        Command::from_json(self)\n    }\n}\n\nimpl AppendArg for Command {\n    fn into_append_opts(self) -\u003e Command {\n        self\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::Converter;\n    use crate::{r, Result};\n\n    #[tokio::test]\n    async fn test_append_ops() -\u003e Result\u003c()\u003e {\n        let conn = r.connection().connect().await?;\n        let response: [u8; 6] = r\n            .expr([10, 20, 30, 40, 50])\n            .append(100)\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(response == [10, 20, 30, 40, 50, 100]);\n\n        Ok(())\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","args.rs"],"content":"use ql2::term::TermType;\nuse serde::Serialize;\n\nuse crate::Command;\n\npub(crate) fn new\u003cT, S\u003e(values: T) -\u003e Command\nwhere\n    S: Serialize,\n    T: AsRef\u003c[S]\u003e + Serialize,\n{\n    let args = Command::from_json(values);\n\n    Command::new(TermType::Args).with_arg(args)\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::{prelude::Converter, r, Result};\n\n    #[tokio::test]\n    async fn test_args_ops() -\u003e Result\u003c()\u003e {\n        let conn = r.connection().connect().await?;\n        let data = vec![1, 2, 3];\n        let response: Vec\u003cu8\u003e = r.args(\u0026data).run(\u0026conn).await?.unwrap().parse()?;\n\n        assert!(response == data);\n\n        Ok(())\n    }\n}\n","traces":[{"line":6,"address":[6642560,6642762,6642789],"length":1,"stats":{"Line":1},"fn_name":"new\u003c\u0026alloc::vec::Vec\u003cu8, alloc::alloc::Global\u003e, u8\u003e"},{"line":11,"address":[6642585],"length":1,"stats":{"Line":1},"fn_name":null},{"line":13,"address":[6642678,6642611],"length":1,"stats":{"Line":2},"fn_name":null},{"line":21,"address":[1780516,1780224,1780256,1780815,1780313,1780381,1780233],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":22,"address":[1780371,1780405,1780476,1780826,1780637,1781094],"length":1,"stats":{"Line":4},"fn_name":null},{"line":23,"address":[1781079,1781341],"length":1,"stats":{"Line":2},"fn_name":null},{"line":24,"address":[1782128,1781373,1782276,1781424,1780420],"length":1,"stats":{"Line":3},"fn_name":null},{"line":26,"address":[1782246,1782558,1782521],"length":1,"stats":{"Line":2},"fn_name":null},{"line":28,"address":[1782527],"length":1,"stats":{"Line":5},"fn_name":null}],"covered":9,"coverable":9},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","asc.rs"],"content":"use ql2::term::TermType;\nuse serde::Serialize;\n\nuse crate::prelude::Func;\nuse crate::Command;\n\npub(crate) fn new(args: impl AscArg) -\u003e Command {\n    Command::new(TermType::Asc).with_arg(args.into_asc_opts())\n}\n\npub trait AscArg {\n    fn into_asc_opts(self) -\u003e Command;\n}\n\nimpl\u003cT\u003e AscArg for T\nwhere\n    T: Into\u003cT\u003e + Serialize,\n{\n    fn into_asc_opts(self) -\u003e Command {\n        Command::from_json(self)\n    }\n}\n\nimpl AscArg for Func {\n    fn into_asc_opts(self) -\u003e Command {\n        self.0\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::*;\n    use crate::spec::*;\n    use crate::{args, r, Result};\n\n    #[tokio::test]\n    async fn test_asc_ops() -\u003e Result\u003c()\u003e {\n        let (conn, table, table_name) = set_up(true).await?;\n        let response: Vec\u003cPost\u003e = table\n            .order_by(args!(r.expr(\"view\"), r.asc(\"title\")))\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(response.len() \u003e 1);\n\n        tear_down(conn, \u0026table_name).await\n    }\n}\n","traces":[{"line":7,"address":[6408378,6408096],"length":1,"stats":{"Line":1},"fn_name":"new\u003c\u0026str\u003e"},{"line":8,"address":[6408244,6408139,6408368],"length":1,"stats":{"Line":2},"fn_name":null},{"line":19,"address":[6408416],"length":1,"stats":{"Line":1},"fn_name":"into_asc_opts\u003c\u0026str\u003e"},{"line":20,"address":[6408437],"length":1,"stats":{"Line":1},"fn_name":null},{"line":25,"address":[2744784],"length":1,"stats":{"Line":0},"fn_name":"into_asc_opts"},{"line":26,"address":[7017416],"length":1,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[1672663,1672624,1673077,1673029],"length":1,"stats":{"Line":6},"fn_name":"test_asc_ops"},{"line":38,"address":[2363805,2364425,2363484,2363983,2363411,2363637],"length":1,"stats":{"Line":4},"fn_name":null},{"line":39,"address":[2365150,2365564,2365896,2364373,2365073,2364907,2365665,2364844,2365345,2365621],"length":1,"stats":{"Line":7},"fn_name":null},{"line":40,"address":[2364395,2364883,2364932,2364914,2364631],"length":1,"stats":{"Line":2},"fn_name":null},{"line":41,"address":[2363505,2365278,2364982,2365106,2363588],"length":1,"stats":{"Line":5},"fn_name":null},{"line":42,"address":[2365468],"length":1,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[2365785,2366094,2366155],"length":1,"stats":{"Line":2},"fn_name":null},{"line":48,"address":[1673040,1672760,1672700,1672655],"length":1,"stats":{"Line":7},"fn_name":null}],"covered":11,"coverable":14},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","avg.rs"],"content":"use ql2::term::TermType;\n\nuse crate::prelude::Func;\nuse crate::Command;\n\npub(crate) fn new(args: impl AvgArg) -\u003e Command {\n    let mut command = Command::new(TermType::Avg);\n\n    if let Some(arg) = args.into_avg_opts() {\n        command = command.with_arg(arg)\n    }\n\n    command\n}\n\npub trait AvgArg {\n    fn into_avg_opts(self) -\u003e Option\u003cCommand\u003e;\n}\n\nimpl AvgArg for () {\n    fn into_avg_opts(self) -\u003e Option\u003cCommand\u003e {\n        None\n    }\n}\n\nimpl AvgArg for \u0026str {\n    fn into_avg_opts(self) -\u003e Option\u003cCommand\u003e {\n        let arg = Command::from_json(self);\n\n        Some(arg)\n    }\n}\n\nimpl AvgArg for Func {\n    fn into_avg_opts(self) -\u003e Option\u003cCommand\u003e {\n        Some(self.0)\n    }\n}\n\nimpl AvgArg for Command {\n    fn into_avg_opts(self) -\u003e Option\u003cCommand\u003e {\n        Some(self)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::Converter;\n    use crate::spec::{set_up, tear_down, Post};\n    use crate::Result;\n\n    #[tokio::test]\n    async fn test_avg_data() -\u003e Result\u003c()\u003e {\n        let data: Vec\u003cu8\u003e = Post::get_many_data().iter().map(|post| post.view).collect();\n        let avg = data.iter().sum::\u003cu8\u003e() as f32 / data.len() as f32;\n        let (conn, table, table_name) = set_up(true).await?;\n        let data_obtained: f32 = table.avg(\"view\").run(\u0026conn).await?.unwrap().parse()?;\n\n        assert!(data_obtained == avg);\n\n        tear_down(conn, table_name.as_str()).await\n    }\n}\n","traces":[{"line":6,"address":[1754384,1755255,1755144],"length":1,"stats":{"Line":1},"fn_name":"new\u003c\u0026str\u003e"},{"line":7,"address":[1754417],"length":1,"stats":{"Line":1},"fn_name":null},{"line":8,"address":[1754527],"length":1,"stats":{"Line":1},"fn_name":null},{"line":10,"address":[1754624,1754860],"length":1,"stats":{"Line":1},"fn_name":null},{"line":11,"address":[1754739,1754834],"length":1,"stats":{"Line":0},"fn_name":null},{"line":14,"address":[1755085,1754862,1754796],"length":1,"stats":{"Line":3},"fn_name":null},{"line":15,"address":[1755059,1754945],"length":1,"stats":{"Line":2},"fn_name":null},{"line":18,"address":[1755006],"length":1,"stats":{"Line":1},"fn_name":null},{"line":26,"address":[1683648],"length":1,"stats":{"Line":0},"fn_name":"into_avg_opts"},{"line":27,"address":[1683667],"length":1,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[1683760],"length":1,"stats":{"Line":1},"fn_name":"into_avg_opts"},{"line":33,"address":[1683793],"length":1,"stats":{"Line":1},"fn_name":null},{"line":35,"address":[1683803],"length":1,"stats":{"Line":1},"fn_name":null},{"line":40,"address":[2826464],"length":1,"stats":{"Line":0},"fn_name":"into_avg_opts"},{"line":41,"address":[2826480],"length":1,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[4037920],"length":1,"stats":{"Line":0},"fn_name":"into_avg_opts"},{"line":47,"address":[2253168],"length":1,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[4038064,4038316],"length":1,"stats":{"Line":0},"fn_name":"into_avg_opts"},{"line":53,"address":[2253321],"length":1,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[4038157],"length":1,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[2253584],"length":1,"stats":{"Line":0},"fn_name":"into_avg_opts"},{"line":61,"address":[4038374],"length":1,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[2253633],"length":1,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[2367045,2366976,2367363,2366944,2366953,2367137,2367664],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":75,"address":[2370797,2367107,2367480,2370784],"length":1,"stats":{"Line":4},"fn_name":"{closure#0}"},{"line":76,"address":[2367727],"length":1,"stats":{"Line":1},"fn_name":null},{"line":77,"address":[2367167,2367320,2368002,2368619],"length":1,"stats":{"Line":3},"fn_name":null},{"line":78,"address":[2367271,2367188,2369560,2369670,2368565,2368831],"length":1,"stats":{"Line":5},"fn_name":null},{"line":80,"address":[2369643,2370025],"length":1,"stats":{"Line":1},"fn_name":null},{"line":82,"address":[2370502,2370123,2369981,2370307,2370247,2370368,2367206],"length":1,"stats":{"Line":7},"fn_name":null}],"covered":17,"coverable":30},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","between.rs"],"content":"use std::borrow::Cow;\n\nuse ql2::term::TermType;\nuse reql_macros::CommandOptions;\nuse serde::Serialize;\n\nuse crate::arguments::{Args, Status};\nuse crate::Command;\n\nuse super::CmdOpts;\n\npub(crate) fn new(args: impl BetweenArg) -\u003e Command {\n    let (min_key, max_key, opts) = args.into_between_opts();\n    let min_key: Option\u003cCommand\u003e = min_key.into();\n    let max_key: Option\u003cCommand\u003e = max_key.into();\n\n    Command::new(TermType::Between)\n        .with_arg(min_key.unwrap())\n        .with_arg(max_key.unwrap())\n        .with_opts(opts)\n}\n\npub trait BetweenArg {\n    fn into_between_opts(self) -\u003e (CmdOpts, CmdOpts, BetweenOption);\n}\n\nimpl BetweenArg for Args\u003c(Command, Command)\u003e {\n    fn into_between_opts(self) -\u003e (CmdOpts, CmdOpts, BetweenOption) {\n        (\n            CmdOpts::Single(self.0 .0),\n            CmdOpts::Single(self.0 .1),\n            Default::default(),\n        )\n    }\n}\n\nimpl BetweenArg for Args\u003c(Command, Command, BetweenOption)\u003e {\n    fn into_between_opts(self) -\u003e (CmdOpts, CmdOpts, BetweenOption) {\n        (\n            CmdOpts::Single(self.0 .0),\n            CmdOpts::Single(self.0 .1),\n            self.0 .2,\n        )\n    }\n}\n\n///  If `index` is set to the name of a secondary index,\n/// `between` will return all documents where that index’s\n/// value is in the specified range (it uses the primary key by default).\n/// `left_bound` or `right_bound` may be set to `Status::Open` or `Status::Closed`\n/// to indicate whether or not to include that endpoint of the range\n/// (by default, `left_bound` is closed and `right_bound` is open).\n#[derive(\n    Debug, Clone, Serialize, Default, Eq, PartialEq, Ord, PartialOrd, Hash, CommandOptions,\n)]\npub struct BetweenOption {\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub index: Option\u003cCow\u003c'static, str\u003e\u003e,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub left_bound: Option\u003cStatus\u003e,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub right_bound: Option\u003cStatus\u003e,\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::arguments::Status;\n    use crate::prelude::*;\n    use crate::spec::{set_up, tear_down, Post};\n    use crate::{args, r, Result};\n\n    use super::BetweenOption;\n\n    #[tokio::test]\n    async fn test_get_data_between() -\u003e Result\u003c()\u003e {\n        let data = Post::get_many_data();\n        let (conn, table, table_name) = set_up(true).await?;\n        let data_get: Vec\u003cPost\u003e = table\n            .between(args!(r.expr(2), r.expr(4)))\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(data_get.len() == 2);\n        assert!(data_get.first() == data.get(2));\n        assert!(data_get.last() == data.get(1));\n\n        tear_down(conn, table_name.as_str()).await\n    }\n\n    #[tokio::test]\n    async fn test_get_data_between_by_minval() -\u003e Result\u003c()\u003e {\n        let data = Post::get_many_data();\n        let (conn, table, table_name) = set_up(true).await?;\n        let data_get: Vec\u003cPost\u003e = table\n            .between(args!(r::min_val(), r.expr(4)))\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(data_get.len() == 3);\n        assert!(data_get.first() == data.get(2));\n        assert!(data_get.last() == data.first());\n\n        tear_down(conn, table_name.as_str()).await\n    }\n\n    #[tokio::test]\n    async fn test_get_data_between_by_maxval() -\u003e Result\u003c()\u003e {\n        let data = Post::get_many_data();\n        let (conn, table, table_name) = set_up(true).await?;\n        let data_get: Vec\u003cPost\u003e = table\n            .between(args!(r.expr(2), r::max_val()))\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(data_get.len() == 4);\n        assert!(data_get.first() == data.get(3));\n        assert!(data_get.last() == data.get(1));\n\n        tear_down(conn, table_name.as_str()).await\n    }\n\n    #[tokio::test]\n    async fn test_get_data_between_with_opts() -\u003e Result\u003c()\u003e {\n        let data = Post::get_many_data();\n        let (conn, table, table_name) = set_up(true).await?;\n        let between_option = BetweenOption::default().right_bound(Status::Closed);\n        let data_get: Vec\u003cPost\u003e = table\n            .between(args!(r.expr(2), r.expr(4), between_option))\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(data_get.len() == 3);\n        assert!(data_get.first() == data.get(3));\n        assert!(data_get.last() == data.get(1));\n\n        tear_down(conn, table_name.as_str()).await\n    }\n\n    #[tokio::test]\n    async fn test_get_data_between_by_minval_and_max_val_with_opts() -\u003e Result\u003c()\u003e {\n        let data = Post::get_many_data();\n        let (conn, table, table_name) = set_up(true).await?;\n        let between_option = BetweenOption::default()\n            .right_bound(Status::Closed)\n            .left_bound(Status::Closed)\n            .index(\"title\");\n        let data_get: Vec\u003cPost\u003e = table\n            .between(args!(r::min_val(), r::max_val(), between_option))\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(data_get.len() == data.len());\n        assert!(data_get.first() == data.get(3));\n        assert!(data_get.last() == data.first());\n\n        tear_down(conn, table_name.as_str()).await\n    }\n}\n","traces":[{"line":12,"address":[4899251,4899595,4899632,4898448,4900435,4900779],"length":1,"stats":{"Line":2},"fn_name":"new\u003creql_rust::arguments::Args\u003c(reql_rust::proto::Command, reql_rust::proto::Command)\u003e\u003e"},{"line":13,"address":[4898465,4899649],"length":1,"stats":{"Line":2},"fn_name":null},{"line":14,"address":[4899985,4898801,4899901,4898717],"length":1,"stats":{"Line":4},"fn_name":null},{"line":15,"address":[4898809,4899993,4898910,4900094],"length":1,"stats":{"Line":4},"fn_name":null},{"line":17,"address":[4899108,4900292,4899303,4898918,4900611,4898989,4899427,4900173,4900487,4900102],"length":1,"stats":{"Line":10},"fn_name":null},{"line":18,"address":[4898997,4899241,4900181,4899147,4900331,4900425],"length":1,"stats":{"Line":4},"fn_name":null},{"line":19,"address":[4899442,4900446,4900531,4900626,4900347,4899262,4899347,4899163],"length":1,"stats":{"Line":4},"fn_name":null},{"line":20,"address":[4900539,4899355],"length":1,"stats":{"Line":2},"fn_name":null},{"line":28,"address":[6656700,6656677,6656368],"length":1,"stats":{"Line":1},"fn_name":"into_between_opts"},{"line":30,"address":[6656425],"length":1,"stats":{"Line":1},"fn_name":null},{"line":31,"address":[6656473],"length":1,"stats":{"Line":1},"fn_name":null},{"line":32,"address":[6656540],"length":1,"stats":{"Line":1},"fn_name":null},{"line":38,"address":[6656720],"length":1,"stats":{"Line":1},"fn_name":"into_between_opts"},{"line":40,"address":[6656742],"length":1,"stats":{"Line":1},"fn_name":null},{"line":41,"address":[6656801],"length":1,"stats":{"Line":1},"fn_name":null},{"line":42,"address":[6656873],"length":1,"stats":{"Line":1},"fn_name":null},{"line":69,"address":[2842992,2842969,2843153,2842960,2843061,2843379,2843725],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":70,"address":[2843123],"length":1,"stats":{"Line":1},"fn_name":null},{"line":71,"address":[2844190,2843183,2843736,2843501,2843561,2843336],"length":1,"stats":{"Line":4},"fn_name":null},{"line":72,"address":[2845661,2845107,2845427,2845326,2844145,2844912,2845383,2844829,2844596,2844663],"length":1,"stats":{"Line":7},"fn_name":null},{"line":73,"address":[2844363,2844670,2844688,2844180,2844635],"length":1,"stats":{"Line":2},"fn_name":null},{"line":74,"address":[2844868,2843204,2844738,2844643,2843287,2845040],"length":1,"stats":{"Line":6},"fn_name":null},{"line":75,"address":[2845230],"length":1,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[2845968,2845547,2845920],"length":1,"stats":{"Line":2},"fn_name":null},{"line":80,"address":[2846016,2845941,2846202],"length":1,"stats":{"Line":2},"fn_name":null},{"line":81,"address":[2846245,2846421,2846181],"length":1,"stats":{"Line":2},"fn_name":null},{"line":83,"address":[2846755,2843222,2846619,2846885,2846495,2846675,2846380],"length":1,"stats":{"Line":7},"fn_name":null},{"line":87,"address":[2847651,2847333,2847425,2847232,2847997,2847264,2847241],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":88,"address":[2847395],"length":1,"stats":{"Line":1},"fn_name":null},{"line":89,"address":[2847773,2847608,2847833,2848457,2847455,2848008],"length":1,"stats":{"Line":4},"fn_name":null},{"line":90,"address":[2849593,2849694,2849374,2849096,2849179,2849650,2848930,2848863,2848417,2849928],"length":1,"stats":{"Line":7},"fn_name":null},{"line":91,"address":[2848630,2848937,2848447,2848902,2848955],"length":1,"stats":{"Line":2},"fn_name":null},{"line":92,"address":[2848910,2849135,2849005,2849307,2847476,2847559],"length":1,"stats":{"Line":6},"fn_name":null},{"line":93,"address":[2849497],"length":1,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[2849814,2850187,2850235],"length":1,"stats":{"Line":2},"fn_name":null},{"line":98,"address":[2850283,2850208,2850469],"length":1,"stats":{"Line":2},"fn_name":null},{"line":99,"address":[2850448,2850512,2850683],"length":1,"stats":{"Line":2},"fn_name":null},{"line":101,"address":[2851147,2850757,2847494,2851017,2850881,2850642,2850937],"length":1,"stats":{"Line":7},"fn_name":null},{"line":105,"address":[2851497,2851488,2851589,2851907,2851520,2851681,2852253],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":106,"address":[2851651],"length":1,"stats":{"Line":1},"fn_name":null},{"line":107,"address":[2852029,2851864,2852264,2851711,2852718,2852089],"length":1,"stats":{"Line":4},"fn_name":null},{"line":108,"address":[2853849,2853630,2853352,2853186,2854184,2853906,2853950,2852673,2853119,2853435],"length":1,"stats":{"Line":7},"fn_name":null},{"line":109,"address":[2853193,2853158,2852891,2852708,2853211],"length":1,"stats":{"Line":2},"fn_name":null},{"line":110,"address":[2853563,2853261,2851732,2853166,2853391,2851815],"length":1,"stats":{"Line":6},"fn_name":null},{"line":111,"address":[2853753],"length":1,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[2854443,2854491,2854070],"length":1,"stats":{"Line":2},"fn_name":null},{"line":116,"address":[2854539,2854725,2854464],"length":1,"stats":{"Line":2},"fn_name":null},{"line":117,"address":[2854768,2854944,2854704],"length":1,"stats":{"Line":2},"fn_name":null},{"line":119,"address":[2855142,2855278,2855018,2855408,2854903,2851750,2855198],"length":1,"stats":{"Line":7},"fn_name":null},{"line":123,"address":[2855744,2856513,2855845,2855941,2855753,2856167,2855776],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":124,"address":[2855907],"length":1,"stats":{"Line":1},"fn_name":null},{"line":125,"address":[2856289,2856349,2855971,2856524,2856911,2856124],"length":1,"stats":{"Line":4},"fn_name":null},{"line":126,"address":[2857136,2856901],"length":1,"stats":{"Line":2},"fn_name":null},{"line":127,"address":[2857823,2857906,2858659,2857657,2858320,2858101,2858425,2858377,2857187,2857590],"length":1,"stats":{"Line":7},"fn_name":null},{"line":128,"address":[2857664,2857629,2857242,2857682],"length":1,"stats":{"Line":2},"fn_name":null},{"line":129,"address":[2856075,2857732,2857862,2858034,2857637,2855992],"length":1,"stats":{"Line":6},"fn_name":null},{"line":130,"address":[2858224],"length":1,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[2858545,2858966,2858918],"length":1,"stats":{"Line":2},"fn_name":null},{"line":135,"address":[2858939,2859014,2859206],"length":1,"stats":{"Line":2},"fn_name":null},{"line":136,"address":[2859255,2859179,2859431],"length":1,"stats":{"Line":2},"fn_name":null},{"line":138,"address":[2859647,2859523,2856010,2859703,2859917,2859390,2859787],"length":1,"stats":{"Line":7},"fn_name":null},{"line":142,"address":[2860304,2861041,2860272,2860373,2860469,2860695,2860281],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":143,"address":[2860435],"length":1,"stats":{"Line":1},"fn_name":null},{"line":144,"address":[2860817,2860499,2860652,2861439,2861052,2860877],"length":1,"stats":{"Line":4},"fn_name":null},{"line":145,"address":[2861429,2861711,2861672],"length":1,"stats":{"Line":3},"fn_name":null},{"line":146,"address":[2861664],"length":1,"stats":{"Line":1},"fn_name":null},{"line":147,"address":[2861703],"length":1,"stats":{"Line":1},"fn_name":null},{"line":149,"address":[2862693,2862969,2862249,2862182,2863017,2862415,2862912,2863251,2862498,2861789],"length":1,"stats":{"Line":7},"fn_name":null},{"line":150,"address":[2862256,2862221,2862274,2861839],"length":1,"stats":{"Line":2},"fn_name":null},{"line":151,"address":[2860603,2862454,2862626,2860520,2862229,2862324],"length":1,"stats":{"Line":6},"fn_name":null},{"line":152,"address":[2862816],"length":1,"stats":{"Line":0},"fn_name":null},{"line":156,"address":[2863510,2863137,2863588],"length":1,"stats":{"Line":2},"fn_name":null},{"line":157,"address":[2863825,2863561,2863636],"length":1,"stats":{"Line":2},"fn_name":null},{"line":158,"address":[2864042,2863871,2863801],"length":1,"stats":{"Line":2},"fn_name":null},{"line":160,"address":[2864258,2864398,2864001,2864528,2860538,2864314,2864134],"length":1,"stats":{"Line":7},"fn_name":null}],"covered":70,"coverable":75},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","binary.rs"],"content":"use crate::types::Binary;\n\npub(crate) fn new(bytes: \u0026[u8]) -\u003e Binary {\n    Binary::new(bytes)\n}\n\n#[cfg(test)]\nmod tests {\n    use serde::{Deserialize, Serialize};\n\n    use crate::prelude::Converter;\n    use crate::spec::{set_up, tear_down};\n    use crate::types::Binary;\n    use crate::{r, Result};\n\n    #[derive(Debug, Serialize, Deserialize)]\n    struct User {\n        id: u8,\n        name: String,\n        avatar: Binary,\n    }\n\n    #[tokio::test]\n    async fn test_binary_ops() -\u003e Result\u003c()\u003e {\n        let avatar_img = std::fs::read(\"logo.png\")?;\n        let user = User {\n            id: 1,\n            name: \"John Doe\".to_string(),\n            avatar: r.binary(\u0026avatar_img),\n        };\n\n        let (conn, table, table_name) = set_up(false).await?;\n        table.clone().insert(\u0026user).run(\u0026conn).await?;\n        let response: User = table.get(1).run(\u0026conn).await?.unwrap().parse()?;\n\n        assert!(response.id == user.id);\n        assert!(response.name == user.name);\n        assert!(!response.avatar.data.is_empty());\n\n        tear_down(conn, \u0026table_name).await\n    }\n}\n","traces":[{"line":3,"address":[6929152],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":4,"address":[2042885],"length":1,"stats":{"Line":1},"fn_name":null},{"line":24,"address":[4110357,4109952,4109991,4110405],"length":1,"stats":{"Line":6},"fn_name":"test_binary_ops"},{"line":25,"address":[4346353,4345878,4346472],"length":1,"stats":{"Line":2},"fn_name":null},{"line":28,"address":[4346442],"length":1,"stats":{"Line":1},"fn_name":null},{"line":29,"address":[4346737,4346645],"length":1,"stats":{"Line":2},"fn_name":null},{"line":32,"address":[6883457],"length":1,"stats":{"Line":4},"fn_name":null},{"line":33,"address":[4346131,4347664,4347442,4345974],"length":1,"stats":{"Line":4},"fn_name":null},{"line":34,"address":[4345995,4348424,4346080,4348548,4349415,4349268],"length":1,"stats":{"Line":5},"fn_name":null},{"line":36,"address":[4349388,4349789],"length":1,"stats":{"Line":1},"fn_name":null},{"line":37,"address":[4349904,4349764,4349872],"length":1,"stats":{"Line":2},"fn_name":null},{"line":38,"address":[4349998,4349938,4349886],"length":1,"stats":{"Line":2},"fn_name":null},{"line":40,"address":[4110368,4110028,4110088,4109983],"length":1,"stats":{"Line":7},"fn_name":null}],"covered":13,"coverable":13},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","bit_and.rs"],"content":"use std::ops::BitAnd;\n\nuse ql2::term::TermType;\n\nuse crate::Command;\n\nimpl\u003cT: BitAndArg\u003e BitAnd\u003cT\u003e for Command {\n    type Output = Self;\n\n    fn bitand(self, arg: T) -\u003e Self {\n        Command::new(TermType::BitAnd)\n            .with_arg(arg.into_bit_and_opts())\n            .with_parent(self)\n    }\n}\n\npub trait BitAndArg {\n    fn into_bit_and_opts(self) -\u003e Command;\n}\n\nimpl BitAndArg for i32 {\n    fn into_bit_and_opts(self) -\u003e Command {\n        Command::from_json(self)\n    }\n}\n\nimpl BitAndArg for Command {\n    fn into_bit_and_opts(self) -\u003e Command {\n        self\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::Converter;\n    use crate::{r, Result};\n\n    #[tokio::test]\n    async fn test_bit_and_ops() -\u003e Result\u003c()\u003e {\n        let conn = r.connection().connect().await?;\n        let response: u8 = r.expr(5).bit_and(3).run(\u0026conn).await?.unwrap().parse()?;\n\n        assert!(response == 1);\n\n        Ok(())\n    }\n\n    #[tokio::test]\n    async fn test_bit_and_ops_with_command() -\u003e Result\u003c()\u003e {\n        let conn = r.connection().connect().await?;\n        let response: u8 = r\n            .bit_and(r.expr(5), r.expr(3))\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(response == 1);\n\n        Ok(())\n    }\n\n    #[tokio::test]\n    async fn test_bit_and_ops_with_syntax() -\u003e Result\u003c()\u003e {\n        let conn = r.connection().connect().await?;\n        let response: u8 = (r.expr(5) \u0026 r.expr(3)).run(\u0026conn).await?.unwrap().parse()?;\n\n        assert!(response == 1);\n\n        Ok(())\n    }\n}\n","traces":[{"line":10,"address":[2189632,2190012,2190417,2190465,2189974,2190048],"length":1,"stats":{"Line":2},"fn_name":"bitand\u003ci32\u003e"},{"line":11,"address":[2189949,2190075,2189852,2190392,2190295,2189783,2189665,2190194],"length":1,"stats":{"Line":8},"fn_name":null},{"line":12,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":13,"address":[2189901,2190344],"length":1,"stats":{"Line":2},"fn_name":null},{"line":22,"address":[2039376],"length":1,"stats":{"Line":1},"fn_name":"into_bit_and_opts"},{"line":23,"address":[2039392],"length":1,"stats":{"Line":1},"fn_name":null},{"line":28,"address":[4038560],"length":1,"stats":{"Line":1},"fn_name":"into_bit_and_opts"},{"line":29,"address":[2172152],"length":1,"stats":{"Line":1},"fn_name":null},{"line":39,"address":[3586144,3586183,3586549,3586597],"length":1,"stats":{"Line":6},"fn_name":"test_bit_and_ops"},{"line":40,"address":[3578378,3578644,3577923,3578189,3578028,3577957],"length":1,"stats":{"Line":4},"fn_name":null},{"line":41,"address":[6889321,6889389],"length":1,"stats":{"Line":4},"fn_name":null},{"line":43,"address":[3579897,3579669],"length":1,"stats":{"Line":1},"fn_name":null},{"line":45,"address":[3579871],"length":1,"stats":{"Line":5},"fn_name":null},{"line":49,"address":[3587093,3587045,3586679,3586640],"length":1,"stats":{"Line":6},"fn_name":"test_bit_and_ops_with_command"},{"line":50,"address":[3580562,3580828,3580091,3580373,3580212,3580141],"length":1,"stats":{"Line":4},"fn_name":null},{"line":51,"address":[3581602,3581121,3581878,3581193,3581915,3581346,3581821,3581417,3582100],"length":1,"stats":{"Line":6},"fn_name":null},{"line":52,"address":[3581208,3581165,3581059,3581024,3580818],"length":1,"stats":{"Line":3},"fn_name":null},{"line":53,"address":[3581545,3581173,3581376,3580156,3581261],"length":1,"stats":{"Line":5},"fn_name":null},{"line":54,"address":[3581725],"length":1,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[3582212,3581984],"length":1,"stats":{"Line":1},"fn_name":null},{"line":60,"address":[3582186],"length":1,"stats":{"Line":5},"fn_name":null},{"line":64,"address":[3582871,3582304,3582572,3582361,3582437,3582272,3582281],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":65,"address":[3582532,3583148,3582461,3582693,3582882,3582411],"length":1,"stats":{"Line":4},"fn_name":null},{"line":66,"address":[3583138,3583379,3584235,3582476,3583581,3584324,3583344],"length":1,"stats":{"Line":5},"fn_name":null},{"line":68,"address":[3584304,3584532],"length":1,"stats":{"Line":1},"fn_name":null},{"line":70,"address":[3584506],"length":1,"stats":{"Line":5},"fn_name":null}],"covered":25,"coverable":26},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","bit_not.rs"],"content":"use ql2::term::TermType;\n\nuse crate::Command;\n\npub(crate) fn new() -\u003e Command {\n    Command::new(TermType::BitNot)\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::Converter;\n    use crate::{r, Result};\n\n    #[tokio::test]\n    async fn test_bit_not_ops() -\u003e Result\u003c()\u003e {\n        let conn = r.connection().connect().await?;\n        let response: i32 = r.expr(7).bit_not().run(\u0026conn).await?.unwrap().parse()?;\n\n        assert!(response == -8);\n\n        Ok(())\n    }\n\n    #[tokio::test]\n    async fn test_bit_not_ops_with_command() -\u003e Result\u003c()\u003e {\n        let conn = r.connection().connect().await?;\n        let response: i32 = r.bit_not(r.expr(7)).run(\u0026conn).await?.unwrap().parse()?;\n\n        assert!(response == -8);\n\n        Ok(())\n    }\n}\n","traces":[{"line":5,"address":[2832256],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":6,"address":[2750620],"length":1,"stats":{"Line":1},"fn_name":null},{"line":15,"address":[1800185,1800767,1800468,1800176,1800333,1800265,1800208],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":16,"address":[1800357,1801044,1800323,1800428,1800589,1800778],"length":1,"stats":{"Line":4},"fn_name":null},{"line":17,"address":[1801995,1800372,1801034,1802085,1801283],"length":1,"stats":{"Line":4},"fn_name":null},{"line":19,"address":[1802064,1802293],"length":1,"stats":{"Line":1},"fn_name":null},{"line":21,"address":[6684168,6684108,6684448,6684063],"length":1,"stats":{"Line":5},"fn_name":null},{"line":25,"address":[1802441,1802384,1802361,1802352,1802509,1802943,1802644],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":26,"address":[1802604,1802765,1802954,1803220,1802499,1802533],"length":1,"stats":{"Line":4},"fn_name":null},{"line":27,"address":[1803210,1804261,1803459,1804171,1802548],"length":1,"stats":{"Line":4},"fn_name":null},{"line":29,"address":[1804240,1804469],"length":1,"stats":{"Line":1},"fn_name":null},{"line":31,"address":[1804443],"length":1,"stats":{"Line":5},"fn_name":null}],"covered":12,"coverable":12},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","bit_or.rs"],"content":"use std::ops::BitOr;\n\nuse ql2::term::TermType;\n\nuse crate::Command;\n\nimpl\u003cT: BitOrArg\u003e BitOr\u003cT\u003e for Command {\n    type Output = Self;\n\n    fn bitor(self, arg: T) -\u003e Self {\n        Command::new(TermType::BitOr)\n            .with_arg(arg.into_bit_or_opts())\n            .with_parent(self)\n    }\n}\n\npub trait BitOrArg {\n    fn into_bit_or_opts(self) -\u003e Command;\n}\n\nimpl BitOrArg for i32 {\n    fn into_bit_or_opts(self) -\u003e Command {\n        Command::from_json(self)\n    }\n}\n\nimpl BitOrArg for Command {\n    fn into_bit_or_opts(self) -\u003e Command {\n        self\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::Converter;\n    use crate::{r, Result};\n\n    #[tokio::test]\n    async fn test_bit_or_ops() -\u003e Result\u003c()\u003e {\n        let conn = r.connection().connect().await?;\n        let response: u8 = r.expr(5).bit_or(3).run(\u0026conn).await?.unwrap().parse()?;\n\n        assert!(response == 7);\n\n        Ok(())\n    }\n\n    #[tokio::test]\n    async fn test_bit_or_ops_with_command() -\u003e Result\u003c()\u003e {\n        let conn = r.connection().connect().await?;\n        let response: u8 = r\n            .bit_or(r.expr(5), r.expr(3))\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(response == 7);\n\n        Ok(())\n    }\n\n    #[tokio::test]\n    async fn test_bit_or_ops_with_syntax() -\u003e Result\u003c()\u003e {\n        let conn = r.connection().connect().await?;\n        let response: u8 = (r.expr(5) | r.expr(3)).run(\u0026conn).await?.unwrap().parse()?;\n\n        assert!(response == 7);\n\n        Ok(())\n    }\n}\n","traces":[{"line":10,"address":[2191281,2190496,2190912,2191329,2190876,2190838],"length":1,"stats":{"Line":2},"fn_name":"bitor\u003ci32\u003e"},{"line":11,"address":[2190647,2191058,2190813,2190939,2190529,2191159,2190716,2191256],"length":1,"stats":{"Line":8},"fn_name":null},{"line":12,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":13,"address":[2190765,2191208],"length":1,"stats":{"Line":2},"fn_name":null},{"line":22,"address":[2039408],"length":1,"stats":{"Line":1},"fn_name":"into_bit_or_opts"},{"line":23,"address":[2039424],"length":1,"stats":{"Line":1},"fn_name":null},{"line":28,"address":[4038592],"length":1,"stats":{"Line":1},"fn_name":"into_bit_or_opts"},{"line":29,"address":[2172184],"length":1,"stats":{"Line":1},"fn_name":null},{"line":39,"address":[7037751,7038117,7038165,7037712],"length":1,"stats":{"Line":6},"fn_name":"test_bit_or_ops"},{"line":40,"address":[2316131,2316397,2316586,2316236,2316852,2316165],"length":1,"stats":{"Line":4},"fn_name":null},{"line":41,"address":[2317096,2317897,2317808,2316842,2316180],"length":1,"stats":{"Line":4},"fn_name":null},{"line":43,"address":[2318105,2317877],"length":1,"stats":{"Line":1},"fn_name":null},{"line":45,"address":[2318079],"length":1,"stats":{"Line":5},"fn_name":null},{"line":49,"address":[7038661,7038613,7038208,7038247],"length":1,"stats":{"Line":6},"fn_name":"test_bit_or_ops_with_command"},{"line":50,"address":[2319036,2318299,2318349,2318420,2318581,2318770],"length":1,"stats":{"Line":4},"fn_name":null},{"line":51,"address":[2320308,2320123,2319329,2319401,2319810,2319554,2319625,2320029,2320086],"length":1,"stats":{"Line":6},"fn_name":null},{"line":52,"address":[2319416,2319373,2319267,2319232,2319026],"length":1,"stats":{"Line":3},"fn_name":null},{"line":53,"address":[2318364,2319753,2319381,2319584,2319469],"length":1,"stats":{"Line":5},"fn_name":null},{"line":54,"address":[2319933],"length":1,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[2320192,2320420],"length":1,"stats":{"Line":1},"fn_name":null},{"line":60,"address":[2320394],"length":1,"stats":{"Line":5},"fn_name":null},{"line":64,"address":[2320645,2320780,2320480,2320512,2320489,2320569,2321079],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":65,"address":[2320901,2320740,2321356,2321090,2320669,2320619],"length":1,"stats":{"Line":4},"fn_name":null},{"line":66,"address":[2322443,2322532,2321789,2320684,2321552,2321346,2321587],"length":1,"stats":{"Line":5},"fn_name":null},{"line":68,"address":[2322512,2322740],"length":1,"stats":{"Line":1},"fn_name":null},{"line":70,"address":[2322714],"length":1,"stats":{"Line":5},"fn_name":null}],"covered":25,"coverable":26},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","bit_sal.rs"],"content":"use ql2::term::TermType;\n\nuse crate::Command;\n\npub(crate) fn new(args: impl BitSalArg) -\u003e Command {\n    Command::new(TermType::BitSal).with_arg(args.into_bit_sal_opts())\n}\n\npub trait BitSalArg {\n    fn into_bit_sal_opts(self) -\u003e Command;\n}\n\nimpl BitSalArg for i32 {\n    fn into_bit_sal_opts(self) -\u003e Command {\n        Command::from_json(self)\n    }\n}\n\nimpl BitSalArg for Command {\n    fn into_bit_sal_opts(self) -\u003e Command {\n        self\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::Converter;\n    use crate::{r, Result};\n\n    #[tokio::test]\n    async fn test_bit_sal_ops() -\u003e Result\u003c()\u003e {\n        let conn = r.connection().connect().await?;\n        let response: u8 = r.expr(5).bit_sal(4).run(\u0026conn).await?.unwrap().parse()?;\n\n        assert!(response == 80);\n\n        Ok(())\n    }\n\n    #[tokio::test]\n    async fn test_bit_sal_ops_with_command() -\u003e Result\u003c()\u003e {\n        let conn = r.connection().connect().await?;\n        let response: u8 = r\n            .bit_sal(r.expr(5), r.expr(4))\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(response == 80);\n\n        Ok(())\n    }\n}\n","traces":[{"line":5,"address":[4457280,4456976,4457566,4457237],"length":1,"stats":{"Line":2},"fn_name":"new\u003ci32\u003e"},{"line":6,"address":[4457004,4457103,4457227,4457402,4457302,4457556],"length":1,"stats":{"Line":4},"fn_name":null},{"line":14,"address":[2121088],"length":1,"stats":{"Line":1},"fn_name":"into_bit_sal_opts"},{"line":15,"address":[2039456],"length":1,"stats":{"Line":1},"fn_name":null},{"line":20,"address":[2253856],"length":1,"stats":{"Line":1},"fn_name":"into_bit_sal_opts"},{"line":21,"address":[2172216],"length":1,"stats":{"Line":1},"fn_name":null},{"line":31,"address":[4412341,4411927,4411888,4412293],"length":1,"stats":{"Line":6},"fn_name":"test_bit_sal_ops"},{"line":32,"address":[4441418,4441068,4440963,4441229,4441684,4440997],"length":1,"stats":{"Line":4},"fn_name":null},{"line":33,"address":[4441928,4441012,4442729,4441674,4442640],"length":1,"stats":{"Line":4},"fn_name":null},{"line":35,"address":[4442709,4442937],"length":1,"stats":{"Line":1},"fn_name":null},{"line":37,"address":[4412304,4411919,4411964,4412024],"length":1,"stats":{"Line":5},"fn_name":null},{"line":41,"address":[4412789,4412423,4412384,4412837],"length":1,"stats":{"Line":6},"fn_name":"test_bit_sal_ops_with_command"},{"line":42,"address":[4443602,4443252,4443413,4443131,4443868,4443181],"length":1,"stats":{"Line":4},"fn_name":null},{"line":43,"address":[4444918,4444955,4444161,4444642,4444457,4444861,4444233,4445140,4444386],"length":1,"stats":{"Line":6},"fn_name":null},{"line":44,"address":[4444099,4444248,4444205,4443858,4444064],"length":1,"stats":{"Line":3},"fn_name":null},{"line":45,"address":[4444585,4444301,4443196,4444416,4444213],"length":1,"stats":{"Line":5},"fn_name":null},{"line":46,"address":[4444765],"length":1,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[4445252,4445024],"length":1,"stats":{"Line":1},"fn_name":null},{"line":52,"address":[4412800,4412460,4412520,4412415],"length":1,"stats":{"Line":5},"fn_name":null}],"covered":18,"coverable":19},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","bit_sar.rs"],"content":"use ql2::term::TermType;\n\nuse crate::Command;\n\npub(crate) fn new(args: impl BitSarArg) -\u003e Command {\n    Command::new(TermType::BitSar).with_arg(args.into_bit_sar_opts())\n}\n\npub trait BitSarArg {\n    fn into_bit_sar_opts(self) -\u003e Command;\n}\n\nimpl BitSarArg for i32 {\n    fn into_bit_sar_opts(self) -\u003e Command {\n        Command::from_json(self)\n    }\n}\n\nimpl BitSarArg for Command {\n    fn into_bit_sar_opts(self) -\u003e Command {\n        self\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::Converter;\n    use crate::{r, Result};\n\n    #[tokio::test]\n    async fn test_bit_sar_ops() -\u003e Result\u003c()\u003e {\n        let conn = r.connection().connect().await?;\n        let response: u8 = r.expr(32).bit_sar(3).run(\u0026conn).await?.unwrap().parse()?;\n\n        assert!(response == 4);\n\n        Ok(())\n    }\n\n    #[tokio::test]\n    async fn test_bit_sar_ops_with_command() -\u003e Result\u003c()\u003e {\n        let conn = r.connection().connect().await?;\n        let response: u8 = r\n            .bit_sar(r.expr(32), r.expr(3))\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(response == 4);\n\n        Ok(())\n    }\n}\n","traces":[{"line":5,"address":[4207758,4207472,4207168,4207429],"length":1,"stats":{"Line":2},"fn_name":"new\u003ci32\u003e"},{"line":6,"address":[4207419,4207196,4207295,4207748,4207494,4207594],"length":1,"stats":{"Line":4},"fn_name":null},{"line":14,"address":[2121120],"length":1,"stats":{"Line":1},"fn_name":"into_bit_sar_opts"},{"line":15,"address":[2039488],"length":1,"stats":{"Line":1},"fn_name":null},{"line":20,"address":[2253888],"length":1,"stats":{"Line":1},"fn_name":"into_bit_sar_opts"},{"line":21,"address":[2172248],"length":1,"stats":{"Line":1},"fn_name":null},{"line":31,"address":[4199993,4200276,4200575,4200073,4200141,4200016,4199984],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":32,"address":[4200397,4200586,4200236,4200131,4200852,4200165],"length":1,"stats":{"Line":4},"fn_name":null},{"line":33,"address":[4201096,4200842,4201897,4201808,4200180],"length":1,"stats":{"Line":4},"fn_name":null},{"line":35,"address":[4201877,4202105],"length":1,"stats":{"Line":1},"fn_name":null},{"line":37,"address":[6685100,6685160,6685055,6685440],"length":1,"stats":{"Line":5},"fn_name":null},{"line":41,"address":[4202160,4202325,4202249,4202759,4202460,4202192,4202169],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":42,"address":[4202420,4202299,4203036,4202349,4202581,4202770],"length":1,"stats":{"Line":4},"fn_name":null},{"line":43,"address":[4204029,4204308,4203625,4203401,4204086,4203329,4203554,4203810,4204123],"length":1,"stats":{"Line":6},"fn_name":null},{"line":44,"address":[4203026,4203267,4203373,4203232,4203416],"length":1,"stats":{"Line":3},"fn_name":null},{"line":45,"address":[4203753,4203381,4202364,4203584,4203469],"length":1,"stats":{"Line":5},"fn_name":null},{"line":46,"address":[4203933],"length":1,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[4204192,4204420],"length":1,"stats":{"Line":1},"fn_name":null},{"line":52,"address":[4204394],"length":1,"stats":{"Line":5},"fn_name":null}],"covered":18,"coverable":19},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","bit_xor.rs"],"content":"use std::ops::BitXor;\n\nuse ql2::term::TermType;\n\nuse crate::Command;\n\nimpl\u003cT: BitXorArg\u003e BitXor\u003cT\u003e for Command {\n    type Output = Self;\n\n    fn bitxor(self, arg: T) -\u003e Self {\n        Command::new(TermType::BitXor)\n            .with_arg(arg.into_bit_xor_opts())\n            .with_parent(self)\n    }\n}\n\npub trait BitXorArg {\n    fn into_bit_xor_opts(self) -\u003e Command;\n}\n\nimpl BitXorArg for i32 {\n    fn into_bit_xor_opts(self) -\u003e Command {\n        Command::from_json(self)\n    }\n}\n\nimpl BitXorArg for Command {\n    fn into_bit_xor_opts(self) -\u003e Command {\n        self\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::Converter;\n    use crate::{r, Result};\n\n    #[tokio::test]\n    async fn test_bit_xor_ops() -\u003e Result\u003c()\u003e {\n        let conn = r.connection().connect().await?;\n        let response: u8 = r.expr(6).bit_xor(4).run(\u0026conn).await?.unwrap().parse()?;\n\n        assert!(response == 2);\n\n        Ok(())\n    }\n\n    #[tokio::test]\n    async fn test_bit_xor_ops_with_command() -\u003e Result\u003c()\u003e {\n        let conn = r.connection().connect().await?;\n        let response: u8 = r\n            .bit_xor(r.expr(6), r.expr(4))\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(response == 2);\n\n        Ok(())\n    }\n\n    #[tokio::test]\n    async fn test_bit_xor_ops_with_syntax() -\u003e Result\u003c()\u003e {\n        let conn = r.connection().connect().await?;\n        let response: u8 = (r.expr(6) ^ r.expr(4)).run(\u0026conn).await?.unwrap().parse()?;\n\n        assert!(response == 2);\n\n        Ok(())\n    }\n}\n","traces":[{"line":10,"address":[2191776,2192145,2191702,2191360,2191740,2192193],"length":1,"stats":{"Line":2},"fn_name":"bitxor\u003ci32\u003e"},{"line":11,"address":[2191677,2191803,2192023,2191393,2191922,2191580,2191511,2192120],"length":1,"stats":{"Line":10},"fn_name":null},{"line":12,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":13,"address":[2192072,2191629],"length":1,"stats":{"Line":3},"fn_name":null},{"line":22,"address":[2039504],"length":1,"stats":{"Line":1},"fn_name":"into_bit_xor_opts"},{"line":23,"address":[2039520],"length":1,"stats":{"Line":1},"fn_name":null},{"line":28,"address":[4038688],"length":1,"stats":{"Line":1},"fn_name":"into_bit_xor_opts"},{"line":29,"address":[2172280],"length":1,"stats":{"Line":2},"fn_name":null},{"line":39,"address":[3587671,3588037,3588085,3587632],"length":1,"stats":{"Line":6},"fn_name":"test_bit_xor_ops"},{"line":40,"address":[1639322,1639133,1638972,1639588,1638867,1638901],"length":1,"stats":{"Line":4},"fn_name":null},{"line":41,"address":[6890537,6890605],"length":1,"stats":{"Line":4},"fn_name":null},{"line":43,"address":[1640841,1640613],"length":1,"stats":{"Line":1},"fn_name":null},{"line":45,"address":[1640815],"length":1,"stats":{"Line":5},"fn_name":null},{"line":49,"address":[3588167,3588533,3588128,3588581],"length":1,"stats":{"Line":6},"fn_name":"test_bit_xor_ops_with_command"},{"line":50,"address":[1641317,1641156,1641035,1641506,1641772,1641085],"length":1,"stats":{"Line":4},"fn_name":null},{"line":51,"address":[1642765,1642065,1642361,1643044,1642859,1642822,1642546,1642137,1642290],"length":1,"stats":{"Line":6},"fn_name":null},{"line":52,"address":[1642003,1641968,1642152,1641762,1642109],"length":1,"stats":{"Line":3},"fn_name":null},{"line":53,"address":[1642117,1642489,1642320,1641100,1642205],"length":1,"stats":{"Line":5},"fn_name":null},{"line":54,"address":[1642669],"length":1,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[1642928,1643156],"length":1,"stats":{"Line":1},"fn_name":null},{"line":60,"address":[1643130],"length":1,"stats":{"Line":5},"fn_name":null},{"line":64,"address":[1643815,1643216,1643516,1643225,1643248,1643305,1643381],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":65,"address":[1643405,1644092,1643355,1643476,1643826,1643637],"length":1,"stats":{"Line":4},"fn_name":null},{"line":66,"address":[1644288,1643420,1645268,1644525,1644082,1645179,1644323],"length":1,"stats":{"Line":5},"fn_name":null},{"line":68,"address":[1645476,1645248],"length":1,"stats":{"Line":1},"fn_name":null},{"line":70,"address":[1645450],"length":1,"stats":{"Line":5},"fn_name":null}],"covered":25,"coverable":26},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","bracket.rs"],"content":"use ql2::term::TermType;\nuse serde::Serialize;\n\nuse crate::Command;\n\npub(crate) fn new(attr: impl Serialize) -\u003e Command {\n    let arg = Command::from_json(attr);\n\n    Command::new(TermType::Bracket).with_arg(arg)\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::Converter;\n    use crate::spec::{set_up, tear_down, Post};\n    use crate::Result;\n\n    #[tokio::test]\n    async fn test_bracket_data() -\u003e Result\u003c()\u003e {\n        let data = Post::get_one_data();\n        let (conn, table, table_name) = set_up(true).await?;\n        let data_obtained: String = table\n            .get(1)\n            .bracket(\"title\")\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(data_obtained == data.title);\n\n        tear_down(conn, \u0026table_name).await\n    }\n}\n","traces":[{"line":6,"address":[6642800,6643039,6643012],"length":1,"stats":{"Line":1},"fn_name":"new\u003c\u0026str\u003e"},{"line":7,"address":[6642833],"length":1,"stats":{"Line":1},"fn_name":null},{"line":9,"address":[6642926,6642859],"length":1,"stats":{"Line":2},"fn_name":null},{"line":19,"address":[1673159,1673120,1673573,1673525],"length":1,"stats":{"Line":6},"fn_name":"test_bracket_data"},{"line":20,"address":[4407203],"length":1,"stats":{"Line":1},"fn_name":null},{"line":21,"address":[4407808,4407408,4407573,4407633,4408246,4407255],"length":1,"stats":{"Line":4},"fn_name":null},{"line":22,"address":[4408703,4409218,4409117,4408193,4409448,4408509,4409174,4408446,4408898,4408626],"length":1,"stats":{"Line":7},"fn_name":null},{"line":25,"address":[4407359,4408532,4408659,4408489,4408831,4407276],"length":1,"stats":{"Line":6},"fn_name":null},{"line":26,"address":[4409021],"length":1,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[4409762,4409707,4409338],"length":1,"stats":{"Line":2},"fn_name":null},{"line":32,"address":[1673256,1673536,1673196,1673151],"length":1,"stats":{"Line":7},"fn_name":null}],"covered":10,"coverable":11},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","branch.rs"],"content":"use ql2::term::TermType;\n\nuse crate::{arguments::Args, Command};\n\nuse super::CmdOpts;\n\npub(crate) fn new(args: impl BranchArg) -\u003e Command {\n    let (test, true_action, false_action) = args.into_branch_opts();\n    let mut command = Command::new(TermType::Branch);\n\n    if let Some(arg) = test {\n        command = command.with_arg(arg)\n    }\n\n    true_action.add_to_cmd(command).with_arg(false_action)\n}\n\npub trait BranchArg {\n    fn into_branch_opts(self) -\u003e (Option\u003cCommand\u003e, CmdOpts, Command);\n}\n\nimpl BranchArg for Args\u003c(Command, Command)\u003e {\n    fn into_branch_opts(self) -\u003e (Option\u003cCommand\u003e, CmdOpts, Command) {\n        (None, CmdOpts::Single(self.0 .0), self.0 .1)\n    }\n}\n\nimpl\u003cconst N: usize\u003e BranchArg for Args\u003c(Command, [(Command, Command); N], Command)\u003e {\n    fn into_branch_opts(self) -\u003e (Option\u003cCommand\u003e, CmdOpts, Command) {\n        let actions = self\n            .0\n             .1\n            .into_iter()\n            .flat_map(|(test, true_action)| [test, true_action])\n            .collect();\n        (Some(self.0 .0), CmdOpts::Many(actions), self.0 .2)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::Converter;\n    use crate::{args, r, Result};\n\n    #[tokio::test]\n    async fn test_branch_data() -\u003e Result\u003c()\u003e {\n        let x = 10;\n        let conn = r.connection().connect().await?;\n        let response: String = r\n            .branch(r.expr(x \u003e 5), args!(r.expr(\"big\"), r.expr(\"small\")))\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(response.eq(\"big\"));\n\n        Ok(())\n    }\n\n    #[tokio::test]\n    async fn test_branch_data_with_infix() -\u003e Result\u003c()\u003e {\n        let x = 10;\n        let conn = r.connection().connect().await?;\n        let response: String = r\n            .expr(x \u003e 5)\n            .branch(args!(r.expr(\"big\"), r.expr(\"small\")))\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(response.eq(\"big\"));\n\n        Ok(())\n    }\n}\n","traces":[{"line":7,"address":[2701936,2702728,2702660],"length":1,"stats":{"Line":1},"fn_name":"new\u003creql_rust::arguments::Args\u003c(reql_rust::proto::Command, reql_rust::proto::Command)\u003e\u003e"},{"line":8,"address":[2701953],"length":1,"stats":{"Line":1},"fn_name":null},{"line":9,"address":[2702133],"length":1,"stats":{"Line":1},"fn_name":null},{"line":11,"address":[2702511,2702207],"length":1,"stats":{"Line":1},"fn_name":null},{"line":12,"address":[2702485,2702322],"length":1,"stats":{"Line":0},"fn_name":null},{"line":15,"address":[2702516,2702379],"length":1,"stats":{"Line":2},"fn_name":null},{"line":23,"address":[6656992],"length":1,"stats":{"Line":1},"fn_name":"into_branch_opts"},{"line":24,"address":[2736678],"length":1,"stats":{"Line":1},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[6686469,6686016,6686421,6686055],"length":1,"stats":{"Line":6},"fn_name":"test_branch_data"},{"line":47,"address":[1701297],"length":1,"stats":{"Line":1},"fn_name":null},{"line":48,"address":[6885458],"length":1,"stats":{"Line":4},"fn_name":null},{"line":49,"address":[1702999,1702589,1702813,1702525,1703312,1703218,1703275,1703555,1702742],"length":1,"stats":{"Line":6},"fn_name":null},{"line":50,"address":[1702245,1702561,1702604,1702019,1702280],"length":1,"stats":{"Line":3},"fn_name":null},{"line":51,"address":[6885322],"length":1,"stats":{"Line":5},"fn_name":null},{"line":52,"address":[1703122],"length":1,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[1703718,1703681,1703425],"length":1,"stats":{"Line":2},"fn_name":null},{"line":58,"address":[1703687],"length":1,"stats":{"Line":5},"fn_name":null},{"line":62,"address":[1704420,1703808,1703840,1703897,1704120,1703985,1703817],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":63,"address":[1703953],"length":1,"stats":{"Line":1},"fn_name":null},{"line":64,"address":[1704431,1704080,1704242,1703975,1704009,1704704],"length":1,"stats":{"Line":4},"fn_name":null},{"line":65,"address":[1704683,1705181,1705245,1705398,1705931,1706211,1705469,1705874,1705968,1705655],"length":1,"stats":{"Line":7},"fn_name":null},{"line":66,"address":[1704936,1704675],"length":1,"stats":{"Line":2},"fn_name":null},{"line":67,"address":[1704901,1704944,1705217,1705260],"length":1,"stats":{"Line":2},"fn_name":null},{"line":68,"address":[1704024,1705225,1705428,1705313,1705597],"length":1,"stats":{"Line":5},"fn_name":null},{"line":69,"address":[1705778],"length":1,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[1706081,1706337,1706374],"length":1,"stats":{"Line":2},"fn_name":null},{"line":75,"address":[1706343],"length":1,"stats":{"Line":5},"fn_name":null}],"covered":24,"coverable":33},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","ceil.rs"],"content":"use ql2::term::TermType;\n\nuse crate::Command;\n\npub(crate) fn new(args: impl CeilArg) -\u003e Command {\n    let mut command = Command::new(TermType::Ceil);\n\n    if let Some(arg) = args.into_ceil_opts() {\n        command = command.with_arg(arg)\n    }\n\n    command\n}\n\npub trait CeilArg {\n    fn into_ceil_opts(self) -\u003e Option\u003cCommand\u003e;\n}\n\nimpl CeilArg for () {\n    fn into_ceil_opts(self) -\u003e Option\u003cCommand\u003e {\n        None\n    }\n}\n\nimpl CeilArg for Command {\n    fn into_ceil_opts(self) -\u003e Option\u003cCommand\u003e {\n        Some(self)\n    }\n}\n\nimpl CeilArg for f64 {\n    fn into_ceil_opts(self) -\u003e Option\u003cCommand\u003e {\n        Some(Command::from_json(self))\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::Converter;\n    use crate::{r, Result};\n\n    #[tokio::test]\n    async fn test_ceil_data() -\u003e Result\u003c()\u003e {\n        let conn = r.connection().connect().await?;\n        let data_obtained: u8 = r.ceil(12.345).run(\u0026conn).await?.unwrap().parse()?;\n        let data_obtained2: u8 = r.expr(12.345).ceil().run(\u0026conn).await?.unwrap().parse()?;\n        let data_obtained3: u8 = r.ceil(r.expr(12.345)).run(\u0026conn).await?.unwrap().parse()?;\n\n        assert!(\n            data_obtained == 13\n                \u0026\u0026 data_obtained == data_obtained2\n                \u0026\u0026 data_obtained == data_obtained3\n        );\n\n        Ok(())\n    }\n}\n","traces":[{"line":5,"address":[7026080,7025488,7026607,7026038],"length":1,"stats":{"Line":1},"fn_name":"new\u003cf64\u003e"},{"line":6,"address":[7026100,7025523,7026192,7025621],"length":1,"stats":{"Line":2},"fn_name":null},{"line":8,"address":[2674730,2674143,2675007,2674081,2674668,2674422],"length":1,"stats":{"Line":3},"fn_name":null},{"line":9,"address":[2756484,2756044,2755898,2756629],"length":1,"stats":{"Line":2},"fn_name":null},{"line":12,"address":[2675032,2674447],"length":1,"stats":{"Line":1},"fn_name":null},{"line":20,"address":[2839344],"length":1,"stats":{"Line":0},"fn_name":"into_ceil_opts"},{"line":21,"address":[2839348],"length":1,"stats":{"Line":0},"fn_name":null},{"line":26,"address":[4750720],"length":1,"stats":{"Line":1},"fn_name":"into_ceil_opts"},{"line":27,"address":[4750746],"length":1,"stats":{"Line":1},"fn_name":null},{"line":37,"address":[4588928,4588905,4589053,4588985,4588896,4589188,4589487],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":38,"address":[4589077,4589148,4589309,4589043,4589498,4589767],"length":1,"stats":{"Line":4},"fn_name":null},{"line":39,"address":[4589757,4589995,4590695,4590784,4589092],"length":1,"stats":{"Line":4},"fn_name":null},{"line":41,"address":[4590764,4590992],"length":1,"stats":{"Line":1},"fn_name":null},{"line":43,"address":[4590966],"length":1,"stats":{"Line":5},"fn_name":null}],"covered":12,"coverable":14},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","change_at.rs"],"content":"use ql2::term::TermType;\nuse serde::Serialize;\n\nuse crate::Command;\n\npub(crate) fn new(offset: isize, value: impl Serialize) -\u003e Command {\n    let arg_offset = Command::from_json(offset);\n    let arg_value = Command::from_json(value);\n\n    Command::new(TermType::ChangeAt)\n        .with_arg(arg_offset)\n        .with_arg(arg_value)\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::Converter;\n    use crate::{r, Result};\n\n    #[tokio::test]\n    async fn test_change_at_ops() -\u003e Result\u003c()\u003e {\n        let conn = r.connection().connect().await?;\n        let response: [String; 3] = r\n            .expr([\"Moussa\", \"Ali\", \"Fati\"])\n            .change_at(1, \"Alima\")\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(response == [\"Moussa\", \"Alima\", \"Fati\"]);\n\n        Ok(())\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","changes.rs"],"content":"use ql2::term::TermType;\nuse reql_macros::CommandOptions;\nuse serde::Serialize;\n\nuse crate::types::Squash;\nuse crate::Command;\n\npub(crate) fn new(args: impl ChangesArg) -\u003e Command {\n    Command::new(TermType::Changes)\n        .with_opts(args.into_changes_opts())\n        .mark_change_feed()\n}\n\npub trait ChangesArg {\n    fn into_changes_opts(self) -\u003e ChangesOption;\n}\n\nimpl ChangesArg for () {\n    fn into_changes_opts(self) -\u003e ChangesOption {\n        Default::default()\n    }\n}\n\nimpl ChangesArg for ChangesOption {\n    fn into_changes_opts(self) -\u003e ChangesOption {\n        self\n    }\n}\n\n#[derive(Debug, Clone, Serialize, Default, PartialEq, PartialOrd, CommandOptions)]\npub struct ChangesOption {\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub squash: Option\u003cSquash\u003e,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub changefeed_queue_size: Option\u003cu32\u003e,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub include_initial: Option\u003cbool\u003e,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub include_states: Option\u003cbool\u003e,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub include_offsets: Option\u003cbool\u003e,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub include_types: Option\u003cbool\u003e,\n}\n","traces":[{"line":19,"address":[4030768],"length":1,"stats":{"Line":0},"fn_name":"into_changes_opts"},{"line":20,"address":[4030780],"length":1,"stats":{"Line":0},"fn_name":null},{"line":25,"address":[4030800],"length":1,"stats":{"Line":0},"fn_name":"into_changes_opts"},{"line":26,"address":[4030803],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":4},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","circle.rs"],"content":"use ql2::term::TermType;\nuse reql_macros::CommandOptions;\nuse serde::Serialize;\n\nuse crate::arguments::{Args, Unit};\nuse crate::types::{GeoSystem, Point};\nuse crate::Command;\n\npub(crate) fn new(args: impl CircleArg) -\u003e Command {\n    let (arg_point, arg_radius, opts) = args.into_circle_opts();\n\n    Command::new(TermType::Circle)\n        .with_arg(arg_point)\n        .with_arg(arg_radius)\n        .with_opts(opts)\n}\n\npub trait CircleArg {\n    fn into_circle_opts(self) -\u003e (Command, Command, CircleOption);\n}\n\nimpl CircleArg for Args\u003c(Point, f64)\u003e {\n    fn into_circle_opts(self) -\u003e (Command, Command, CircleOption) {\n        (\n            Command::from_json(self.0 .0),\n            Command::from_json(self.0 .1),\n            Default::default(),\n        )\n    }\n}\n\nimpl CircleArg for Args\u003c(Command, f64)\u003e {\n    fn into_circle_opts(self) -\u003e (Command, Command, CircleOption) {\n        (self.0 .0, Command::from_json(self.0 .1), Default::default())\n    }\n}\n\nimpl CircleArg for Args\u003c(Point, f64, CircleOption)\u003e {\n    fn into_circle_opts(self) -\u003e (Command, Command, CircleOption) {\n        (\n            Command::from_json(self.0 .0),\n            Command::from_json(self.0 .1),\n            self.0 .2,\n        )\n    }\n}\n\nimpl CircleArg for Args\u003c(Command, f64, CircleOption)\u003e {\n    fn into_circle_opts(self) -\u003e (Command, Command, CircleOption) {\n        (self.0 .0, Command::from_json(self.0 .1), self.0 .2)\n    }\n}\n\n#[derive(\n    Debug, Clone, Serialize, Default, PartialEq, Eq, PartialOrd, Ord, Hash, CommandOptions,\n)]\npub struct CircleOption {\n    /// the number of vertices in the polygon or line. Defaults to 32.\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub num_vertices: Option\u003cusize\u003e,\n    /// the reference ellipsoid to use for geographic coordinates.\n    /// Possible values are `WGS84` (the default), a common standard\n    /// for Earth’s geometry, or `UnitSphere`, a perfect sphere of 1 meter radius.\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub geo_system: Option\u003cGeoSystem\u003e,\n    /// Unit for the radius distance.\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub unit: Option\u003cUnit\u003e,\n    /// if `true` (the default) the circle is filled, creating a polygon;\n    /// if `false` the circle is unfilled (creating a line).\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub fill: Option\u003cbool\u003e,\n}\n\n// TODO write test\n","traces":[{"line":9,"address":[2328704,2329245],"length":1,"stats":{"Line":1},"fn_name":"new\u003creql_rust::arguments::Args\u003c(reql_rust::cmd::point::Point, f64)\u003e\u003e"},{"line":10,"address":[2328721],"length":1,"stats":{"Line":1},"fn_name":null},{"line":12,"address":[2329053,2329122,2328918,2329182],"length":1,"stats":{"Line":4},"fn_name":null},{"line":13,"address":[2328992],"length":1,"stats":{"Line":1},"fn_name":null},{"line":14,"address":[2329060],"length":1,"stats":{"Line":1},"fn_name":null},{"line":15,"address":[2329134],"length":1,"stats":{"Line":1},"fn_name":null},{"line":23,"address":[2655232,2655545],"length":1,"stats":{"Line":1},"fn_name":"into_circle_opts"},{"line":25,"address":[6657237],"length":1,"stats":{"Line":1},"fn_name":null},{"line":26,"address":[2655311],"length":1,"stats":{"Line":1},"fn_name":null},{"line":27,"address":[6657359],"length":1,"stats":{"Line":1},"fn_name":null},{"line":33,"address":[2737515,2737232],"length":1,"stats":{"Line":0},"fn_name":"into_circle_opts"},{"line":34,"address":[6657591],"length":1,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[6657856,6658144],"length":1,"stats":{"Line":0},"fn_name":"into_circle_opts"},{"line":41,"address":[6657877],"length":1,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[6657934],"length":1,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[6658000],"length":1,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[6658445,6658176],"length":1,"stats":{"Line":0},"fn_name":"into_circle_opts"},{"line":50,"address":[6658215],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":10,"coverable":18},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","coerce_to.rs"],"content":"use ql2::term::TermType;\nuse serde::Serialize;\n\nuse crate::Command;\n\npub(crate) fn new(value: impl Serialize) -\u003e Command {\n    Command::new(TermType::CoerceTo).with_arg(Command::from_json(value))\n}\n\n#[cfg(test)]\nmod tests {\n    use serde_json::json;\n\n    use crate::prelude::Converter;\n    use crate::spec::Post;\n    use crate::{r, Result};\n\n    #[tokio::test]\n    async fn test_coerce_to_ops() -\u003e Result\u003c()\u003e {\n        let data = Post::get_one_data();\n        let conn = r.connection().connect().await?;\n        let response: Post = r\n            .expr(json!([\n                [\"id\", 1],\n                [\"title\", \"title1\"],\n                [\"content\", \"content1\"],\n                [\"view\", 0]\n            ]))\n            .coerce_to(\"object\")\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        let response2: char = r\n            .expr(1)\n            .coerce_to(\"string\")\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(response == data);\n        assert!(response2 == '1');\n\n        Ok(())\n    }\n}\n","traces":[{"line":6,"address":[1837360,1837642],"length":1,"stats":{"Line":1},"fn_name":"new\u003c\u0026str\u003e"},{"line":7,"address":[1837403,1837632,1837508],"length":1,"stats":{"Line":2},"fn_name":null},{"line":19,"address":[2253504,2253543,2253909,2253957],"length":1,"stats":{"Line":6},"fn_name":"test_coerce_to_ops"},{"line":20,"address":[6644851],"length":1,"stats":{"Line":1},"fn_name":null},{"line":21,"address":[6644891,6645206,6645757,6645470,6645266,6645046],"length":1,"stats":{"Line":4},"fn_name":null},{"line":22,"address":[6648245,6648362,6648853,6648439,6648910,6649224,6648933,6648634,6648175],"length":1,"stats":{"Line":6},"fn_name":null},{"line":23,"address":[6645739,6645983],"length":1,"stats":{"Line":2},"fn_name":null},{"line":30,"address":[6648268,6648395,6644912,6648225,6644997,6648567],"length":1,"stats":{"Line":6},"fn_name":null},{"line":31,"address":[6648757],"length":1,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[6650031,6649812,6650128,6649617,6649540,6649357,6650088,6650326,6649118,6649420],"length":1,"stats":{"Line":7},"fn_name":null},{"line":38,"address":[6649443,6644930,6649400,6649573,6649745],"length":1,"stats":{"Line":5},"fn_name":null},{"line":39,"address":[6649935],"length":1,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[6650536,6650209,6650512],"length":1,"stats":{"Line":2},"fn_name":null},{"line":44,"address":[6650522,6650599],"length":1,"stats":{"Line":1},"fn_name":null},{"line":46,"address":[2253920,2253535,2253580,2253640],"length":1,"stats":{"Line":5},"fn_name":null}],"covered":13,"coverable":15},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","concat_map.rs"],"content":"use ql2::term::TermType;\n\nuse crate::prelude::Func;\nuse crate::Command;\n\npub(crate) fn new(func: Func) -\u003e Command {\n    Command::new(TermType::ConcatMap).with_arg(func.0)\n}\n\n// FIX Bug\n// #[cfg(test)]\n// mod tests {\n//     use crate::prelude::*;\n//     use crate::{r, Result};\n\n//     #[tokio::test]\n//     async fn test_concat_map_data() -\u003e Result\u003c()\u003e {\n//         let conn = r.connection().connect().await?;\n//         let data_obtained: Vec\u003cu8\u003e = r\n//             .expr([1, 2, 3])\n//             .concat_map(func!(|x| vec![r.expr(1), x * 2]))\n//             .run(\u0026conn)\n//             .await?\n//             .unwrap()\n//             .parse()?;\n\n//         assert!(data_obtained == vec![1, 2, 2, 4, 3, 6]);\n\n//         Ok(())\n//     }\n// }\n","traces":[{"line":6,"address":[4583948,4583744,4583921],"length":1,"stats":{"Line":0},"fn_name":"new"},{"line":7,"address":[4583851,4583766],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":2},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","config.rs"],"content":"use ql2::term::TermType;\n\nuse crate::Command;\n\npub(crate) fn new() -\u003e Command {\n    Command::new(TermType::Config)\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::Converter;\n    use crate::spec::{set_up, tear_down};\n    use crate::types::ConfigResponse;\n    use crate::Result;\n\n    #[tokio::test]\n    async fn test_get_config_info() -\u003e Result\u003c()\u003e {\n        let (conn, table, table_name) = set_up(false).await?;\n        let response: ConfigResponse = table.config().run(\u0026conn).await?.unwrap().parse()?;\n\n        assert!(response.name == table_name);\n\n        tear_down(conn, table_name.as_str()).await\n    }\n}\n","traces":[{"line":5,"address":[2718656],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":6,"address":[2718668],"length":1,"stats":{"Line":1},"fn_name":null},{"line":17,"address":[4213813,4213360,4213399,4213765],"length":1,"stats":{"Line":6},"fn_name":"test_get_config_info"},{"line":18,"address":[6688548,6688380,6688225,6689158,6688163,6688726],"length":1,"stats":{"Line":4},"fn_name":null},{"line":19,"address":[6690280,6688331,6689110,6689415,6688246,6690124],"length":1,"stats":{"Line":5},"fn_name":null},{"line":21,"address":[6690255,6690573,6690627],"length":1,"stats":{"Line":2},"fn_name":null},{"line":23,"address":[4213496,4213436,4213776,4213391],"length":1,"stats":{"Line":7},"fn_name":null}],"covered":7,"coverable":7},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","connect.rs"],"content":"#![allow(clippy::unused_io_amount)]\n\n//! Create a new connection to the database server\n\nuse std::borrow::Cow;\nuse std::fs::File;\nuse std::io::Read;\nuse std::sync::atomic::{AtomicBool, AtomicU64};\nuse std::sync::Arc;\nuse std::time::Duration;\n\nuse async_native_tls::{Certificate, TlsConnector};\nuse async_net::TcpStream;\nuse dashmap::DashMap;\nuse futures::channel::oneshot;\nuse futures::lock::Mutex;\nuse tokio::task;\nuse tokio::time;\n\nuse super::{StaticString, TcpStreamConnection};\nuse crate::constants::{\n    DEFAULT_RETHINKDB_DBNAME, DEFAULT_RETHINKDB_HOSTNAME, DEFAULT_RETHINKDB_PASSWORD,\n    DEFAULT_RETHINKDB_PORT, DEFAULT_RETHINKDB_USER,\n};\nuse crate::{InnerSession, Result, Session};\n\n#[derive(Debug)]\n#[non_exhaustive]\npub struct ConnectionCommand {\n    /// Host of the RethinkDB instance. The default value is `localhost`.\n    host: Cow\u003c'static, str\u003e,\n\n    /// The driver port, by default `28015`.\n    port: u16,\n\n    /// The database used if not explicitly specified in a query, by default `test`.\n    db: Cow\u003c'static, str\u003e,\n\n    /// The user account to connect as (default `admin`).\n    user: Cow\u003c'static, str\u003e,\n\n    /// The password for the user account to connect as (default `\"\"`, empty).\n    password: Cow\u003c'static, str\u003e,\n\n    timeout: Option\u003cDuration\u003e,\n\n    tls_connector: Option\u003cTlsConnector\u003e,\n}\n\n#[derive(Debug, Clone)]\n#[non_exhaustive]\npub struct SslContext\u003c'a\u003e {\n    pub ca_certs: \u0026'a str,\n    pub auth_key: Option\u003c\u0026'a str\u003e,\n}\n\nimpl ConnectionCommand {\n    /// This method connect to database\n    pub async fn connect(self) -\u003e Result\u003cSession\u003e {\n        if let Some(timeout) = self.timeout {\n            let (sender, reciever) = oneshot::channel();\n\n            task::spawn(async move { sender.send(self.create_session().await) });\n\n            let session = time::timeout(timeout, reciever)\n                .await\n                .unwrap_or_else(|_| {\n                    panic!(\n                        \"It took {} seconds to open the connection\",\n                        timeout.as_secs_f32()\n                    )\n                })\n                .expect(\"The connection has been closed\");\n\n            session\n        } else {\n            self.create_session().await\n        }\n    }\n\n    /// This method set database host\n    pub fn host(mut self, host: \u0026'static str) -\u003e Self {\n        self.host = host.static_string();\n        self\n    }\n\n    /// This method set database port\n    pub fn port(mut self, port: u16) -\u003e Self {\n        self.port = port;\n        self\n    }\n\n    /// This method set database name\n    pub fn dbname(mut self, dbname: \u0026'static str) -\u003e Self {\n        self.db = Cow::from(dbname);\n        self\n    }\n\n    /// This method set database user\n    pub fn user(mut self, user: \u0026'static str, password: \u0026'static str) -\u003e Self {\n        self.user = user.static_string();\n        self.password = password.static_string();\n        self\n    }\n\n    /// Timeout period in seconds for the connection to be opened\n    pub fn timeout(mut self, timeout: Duration) -\u003e Self {\n        self.timeout = Some(timeout);\n        self\n    }\n\n    /// This method set ssl connection\n    pub fn ssl_context(mut self, ssl_context: SslContext) -\u003e Self {\n        let mut file = File::open(ssl_context.ca_certs).unwrap();\n        let mut certificate = Vec::new();\n\n        file.read_to_end(\u0026mut certificate).unwrap();\n\n        let certificate = if let Ok(cert) = Certificate::from_pem(\u0026certificate) {\n            cert\n        } else {\n            Certificate::from_der(\u0026certificate).unwrap()\n        };\n\n        self.tls_connector = Some(TlsConnector::new().add_root_certificate(certificate));\n\n        self\n    }\n\n    async fn create_session(self) -\u003e Result\u003cSession\u003e {\n        let stream = TcpStream::connect((self.host.as_ref(), self.port)).await?;\n        let mut stream = TcpStreamConnection {\n            tls_stream: if let Some(connector) = \u0026self.tls_connector {\n                let stream = connector\n                    .connect(self.host.as_ref(), stream.clone())\n                    .await?;\n                Some(stream)\n            } else {\n                None\n            },\n            stream,\n        };\n\n        if let Some(tcp_stream) = stream.tls_stream {\n            stream.tls_stream = Some(tools::handshake(tcp_stream, \u0026self).await?);\n        } else {\n            stream.stream = tools::handshake(stream.stream, \u0026self).await?;\n        }\n\n        let inner = InnerSession {\n            stream: Mutex::new(stream),\n            db: Mutex::new(self.db),\n            channels: DashMap::new(),\n            token: AtomicU64::new(0),\n            broken: AtomicBool::new(false),\n            change_feed: AtomicBool::new(false),\n        };\n\n        Ok(Session {\n            inner: Arc::new(inner),\n        })\n    }\n}\n\nimpl Default for ConnectionCommand {\n    fn default() -\u003e Self {\n        Self {\n            host: DEFAULT_RETHINKDB_HOSTNAME.static_string(),\n            port: DEFAULT_RETHINKDB_PORT,\n            db: DEFAULT_RETHINKDB_DBNAME.static_string(),\n            user: DEFAULT_RETHINKDB_USER.static_string(),\n            password: DEFAULT_RETHINKDB_PASSWORD.static_string(),\n            timeout: None,\n            tls_connector: None,\n        }\n    }\n}\n\nmod tools {\n    use futures::io::{AsyncReadExt, AsyncWriteExt};\n    use futures::{AsyncRead, AsyncWrite};\n    use ql2::version_dummy::Version;\n    use scram::client::{ScramClient, ServerFinal, ServerFirst};\n    use serde::{Deserialize, Serialize};\n    use tracing::trace;\n\n    use super::ConnectionCommand;\n    use crate::cmd::bytes_to_string;\n    use crate::constants::{\n        BUFFER_SIZE, DEFAULT_AUTHENTICATION_METHOD, NULL_BYTE, PROTOCOL_VERSION,\n    };\n    use crate::{err, Result};\n\n    // Performs the actual handshake\n    //\n    // This method optimises message exchange as suggested in the RethinkDB\n    // documentation by sending message 3 right after message 1, without waiting\n    // for message 2 first.\n    pub async fn handshake\u003cT\u003e(mut stream: T, opts: \u0026ConnectionCommand) -\u003e Result\u003cT\u003e\n    where\n        T: Unpin + AsyncWrite + AsyncReadExt + AsyncRead + AsyncReadExt,\n    {\n        trace!(\"sending supported version to RethinkDB\");\n\n        stream\n            .write_all(\u0026(Version::V10 as i32).to_le_bytes())\n            .await?; // message 1\n\n        let scram = ScramClient::new(opts.user.as_ref(), opts.password.as_ref(), None);\n        let (scram, msg) = client_first(scram)?;\n        trace!(\"sending client first message\");\n        stream.write_all(\u0026msg).await?; // message 3\n\n        let mut buf = [0u8; BUFFER_SIZE];\n\n        trace!(\"receiving message(s) from RethinkDB\");\n        stream.read(\u0026mut buf).await?; // message 2\n        let (len, resp) = bytes(\u0026buf, 0);\n        trace!(\"received server info; info: {}\", bytes_to_string(resp));\n        ServerInfo::validate(resp)?;\n\n        let offset = len + 1;\n        let resp = if offset \u003c BUFFER_SIZE \u0026\u0026 buf[offset] != NULL_BYTE {\n            bytes(\u0026buf, offset).1\n        } else {\n            trace!(\"reading auth response\");\n            stream.read(\u0026mut buf).await?; // message 4\n            bytes(\u0026buf, 0).1\n        };\n        trace!(\"received auth response\");\n        let info = AuthResponse::from_slice(resp)?;\n        let auth = match info.authentication {\n            Some(auth) =\u003e auth,\n            None =\u003e {\n                let msg = String::from(\"server did not send authentication info\");\n                return Err(err::ReqlDriverError::Other(msg).into());\n            }\n        };\n\n        let (scram, msg) = client_final(scram, \u0026auth)?;\n        trace!(\"sending client final message\");\n        stream.write_all(\u0026msg).await?; // message 5\n\n        trace!(\"reading server final message\");\n        stream.read(\u0026mut buf).await?; // message 6\n        let resp = bytes(\u0026buf, 0).1;\n        trace!(\"received server final message\");\n        server_final(scram, resp)?;\n\n        trace!(\"client connected successfully\");\n\n        Ok(stream)\n    }\n    fn bytes(buf: \u0026[u8], offset: usize) -\u003e (usize, \u0026[u8]) {\n        let len = (\u0026buf[offset..])\n            .iter()\n            .take_while(|x| **x != NULL_BYTE)\n            .count();\n        let max = offset + len;\n        (max, \u0026buf[offset..max])\n    }\n\n    // We are going to use \u0026str for `server_version` because it is safe to do so.\n    // Unfortunately, the other fields that are using String, are doing so because\n    // because they can potentially contain an escaped double quote which is not\n    // supported by serde in \u0026str.\n    #[derive(Serialize, Deserialize, Debug)]\n    struct ServerInfo\u003c'a\u003e {\n        success: bool,\n        min_protocol_version: usize,\n        max_protocol_version: usize,\n        server_version: \u0026'a str,\n    }\n\n    impl ServerInfo\u003c'_\u003e {\n        fn validate(resp: \u0026[u8]) -\u003e Result\u003c()\u003e {\n            let info = serde_json::from_slice::\u003cServerInfo\u003e(resp)?;\n            if !info.success {\n                return Err(err::ReqlRuntimeError::Internal(bytes_to_string(resp)).into());\n            }\n            #[allow(clippy::absurd_extreme_comparisons)]\n            if PROTOCOL_VERSION \u003c info.min_protocol_version\n                || info.max_protocol_version \u003c PROTOCOL_VERSION\n            {\n                let msg = format!(\n                    \"unsupported protocol version {version}, expected between {min} and {max}\",\n                    version = PROTOCOL_VERSION,\n                    min = info.min_protocol_version,\n                    max = info.max_protocol_version,\n                );\n                return Err(err::ReqlDriverError::Other(msg).into());\n            }\n            Ok(())\n        }\n    }\n\n    #[derive(Serialize, Deserialize, Debug)]\n    struct AuthRequest {\n        protocol_version: usize,\n        authentication_method: \u0026'static str,\n        authentication: String,\n    }\n\n    fn client_first(scram: ScramClient\u003c'_\u003e) -\u003e Result\u003c(ServerFirst\u003c'_\u003e, Vec\u003cu8\u003e)\u003e {\n        let (scram, client_first) = scram.client_first();\n        let ar = AuthRequest {\n            protocol_version: PROTOCOL_VERSION,\n            authentication_method: DEFAULT_AUTHENTICATION_METHOD,\n            authentication: client_first,\n        };\n        let mut msg = serde_json::to_vec(\u0026ar)?;\n        msg.push(NULL_BYTE);\n        Ok((scram, msg))\n    }\n\n    #[derive(Serialize, Deserialize, Debug)]\n    struct AuthConfirmation {\n        authentication: String,\n    }\n\n    fn client_final(scram: ServerFirst\u003c'_\u003e, auth: \u0026str) -\u003e Result\u003c(ServerFinal, Vec\u003cu8\u003e)\u003e {\n        let scram = scram\n            .handle_server_first(auth)\n            .map_err(|x| x.to_string())\n            .map_err(err::ReqlDriverError::Other)?;\n        let (scram, client_final) = scram.client_final();\n        let conf = AuthConfirmation {\n            authentication: client_final,\n        };\n        let mut msg = serde_json::to_vec(\u0026conf)?;\n        msg.push(NULL_BYTE);\n        Ok((scram, msg))\n    }\n\n    #[derive(Serialize, Deserialize, Debug)]\n    struct AuthResponse {\n        success: bool,\n        authentication: Option\u003cString\u003e,\n        error_code: Option\u003cusize\u003e,\n        error: Option\u003cString\u003e,\n    }\n\n    impl AuthResponse {\n        fn from_slice(resp: \u0026[u8]) -\u003e Result\u003cSelf\u003e {\n            let info = serde_json::from_slice::\u003cAuthResponse\u003e(resp)?;\n            if !info.success {\n                // If error code is between 10 and 20, this is an auth error\n                if let Some(10..=20) = info.error_code {\n                    if let Some(msg) = info.error {\n                        return Err(err::ReqlDriverError::Auth(msg).into());\n                    }\n                }\n                return Err(err::ReqlRuntimeError::Internal(bytes_to_string(resp)).into());\n            }\n            Ok(info)\n        }\n    }\n\n    fn server_final(scram: ServerFinal, resp: \u0026[u8]) -\u003e Result\u003c()\u003e {\n        let info = AuthResponse::from_slice(resp)?;\n        if let Some(auth) = info.authentication {\n            if let Err(error) = scram.handle_server_final(\u0026auth) {\n                return Err(err::ReqlDriverError::Other(error.to_string()).into());\n            }\n        }\n        Ok(())\n    }\n}\n\n#[cfg(test)]\nmod test {\n    use crate::{ReqlDriverError, ReqlError};\n\n    use super::ConnectionCommand;\n\n    #[tokio::test]\n    async fn test_default_connection() {\n        execute_test(ConnectionCommand::default()).await\n    }\n\n    #[tokio::test]\n    async fn test_custom_connection() {\n        let connection_command = ConnectionCommand::default()\n            .host(\"127.0.0.1\")\n            .port(28015)\n            .user(\"admin\", \"\")\n            .dbname(\"test\");\n\n        execute_test(connection_command).await\n    }\n\n    async fn execute_test(connection_command: ConnectionCommand) {\n        let db_expected = connection_command.db.clone();\n\n        match connection_command.connect().await {\n            Ok(session) =\u003e {\n                let db_obtained = \u0026session.inner.db.lock().await;\n                assert!(db_obtained.eq(\u0026db_expected));\n            }\n            Err(err) =\u003e {\n                if let ReqlError::Driver(err) = err {\n                    match err {\n                        ReqlDriverError::Io(err, msg) =\u003e {\n                            assert!(std::io::ErrorKind::ConnectionRefused.eq(\u0026err), \"{}\", msg)\n                        }\n                        ReqlDriverError::Auth(msg) =\u003e assert!(true, \"{}\", msg),\n                        _ =\u003e (),\n                    }\n                }\n            }\n        };\n    }\n}\n","traces":[{"line":59,"address":[2375656,2376237,2376459,2376014,2375525,2375456,2377446,2375814],"length":1,"stats":{"Line":27},"fn_name":"{async_fn#0}"},{"line":60,"address":[2375636,2377357,2375882],"length":1,"stats":{"Line":4},"fn_name":null},{"line":61,"address":[2375910,2376536],"length":1,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[2377553,2377758,2376566,2377504,2376705],"length":1,"stats":{"Line":0},"fn_name":"{async_block#0}"},{"line":65,"address":[2375686,2376786,2377236,2375771],"length":1,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[2377222,2378448],"length":1,"stats":{"Line":0},"fn_name":"{closure#1}"},{"line":68,"address":[2378481],"length":1,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[2378470],"length":1,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[2377309],"length":1,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[2375704,2375944,2376070,2376248],"length":1,"stats":{"Line":13},"fn_name":null},{"line":82,"address":[1777216,1777451],"length":1,"stats":{"Line":1},"fn_name":"host"},{"line":83,"address":[1777274,1777317],"length":1,"stats":{"Line":2},"fn_name":null},{"line":84,"address":[1777431],"length":1,"stats":{"Line":1},"fn_name":null},{"line":88,"address":[1777488],"length":1,"stats":{"Line":1},"fn_name":"port"},{"line":89,"address":[1777508],"length":1,"stats":{"Line":1},"fn_name":null},{"line":90,"address":[1777515],"length":1,"stats":{"Line":1},"fn_name":null},{"line":94,"address":[1777777,1777536],"length":1,"stats":{"Line":1},"fn_name":"dbname"},{"line":95,"address":[1777637,1777594],"length":1,"stats":{"Line":2},"fn_name":null},{"line":96,"address":[1777757],"length":1,"stats":{"Line":1},"fn_name":null},{"line":100,"address":[1778229,1777808],"length":1,"stats":{"Line":1},"fn_name":"user"},{"line":101,"address":[1777899,1777948],"length":1,"stats":{"Line":2},"fn_name":null},{"line":102,"address":[1778065],"length":1,"stats":{"Line":1},"fn_name":null},{"line":103,"address":[1778206],"length":1,"stats":{"Line":1},"fn_name":null},{"line":107,"address":[1778256],"length":1,"stats":{"Line":0},"fn_name":"timeout"},{"line":108,"address":[1778277],"length":1,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[1778331],"length":1,"stats":{"Line":0},"fn_name":null},{"line":113,"address":[1778916,1778352,1779581],"length":1,"stats":{"Line":0},"fn_name":"ssl_context"},{"line":114,"address":[1778374,1778486],"length":1,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[1778517],"length":1,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[1778635,1778571],"length":1,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[1778768,1778914,1778654],"length":1,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[1778752],"length":1,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[1778849,1778773],"length":1,"stats":{"Line":0},"fn_name":null},{"line":125,"address":[1779014,1779052],"length":1,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[1779352],"length":1,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[2382999,2383788,2379947,2378592,2378653,2379514,2383962,2379132,2379207,2378830],"length":1,"stats":{"Line":27},"fn_name":"{async_fn#0}"},{"line":131,"address":[2379865,2379089,2378800,2379525,2378860,2379274],"length":1,"stats":{"Line":29},"fn_name":null},{"line":133,"address":[2379806,2379980,2380877],"length":1,"stats":{"Line":11},"fn_name":null},{"line":144,"address":[2382600,2381092,2381744,2380192],"length":1,"stats":{"Line":22},"fn_name":null},{"line":145,"address":[2378902,2381129,2382605,2382059,2378987],"length":1,"stats":{"Line":0},"fn_name":null},{"line":147,"address":[2381749,2381302,2381162,2378920],"length":1,"stats":{"Line":24},"fn_name":null},{"line":151,"address":[2381938],"length":1,"stats":{"Line":11},"fn_name":null},{"line":152,"address":[2383130],"length":1,"stats":{"Line":11},"fn_name":null},{"line":153,"address":[2383238],"length":1,"stats":{"Line":11},"fn_name":null},{"line":154,"address":[2383286,2383340],"length":1,"stats":{"Line":22},"fn_name":null},{"line":155,"address":[2383366],"length":1,"stats":{"Line":11},"fn_name":null},{"line":156,"address":[2383404],"length":1,"stats":{"Line":11},"fn_name":null},{"line":159,"address":[2383724],"length":1,"stats":{"Line":11},"fn_name":null},{"line":160,"address":[2383692],"length":1,"stats":{"Line":11},"fn_name":null},{"line":166,"address":[1780192,1779696],"length":1,"stats":{"Line":4},"fn_name":"default"},{"line":168,"address":[1779713],"length":1,"stats":{"Line":4},"fn_name":null},{"line":170,"address":[1779735],"length":1,"stats":{"Line":4},"fn_name":null},{"line":171,"address":[1779800],"length":1,"stats":{"Line":4},"fn_name":null},{"line":172,"address":[1779862],"length":1,"stats":{"Line":4},"fn_name":null},{"line":199,"address":[2405104,2405200,2426254,2405422],"length":1,"stats":{"Line":22},"fn_name":"handshake\u003casync_native_tls::tls_stream::TlsStream\u003casync_net::tcp::TcpStream\u003e\u003e"},{"line":203,"address":[2427008,2427795,2406157,2427684,2406519,2407028,2406944,2427879,2406683,2406833,2427370,2427534],"length":1,"stats":{"Line":33},"fn_name":null},{"line":205,"address":[2407738,2428486,2428390,2428680,2407361,2428591,2407633,2428775,2407537,2407919,2428212,2407827],"length":1,"stats":{"Line":55},"fn_name":null},{"line":206,"address":[2428650,2407797,2428226,2428517,2426477,2407560,2407373,2405999,2405626,2407664,2428413,2426850],"length":1,"stats":{"Line":44},"fn_name":null},{"line":207,"address":[2407903,2428797,2428759,2407941],"length":1,"stats":{"Line":0},"fn_name":null},{"line":209,"address":[2428895,2428721,2407868,2408032],"length":1,"stats":{"Line":22},"fn_name":null},{"line":210,"address":[2408152,2429446,2429018,2408577],"length":1,"stats":{"Line":11},"fn_name":null},{"line":211,"address":[2408793,2409155,2429662,2409469,2430188,2430024,2409319,2409580,2430338,2430449,2430533,2409664],"length":1,"stats":{"Line":33},"fn_name":null},{"line":212,"address":[2426799,2410543,2426498,2431414,2409997,2405948,2405647,2430866],"length":1,"stats":{"Line":22},"fn_name":null},{"line":214,"address":[2410412,2431283],"length":1,"stats":{"Line":11},"fn_name":null},{"line":216,"address":[2432043,2432193,2411433,2432388,2411172,2410646,2411517,2411008,2432304,2411322,2431517,2431879],"length":1,"stats":{"Line":33},"fn_name":null},{"line":217,"address":[2426519,2411850,2426748,2433098,2432721,2412224,2405897,2405668],"length":1,"stats":{"Line":23},"fn_name":null},{"line":218,"address":[2433168,2412193,2433067,2412294],"length":1,"stats":{"Line":22},"fn_name":null},{"line":219,"address":[2433719,2413354,2434228,2433357,2434723,2412483,2413849,2413159,2434033,2434144,2412845,2413270,2433883,2413009],"length":1,"stats":{"Line":33},"fn_name":null},{"line":220,"address":[2434749,2434841,2413875,2413967],"length":1,"stats":{"Line":11},"fn_name":null},{"line":222,"address":[2414133,2435007,2434813,2413939,2435025,2414151],"length":1,"stats":{"Line":22},"fn_name":null},{"line":223,"address":[2437168,2414184,2435015,2416291,2435058,2414141],"length":1,"stats":{"Line":12},"fn_name":null},{"line":224,"address":[2414430,2435304],"length":1,"stats":{"Line":11},"fn_name":null},{"line":226,"address":[2414611,2415482,2415137,2415398,2415287,2435485,2436356,2435847,2414973,2436011,2436272,2436161],"length":1,"stats":{"Line":3},"fn_name":null},{"line":227,"address":[2415815,2437066,2416189,2426540,2436689,2426697,2405689,2405846],"length":1,"stats":{"Line":3},"fn_name":null},{"line":228,"address":[2437136,2416158,2416259,2437035],"length":1,"stats":{"Line":2},"fn_name":null},{"line":230,"address":[2416303,2417174,2437967,2438051,2416979,2417090,2437542,2437856,2416829,2416665,2437706,2437180],"length":1,"stats":{"Line":33},"fn_name":null},{"line":231,"address":[2417499,2438465,2438376,2417588,2417816,2438693],"length":1,"stats":{"Line":22},"fn_name":null},{"line":232,"address":[2417991,2438868,2417787,2438664],"length":1,"stats":{"Line":11},"fn_name":null},{"line":233,"address":[2438908,2418031],"length":1,"stats":{"Line":11},"fn_name":null},{"line":234,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":235,"address":[2438870,2417993],"length":1,"stats":{"Line":0},"fn_name":null},{"line":236,"address":[2446659,2425682],"length":1,"stats":{"Line":0},"fn_name":null},{"line":240,"address":[2418692,2439235,2418108,2438985,2418413,2439305,2439584,2418343],"length":1,"stats":{"Line":22},"fn_name":null},{"line":241,"address":[2440502,2419296,2440613,2440697,2440352,2419460,2419721,2419610,2419805,2418934,2440188,2439826],"length":1,"stats":{"Line":33},"fn_name":null},{"line":242,"address":[2426561,2441030,2420654,2420138,2426646,2405795,2405710,2441548],"length":1,"stats":{"Line":22},"fn_name":null},{"line":244,"address":[2421544,2421283,2442013,2421119,2442438,2421433,2442522,2442177,2441651,2421628,2442327,2420757],"length":1,"stats":{"Line":33},"fn_name":null},{"line":245,"address":[2442855,2443232,2405728,2422335,2421961,2426579],"length":1,"stats":{"Line":12},"fn_name":null},{"line":246,"address":[2443201,2422304,2443302,2422405],"length":1,"stats":{"Line":22},"fn_name":null},{"line":247,"address":[2443829,2422570,2444143,2444338,2444254,2423441,2423096,2423246,2443467,2422932,2443993,2423357],"length":1,"stats":{"Line":33},"fn_name":null},{"line":248,"address":[2423790,2424043,2444949,2444687],"length":1,"stats":{"Line":11},"fn_name":null},{"line":250,"address":[2424911,2424298,2424627,2446006,2445703,2424779,2445934,2425082,2445551,2445835,2445207,2425010],"length":1,"stats":{"Line":33},"fn_name":null},{"line":252,"address":[2425409,2446333],"length":1,"stats":{"Line":11},"fn_name":null},{"line":254,"address":[2397200],"length":1,"stats":{"Line":11},"fn_name":"bytes"},{"line":255,"address":[2397272],"length":1,"stats":{"Line":11},"fn_name":null},{"line":257,"address":[2447120,2447133],"length":1,"stats":{"Line":22},"fn_name":"{closure#0}"},{"line":259,"address":[2397490,2397390],"length":1,"stats":{"Line":11},"fn_name":null},{"line":260,"address":[2397545,2397433],"length":1,"stats":{"Line":22},"fn_name":null},{"line":276,"address":[2397568],"length":1,"stats":{"Line":11},"fn_name":"validate"},{"line":277,"address":[2397725,2397611],"length":1,"stats":{"Line":11},"fn_name":null},{"line":278,"address":[2397708],"length":1,"stats":{"Line":11},"fn_name":null},{"line":279,"address":[2397796],"length":1,"stats":{"Line":0},"fn_name":null},{"line":282,"address":[2397768,2397927],"length":1,"stats":{"Line":22},"fn_name":null},{"line":283,"address":[2397918],"length":1,"stats":{"Line":11},"fn_name":null},{"line":285,"address":[2397973],"length":1,"stats":{"Line":0},"fn_name":null},{"line":291,"address":[2398225],"length":1,"stats":{"Line":0},"fn_name":null},{"line":293,"address":[2397961],"length":1,"stats":{"Line":11},"fn_name":null},{"line":304,"address":[2399449,2398384,2399509],"length":1,"stats":{"Line":11},"fn_name":"client_first"},{"line":305,"address":[2398400],"length":1,"stats":{"Line":11},"fn_name":null},{"line":311,"address":[2398884,2398703,2398766],"length":1,"stats":{"Line":22},"fn_name":null},{"line":312,"address":[2398856],"length":1,"stats":{"Line":11},"fn_name":null},{"line":313,"address":[2399085],"length":1,"stats":{"Line":11},"fn_name":null},{"line":321,"address":[2399552,2401195,2401141],"length":1,"stats":{"Line":11},"fn_name":"client_final"},{"line":322,"address":[2399594,2400171],"length":1,"stats":{"Line":11},"fn_name":null},{"line":324,"address":[2447152,2447168],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":325,"address":[2400043],"length":1,"stats":{"Line":0},"fn_name":null},{"line":326,"address":[2400247,2399927],"length":1,"stats":{"Line":22},"fn_name":null},{"line":330,"address":[2400636,2400455,2400518],"length":1,"stats":{"Line":22},"fn_name":null},{"line":331,"address":[2400608],"length":1,"stats":{"Line":11},"fn_name":null},{"line":332,"address":[2400823],"length":1,"stats":{"Line":11},"fn_name":null},{"line":344,"address":[2401232,2401945,2401989],"length":1,"stats":{"Line":11},"fn_name":"from_slice"},{"line":345,"address":[2401274,2401408],"length":1,"stats":{"Line":11},"fn_name":null},{"line":346,"address":[2401387],"length":1,"stats":{"Line":11},"fn_name":null},{"line":348,"address":[2401531,2401578],"length":1,"stats":{"Line":0},"fn_name":null},{"line":349,"address":[2401586],"length":1,"stats":{"Line":0},"fn_name":null},{"line":350,"address":[2401643,2401784],"length":1,"stats":{"Line":0},"fn_name":null},{"line":353,"address":[2401837,2401568],"length":1,"stats":{"Line":0},"fn_name":null},{"line":355,"address":[2401448],"length":1,"stats":{"Line":11},"fn_name":null},{"line":359,"address":[2402176,2402994],"length":1,"stats":{"Line":11},"fn_name":"server_final"},{"line":360,"address":[2402240,2402390],"length":1,"stats":{"Line":11},"fn_name":null},{"line":361,"address":[2402362,2402491],"length":1,"stats":{"Line":22},"fn_name":null},{"line":362,"address":[2402707,2402525],"length":1,"stats":{"Line":22},"fn_name":null},{"line":363,"address":[2402812,2403085],"length":1,"stats":{"Line":0},"fn_name":null},{"line":366,"address":[2402614],"length":1,"stats":{"Line":11},"fn_name":null},{"line":377,"address":[4534048,4534481,4534077,4534438],"length":1,"stats":{"Line":6},"fn_name":"test_default_connection"},{"line":378,"address":[4534114,4534449,4534174,4534069],"length":1,"stats":{"Line":7},"fn_name":null},{"line":382,"address":[4534541,4534902,4534512,4534945],"length":1,"stats":{"Line":6},"fn_name":"test_custom_connection"},{"line":383,"address":[4786578,4786391],"length":1,"stats":{"Line":2},"fn_name":null},{"line":389,"address":[4534533,4534578,4534913,4534638],"length":1,"stats":{"Line":6},"fn_name":null},{"line":392,"address":[4532457,4532432],"length":1,"stats":{"Line":5},"fn_name":"execute_test"},{"line":393,"address":[4783164],"length":1,"stats":{"Line":1},"fn_name":null},{"line":395,"address":[4783225,4783787,4783603,4783310,4783469],"length":1,"stats":{"Line":4},"fn_name":null},{"line":396,"address":[4784009],"length":1,"stats":{"Line":1},"fn_name":null},{"line":397,"address":[4785032,4783243,4784033],"length":1,"stats":{"Line":2},"fn_name":null},{"line":398,"address":[4785475,4785363,4785428],"length":1,"stats":{"Line":2},"fn_name":null},{"line":400,"address":[4784059],"length":1,"stats":{"Line":0},"fn_name":null},{"line":401,"address":[4784096,4784202,4784804],"length":1,"stats":{"Line":0},"fn_name":null},{"line":402,"address":[4784163],"length":1,"stats":{"Line":0},"fn_name":null},{"line":403,"address":[4784300],"length":1,"stats":{"Line":0},"fn_name":null},{"line":404,"address":[4784506,4784481,4784354],"length":1,"stats":{"Line":0},"fn_name":null},{"line":406,"address":[4784229,4784595],"length":1,"stats":{"Line":0},"fn_name":null},{"line":407,"address":[4784224],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":110,"coverable":151},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","contains.rs"],"content":"use ql2::term::TermType;\nuse serde::Serialize;\n\nuse crate::arguments::Args;\nuse crate::prelude::Func;\nuse crate::Command;\n\nuse super::CmdOpts;\n\npub(crate) fn new(args: impl ContainsArg) -\u003e Command {\n    args.into_contains_opts()\n        .add_to_cmd(Command::new(TermType::Contains))\n}\n\npub trait ContainsArg {\n    fn into_contains_opts(self) -\u003e CmdOpts;\n}\n\nimpl\u003cT\u003e ContainsArg for T\nwhere\n    T: Serialize,\n{\n    fn into_contains_opts(self) -\u003e CmdOpts {\n        CmdOpts::Single(Command::from_json(self))\n    }\n}\n\nimpl ContainsArg for Func {\n    fn into_contains_opts(self) -\u003e CmdOpts {\n        CmdOpts::Single(self.0)\n    }\n}\n\nimpl ContainsArg for Command {\n    fn into_contains_opts(self) -\u003e CmdOpts {\n        CmdOpts::Single(self)\n    }\n}\n\nimpl\u003cS, T\u003e ContainsArg for Args\u003cT\u003e\nwhere\n    S: Into\u003cCommand\u003e,\n    T: IntoIterator\u003cItem = S\u003e,\n{\n    fn into_contains_opts(self) -\u003e CmdOpts {\n        CmdOpts::Many(self.0.into_iter().map(|cmd| cmd.into()).collect())\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::Converter;\n    use crate::{r, Result};\n\n    #[tokio::test]\n    async fn test_contains_ops() -\u003e Result\u003c()\u003e {\n        let conn = r.connection().connect().await?;\n        let response: bool = r\n            .expr([\"red\", \"green\", \"blue\"])\n            .contains(\"green\")\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(response);\n\n        Ok(())\n    }\n}\n","traces":[{"line":23,"address":[2855856,2856034],"length":1,"stats":{"Line":0},"fn_name":"into_contains_opts"},{"line":24,"address":[5125041],"length":1,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[2744960],"length":1,"stats":{"Line":0},"fn_name":"into_contains_opts"},{"line":30,"address":[7017601],"length":1,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[4038720,4038952],"length":1,"stats":{"Line":0},"fn_name":"into_contains_opts"},{"line":36,"address":[4038776],"length":1,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[4038992],"length":1,"stats":{"Line":0},"fn_name":"into_contains_opts"},{"line":42,"address":[4039013],"length":1,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[4039039],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":9},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","count.rs"],"content":"use ql2::term::TermType;\nuse serde::Serialize;\n\nuse crate::arguments::Args;\nuse crate::prelude::Func;\nuse crate::Command;\n\npub(crate) fn new(args: impl CountArg) -\u003e Command {\n    let mut command = Command::new(TermType::Count);\n\n    if let Some(arg) = args.into_count_arg() {\n        command = command.with_arg(arg)\n    }\n\n    command\n}\n\npub trait CountArg {\n    fn into_count_arg(self) -\u003e Option\u003cCommand\u003e;\n}\n\nimpl CountArg for () {\n    fn into_count_arg(self) -\u003e Option\u003cCommand\u003e {\n        None\n    }\n}\n\nimpl CountArg for Command {\n    fn into_count_arg(self) -\u003e Option\u003cCommand\u003e {\n        Some(self)\n    }\n}\n\nimpl CountArg for Func {\n    fn into_count_arg(self) -\u003e Option\u003cCommand\u003e {\n        Some(self.0)\n    }\n}\n\nimpl\u003cT\u003e CountArg for Args\u003cT\u003e\nwhere\n    T: Serialize,\n{\n    fn into_count_arg(self) -\u003e Option\u003cCommand\u003e {\n        Some(Command::from_json(self.0))\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::Converter;\n    use crate::spec::{set_up, tear_down, Post};\n    use crate::Result;\n\n    #[tokio::test]\n    async fn test_count_data() -\u003e Result\u003c()\u003e {\n        let data = Post::get_many_data();\n        let (conn, table, table_name) = set_up(true).await?;\n        let data_obtained: usize = table.count(()).run(\u0026conn).await?.unwrap().parse()?;\n\n        assert!(data_obtained == data.len());\n\n        tear_down(conn, \u0026table_name).await\n    }\n}\n","traces":[{"line":7,"address":[4438431,4437328,4438226],"length":1,"stats":{"Line":1},"fn_name":"new\u003c()\u003e"},{"line":8,"address":[4437345,4437456],"length":1,"stats":{"Line":2},"fn_name":null},{"line":9,"address":[4437464,4437525],"length":1,"stats":{"Line":2},"fn_name":null},{"line":11,"address":[4437600,4437916],"length":1,"stats":{"Line":1},"fn_name":null},{"line":12,"address":[4437885,4437700],"length":1,"stats":{"Line":0},"fn_name":null},{"line":15,"address":[4437783,4437921,4438161],"length":1,"stats":{"Line":1},"fn_name":null},{"line":16,"address":[4438130,4437984],"length":1,"stats":{"Line":0},"fn_name":null},{"line":19,"address":[4438072],"length":1,"stats":{"Line":1},"fn_name":null},{"line":27,"address":[2718704],"length":1,"stats":{"Line":1},"fn_name":"into_count_arg"},{"line":28,"address":[2881859],"length":1,"stats":{"Line":1},"fn_name":null},{"line":33,"address":[2172768],"length":1,"stats":{"Line":0},"fn_name":"into_count_arg"},{"line":34,"address":[2254432],"length":1,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[2745072],"length":1,"stats":{"Line":0},"fn_name":"into_count_arg"},{"line":40,"address":[2745088],"length":1,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[6658480],"length":1,"stats":{"Line":0},"fn_name":"into_count_arg"},{"line":46,"address":[2656566],"length":1,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[6658529],"length":1,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[4791831,4791792,4792245,4792197],"length":1,"stats":{"Line":6},"fn_name":"test_count_data"},{"line":60,"address":[2356611],"length":1,"stats":{"Line":1},"fn_name":null},{"line":61,"address":[2356816,2357041,2356663,2357216,2356981,2357649],"length":1,"stats":{"Line":4},"fn_name":null},{"line":62,"address":[2356684,2357857,2357601,2356767,2358586,2358687],"length":1,"stats":{"Line":5},"fn_name":null},{"line":64,"address":[2359086,2358672,2359025],"length":1,"stats":{"Line":2},"fn_name":null},{"line":66,"address":[2359343,2359159,2356702,2359400,2359045,2359534,2359283],"length":1,"stats":{"Line":7},"fn_name":null}],"covered":14,"coverable":23},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","date.rs"],"content":"use ql2::term::TermType;\n\nuse crate::Command;\n\npub(crate) fn new() -\u003e Command {\n    Command::new(TermType::Date)\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::Converter;\n    use crate::types::Time;\n    use crate::{r, Result};\n\n    #[tokio::test]\n    async fn test_date_ops() -\u003e Result\u003c()\u003e {\n        let conn = r.connection().connect().await?;\n\n        let datetime = r.now().date();\n        let date1 = datetime.clone().value();\n        let date2: Time = datetime.cmd().run(\u0026conn).await?.unwrap().parse()?;\n\n        assert!(date1 == date2);\n\n        Ok(())\n    }\n}\n","traces":[{"line":5,"address":[2718816],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":6,"address":[2718828],"length":1,"stats":{"Line":1},"fn_name":null},{"line":16,"address":[4752735,4752464,4752441,4752432,4752598,4753034,4752521],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":17,"address":[4752695,4752622,4752856,4752576,4753045,4753306],"length":1,"stats":{"Line":4},"fn_name":null},{"line":19,"address":[4753296,4753552],"length":1,"stats":{"Line":2},"fn_name":null},{"line":20,"address":[4753643,4753580],"length":1,"stats":{"Line":2},"fn_name":null},{"line":21,"address":[4754651,4752637,4753757,4753670,4754469],"length":1,"stats":{"Line":4},"fn_name":null},{"line":23,"address":[4754622,4754928,4754895],"length":1,"stats":{"Line":2},"fn_name":null},{"line":25,"address":[4754901],"length":1,"stats":{"Line":5},"fn_name":null}],"covered":9,"coverable":9},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","day.rs"],"content":"use ql2::term::TermType;\n\nuse crate::Command;\n\npub(crate) fn new() -\u003e Command {\n    Command::new(TermType::Day)\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::Converter;\n    use crate::{r, Result};\n\n    #[tokio::test]\n    async fn test_day_ops() -\u003e Result\u003c()\u003e {\n        let conn = r.connection().connect().await?;\n\n        let day = r.now().day();\n        let day1 = day.clone().value();\n        let day2: u8 = day.cmd().run(\u0026conn).await?.unwrap().parse()?;\n\n        assert!(day1 == day2);\n\n        Ok(())\n    }\n}\n","traces":[{"line":5,"address":[4750800],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":6,"address":[4750812],"length":1,"stats":{"Line":1},"fn_name":null},{"line":15,"address":[2254039,2254453,2254405,2254000],"length":1,"stats":{"Line":6},"fn_name":"test_day_ops"},{"line":16,"address":[2545454,2545408,2545877,2545527,2545688,2546138],"length":1,"stats":{"Line":4},"fn_name":null},{"line":18,"address":[2546128,2546384],"length":1,"stats":{"Line":2},"fn_name":null},{"line":19,"address":[2546412,2546475],"length":1,"stats":{"Line":2},"fn_name":null},{"line":20,"address":[2546606,2547319,2547414,2546519,2545469],"length":1,"stats":{"Line":4},"fn_name":null},{"line":22,"address":[2547393,2547607],"length":1,"stats":{"Line":1},"fn_name":null},{"line":24,"address":[2254031,2254136,2254416,2254076],"length":1,"stats":{"Line":5},"fn_name":null}],"covered":9,"coverable":9},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","day_of_week.rs"],"content":"use ql2::term::TermType;\n\nuse crate::Command;\n\npub(crate) fn new() -\u003e Command {\n    Command::new(TermType::DayOfWeek)\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::Converter;\n    use crate::{r, Result};\n\n    #[tokio::test]\n    async fn test_day_of_week_ops() -\u003e Result\u003c()\u003e {\n        let conn = r.connection().connect().await?;\n\n        let day_of_week = r.now().day_of_week();\n        let day_of_week1 = day_of_week.clone().value();\n        let day_of_week2: u8 = day_of_week.cmd().run(\u0026conn).await?.unwrap().parse()?;\n\n        assert!(day_of_week1 == day_of_week2);\n\n        Ok(())\n    }\n}\n","traces":[{"line":5,"address":[2718864],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":6,"address":[2718876],"length":1,"stats":{"Line":1},"fn_name":null},{"line":15,"address":[1711984,1712437,1712023,1712389],"length":1,"stats":{"Line":6},"fn_name":"test_day_of_week_ops"},{"line":16,"address":[4535991,4536602,4536341,4535918,4535872,4536152],"length":1,"stats":{"Line":4},"fn_name":null},{"line":18,"address":[4536592,4536848],"length":1,"stats":{"Line":2},"fn_name":null},{"line":19,"address":[4536876,4536939],"length":1,"stats":{"Line":2},"fn_name":null},{"line":20,"address":[4537878,4537783,4537070,4535933,4536983],"length":1,"stats":{"Line":4},"fn_name":null},{"line":22,"address":[4538071,4537857],"length":1,"stats":{"Line":1},"fn_name":null},{"line":24,"address":[1712120,1712060,1712015,1712400],"length":1,"stats":{"Line":5},"fn_name":null}],"covered":9,"coverable":9},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","day_of_year.rs"],"content":"use ql2::term::TermType;\n\nuse crate::Command;\n\npub(crate) fn new() -\u003e Command {\n    Command::new(TermType::DayOfYear)\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::Converter;\n    use crate::{r, Result};\n\n    #[tokio::test]\n    async fn test_day_of_year_ops() -\u003e Result\u003c()\u003e {\n        let conn = r.connection().connect().await?;\n\n        let day_of_year = r.now().day_of_year();\n        let day_of_year1 = day_of_year.clone().value();\n        let day_of_year2: u16 = day_of_year.cmd().run(\u0026conn).await?.unwrap().parse()?;\n\n        assert!(day_of_year1 == day_of_year2);\n\n        Ok(())\n    }\n}\n","traces":[{"line":5,"address":[2718912],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":6,"address":[2718924],"length":1,"stats":{"Line":1},"fn_name":null},{"line":15,"address":[1534879,1534742,1535178,1534608,1534665,1534576,1534585],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":16,"address":[1535189,1534839,1534766,1534720,1535000,1535450],"length":1,"stats":{"Line":4},"fn_name":null},{"line":18,"address":[1535696,1535440],"length":1,"stats":{"Line":2},"fn_name":null},{"line":19,"address":[1535787,1535724],"length":1,"stats":{"Line":2},"fn_name":null},{"line":20,"address":[1535921,1536734,1535834,1534781,1536634],"length":1,"stats":{"Line":4},"fn_name":null},{"line":22,"address":[1536712,1536927],"length":1,"stats":{"Line":1},"fn_name":null},{"line":24,"address":[1536897],"length":1,"stats":{"Line":5},"fn_name":null}],"covered":9,"coverable":9},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","db.rs"],"content":"use ql2::term::TermType;\n\nuse crate::Command;\n\npub(crate) fn new(db_name: impl Into\u003cString\u003e) -\u003e Command {\n    let arg = Command::from_json(db_name.into());\n\n    Command::new(TermType::Db).with_arg(arg)\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::{r, ReqlError, ReqlRuntimeError, Result};\n\n    #[tokio::test]\n    async fn test_select_db() -\u003e Result\u003c()\u003e {\n        let conn = r.connection().connect().await?;\n        let response = r.db(\"test\").run(\u0026conn).await.err().unwrap();\n\n        if let ReqlError::Runtime(err) = response {\n            if let ReqlRuntimeError::QueryLogic(msg) = err {\n                assert!(true, \"{}\", msg);\n                return Ok(());\n            }\n        }\n\n        assert!(false);\n        Ok(())\n    }\n}\n","traces":[{"line":5,"address":[2584016,2584241,2584272],"length":1,"stats":{"Line":3},"fn_name":"new"},{"line":6,"address":[4352321],"length":1,"stats":{"Line":3},"fn_name":null},{"line":8,"address":[2502428,2502503],"length":1,"stats":{"Line":6},"fn_name":null},{"line":16,"address":[1673655,1674069,1673616,1674021],"length":1,"stats":{"Line":6},"fn_name":"test_select_db"},{"line":17,"address":[4755477,4755316,4755666,4755195,4755245,4755939],"length":1,"stats":{"Line":4},"fn_name":null},{"line":18,"address":[6856566],"length":1,"stats":{"Line":3},"fn_name":null},{"line":20,"address":[4756683,4756621],"length":1,"stats":{"Line":1},"fn_name":null},{"line":21,"address":[4756697,4756670],"length":1,"stats":{"Line":2},"fn_name":null},{"line":22,"address":[4756745,4756974],"length":1,"stats":{"Line":1},"fn_name":null},{"line":23,"address":[4756943],"length":1,"stats":{"Line":1},"fn_name":null},{"line":27,"address":[4756842,4756685],"length":1,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[1673752,1674032,1673692,1673647],"length":1,"stats":{"Line":4},"fn_name":null}],"covered":11,"coverable":12},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","db_create.rs"],"content":"use ql2::term::TermType;\n\nuse crate::Command;\n\npub(crate) fn new(db_name: impl Into\u003cString\u003e) -\u003e Command {\n    Command::new(TermType::DbCreate).with_arg(Command::from_json(db_name.into()))\n}\n\n#[cfg(test)]\nmod tests {\n    use uuid::Uuid;\n\n    use crate::prelude::*;\n    use crate::types::DbResponse;\n    use crate::{r, Result};\n\n    #[tokio::test]\n    async fn test_create_db() -\u003e Result\u003c()\u003e {\n        let dbname = Uuid::new_v4().to_string();\n        let conn = r.connection().connect().await?;\n        let db_created: DbResponse = r\n            .db_create(dbname.as_str())\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(db_created.dbs_created == Some(1));\n\n        r.db_drop(\u0026dbname).run(\u0026conn).await?;\n        Ok(())\n    }\n}\n","traces":[{"line":5,"address":[4352783,4352544,4352756],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":6,"address":[2231265],"length":1,"stats":{"Line":1},"fn_name":null},{"line":8,"address":[2312940,2313015],"length":1,"stats":{"Line":2},"fn_name":null},{"line":20,"address":[2839440,2839813,2839585,2840210,2839509,2839408,2839417],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":21,"address":[2839563,2839938],"length":1,"stats":{"Line":2},"fn_name":null},{"line":22,"address":[2840017,2839615,2840506,2839953,2840221,2839770],"length":1,"stats":{"Line":4},"fn_name":null},{"line":23,"address":[2841164,2841440,2841819,2840769,2841463,2840734,2840886,2841383,2840969],"length":1,"stats":{"Line":6},"fn_name":null},{"line":24,"address":[2840480],"length":1,"stats":{"Line":1},"fn_name":null},{"line":25,"address":[2839721,2841097,2839636,2840749,2840792,2840925],"length":1,"stats":{"Line":6},"fn_name":null},{"line":26,"address":[2841287],"length":1,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[2841973,2841691,2842010],"length":1,"stats":{"Line":2},"fn_name":null},{"line":32,"address":[2842090,2839654,2841987],"length":1,"stats":{"Line":3},"fn_name":null},{"line":33,"address":[2842888],"length":1,"stats":{"Line":5},"fn_name":null}],"covered":12,"coverable":13},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","db_drop.rs"],"content":"use ql2::term::TermType;\n\nuse crate::Command;\n\npub(crate) fn new(db_name: impl Into\u003cString\u003e) -\u003e Command {\n    Command::new(TermType::DbDrop).with_arg(Command::from_json(db_name.into()))\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::*;\n    use crate::types::DbResponse;\n    use crate::{r, Result};\n\n    #[tokio::test]\n    async fn test_drop_db() -\u003e Result\u003c()\u003e {\n        let dbname = \"zuma\";\n        let conn = r.connection().connect().await?;\n        r.db_create(dbname).run(\u0026conn).await?;\n\n        let db_dropped: DbResponse = r.db_drop(dbname).run(\u0026conn).await?.unwrap().parse()?;\n\n        assert!(db_dropped.dbs_dropped == Some(1));\n        Ok(())\n    }\n}\n","traces":[{"line":5,"address":[2314225,2314000,2314256],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":6,"address":[4352833],"length":1,"stats":{"Line":1},"fn_name":null},{"line":8,"address":[2232487,2232412],"length":1,"stats":{"Line":2},"fn_name":null},{"line":18,"address":[1674565,1674151,1674112,1674517],"length":1,"stats":{"Line":6},"fn_name":"test_drop_db"},{"line":19,"address":[5121601],"length":1,"stats":{"Line":1},"fn_name":null},{"line":20,"address":[6870801],"length":1,"stats":{"Line":4},"fn_name":null},{"line":21,"address":[5122642,5122388,5121750,5121679],"length":1,"stats":{"Line":4},"fn_name":null},{"line":23,"address":[5123391,5123321,5124352,5121694,5124075],"length":1,"stats":{"Line":4},"fn_name":null},{"line":25,"address":[5124319,5124554,5124587],"length":1,"stats":{"Line":2},"fn_name":null},{"line":26,"address":[1674248,1674188,1674143,1674528],"length":1,"stats":{"Line":5},"fn_name":null}],"covered":10,"coverable":10},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","db_list.rs"],"content":"use ql2::term::TermType;\n\nuse crate::Command;\n\npub(crate) fn new() -\u003e Command {\n    Command::new(TermType::DbList)\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::*;\n    use crate::{r, Result};\n\n    #[tokio::test]\n    async fn test_list_db() -\u003e Result\u003c()\u003e {\n        let conn = r.connection().connect().await?;\n        let db_list: Vec\u003cString\u003e = r.db_list().run(\u0026conn).await?.unwrap().parse()?;\n\n        assert!(db_list.len() \u003e 0);\n        Ok(())\n    }\n}\n","traces":[{"line":5,"address":[2718960],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":6,"address":[2718972],"length":1,"stats":{"Line":1},"fn_name":null},{"line":15,"address":[2550445,2550297,2550580,2550377,2550879,2550288,2550320],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":16,"address":[2550435,2550540,2550890,2550701,2551151,2550469],"length":1,"stats":{"Line":4},"fn_name":null},{"line":17,"address":[2551379,2552079,2550484,2552219,2551141],"length":1,"stats":{"Line":4},"fn_name":null},{"line":19,"address":[2552442,2552192,2552486],"length":1,"stats":{"Line":2},"fn_name":null},{"line":20,"address":[2552455],"length":1,"stats":{"Line":5},"fn_name":null}],"covered":7,"coverable":7},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","default.rs"],"content":"use ql2::term::TermType;\nuse serde::Serialize;\n\nuse crate::Command;\n\npub(crate) fn new(args: impl Serialize) -\u003e Command {\n    Command::new(TermType::Default).with_arg(Command::from_json(args))\n}\n\n#[cfg(test)]\nmod tests {\n    use std::collections::HashMap;\n\n    use serde::{Deserialize, Serialize};\n\n    use crate::prelude::*;\n    use crate::spec::{set_up, tear_down, Post};\n    use crate::{r, Result};\n\n    #[derive(Debug, Serialize, Deserialize, PartialEq, Eq)]\n    struct InnerPost {\n        title: String,\n        content: String,\n    }\n\n    #[tokio::test]\n    async fn test_default_ops() -\u003e Result\u003c()\u003e {\n        let data: Vec\u003cInnerPost\u003e = Post::get_many_data()\n            .into_iter()\n            .map(|post| InnerPost {\n                title: post.title,\n                content: if let Some(content) = post.content {\n                    content\n                } else {\n                    \"Anonymous\".to_owned()\n                },\n            })\n            .collect();\n        let (conn, table, table_name) = set_up(true).await?;\n        let response: Vec\u003cInnerPost\u003e = table\n            .order_by(r.expr(\"title\"))\n            .map(func!(|doc| {\n                let mut post = HashMap::new();\n                post.insert(\"title\", doc.clone().g(\"title\"));\n                post.insert(\"content\", doc.g(\"content\").default(\"Anonymous\"));\n                r.hash_map(post)\n            }))\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(response == data);\n\n        tear_down(conn, \u0026table_name).await\n    }\n}\n","traces":[{"line":6,"address":[4457616,4457898],"length":1,"stats":{"Line":1},"fn_name":"new\u003c\u0026str\u003e"},{"line":7,"address":[4457888,4457659,4457764],"length":1,"stats":{"Line":2},"fn_name":null},{"line":27,"address":[3080789,3080720,3080905,3081131,3080688,3080697,3081549],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":28,"address":[3080851,3081256],"length":1,"stats":{"Line":2},"fn_name":null},{"line":30,"address":[3085152,3085398,3085367],"length":1,"stats":{"Line":1},"fn_name":"{closure#0}"},{"line":31,"address":[3085179],"length":1,"stats":{"Line":1},"fn_name":null},{"line":32,"address":[3085215,3085304],"length":1,"stats":{"Line":2},"fn_name":null},{"line":33,"address":[3085274],"length":1,"stats":{"Line":1},"fn_name":null},{"line":35,"address":[3085365,3085306],"length":1,"stats":{"Line":2},"fn_name":null},{"line":39,"address":[6891800],"length":1,"stats":{"Line":4},"fn_name":null},{"line":40,"address":[3083211,3082918,3083759,3083052,3082228,3083702,3083483,3084033,3083803,3081969,3083288],"length":1,"stats":{"Line":8},"fn_name":null},{"line":41,"address":[3082303,3082267,3081991,3082194,3082321],"length":1,"stats":{"Line":2},"fn_name":null},{"line":42,"address":[3082341,3082296,3086058,3082376,3082957,3085536],"length":1,"stats":{"Line":3},"fn_name":"{closure#1}"},{"line":43,"address":[3085566],"length":1,"stats":{"Line":1},"fn_name":null},{"line":44,"address":[3085648,3085709],"length":1,"stats":{"Line":2},"fn_name":null},{"line":45,"address":[3085798],"length":1,"stats":{"Line":1},"fn_name":null},{"line":46,"address":[3085960],"length":1,"stats":{"Line":1},"fn_name":null},{"line":48,"address":[3080956,3083032,3081039,3083120,3083416,3083244],"length":1,"stats":{"Line":6},"fn_name":null},{"line":49,"address":[3083606],"length":1,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[3083923,3084288,3084343],"length":1,"stats":{"Line":2},"fn_name":null},{"line":55,"address":[2269936,2269596,2269656,2269551],"length":1,"stats":{"Line":7},"fn_name":null}],"covered":20,"coverable":21},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","delete.rs"],"content":"use ql2::term::TermType;\nuse reql_macros::CommandOptions;\nuse serde::Serialize;\n\nuse crate::arguments::{Durability, ReturnChanges};\nuse crate::Command;\n\npub(crate) fn new(args: impl DeleteArg) -\u003e Command {\n    Command::new(TermType::Delete).with_opts(args.into_delete_opts())\n}\n\npub trait DeleteArg {\n    fn into_delete_opts(self) -\u003e DeleteOption;\n}\n\nimpl DeleteArg for () {\n    fn into_delete_opts(self) -\u003e DeleteOption {\n        Default::default()\n    }\n}\nimpl DeleteArg for DeleteOption {\n    fn into_delete_opts(self) -\u003e DeleteOption {\n        self\n    }\n}\n\n#[derive(Debug, Clone, Copy, Serialize, Default, PartialEq, PartialOrd, CommandOptions)]\npub struct DeleteOption {\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub durability: Option\u003cDurability\u003e,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub return_changes: Option\u003cReturnChanges\u003e,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub non_atomic: Option\u003cbool\u003e,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub ignore_write_hook: Option\u003cbool\u003e,\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::arguments::ReturnChanges;\n    use crate::prelude::Converter;\n    use crate::spec::*;\n    use crate::types::MutationResponse;\n    use crate::Result;\n\n    use super::DeleteOption;\n\n    #[tokio::test]\n    async fn test_delete_docs() -\u003e Result\u003c()\u003e {\n        let (conn, table, table_name) = set_up(true).await?;\n        let response: MutationResponse =\n            table.get(5).delete(()).run(\u0026conn).await?.unwrap().parse()?;\n\n        assert!(response.deleted == 1);\n\n        tear_down(conn, \u0026table_name).await\n    }\n\n    #[tokio::test]\n    async fn test_delete_docs_with_opts() -\u003e Result\u003c()\u003e {\n        let data = Post::get_many_data().get(0).unwrap().to_owned();\n        let delete_option = DeleteOption::default().return_changes(ReturnChanges::Bool(true));\n        let (conn, table, table_name) = set_up(true).await?;\n        let response: MutationResponse = table\n            .get(1)\n            .delete(delete_option)\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(response.deleted == 1);\n\n        let old_val: Post = response\n            .changes\n            .unwrap()\n            .first()\n            .unwrap()\n            .to_owned()\n            .old_val\n            .unwrap()\n            .parse()?;\n\n        assert!(old_val == data);\n\n        tear_down(conn, \u0026table_name).await\n    }\n}\n","traces":[{"line":8,"address":[2353984,2354250],"length":1,"stats":{"Line":1},"fn_name":"new\u003c()\u003e"},{"line":9,"address":[2354240,2354096,2354001],"length":1,"stats":{"Line":2},"fn_name":null},{"line":17,"address":[2697872],"length":1,"stats":{"Line":1},"fn_name":"into_delete_opts"},{"line":18,"address":[2697876],"length":1,"stats":{"Line":1},"fn_name":null},{"line":22,"address":[2697904],"length":1,"stats":{"Line":0},"fn_name":"into_delete_opts"},{"line":23,"address":[2697919],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":4,"coverable":6},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","delete_at.rs"],"content":"use ql2::term::TermType;\n\nuse crate::arguments::Args;\nuse crate::Command;\n\npub(crate) fn new(args: impl DeleteAtArg) -\u003e Command {\n    let (start_offset, end_offset) = args.into_delete_at_opts();\n    let mut command = Command::new(TermType::DeleteAt).with_arg(start_offset);\n\n    if let Some(end_offset) = end_offset {\n        command = command.with_arg(end_offset);\n    }\n\n    command\n}\n\npub trait DeleteAtArg {\n    fn into_delete_at_opts(self) -\u003e (Command, Option\u003cCommand\u003e);\n}\n\nimpl DeleteAtArg for isize {\n    fn into_delete_at_opts(self) -\u003e (Command, Option\u003cCommand\u003e) {\n        (Command::from_json(self), None)\n    }\n}\n\nimpl DeleteAtArg for Args\u003c(isize, isize)\u003e {\n    fn into_delete_at_opts(self) -\u003e (Command, Option\u003cCommand\u003e) {\n        (\n            Command::from_json(self.0 .0),\n            Some(Command::from_json(self.0 .1)),\n        )\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::Converter;\n    use crate::{args, r, Result};\n\n    const DATA: [char; 6] = ['a', 'b', 'c', 'd', 'e', 'f'];\n\n    #[tokio::test]\n    async fn test_delete_at_ops() -\u003e Result\u003c()\u003e {\n        let conn = r.connection().connect().await?;\n        let response: [char; 5] = r\n            .expr(\u0026DATA)\n            .delete_at(1)\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        let response2: [char; 5] = r\n            .expr(\u0026DATA)\n            .delete_at(-2)\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        let response3: [char; 4] = r\n            .expr(\u0026DATA)\n            .delete_at(args!(1, 3))\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(response == ['a', 'c', 'd', 'e', 'f']);\n        assert!(response2 == ['a', 'b', 'c', 'd', 'f']);\n        assert!(response3 == ['a', 'd', 'e', 'f']);\n\n        Ok(())\n    }\n}\n","traces":[{"line":21,"address":[1550752],"length":1,"stats":{"Line":0},"fn_name":"into_delete_at_opts"},{"line":22,"address":[1550776],"length":1,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[1550864,1551055],"length":1,"stats":{"Line":0},"fn_name":"into_delete_at_opts"},{"line":28,"address":[1550902],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":4},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","desc.rs"],"content":"use ql2::term::TermType;\nuse serde::Serialize;\n\nuse crate::prelude::Func;\nuse crate::Command;\n\npub(crate) fn new(args: impl DescArg) -\u003e Command {\n    Command::new(TermType::Desc).with_arg(args.into_desc_opts())\n}\n\npub trait DescArg {\n    fn into_desc_opts(self) -\u003e Command;\n}\n\nimpl\u003cT\u003e DescArg for T\nwhere\n    T: Into\u003cT\u003e + Serialize,\n{\n    fn into_desc_opts(self) -\u003e Command {\n        Command::from_json(self)\n    }\n}\n\nimpl DescArg for Func {\n    fn into_desc_opts(self) -\u003e Command {\n        self.0\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::*;\n    use crate::spec::*;\n    use crate::{args, r, Result};\n\n    #[tokio::test]\n    async fn test_desc_ops() -\u003e Result\u003c()\u003e {\n        let (conn, table, table_name) = set_up(true).await?;\n        let response: Vec\u003cPost\u003e = table\n            .order_by(args!(r.expr(\"view\"), r.desc(\"title\")))\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(response.len() \u003e 1);\n\n        tear_down(conn, \u0026table_name).await\n    }\n}\n","traces":[{"line":7,"address":[6934906,6934624],"length":1,"stats":{"Line":1},"fn_name":"new\u003c\u0026str\u003e"},{"line":8,"address":[6934772,6934667,6934896],"length":1,"stats":{"Line":2},"fn_name":null},{"line":19,"address":[6934944],"length":1,"stats":{"Line":1},"fn_name":"into_desc_opts\u003c\u0026str\u003e"},{"line":20,"address":[6934965],"length":1,"stats":{"Line":1},"fn_name":null},{"line":25,"address":[2745216],"length":1,"stats":{"Line":0},"fn_name":"into_desc_opts"},{"line":26,"address":[7017848],"length":1,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[1755429,1755360,1756052,1755328,1755760,1755534,1755337],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":38,"address":[1756505,1755885,1755564,1755717,1756063,1755491],"length":1,"stats":{"Line":4},"fn_name":null},{"line":39,"address":[1757745,1757425,1756924,1757644,1757230,1757976,1757701,1756453,1757153,1756987],"length":1,"stats":{"Line":7},"fn_name":null},{"line":40,"address":[1756711,1756994,1756475,1756963,1757012],"length":1,"stats":{"Line":2},"fn_name":null},{"line":41,"address":[1755585,1757062,1757186,1755668,1757358],"length":1,"stats":{"Line":5},"fn_name":null},{"line":42,"address":[1757548],"length":1,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[1758174,1757865,1758235],"length":1,"stats":{"Line":2},"fn_name":null},{"line":48,"address":[1758428,1758484,1758195,1758559,1758689,1755603,1758304],"length":1,"stats":{"Line":7},"fn_name":null}],"covered":11,"coverable":14},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","difference.rs"],"content":"use ql2::term::TermType;\nuse serde::Serialize;\n\nuse crate::Command;\n\npub(crate) fn new(args: impl DifferenceArg) -\u003e Command {\n    Command::new(TermType::Difference).with_arg(args.into_difference_opts())\n}\n\npub trait DifferenceArg {\n    fn into_difference_opts(self) -\u003e Command;\n}\n\nimpl\u003cS, T\u003e DifferenceArg for T\nwhere\n    S: Serialize,\n    T: IntoIterator\u003cItem = S\u003e + Serialize,\n{\n    fn into_difference_opts(self) -\u003e Command {\n        Command::from_json(self)\n    }\n}\n\nimpl DifferenceArg for Command {\n    fn into_difference_opts(self) -\u003e Command {\n        self\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::Converter;\n    use crate::{r, Result};\n\n    #[tokio::test]\n    async fn test_difference_ops() -\u003e Result\u003c()\u003e {\n        let conn = r.connection().connect().await?;\n        let response: [u8; 4] = r\n            .expr([10, 20, 30, 40, 50])\n            .difference([30, 70])\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(response == [10, 20, 40, 50]);\n\n        Ok(())\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","distance.rs"],"content":"use ql2::term::TermType;\nuse reql_macros::CommandOptions;\nuse serde::Serialize;\n\nuse crate::arguments::{Args, Unit};\nuse crate::prelude::Geometry;\nuse crate::types::GeoSystem;\nuse crate::Command;\n\npub(crate) fn new(args: impl DistanceArg) -\u003e Command {\n    let (arg1, arg2, opts) = args.into_distance_opts();\n    let mut command = Command::new(TermType::Distance).with_arg(arg1);\n\n    if let Some(arg) = arg2 {\n        command = command.with_arg(arg)\n    }\n\n    command.with_opts(opts)\n}\n\npub trait DistanceArg {\n    fn into_distance_opts(self) -\u003e (Command, Option\u003cCommand\u003e, DistanceOption);\n}\n\nimpl\u003cT: Geometry\u003e DistanceArg for T {\n    fn into_distance_opts(self) -\u003e (Command, Option\u003cCommand\u003e, DistanceOption) {\n        (self.into(), None, Default::default())\n    }\n}\n\nimpl\u003cT: Geometry\u003e DistanceArg for Args\u003c(T, DistanceOption)\u003e {\n    fn into_distance_opts(self) -\u003e (Command, Option\u003cCommand\u003e, DistanceOption) {\n        (self.0 .0.into(), None, self.0 .1)\n    }\n}\n\n#[derive(\n    Debug, Clone, Copy, Serialize, Default, PartialEq, Eq, PartialOrd, Ord, CommandOptions,\n)]\npub struct DistanceOption {\n    /// the reference ellipsoid to use for geographic coordinates.\n    /// Possible values are `GeoSystem::WGS84` (the default),\n    /// a common standard for Earth’s geometry, or `GeoSystem::UnitSphere`,\n    /// a perfect sphere of 1 meter radius.\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub geo_system: Option\u003cGeoSystem\u003e,\n    /// Unit to return the distance in.\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub unit: Option\u003cUnit\u003e,\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::arguments::Unit;\n    use crate::prelude::*;\n    use crate::{args, r, Result};\n\n    use super::DistanceOption;\n\n    #[tokio::test]\n    async fn test_distance_data() -\u003e Result\u003c()\u003e {\n        let conn = r.connection().connect().await?;\n        let point1 = r.point(-122.423246, 37.779388);\n        let point2 = r.point(-117.220406, 32.719464);\n        let distance_option = DistanceOption::default().unit(Unit::Kilometer);\n\n        let response: f64 = r\n            .distance(point1.cmd(), args!(point2, distance_option))\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(response == 734.125249602186);\n\n        Ok(())\n    }\n}\n","traces":[{"line":10,"address":[3502864,3503591,3503678],"length":1,"stats":{"Line":1},"fn_name":"new\u003creql_rust::arguments::Args\u003c(reql_rust::cmd::point::Point, reql_rust::cmd::distance::DistanceOption)\u003e\u003e"},{"line":11,"address":[3502881],"length":1,"stats":{"Line":1},"fn_name":null},{"line":12,"address":[3503082,3503179],"length":1,"stats":{"Line":2},"fn_name":null},{"line":14,"address":[3503517,3503247],"length":1,"stats":{"Line":1},"fn_name":null},{"line":15,"address":[3503368,3503491],"length":1,"stats":{"Line":0},"fn_name":null},{"line":18,"address":[3503458],"length":1,"stats":{"Line":1},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":33,"address":[1817142],"length":1,"stats":{"Line":1},"fn_name":null},{"line":61,"address":[4774477,4774329,4774320,4774612,4774409,4774911,4774352],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":62,"address":[4774922,4774733,4774501,4775199,4774467,4774572],"length":1,"stats":{"Line":4},"fn_name":null},{"line":63,"address":[4775189],"length":1,"stats":{"Line":1},"fn_name":null},{"line":64,"address":[4775460],"length":1,"stats":{"Line":1},"fn_name":null},{"line":65,"address":[4775467],"length":1,"stats":{"Line":1},"fn_name":null},{"line":67,"address":[4776460,4775999,4775785,4776497,4776184,4775928,4776403,4776704,4775817],"length":1,"stats":{"Line":6},"fn_name":null},{"line":68,"address":[4775561,4775651],"length":1,"stats":{"Line":2},"fn_name":null},{"line":69,"address":[4775840,4775797,4774516,4776127,4775958],"length":1,"stats":{"Line":5},"fn_name":null},{"line":70,"address":[4776307],"length":1,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[4776573,4776797],"length":1,"stats":{"Line":1},"fn_name":null},{"line":76,"address":[4214428,4214488,4214383,4214768],"length":1,"stats":{"Line":5},"fn_name":null}],"covered":17,"coverable":21},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","distinct.rs"],"content":"use std::borrow::Cow;\n\nuse ql2::term::TermType;\nuse reql_macros::CommandOptions;\nuse serde::Serialize;\n\nuse crate::Command;\n\npub(crate) fn new(args: impl DistinctArg) -\u003e Command {\n    let (args, opts) = args.into_distinct_opts();\n    let mut command = Command::new(TermType::Distinct);\n\n    if let Some(arg) = args {\n        command = command.with_arg(arg)\n    }\n\n    command.with_opts(opts)\n}\n\npub trait DistinctArg {\n    fn into_distinct_opts(self) -\u003e (Option\u003cCommand\u003e, DistinctOption);\n}\n\nimpl DistinctArg for () {\n    fn into_distinct_opts(self) -\u003e (Option\u003cCommand\u003e, DistinctOption) {\n        (None, Default::default())\n    }\n}\n\nimpl DistinctArg for DistinctOption {\n    fn into_distinct_opts(self) -\u003e (Option\u003cCommand\u003e, DistinctOption) {\n        (None, self)\n    }\n}\n\nimpl DistinctArg for Command {\n    fn into_distinct_opts(self) -\u003e (Option\u003cCommand\u003e, DistinctOption) {\n        (Some(self), Default::default())\n    }\n}\n\n#[derive(Debug, Clone, Serialize, Default, PartialEq, PartialOrd, CommandOptions)]\npub struct DistinctOption {\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub index: Option\u003cCow\u003c'static, str\u003e\u003e,\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::Converter;\n    use crate::spec::{set_up, tear_down, Post};\n    use crate::Result;\n\n    use super::DistinctOption;\n\n    #[tokio::test]\n    async fn test_distinct_data() -\u003e Result\u003c()\u003e {\n        let mut data = Post::get_many_data()\n            .into_iter()\n            .map(|post| post.title)\n            .collect::\u003cVec\u003cString\u003e\u003e();\n        data.pop();\n        let (conn, table, table_name) = set_up(true).await?;\n        let data_obtained: Vec\u003cString\u003e = table\n            .distinct(DistinctOption::default().index(\"title\"))\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(data_obtained == data);\n\n        tear_down(conn, \u0026table_name).await\n    }\n}\n","traces":[{"line":9,"address":[1546189,1546210,1545552],"length":1,"stats":{"Line":1},"fn_name":"new\u003creql_rust::cmd::distinct::DistinctOption\u003e"},{"line":10,"address":[1545569],"length":1,"stats":{"Line":1},"fn_name":null},{"line":11,"address":[1545728],"length":1,"stats":{"Line":1},"fn_name":null},{"line":13,"address":[1545802,1546100],"length":1,"stats":{"Line":1},"fn_name":null},{"line":14,"address":[1545917,1546074],"length":1,"stats":{"Line":0},"fn_name":null},{"line":17,"address":[1546007],"length":1,"stats":{"Line":1},"fn_name":null},{"line":25,"address":[2743856,2744036],"length":1,"stats":{"Line":0},"fn_name":"into_distinct_opts"},{"line":26,"address":[2743873],"length":1,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[2744064],"length":1,"stats":{"Line":1},"fn_name":"into_distinct_opts"},{"line":32,"address":[2825731],"length":1,"stats":{"Line":1},"fn_name":null},{"line":37,"address":[2173139,2172912],"length":1,"stats":{"Line":0},"fn_name":"into_distinct_opts"},{"line":38,"address":[4039379],"length":1,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[2173168],"length":1,"stats":{"Line":0},"fn_name":"into_distinct_opts"},{"line":44,"address":[2173189],"length":1,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[4767296,4767749,4767701,4767335],"length":1,"stats":{"Line":6},"fn_name":"test_distinct_data"},{"line":64,"address":[4014451,4014840],"length":1,"stats":{"Line":2},"fn_name":null},{"line":66,"address":[4018124,4018096],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":68,"address":[4014909,4014960],"length":1,"stats":{"Line":2},"fn_name":null},{"line":69,"address":[6760432],"length":1,"stats":{"Line":3},"fn_name":null},{"line":70,"address":[4016672,4016716,4015958,4016396,4015883,4016615,4016124,4016946,4015590,4016201],"length":1,"stats":{"Line":7},"fn_name":null},{"line":71,"address":[4015807,4015930,4015965,4015983,4015620],"length":1,"stats":{"Line":2},"fn_name":null},{"line":72,"address":[4015938,4016157,4014540,4014623,4016033,4016329],"length":1,"stats":{"Line":6},"fn_name":null},{"line":73,"address":[4016519],"length":1,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[4017260,4016836,4017205],"length":1,"stats":{"Line":2},"fn_name":null},{"line":79,"address":[4017601,4017457,4017735,4017219,4017517,4017333,4014558],"length":1,"stats":{"Line":7},"fn_name":null}],"covered":17,"coverable":25},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","div.rs"],"content":"use std::ops::Div;\n\nuse ql2::term::TermType;\nuse serde::Serialize;\n\nuse crate::Command;\n\nimpl\u003cT: DivArg\u003e Div\u003cT\u003e for Command {\n    type Output = Self;\n\n    fn div(self, arg: T) -\u003e Self {\n        Command::new(TermType::Div)\n            .with_arg(arg.into_div_opts())\n            .with_parent(self)\n    }\n}\n\npub trait DivArg {\n    fn into_div_opts(self) -\u003e Command;\n}\n\nimpl\u003cT: Serialize\u003e DivArg for T {\n    fn into_div_opts(self) -\u003e Command {\n        Command::from_json(self)\n    }\n}\n\nimpl DivArg for Command {\n    fn into_div_opts(self) -\u003e Command {\n        self\n    }\n}\n\n// TODO write test\n","traces":[{"line":11,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":12,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":13,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":14,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[4039808],"length":1,"stats":{"Line":0},"fn_name":"into_div_opts"},{"line":30,"address":[4039816],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":8},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","do_.rs"],"content":"use ql2::term::TermType;\n\nuse crate::arguments::Args;\nuse crate::prelude::Func;\nuse crate::Command;\n\nuse super::CmdOpts;\n\npub(crate) fn new(args: impl DoArg) -\u003e Command {\n    args.into_do_opts()\n        .add_to_cmd(Command::new(TermType::Funcall))\n}\n\npub trait DoArg {\n    fn into_do_opts(self) -\u003e CmdOpts;\n}\n\nimpl DoArg for Command {\n    fn into_do_opts(self) -\u003e CmdOpts {\n        CmdOpts::Single(self)\n    }\n}\n\nimpl DoArg for Func {\n    fn into_do_opts(self) -\u003e CmdOpts {\n        CmdOpts::Single(self.0)\n    }\n}\n\nimpl DoArg for Args\u003c(Command, Command)\u003e {\n    fn into_do_opts(self) -\u003e CmdOpts {\n        CmdOpts::Many(vec![self.0 .0, self.0 .1])\n    }\n}\n\nimpl DoArg for Args\u003c(Command, Func)\u003e {\n    fn into_do_opts(self) -\u003e CmdOpts {\n        let Func(func) = self.0 .1;\n\n        CmdOpts::Many(vec![self.0 .0, func])\n    }\n}\n\nimpl\u003cconst N: usize\u003e DoArg for Args\u003c([Command; N], Func)\u003e {\n    fn into_do_opts(self) -\u003e CmdOpts {\n        let Func(func) = self.0 .1;\n        let mut args = self.0 .0.to_vec();\n\n        args.push(func);\n        CmdOpts::Many(args)\n    }\n}\n\nimpl\u003cconst N: usize\u003e DoArg for Args\u003c([Command; N], Command)\u003e {\n    fn into_do_opts(self) -\u003e CmdOpts {\n        let mut args = self.0 .0.to_vec();\n\n        args.push(self.0 .1);\n        CmdOpts::Many(args)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use std::ops::Add;\n\n    use crate::prelude::*;\n    use crate::spec::*;\n    use crate::{r, Result};\n\n    #[tokio::test]\n    #[ignore = \"not work\"]\n    async fn test_do_opts() -\u003e Result\u003c()\u003e {\n        let (conn, table, table_name) = set_up(true).await?;\n        let response = table\n            .get(1)\n            .do_(func!(|post| post.g(\"view\").add(r.expr(5))))\n            .run(\u0026conn)\n            .await;\n\n        dbg!(\u0026response);\n\n        tear_down(conn, \u0026table_name).await\n    }\n}\n","traces":[{"line":9,"address":[4532512,4532700,4532727],"length":1,"stats":{"Line":0},"fn_name":"new\u003creql_rust::cmd::func::Func\u003e"},{"line":10,"address":[4532651,4532528],"length":1,"stats":{"Line":0},"fn_name":null},{"line":11,"address":[4532720,4532684,4532580],"length":1,"stats":{"Line":0},"fn_name":null},{"line":19,"address":[2255072],"length":1,"stats":{"Line":0},"fn_name":"into_do_opts"},{"line":20,"address":[2173440],"length":1,"stats":{"Line":0},"fn_name":null},{"line":25,"address":[2826896],"length":1,"stats":{"Line":0},"fn_name":"into_do_opts"},{"line":26,"address":[2745264],"length":1,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[2738766,2738400],"length":1,"stats":{"Line":0},"fn_name":"into_do_opts"},{"line":32,"address":[2738522,2738422],"length":1,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[6659502,6659104],"length":1,"stats":{"Line":0},"fn_name":"into_do_opts"},{"line":38,"address":[6659126],"length":1,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[6659252,6659194],"length":1,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":21},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","downcase.rs"],"content":"use ql2::term::TermType;\n\nuse crate::Command;\n\npub(crate) fn new() -\u003e Command {\n    Command::new(TermType::Downcase)\n}\n\n// TODO write test\n","traces":[{"line":5,"address":[2719008],"length":1,"stats":{"Line":0},"fn_name":"new"},{"line":6,"address":[2719020],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":2},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","during.rs"],"content":"use ql2::term::TermType;\nuse reql_macros::CommandOptions;\nuse serde::Serialize;\n\nuse crate::arguments::{Args, Status};\nuse crate::types::DateTime;\nuse crate::Command;\n\npub(crate) fn new(args: impl DuringArg) -\u003e Command {\n    let (arg1, arg2, opts) = args.into_during_opts();\n\n    Command::new(TermType::During)\n        .with_arg(arg1)\n        .with_arg(arg2)\n        .with_opts(opts)\n}\n\npub trait DuringArg {\n    fn into_during_opts(self) -\u003e (Command, Command, DuringOption);\n}\n\nimpl DuringArg for Args\u003c(DateTime, DateTime)\u003e {\n    fn into_during_opts(self) -\u003e (Command, Command, DuringOption) {\n        (self.0 .0.into(), self.0 .1.into(), Default::default())\n    }\n}\n\nimpl DuringArg for Args\u003c(DateTime, DateTime, DuringOption)\u003e {\n    fn into_during_opts(self) -\u003e (Command, Command, DuringOption) {\n        (self.0 .0.into(), self.0 .1.into(), self.0 .2)\n    }\n}\n\nimpl DuringArg for Args\u003c(DateTime, DateTime, Option\u003cDuringOption\u003e)\u003e {\n    fn into_during_opts(self) -\u003e (Command, Command, DuringOption) {\n        (\n            self.0 .0.into(),\n            self.0 .1.into(),\n            self.0 .2.unwrap_or_default(),\n        )\n    }\n}\n\nimpl DuringArg for Args\u003c(Command, Command)\u003e {\n    fn into_during_opts(self) -\u003e (Command, Command, DuringOption) {\n        (self.0 .0, self.0 .1, Default::default())\n    }\n}\n\nimpl DuringArg for Args\u003c(Command, Command, DuringOption)\u003e {\n    fn into_during_opts(self) -\u003e (Command, Command, DuringOption) {\n        (self.0 .0, self.0 .1, self.0 .2)\n    }\n}\n\n/// By default, this is inclusive of the start time and exclusive of the end time.\n/// Set left_bound and right_bound to explicitly include\n/// (closed) or exclude (open) that endpoint of the range.\n#[derive(Debug, Clone, Copy, Serialize, Default, PartialEq, PartialOrd, CommandOptions)]\npub struct DuringOption {\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub left_bound: Option\u003cStatus\u003e,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub right_bound: Option\u003cStatus\u003e,\n}\n\n#[cfg(test)]\nmod tests {\n    use time::macros::{date, offset};\n\n    use crate::prelude::Converter;\n    use crate::{args, r, Result};\n\n    #[tokio::test]\n    async fn test_during_ops() -\u003e Result\u003c()\u003e {\n        let conn = r.connection().connect().await?;\n        let start_date = r.time(args!(date!(2022 - 08 - 01), offset!(UTC)));\n        let end_date = r.time(args!(date!(2022 - 12 - 31), offset!(UTC)));\n\n        let datetime = r.epoch_time(1661990400)?;\n\n        let response = datetime\n            .clone()\n            .during(start_date.clone(), end_date.clone(), None);\n        let response2: bool = response.clone().cmd().run(\u0026conn).await?.unwrap().parse()?;\n        let response3: bool = datetime\n            .cmd()\n            .during(args!(start_date, end_date))\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(response2 == response3 \u0026\u0026 response2 == response.value());\n\n        Ok(())\n    }\n}\n","traces":[{"line":9,"address":[2567855,2567344],"length":1,"stats":{"Line":2},"fn_name":"new\u003creql_rust::arguments::Args\u003c(reql_rust::types::datetime::DateTime, reql_rust::types::datetime::DateTime, core::option::Option\u003creql_rust::cmd::during::DuringOption\u003e)\u003e\u003e"},{"line":10,"address":[2567361],"length":1,"stats":{"Line":2},"fn_name":null},{"line":12,"address":[2567657,2567730,2567534],"length":1,"stats":{"Line":6},"fn_name":null},{"line":13,"address":[2567612],"length":1,"stats":{"Line":2},"fn_name":null},{"line":14,"address":[1794603,1794059],"length":1,"stats":{"Line":2},"fn_name":null},{"line":23,"address":[6659552,6659918],"length":1,"stats":{"Line":1},"fn_name":"into_during_opts"},{"line":24,"address":[6659574,6659680],"length":1,"stats":{"Line":2},"fn_name":null},{"line":29,"address":[6660307,6659968],"length":1,"stats":{"Line":0},"fn_name":"into_during_opts"},{"line":30,"address":[6659990,6660096],"length":1,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[6660736,6660352],"length":1,"stats":{"Line":1},"fn_name":"into_during_opts"},{"line":37,"address":[6660374],"length":1,"stats":{"Line":1},"fn_name":null},{"line":38,"address":[6660480],"length":1,"stats":{"Line":1},"fn_name":null},{"line":39,"address":[6660581],"length":1,"stats":{"Line":1},"fn_name":null},{"line":45,"address":[2740789,2740560,2740816],"length":1,"stats":{"Line":0},"fn_name":"into_during_opts"},{"line":46,"address":[6660833,6661025],"length":1,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[6661056],"length":1,"stats":{"Line":0},"fn_name":"into_during_opts"},{"line":52,"address":[6661078],"length":1,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[4472442,4471984,4472212,4472085,4471993,4472016,4472766],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":76,"address":[4472777,4472242,4472399,4473138,4472570,4472150],"length":1,"stats":{"Line":4},"fn_name":null},{"line":77,"address":[4473041,4473402],"length":1,"stats":{"Line":2},"fn_name":null},{"line":78,"address":[4473409,4473569],"length":1,"stats":{"Line":2},"fn_name":null},{"line":80,"address":[4473664,4473829,4473589],"length":1,"stats":{"Line":2},"fn_name":null},{"line":82,"address":[4473819,4474225],"length":1,"stats":{"Line":2},"fn_name":null},{"line":84,"address":[4474068,4474017,4474358,4474305],"length":1,"stats":{"Line":2},"fn_name":null},{"line":85,"address":[6884130,6884184],"length":1,"stats":{"Line":5},"fn_name":null},{"line":86,"address":[4476459,4475275,4475962,4476731,4476516,4476039,4475808,4476240,4476539],"length":1,"stats":{"Line":6},"fn_name":null},{"line":88,"address":[4475586],"length":1,"stats":{"Line":1},"fn_name":null},{"line":89,"address":[4476167,4475995,4472281,4475862],"length":1,"stats":{"Line":4},"fn_name":null},{"line":90,"address":[4476363],"length":1,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[4477138,4476963,4476616],"length":1,"stats":{"Line":1},"fn_name":null},{"line":96,"address":[1674684,1674744,1674639,1675024],"length":1,"stats":{"Line":5},"fn_name":null}],"covered":24,"coverable":31},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","epoch_time.rs"],"content":"use ql2::term::TermType;\n\nuse crate::Command;\n\npub(crate) fn epoch_time(timestamp: i64) -\u003e Command {\n    Command::new(TermType::EpochTime).with_arg(Command::from_json(timestamp))\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::Converter;\n    use crate::types::Time;\n    use crate::{r, Result};\n\n    #[tokio::test]\n    async fn test_time_ops() -\u003e Result\u003c()\u003e {\n        let conn = r.connection().connect().await?;\n\n        let date_time = r.epoch_time(531360000)?;\n        let time1 = date_time.clone().value();\n        let time2: Time = date_time.cmd().run(\u0026conn).await?.unwrap().parse()?;\n\n        assert!(time2 == time1);\n\n        Ok(())\n    }\n}\n","traces":[{"line":5,"address":[1651878,1651696,1651905],"length":1,"stats":{"Line":1},"fn_name":"epoch_time"},{"line":6,"address":[1651726,1651898],"length":1,"stats":{"Line":1},"fn_name":null},{"line":16,"address":[1675509,1675557,1675104,1675143],"length":1,"stats":{"Line":6},"fn_name":"test_time_ops"},{"line":17,"address":[4210128,4210408,4210174,4210247,4210597,4210863],"length":1,"stats":{"Line":4},"fn_name":null},{"line":19,"address":[4211249,4210853,4211120],"length":1,"stats":{"Line":2},"fn_name":null},{"line":20,"address":[4211474,4211239],"length":1,"stats":{"Line":2},"fn_name":null},{"line":21,"address":[4211501,4212482,4210189,4211588,4212300],"length":1,"stats":{"Line":4},"fn_name":null},{"line":23,"address":[4212703,4212453,4212736],"length":1,"stats":{"Line":2},"fn_name":null},{"line":25,"address":[1675240,1675180,1675135,1675520],"length":1,"stats":{"Line":5},"fn_name":null}],"covered":9,"coverable":9},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","eq.rs"],"content":"use ql2::term::TermType;\nuse serde::Serialize;\n\nuse crate::{arguments::Args, Command};\n\nuse super::CmdOpts;\n\npub(crate) fn new(args: impl EqArg) -\u003e Command {\n    args.into_eq_opts().add_to_cmd(Command::new(TermType::Eq))\n}\n\npub trait EqArg {\n    fn into_eq_opts(self) -\u003e CmdOpts;\n}\n\nimpl\u003cT\u003e EqArg for T\nwhere\n    T: Serialize,\n{\n    fn into_eq_opts(self) -\u003e CmdOpts {\n        CmdOpts::Single(Command::from_json(self))\n    }\n}\n\nimpl EqArg for Command {\n    fn into_eq_opts(self) -\u003e CmdOpts {\n        CmdOpts::Single(self)\n    }\n}\n\nimpl\u003cS, T\u003e EqArg for Args\u003cT\u003e\nwhere\n    S: Serialize,\n    T: IntoIterator\u003cItem = S\u003e,\n{\n    fn into_eq_opts(self) -\u003e CmdOpts {\n        let commands = self.0.into_iter().map(Command::from_json).collect();\n\n        CmdOpts::Many(commands)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::Converter;\n    use crate::spec::{set_up, tear_down};\n    use crate::{args, r, Result};\n\n    #[tokio::test]\n    async fn test_eq_data() -\u003e Result\u003c()\u003e {\n        let (conn, table, table_name) = set_up(true).await?;\n        let data_obtained: bool = table\n            .get(1)\n            .g(\"title\")\n            .eq(\"title1\")\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(data_obtained);\n\n        tear_down(conn, \u0026table_name).await\n    }\n\n    #[tokio::test]\n    async fn test_eq_data_r() -\u003e Result\u003c()\u003e {\n        let conn = r.connection().connect().await?;\n        let data_obtained: bool = r.eq(args!([5, 5, 5])).run(\u0026conn).await?.unwrap().parse()?;\n\n        assert!(data_obtained);\n\n        Ok(())\n    }\n}\n","traces":[{"line":8,"address":[4532984,4532957,4533196,4533223,4532752,4533008],"length":1,"stats":{"Line":2},"fn_name":"new\u003calloc::vec::Vec\u003ci32, alloc::alloc::Global\u003e\u003e"},{"line":9,"address":[4533216,4532768,4532977,4533024],"length":1,"stats":{"Line":2},"fn_name":null},{"line":17,"address":[2173504],"length":1,"stats":{"Line":1},"fn_name":"into_eq_opts"},{"line":18,"address":[2173520],"length":1,"stats":{"Line":1},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":37,"address":[4412880,4413333,4412919,4413285],"length":1,"stats":{"Line":6},"fn_name":"test_eq_data"},{"line":38,"address":[6650835,6651844,6651407,6651229,6650908,6651061],"length":1,"stats":{"Line":4},"fn_name":null},{"line":39,"address":[6652419,6653201,6652085,6652260,6651791,6652967,6652691,6652189,6652496,6652910,6653011],"length":1,"stats":{"Line":8},"fn_name":null},{"line":42,"address":[6652128,6652236,6652050,6652275],"length":1,"stats":{"Line":2},"fn_name":null},{"line":43,"address":[6850608],"length":1,"stats":{"Line":5},"fn_name":null},{"line":44,"address":[6652814],"length":1,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[6653090,6653404],"length":1,"stats":{"Line":1},"fn_name":null},{"line":50,"address":[4412956,4413296,4413016,4412911],"length":1,"stats":{"Line":7},"fn_name":null},{"line":54,"address":[4413829,4413415,4413781,4413376],"length":1,"stats":{"Line":6},"fn_name":"test_eq_data_r"},{"line":55,"address":[6655014,6654396,6654557,6654291,6654746,6654325],"length":1,"stats":{"Line":4},"fn_name":null},{"line":56,"address":[6656104,6654999,6654340,6655242,6656010],"length":1,"stats":{"Line":4},"fn_name":null},{"line":58,"address":[6656312,6656089],"length":1,"stats":{"Line":1},"fn_name":null},{"line":60,"address":[4413792,4413512,4413452,4413407],"length":1,"stats":{"Line":5},"fn_name":null}],"covered":19,"coverable":20},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","eq_join.rs"],"content":"use std::borrow::Cow;\n\nuse ql2::term::TermType;\nuse reql_macros::CommandOptions;\nuse serde::Serialize;\n\nuse crate::arguments::Args;\nuse crate::prelude::Func;\nuse crate::Command;\n\npub(crate) fn new(args: impl EqJoinArg) -\u003e Command {\n    let (arg, right_table, opts) = args.into_eq_join_opts();\n\n    Command::new(TermType::EqJoin)\n        .with_arg(arg)\n        .with_arg(right_table)\n        .with_opts(opts)\n}\n\npub trait EqJoinArg {\n    fn into_eq_join_opts(self) -\u003e (Command, Command, EqJoinOption);\n}\n\nimpl\u003cT\u003e EqJoinArg for Args\u003c(T, Command)\u003e\nwhere\n    T: Into\u003cString\u003e,\n{\n    fn into_eq_join_opts(self) -\u003e (Command, Command, EqJoinOption) {\n        (\n            Command::from_json(self.0 .0.into()),\n            self.0 .1,\n            Default::default(),\n        )\n    }\n}\n\nimpl EqJoinArg for Args\u003c(Func, Command)\u003e {\n    fn into_eq_join_opts(self) -\u003e (Command, Command, EqJoinOption) {\n        let Func(func) = self.0 .0;\n\n        (func, self.0 .1, Default::default())\n    }\n}\n\nimpl EqJoinArg for Args\u003c(Command, Command)\u003e {\n    fn into_eq_join_opts(self) -\u003e (Command, Command, EqJoinOption) {\n        (self.0 .0, self.0 .1, Default::default())\n    }\n}\n\nimpl\u003cT\u003e EqJoinArg for Args\u003c(T, Command, EqJoinOption)\u003e\nwhere\n    T: Into\u003cString\u003e,\n{\n    fn into_eq_join_opts(self) -\u003e (Command, Command, EqJoinOption) {\n        (Command::from_json(self.0 .0.into()), self.0 .1, self.0 .2)\n    }\n}\n\nimpl EqJoinArg for Args\u003c(Func, Command, EqJoinOption)\u003e {\n    fn into_eq_join_opts(self) -\u003e (Command, Command, EqJoinOption) {\n        let Func(func) = self.0 .0;\n\n        (func, self.0 .1, self.0 .2)\n    }\n}\n\nimpl EqJoinArg for Args\u003c(Command, Command, EqJoinOption)\u003e {\n    fn into_eq_join_opts(self) -\u003e (Command, Command, EqJoinOption) {\n        (self.0 .0, self.0 .1, self.0 .2)\n    }\n}\n\n#[derive(\n    Debug, Clone, Serialize, Default, Eq, PartialEq, Ord, PartialOrd, Hash, CommandOptions,\n)]\n#[non_exhaustive]\npub struct EqJoinOption {\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub index: Option\u003cCow\u003c'static, str\u003e\u003e,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub ordered: Option\u003cbool\u003e,\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::Converter;\n    use crate::spec::{Comment, Post};\n    use crate::types::JoinResponse;\n    use crate::{args, Result};\n\n    #[tokio::test]\n    pub async fn test_eq_join_ops() -\u003e Result\u003c()\u003e {\n        let data = JoinResponse {\n            left: Some(Comment {\n                id: 5,\n                text: \"comment4\".to_string(),\n                post_id: 1,\n            }),\n            right: Some(Post {\n                id: 1,\n                title: \"title1\".to_string(),\n                content: Some(\"content1\".to_string()),\n                view: 10,\n            }),\n        };\n        let (conn, comment_table, post_table, comment_tablename, post_tablename) =\n            Comment::own_set_up().await?;\n\n        let response: Vec\u003cJoinResponse\u003cComment, Post\u003e\u003e = comment_table\n            .eq_join(args!(\"post_id\", post_table))\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(response.len() \u003e 0);\n        assert_eq!(response.first(), Some(\u0026data));\n\n        Comment::own_tear_down(conn, comment_tablename, post_tablename).await\n    }\n}\n","traces":[{"line":25,"address":[5125540,5125566,5125232],"length":1,"stats":{"Line":0},"fn_name":"into_eq_join_opts"},{"line":26,"address":[5125358,5125556,5125253],"length":1,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[2745328,2745596,2745626],"length":1,"stats":{"Line":0},"fn_name":"into_eq_join_opts"},{"line":32,"address":[7018006],"length":1,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[2745607,2745407],"length":1,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[4040228,4040251,4040000],"length":1,"stats":{"Line":0},"fn_name":"into_eq_join_opts"},{"line":40,"address":[4040244,4040049],"length":1,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[5125600,5125863,5125893],"length":1,"stats":{"Line":0},"fn_name":"into_eq_join_opts"},{"line":46,"address":[5125715,5125647],"length":1,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[7018272],"length":1,"stats":{"Line":0},"fn_name":"into_eq_join_opts"},{"line":52,"address":[7018293],"length":1,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[7018308],"length":1,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[4040272],"length":1,"stats":{"Line":0},"fn_name":"into_eq_join_opts"},{"line":60,"address":[4040294],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":14},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","error.rs"],"content":"use ql2::term::TermType;\n\nuse crate::Command;\n\npub(crate) fn new(message: impl Into\u003cString\u003e) -\u003e Command {\n    let arg = Command::from_json(message.into());\n\n    Command::new(TermType::Error).with_arg(arg)\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::{r, ReqlError, ReqlRuntimeError, Result};\n\n    #[tokio::test]\n    async fn test_error_ops() -\u003e Result\u003c()\u003e {\n        let msg = \"Error\";\n        let conn = r.connection().connect().await?;\n        let err = r.error(msg).run(\u0026conn).await.err().unwrap();\n\n        if let ReqlError::Runtime(err) = err {\n            if let ReqlRuntimeError::User(err) = err {\n                assert!(err == msg);\n\n                return Ok(());\n            }\n        }\n\n        assert!(false);\n\n        Ok(())\n    }\n}\n","traces":[{"line":5,"address":[2719315,2719056,2719288],"length":1,"stats":{"Line":1},"fn_name":"new\u003c\u0026str\u003e"},{"line":6,"address":[2719089],"length":1,"stats":{"Line":1},"fn_name":null},{"line":8,"address":[2719204,2719137],"length":1,"stats":{"Line":2},"fn_name":null},{"line":16,"address":[1838029,1838464,1838164,1837929,1837840,1837849,1837872],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":17,"address":[1837985],"length":1,"stats":{"Line":1},"fn_name":null},{"line":18,"address":[1838744,1838124,1838286,1838475,1838053,1838019],"length":1,"stats":{"Line":4},"fn_name":null},{"line":19,"address":[1838719,1838995,1838068],"length":1,"stats":{"Line":3},"fn_name":null},{"line":21,"address":[1839490,1839428],"length":1,"stats":{"Line":1},"fn_name":null},{"line":22,"address":[1839509,1839477],"length":1,"stats":{"Line":2},"fn_name":null},{"line":23,"address":[1839828,1839791,1839549],"length":1,"stats":{"Line":2},"fn_name":null},{"line":25,"address":[1839797],"length":1,"stats":{"Line":1},"fn_name":null},{"line":29,"address":[1839492,1839645],"length":1,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[1839620],"length":1,"stats":{"Line":4},"fn_name":null}],"covered":12,"coverable":13},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","expr.rs"],"content":"use serde::Serialize;\n\nuse crate::Command;\n\npub(crate) fn new(value: impl Serialize) -\u003e Command {\n    Command::from_json(value)\n}\n\n#[cfg(test)]\nmod tests {\n    use serde::{Deserialize, Serialize};\n    use serde_json::json;\n\n    use crate::prelude::Converter;\n    use crate::{r, Result};\n\n    #[derive(Debug, Serialize, Deserialize, PartialEq, Eq)]\n    struct Dummy {\n        a: char,\n        b: [u8; 3],\n    }\n\n    #[tokio::test]\n    async fn test_expr_ops() -\u003e Result\u003c()\u003e {\n        let data = Dummy {\n            a: 'b',\n            b: [1, 2, 3],\n        };\n        let conn = r.connection().connect().await?;\n        let response: Dummy = r\n            .expr(json!({'a':'b'}))\n            .merge(r.expr(json!({'b':[1, 2, 3]})))\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(data == response);\n\n        Ok(())\n    }\n}\n","traces":[{"line":5,"address":[4353056,4353184,4353280,4353232,4353104],"length":1,"stats":{"Line":6},"fn_name":"new\u003c[i32; 3]\u003e"},{"line":6,"address":[4353115,4353256,4353205,4353067,4353296],"length":1,"stats":{"Line":6},"fn_name":null},{"line":24,"address":[2270663,2271077,2271029,2270624],"length":1,"stats":{"Line":6},"fn_name":"test_expr_ops"},{"line":27,"address":[3497075],"length":1,"stats":{"Line":1},"fn_name":null},{"line":29,"address":[3497591,3497402,3497240,3497853,3497169,3497135],"length":1,"stats":{"Line":4},"fn_name":null},{"line":30,"address":[3500485,3500245,3499969,3498476,3500282,3499712,3500188,3499783,3499559,3499487],"length":1,"stats":{"Line":7},"fn_name":null},{"line":31,"address":[3497843,3498483,3498344,3498137,3498098],"length":1,"stats":{"Line":4},"fn_name":null},{"line":32,"address":[3498599,3498979,3499348,3498050,3498499,3498842,3499531,3499574],"length":1,"stats":{"Line":3},"fn_name":null},{"line":33,"address":[3499742,3499911,3499627,3497184,3499539],"length":1,"stats":{"Line":5},"fn_name":null},{"line":34,"address":[3500092],"length":1,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[3500375,3500592,3500629],"length":1,"stats":{"Line":2},"fn_name":null},{"line":40,"address":[2270655,2270700,2271040,2270760],"length":1,"stats":{"Line":5},"fn_name":null}],"covered":11,"coverable":12},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","fill.rs"],"content":"use ql2::term::TermType;\n\nuse crate::Command;\n\npub(crate) fn new() -\u003e Command {\n    Command::new(TermType::Fill)\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::Converter;\n    use crate::types::{Point, Polygon};\n    use crate::{r, Result};\n\n    #[tokio::test]\n    async fn test_fill_ops() -\u003e Result\u003c()\u003e {\n        let conn = r.connection().connect().await?;\n        let rectangle = r.line(\u0026[\n            Point::new(-122.423246, 37.779388),\n            Point::new(-122.423246, 37.329898),\n            Point::new(-121.886420, 37.329898),\n            Point::new(-121.886420, 37.779388),\n        ]);\n        let data = Polygon::new(\u0026[\n            Point::new(-122.423246, 37.779388),\n            Point::new(-122.423246, 37.329898),\n            Point::new(-121.88642, 37.329898),\n            Point::new(-121.88642, 37.779388),\n            Point::new(-122.423246, 37.779388),\n        ]);\n\n        let response: Polygon = rectangle.fill().run(\u0026conn).await?.unwrap().parse()?;\n\n        assert!(response == data);\n\n        Ok(())\n    }\n}\n","traces":[{"line":5,"address":[2110176],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":6,"address":[2028540],"length":1,"stats":{"Line":1},"fn_name":null},{"line":16,"address":[4215253,4214887,4215301,4214848],"length":1,"stats":{"Line":6},"fn_name":"test_fill_ops"},{"line":17,"address":[4483408,4483525,4484152,4483454,4483686,4483875],"length":1,"stats":{"Line":4},"fn_name":null},{"line":18,"address":[4484486],"length":1,"stats":{"Line":1},"fn_name":null},{"line":19,"address":[4484142],"length":1,"stats":{"Line":1},"fn_name":null},{"line":20,"address":[4484417],"length":1,"stats":{"Line":1},"fn_name":null},{"line":21,"address":[4484448],"length":1,"stats":{"Line":1},"fn_name":null},{"line":22,"address":[4484479],"length":1,"stats":{"Line":1},"fn_name":null},{"line":24,"address":[4484853],"length":1,"stats":{"Line":1},"fn_name":null},{"line":25,"address":[4484675],"length":1,"stats":{"Line":1},"fn_name":null},{"line":26,"address":[4484748],"length":1,"stats":{"Line":1},"fn_name":null},{"line":27,"address":[4484779],"length":1,"stats":{"Line":1},"fn_name":null},{"line":28,"address":[4484810],"length":1,"stats":{"Line":1},"fn_name":null},{"line":29,"address":[4484841],"length":1,"stats":{"Line":1},"fn_name":null},{"line":32,"address":[4485977,4485133,4485042,4483469,4485833],"length":1,"stats":{"Line":4},"fn_name":null},{"line":34,"address":[4485951,4486218,4486251],"length":1,"stats":{"Line":2},"fn_name":null},{"line":36,"address":[4215264,4214984,4214879,4214924],"length":1,"stats":{"Line":5},"fn_name":null}],"covered":18,"coverable":18},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","filter.rs"],"content":"use ql2::term::TermType;\nuse serde::Serialize;\n\nuse crate::arguments::Args;\nuse crate::prelude::Func;\nuse crate::Command;\n\npub(crate) fn new(args: impl FilterArg) -\u003e Command {\n    let (arg, opts) = args.into_filter_opts();\n\n    Command::new(TermType::Filter).with_arg(arg).with_opts(opts)\n}\n\npub trait FilterArg {\n    fn into_filter_opts(self) -\u003e (Command, FilterOption);\n}\n\nimpl\u003cT\u003e FilterArg for T\nwhere\n    T: Serialize,\n{\n    fn into_filter_opts(self) -\u003e (Command, FilterOption) {\n        (Command::from_json(self), Default::default())\n    }\n}\n\nimpl FilterArg for Func {\n    fn into_filter_opts(self) -\u003e (Command, FilterOption) {\n        (self.0, Default::default())\n    }\n}\n\nimpl FilterArg for Command {\n    fn into_filter_opts(self) -\u003e (Command, FilterOption) {\n        (self, Default::default())\n    }\n}\n\nimpl\u003cT\u003e FilterArg for Args\u003c(T, FilterOption)\u003e\nwhere\n    T: Serialize,\n{\n    fn into_filter_opts(self) -\u003e (Command, FilterOption) {\n        (Command::from_json(self.0 .0), self.0 .1)\n    }\n}\n\nimpl FilterArg for Args\u003c(Func, FilterOption)\u003e {\n    fn into_filter_opts(self) -\u003e (Command, FilterOption) {\n        let Func(func) = self.0 .0;\n\n        (func, self.0 .1)\n    }\n}\n\nimpl FilterArg for Args\u003c(Command, FilterOption)\u003e {\n    fn into_filter_opts(self) -\u003e (Command, FilterOption) {\n        (self.0 .0, self.0 .1)\n    }\n}\n\n#[derive(Debug, Clone, Copy, Serialize, Default, Eq, PartialEq, Ord, PartialOrd, Hash)]\npub struct FilterOption {\n    /// - If `default` is set to `true`, documents with missing\n    /// fields will be returned rather than skipped.\n    /// - If `default` is set to `r.error()`, an `ReqlRuntimeError` will\n    /// be thrown when a document with a missing field is tested.\n    /// - If `default` is set to `false` (the default),\n    /// documents with missing fields will be skipped.\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub default: Option\u003cbool\u003e,\n}\n\nimpl FilterOption {\n    pub fn default_(mut self, default: bool) -\u003e Self {\n        self.default = Some(default);\n        self\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use serde_json::json;\n\n    use crate::prelude::*;\n    use crate::spec::{set_up, tear_down, Post};\n    use crate::{r, Result};\n\n    #[tokio::test]\n    async fn test_filter_data() -\u003e Result\u003c()\u003e {\n        let data = Post::get_many_data();\n        let (conn, table, table_name) = set_up(true).await?;\n        let data_filtered: Vec\u003cPost\u003e = table\n            .clone()\n            .filter(json!({\"view\": 2}))\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(data_filtered.len() == 2);\n        assert!(data_filtered.first() == data.get(3));\n        assert!(data_filtered.last() == data.get(1));\n\n        tear_down(conn, \u0026table_name).await\n    }\n\n    #[tokio::test]\n    async fn test_filter_data_with_func() -\u003e Result\u003c()\u003e {\n        let data = Post::get_many_data();\n        let (conn, table, table_name) = set_up(true).await?;\n        let data_filtered: Vec\u003cPost\u003e = table\n            .clone()\n            .filter(func!(|user| user.g(\"view\").eq(r.expr(2))))\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(data_filtered.len() == 2);\n        assert!(data_filtered.first() == data.get(3));\n        assert!(data_filtered.last() == data.get(1));\n\n        tear_down(conn, \u0026table_name).await\n    }\n}\n","traces":[{"line":10,"address":[1700635,1701121,1700720,1701067,1700689,1700288],"length":1,"stats":{"Line":2},"fn_name":"new\u003creql_rust::cmd::func::Func\u003e"},{"line":11,"address":[1700737,1700305],"length":1,"stats":{"Line":2},"fn_name":null},{"line":13,"address":[1700873,1700441,1700628,1701060],"length":1,"stats":{"Line":2},"fn_name":null},{"line":22,"address":[7018671,7018496],"length":1,"stats":{"Line":1},"fn_name":"into_filter_opts"},{"line":23,"address":[2827571],"length":1,"stats":{"Line":1},"fn_name":null},{"line":28,"address":[4040639,4040464],"length":1,"stats":{"Line":1},"fn_name":"into_filter_opts"},{"line":29,"address":[4040515],"length":1,"stats":{"Line":1},"fn_name":null},{"line":34,"address":[6661248],"length":1,"stats":{"Line":0},"fn_name":"into_filter_opts"},{"line":35,"address":[6661270],"length":1,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[6661285],"length":1,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[6661424],"length":1,"stats":{"Line":0},"fn_name":"into_filter_opts"},{"line":43,"address":[6661445],"length":1,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[5125920],"length":1,"stats":{"Line":0},"fn_name":"default_"},{"line":55,"address":[5125942],"length":1,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[5125955],"length":1,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[4414277,4413872,4413911,4414325],"length":1,"stats":{"Line":6},"fn_name":"test_filter_data"},{"line":70,"address":[2555030],"length":1,"stats":{"Line":1},"fn_name":null},{"line":71,"address":[2555479,2555657,2555419,2555251,2556064,2555094],"length":1,"stats":{"Line":4},"fn_name":null},{"line":72,"address":[2557485,2557266,2556054,2557832,2556742,2557065,2557589,2557542,2556817,2556982],"length":1,"stats":{"Line":7},"fn_name":null},{"line":74,"address":[2556237,2556603,2556288,2556832,2556789,2556396],"length":1,"stats":{"Line":3},"fn_name":null},{"line":75,"address":[2555115,2555200,2556797,2556885,2557193,2557021],"length":1,"stats":{"Line":6},"fn_name":null},{"line":76,"address":[2557389],"length":1,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[2558203,2558155,2557718],"length":1,"stats":{"Line":2},"fn_name":null},{"line":81,"address":[2558248,2558176,2558407],"length":1,"stats":{"Line":2},"fn_name":null},{"line":82,"address":[2558450,2558383,2558629],"length":1,"stats":{"Line":2},"fn_name":null},{"line":84,"address":[6885636],"length":1,"stats":{"Line":7},"fn_name":null},{"line":88,"address":[2559488,2559589,2559497,2559520,2559688,2559918,2560270],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":89,"address":[2559654],"length":1,"stats":{"Line":1},"fn_name":null},{"line":90,"address":[6777135],"length":1,"stats":{"Line":4},"fn_name":null},{"line":91,"address":[2562363,2562420,2561695,2560678,2562710,2562467,2561561,2562144,2561860,2561943],"length":1,"stats":{"Line":7},"fn_name":null},{"line":93,"address":[2561600,2561710,2560959,2564400,2560917,2564438,2560861],"length":1,"stats":{"Line":4},"fn_name":"{closure#0}"},{"line":94,"address":[2559739,2559824,2561763,2561675,2562071,2561899],"length":1,"stats":{"Line":6},"fn_name":null},{"line":95,"address":[2562267],"length":1,"stats":{"Line":0},"fn_name":null},{"line":99,"address":[2563033,2563084,2562596],"length":1,"stats":{"Line":2},"fn_name":null},{"line":100,"address":[2563054,2563132,2563315],"length":1,"stats":{"Line":2},"fn_name":null},{"line":101,"address":[2563537,2563358,2563291],"length":1,"stats":{"Line":2},"fn_name":null},{"line":103,"address":[2563990,2563570,2563694,2559757,2563493,2563854,2563753],"length":1,"stats":{"Line":7},"fn_name":null}],"covered":27,"coverable":37},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","floor.rs"],"content":"use ql2::term::TermType;\n\nuse crate::Command;\n\npub(crate) fn new(args: impl FloorArg) -\u003e Command {\n    let mut command = Command::new(TermType::Floor);\n\n    if let Some(arg) = args.into_floor_opts() {\n        command = command.with_arg(arg)\n    }\n\n    command\n}\n\npub trait FloorArg {\n    fn into_floor_opts(self) -\u003e Option\u003cCommand\u003e;\n}\n\nimpl FloorArg for () {\n    fn into_floor_opts(self) -\u003e Option\u003cCommand\u003e {\n        None\n    }\n}\n\nimpl FloorArg for Command {\n    fn into_floor_opts(self) -\u003e Option\u003cCommand\u003e {\n        Some(self)\n    }\n}\n\nimpl FloorArg for f64 {\n    fn into_floor_opts(self) -\u003e Option\u003cCommand\u003e {\n        Some(Command::from_json(self))\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::Converter;\n    use crate::{r, Result};\n\n    #[tokio::test]\n    async fn test_floor_data() -\u003e Result\u003c()\u003e {\n        let conn = r.connection().connect().await?;\n        let data_obtained: i8 = r.floor(-12.345).run(\u0026conn).await?.unwrap().parse()?;\n        let data_obtained2: i8 = r.expr(-12.345).floor().run(\u0026conn).await?.unwrap().parse()?;\n        let data_obtained3: i8 = r\n            .floor(r.expr(-12.345))\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(\n            data_obtained == -13\n                \u0026\u0026 data_obtained == data_obtained2\n                \u0026\u0026 data_obtained == data_obtained3\n        );\n\n        Ok(())\n    }\n}\n","traces":[{"line":5,"address":[7027167,7027200,7026640,7027750],"length":1,"stats":{"Line":1},"fn_name":"new\u003c()\u003e"},{"line":6,"address":[7027235,7026752,7027333,7026660],"length":1,"stats":{"Line":2},"fn_name":null},{"line":8,"address":[2385372,2386310,2386031,2385434,2385711,2385969],"length":1,"stats":{"Line":3},"fn_name":null},{"line":9,"address":[2467932,2467333,2467786,2467188],"length":1,"stats":{"Line":2},"fn_name":null},{"line":12,"address":[2385736,2386335],"length":1,"stats":{"Line":1},"fn_name":null},{"line":20,"address":[2469232],"length":1,"stats":{"Line":0},"fn_name":"into_floor_opts"},{"line":21,"address":[2469236],"length":1,"stats":{"Line":0},"fn_name":null},{"line":26,"address":[4750864],"length":1,"stats":{"Line":1},"fn_name":"into_floor_opts"},{"line":27,"address":[4750890],"length":1,"stats":{"Line":1},"fn_name":null},{"line":37,"address":[2255397,2254992,2255445,2255031],"length":1,"stats":{"Line":6},"fn_name":"test_floor_data"},{"line":38,"address":[4591658,4591927,4591203,4591308,4591237,4591469],"length":1,"stats":{"Line":4},"fn_name":null},{"line":39,"address":[4591252,4592944,4592155,4591917,4592855],"length":1,"stats":{"Line":4},"fn_name":null},{"line":41,"address":[4592924,4593152],"length":1,"stats":{"Line":1},"fn_name":null},{"line":43,"address":[2255068,2255023,2255408,2255128],"length":1,"stats":{"Line":5},"fn_name":null}],"covered":12,"coverable":14},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","fold.rs"],"content":"use ql2::term::TermType;\nuse serde::Serialize;\n\nuse crate::prelude::Func;\nuse crate::Command;\n\npub(crate) fn new\u003cT\u003e(base: T, func: Func) -\u003e Command\nwhere\n    T: Serialize,\n{\n    Command::new(TermType::Fold)\n        .with_arg(Command::from_json(base))\n        .with_arg(func.0)\n}\n\n// #[derive(Debug, Clone, Serialize, Default)]\n// #[non_exhaustive]\n// pub struct FoldOption {\n//     pub emit: Option\u003cCommand\u003e,\n//     pub final_emit: Option\u003cCommand\u003e,\n// }\n\n#[cfg(test)]\nmod tests {\n    use crate::args;\n    use crate::prelude::*;\n    use crate::spec::*;\n    use crate::{r, Result};\n\n    #[tokio::test]\n    async fn test_fold_ops() -\u003e Result\u003c()\u003e {\n        let posts = Post::get_many_data()\n            .into_iter()\n            .fold(String::new(), |acc, post| {\n                format!(\"{}{}{}\", acc, if acc == \"\" { \"\" } else { \", \" }, post.title)\n            });\n        let (conn, table, table_name) = set_up(true).await?;\n        let response: String = table\n            .order_by(r.expr(\"id\"))\n            .fold(\n                \"\",\n                func!(|acc, post| acc.clone()\n                    + r.branch(acc.eq(\"\"), args!(r.expr(\"\"), r.expr(\", \")))\n                    + post.g(\"title\")),\n            )\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(response == posts);\n\n        tear_down(conn, \u0026table_name).await\n    }\n}\n","traces":[{"line":7,"address":[2673209,2672768],"length":1,"stats":{"Line":0},"fn_name":"new"},{"line":8,"address":[2672803],"length":1,"stats":{"Line":0},"fn_name":null},{"line":9,"address":[2672884,2672947],"length":1,"stats":{"Line":0},"fn_name":null},{"line":11,"address":[2673026,2672955],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":4},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","for_each.rs"],"content":"use ql2::term::TermType;\n\nuse crate::prelude::Func;\nuse crate::Command;\n\npub(crate) fn new(arg: Func) -\u003e Command {\n    Command::new(TermType::ForEach).with_arg(arg.0)\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::*;\n    use crate::spec::{set_up, tear_down};\n    use crate::types::MutationResponse;\n    use crate::Result;\n\n    #[tokio::test]\n    async fn test_for_each_opts() -\u003e Result\u003c()\u003e {\n        let (conn, table, table_name) = set_up(true).await?;\n        let response: MutationResponse = table\n            .clone()\n            .for_each(func!(|doc| table.get(doc.g(\"id\")).delete(())))\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(response.deleted == 5);\n\n        tear_down(conn, \u0026table_name).await\n    }\n}\n","traces":[{"line":6,"address":[4584172,4583968,4584145],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":7,"address":[4584075,4583990],"length":1,"stats":{"Line":2},"fn_name":null},{"line":18,"address":[1676053,1676005,1675600,1675639],"length":1,"stats":{"Line":6},"fn_name":"test_for_each_opts"},{"line":19,"address":[4116618,4116775,4116946,4117127,4117540,4116518],"length":1,"stats":{"Line":4},"fn_name":null},{"line":20,"address":[4118926,4119527,4119003,4119480,4119423,4119204,4118606,4117530,4119769,4118761],"length":1,"stats":{"Line":7},"fn_name":null},{"line":22,"address":[4118645,4117800,4120885,4117749,4118685,4118776,4118583,4120864],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":23,"address":[4116724,4119131,4116639,4118959,4118829],"length":1,"stats":{"Line":5},"fn_name":null},{"line":24,"address":[4119327],"length":1,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[4119647,4119984],"length":1,"stats":{"Line":1},"fn_name":null},{"line":30,"address":[1675676,1675736,1676016,1675631],"length":1,"stats":{"Line":7},"fn_name":null}],"covered":9,"coverable":10},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","func.rs"],"content":"use crate::Command;\nuse ql2::term::TermType;\n\n#[derive(Debug, Clone)]\npub struct Func(pub(crate) Command);\n\nimpl Func {\n    pub fn new\u003cT\u003e(ids: Vec\u003cu64\u003e, body: T) -\u003e Self\n    where\n        T: Into\u003cCommand\u003e,\n    {\n        Func(\n            Command::new(TermType::Func)\n                .with_arg(Command::from_json(ids))\n                .with_arg(body),\n        )\n    }\n}\n\nimpl From\u003cFunc\u003e for Command {\n    fn from(func: Func) -\u003e Self {\n        func.0\n    }\n}\n","traces":[{"line":8,"address":[2703242,2702800,2703174],"length":1,"stats":{"Line":1},"fn_name":"new\u003creql_rust::proto::Command\u003e"},{"line":13,"address":[2703149,2703046,2702946,2702827],"length":1,"stats":{"Line":4},"fn_name":null},{"line":14,"address":[2703090,2703164,2702954],"length":1,"stats":{"Line":2},"fn_name":null},{"line":15,"address":[2703098],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":4,"coverable":4},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","ge.rs"],"content":"use ql2::term::TermType;\nuse serde::Serialize;\n\nuse crate::arguments::Args;\nuse crate::Command;\n\nuse super::CmdOpts;\n\npub(crate) fn new(args: impl GeArg) -\u003e Command {\n    args.into_ge_opts().add_to_cmd(Command::new(TermType::Ge))\n}\n\npub trait GeArg {\n    fn into_ge_opts(self) -\u003e CmdOpts;\n}\n\nimpl\u003cT: Serialize\u003e GeArg for T {\n    fn into_ge_opts(self) -\u003e CmdOpts {\n        CmdOpts::Single(Command::from_json(self))\n    }\n}\n\nimpl GeArg for Command {\n    fn into_ge_opts(self) -\u003e CmdOpts {\n        CmdOpts::Single(self)\n    }\n}\n\nimpl\u003cS, T\u003e GeArg for Args\u003cT\u003e\nwhere\n    S: Serialize,\n    T: IntoIterator\u003cItem = S\u003e,\n{\n    fn into_ge_opts(self) -\u003e CmdOpts {\n        let commands = self.0.into_iter().map(Command::from_json).collect();\n\n        CmdOpts::Many(commands)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::Converter;\n    use crate::spec::{set_up, tear_down};\n    use crate::{args, r, Result};\n\n    #[tokio::test]\n    async fn test_ge_data() -\u003e Result\u003c()\u003e {\n        let (conn, table, table_name) = set_up(true).await?;\n        let data_obtained: bool = table\n            .get(1)\n            .g(\"view\")\n            .ge(10)\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(data_obtained);\n\n        tear_down(conn, \u0026table_name).await\n    }\n\n    #[tokio::test]\n    async fn test_ge_data_r() -\u003e Result\u003c()\u003e {\n        let conn = r.connection().connect().await?;\n        let data_obtained: bool = r.ge(args!([7, 6, 5])).run(\u0026conn).await?.unwrap().parse()?;\n\n        assert!(data_obtained);\n\n        Ok(())\n    }\n}\n","traces":[{"line":9,"address":[2391272,2391245,2391001,2390832,2391040,2391028],"length":1,"stats":{"Line":2},"fn_name":"new\u003ci32\u003e"},{"line":10,"address":[2390855,2391265,2391021,2391056],"length":1,"stats":{"Line":2},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":27,"address":[1817501],"length":1,"stats":{"Line":1},"fn_name":null},{"line":38,"address":[2579095,2579509,2579461,2579056],"length":1,"stats":{"Line":6},"fn_name":"test_ge_data"},{"line":39,"address":[2336327,2336149,2336764,2335763,2335981,2335828],"length":1,"stats":{"Line":4},"fn_name":null},{"line":40,"address":[2336997,2337793,2337749,2337278,2336711,2337473,2337201,2337983,2337692],"length":1,"stats":{"Line":6},"fn_name":null},{"line":44,"address":[2337107,2335932,2337406,2337234,2335849],"length":1,"stats":{"Line":5},"fn_name":null},{"line":45,"address":[2337596],"length":1,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[2337872,2338186],"length":1,"stats":{"Line":1},"fn_name":null},{"line":51,"address":[6850977],"length":1,"stats":{"Line":7},"fn_name":null},{"line":55,"address":[2339204,2338944,2339001,2339503,2338912,2339069,2338921],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":56,"address":[2339325,2339164,2339059,2339093,2339782,2339514],"length":1,"stats":{"Line":4},"fn_name":null},{"line":57,"address":[2340716,2340312,2340098,2340773,2340241,2341000,2340497,2340810,2340130],"length":1,"stats":{"Line":6},"fn_name":null},{"line":58,"address":[2339767,2340010],"length":1,"stats":{"Line":2},"fn_name":null},{"line":59,"address":[2340271,2340110,2339108,2340440,2340153],"length":1,"stats":{"Line":5},"fn_name":null},{"line":60,"address":[2340620],"length":1,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[2340889,2341112],"length":1,"stats":{"Line":1},"fn_name":null},{"line":66,"address":[2341086],"length":1,"stats":{"Line":5},"fn_name":null}],"covered":20,"coverable":22},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","geojson.rs"],"content":"use ql2::term::TermType;\nuse serde::{Deserialize, Serialize};\n\nuse crate::prelude::Geometry;\nuse crate::types::{GeoJson, GeoType, ReqlType};\nuse crate::Command;\n\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, PartialOrd)]\npub struct ReqlGeoJson\u003cT\u003e {\n    #[serde(rename = \"$reql_type$\")]\n    pub reql_type: ReqlType,\n    pub coordinates: T,\n    #[serde(rename = \"type\")]\n    pub typ: GeoType,\n}\n\nimpl\u003cT: Serialize\u003e ReqlGeoJson\u003cT\u003e {\n    pub fn new(geojson: GeoJson\u003cT\u003e) -\u003e Self {\n        Self {\n            reql_type: ReqlType::Geometry,\n            typ: geojson.typ,\n            coordinates: geojson.coordinates,\n        }\n    }\n}\n\nimpl\u003cT: Serialize\u003e From\u003cReqlGeoJson\u003cT\u003e\u003e for Command {\n    fn from(geo: ReqlGeoJson\u003cT\u003e) -\u003e Self {\n        let geo: GeoJson\u003cT\u003e = geo.into();\n        let arg = Command::from_json(geo);\n\n        Command::new(TermType::Geojson).with_arg(arg)\n    }\n}\n\nimpl\u003cT: Serialize\u003e From\u003cReqlGeoJson\u003cT\u003e\u003e for GeoJson\u003cT\u003e {\n    fn from(geo: ReqlGeoJson\u003cT\u003e) -\u003e Self {\n        Self {\n            typ: geo.typ,\n            coordinates: geo.coordinates,\n        }\n    }\n}\n\nimpl\u003cT: Serialize\u003e Geometry for ReqlGeoJson\u003cT\u003e {\n    fn cmd(self) -\u003e Command {\n        self.into()\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use serde::{Deserialize, Serialize};\n\n    use crate::prelude::Converter;\n    use crate::spec::{set_up, tear_down};\n    use crate::types::{GeoJson, GeoType};\n    use crate::{r, Result};\n\n    use super::ReqlGeoJson;\n\n    #[derive(Debug, Serialize, Deserialize, PartialEq)]\n    struct User {\n        id: u8,\n        name: String,\n        location: ReqlGeoJson\u003c[f64; 2]\u003e,\n    }\n\n    #[tokio::test]\n    async fn test_geojson_data() -\u003e Result\u003c()\u003e {\n        let geo_json = GeoJson {\n            typ: GeoType::Point,\n            coordinates: [-122.423246, 37.779388],\n        };\n        let user = User {\n            id: 1,\n            name: \"Yaoundé\".to_string(),\n            location: r.geojson(geo_json),\n        };\n        let (conn, table, table_name) = set_up(false).await?;\n        table.clone().insert(\u0026user).run(\u0026conn).await?;\n        let response: User = table.get(1).run(\u0026conn).await?.unwrap().parse()?;\n\n        assert!(response == user);\n\n        tear_down(conn, \u0026table_name).await\n    }\n}\n","traces":[{"line":18,"address":[4686912],"length":1,"stats":{"Line":1},"fn_name":"new\u003c[f64; 2]\u003e"},{"line":21,"address":[4686924],"length":1,"stats":{"Line":1},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[4227829,4227728,4227760,4228599,4228013,4228315,4227737],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":73,"address":[4227927],"length":1,"stats":{"Line":1},"fn_name":null},{"line":77,"address":[4227983],"length":1,"stats":{"Line":1},"fn_name":null},{"line":78,"address":[4228427],"length":1,"stats":{"Line":1},"fn_name":null},{"line":80,"address":[4228043,4229247,4228272,4228666,4228592],"length":1,"stats":{"Line":4},"fn_name":null},{"line":81,"address":[4229471,4228064,4228221,4229237],"length":1,"stats":{"Line":4},"fn_name":null},{"line":82,"address":[4231269,4230217,4228170,4231061,4230341,4228085],"length":1,"stats":{"Line":5},"fn_name":null},{"line":84,"address":[4231255,4231693,4231751],"length":1,"stats":{"Line":2},"fn_name":null},{"line":86,"address":[4232213,4228103,4231988,4231805,4231929,4231707,4232077],"length":1,"stats":{"Line":7},"fn_name":null}],"covered":12,"coverable":21},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","get.rs"],"content":"use ql2::term::TermType;\nuse serde::Serialize;\n\nuse crate::Command;\n\npub(crate) fn new(args: impl GetArg) -\u003e Command {\n    Command::new(TermType::Get).with_arg(args.into_get_opts())\n}\n\npub trait GetArg {\n    fn into_get_opts(self) -\u003e Command;\n}\n\nimpl GetArg for Command {\n    fn into_get_opts(self) -\u003e Command {\n        self\n    }\n}\n\nimpl\u003cT\u003e GetArg for T\nwhere\n    T: Serialize,\n{\n    fn into_get_opts(self) -\u003e Command {\n        Command::from_json(self)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::Converter;\n    use crate::spec::{set_up, tear_down, Post};\n    use crate::Result;\n\n    #[tokio::test]\n    async fn test_get_data() -\u003e Result\u003c()\u003e {\n        let expected_post = Post::get_many_data().get(3).unwrap().to_owned();\n        let (conn, table, table_name) = set_up(true).await?;\n        let data_inserted: Option\u003cPost\u003e = table\n            .get(expected_post.id)\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(data_inserted == Some(expected_post));\n\n        tear_down(conn, table_name.as_str()).await\n    }\n}\n","traces":[{"line":6,"address":[2219673,2219998,2219066,2219365,2218784,2219104,2219408,2219712],"length":1,"stats":{"Line":4},"fn_name":"new\u003c\u0026str\u003e"},{"line":7,"address":[2219438,2218932,2219056,2219537,2219734,2218827,2219834,2219355,2219988,2219663,2219231,2219132],"length":1,"stats":{"Line":8},"fn_name":null},{"line":15,"address":[2174272],"length":1,"stats":{"Line":1},"fn_name":"into_get_opts"},{"line":16,"address":[2255928],"length":1,"stats":{"Line":1},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":25,"address":[2220112,2220149,2220067],"length":1,"stats":{"Line":3},"fn_name":null},{"line":36,"address":[1694014,1693321,1696516,1693344,1693737,1693509,1693413,1693312],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":37,"address":[1693844,1693475],"length":1,"stats":{"Line":2},"fn_name":null},{"line":38,"address":[1693539,1694083,1693694,1694675],"length":1,"stats":{"Line":3},"fn_name":null},{"line":39,"address":[1694622,1695511,1695612,1695020,1695568,1694903,1695097,1695292,1696030],"length":1,"stats":{"Line":6},"fn_name":null},{"line":41,"address":[1693560,1695225,1695053,1693645,1694883,1694926],"length":1,"stats":{"Line":6},"fn_name":null},{"line":42,"address":[1695415],"length":1,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[1696257,1696417,1696359,1695797],"length":1,"stats":{"Line":2},"fn_name":null},{"line":48,"address":[1696535,1693578,1696928,1696715,1696797,1696373,1696659],"length":1,"stats":{"Line":7},"fn_name":null}],"covered":13,"coverable":14},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","get_all.rs"],"content":"use std::borrow::Cow;\n\nuse ql2::term::TermType;\nuse reql_macros::CommandOptions;\nuse serde::Serialize;\n\nuse crate::{arguments::Args, Command};\n\nuse super::CmdOpts;\n\npub(crate) fn new(args: impl GetAllArg) -\u003e Command {\n    let (args, opts) = args.into_get_all_opts();\n\n    args.add_to_cmd(Command::new(TermType::GetAll))\n        .with_opts(opts)\n}\n\npub trait GetAllArg {\n    fn into_get_all_opts(self) -\u003e (CmdOpts, GetAllOption);\n}\n\nimpl\u003cS, T\u003e GetAllArg for T\nwhere\n    S: Serialize,\n    T: IntoIterator\u003cItem = S\u003e,\n{\n    fn into_get_all_opts(self) -\u003e (CmdOpts, GetAllOption) {\n        let keys = self\n            .into_iter()\n            .map(|key| Command::from_json(key))\n            .collect();\n\n        (CmdOpts::Many(keys), Default::default())\n    }\n}\n\nimpl GetAllArg for Command {\n    fn into_get_all_opts(self) -\u003e (CmdOpts, GetAllOption) {\n        (CmdOpts::Single(self), Default::default())\n    }\n}\n\nimpl\u003cS, T\u003e GetAllArg for Args\u003c(T, GetAllOption)\u003e\nwhere\n    S: Serialize,\n    T: IntoIterator\u003cItem = S\u003e,\n{\n    fn into_get_all_opts(self) -\u003e (CmdOpts, GetAllOption) {\n        let keys = self\n            .0\n             .0\n            .into_iter()\n            .map(|key| Command::from_json(key))\n            .collect();\n\n        (CmdOpts::Many(keys), self.0 .1)\n    }\n}\n\nimpl GetAllArg for Args\u003c(Command, GetAllOption)\u003e {\n    fn into_get_all_opts(self) -\u003e (CmdOpts, GetAllOption) {\n        (CmdOpts::Single(self.0 .0), self.0 .1)\n    }\n}\n\n#[derive(Debug, Clone, Serialize, Default, PartialEq, PartialOrd, CommandOptions)]\npub struct GetAllOption {\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub index: Option\u003cCow\u003c'static, str\u003e\u003e,\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::args;\n    use crate::prelude::*;\n    use crate::spec::{set_up, tear_down, Post};\n    use crate::Result;\n\n    use super::GetAllOption;\n\n    #[tokio::test]\n    async fn test_get_all() -\u003e Result\u003c()\u003e {\n        let data = Post::get_many_data();\n        let (conn, table, table_name) = set_up(true).await?;\n\n        table.clone().sync().run(\u0026conn).await?;\n\n        let data_get: Vec\u003cPost\u003e = table\n            .get_all(args!([\"title4\"], GetAllOption::default().index(\"title\")))\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(data_get.len() == 2);\n        assert!(data_get.first() == data.get(3));\n        assert!(data_get.last() == data.last());\n\n        tear_down(conn, \u0026table_name).await\n    }\n}\n","traces":[{"line":11,"address":[2373003,2372576,2373092],"length":1,"stats":{"Line":1},"fn_name":"new\u003c(alloc::vec::Vec\u003c\u0026str, alloc::alloc::Global\u003e, reql_rust::cmd::get_all::GetAllOption)\u003e"},{"line":12,"address":[2372593],"length":1,"stats":{"Line":1},"fn_name":null},{"line":14,"address":[2372996,2372969,2372761],"length":1,"stats":{"Line":2},"fn_name":null},{"line":15,"address":[2372913],"length":1,"stats":{"Line":1},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[2373120,2373173],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}\u003c\u0026str\u003e"},{"line":41,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":60,"address":[4445813,4445511,4446165,4445321,4445344,4445312,4445413],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":61,"address":[4445478],"length":1,"stats":{"Line":1},"fn_name":null},{"line":62,"address":[4445938,4446176,4446590,4445770,4445541,4445998],"length":1,"stats":{"Line":4},"fn_name":null},{"line":64,"address":[4446580,4446806,4445562,4445719],"length":1,"stats":{"Line":4},"fn_name":null},{"line":66,"address":[4448962,4448219,4448719,4448420,4448696,4447889,4448639,4447964,4447552,4448136],"length":1,"stats":{"Line":7},"fn_name":null},{"line":67,"address":[4447647,4447603,4447989,4447936,4447971],"length":1,"stats":{"Line":2},"fn_name":null},{"line":68,"address":[4448039,4448347,4447944,4448175,4445583,4445668],"length":1,"stats":{"Line":6},"fn_name":null},{"line":69,"address":[4448543],"length":1,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[4448848,4449345,4449294],"length":1,"stats":{"Line":2},"fn_name":null},{"line":74,"address":[4449393,4449588,4449315],"length":1,"stats":{"Line":2},"fn_name":null},{"line":75,"address":[4449637,4449841,4449558],"length":1,"stats":{"Line":2},"fn_name":null},{"line":77,"address":[2255519,2255564,2255904,2255624],"length":1,"stats":{"Line":7},"fn_name":null}],"covered":19,"coverable":25},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","get_field.rs"],"content":"use ql2::term::TermType;\n\nuse crate::Command;\n\npub(crate) fn new(attr: impl Into\u003cString\u003e) -\u003e Command {\n    let arg = Command::from_json(attr.into());\n\n    Command::new(TermType::GetField).with_arg(arg)\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::Converter;\n    use crate::spec::{set_up, tear_down, Post};\n    use crate::Result;\n\n    #[tokio::test]\n    async fn test_get_fields_ops() -\u003e Result\u003c()\u003e {\n        let data = Post::get_one_data();\n        let (conn, table, table_name) = set_up(true).await?;\n        let data_obtained: String = table.get(1).g(\"title\").run(\u0026conn).await?.unwrap().parse()?;\n\n        assert!(data_obtained == data.title);\n\n        tear_down(conn, \u0026table_name).await\n    }\n}\n","traces":[{"line":6,"address":[4481407,4481380,4481168],"length":1,"stats":{"Line":1},"fn_name":"new\u003c\u0026str\u003e"},{"line":7,"address":[4481201],"length":1,"stats":{"Line":1},"fn_name":null},{"line":9,"address":[4481294,4481227],"length":1,"stats":{"Line":2},"fn_name":null},{"line":19,"address":[1676549,1676135,1676501,1676096],"length":1,"stats":{"Line":6},"fn_name":"test_get_fields"},{"line":20,"address":[2704051],"length":1,"stats":{"Line":1},"fn_name":null},{"line":21,"address":[2704256,2704103,2704656,2704421,2704481,2705094],"length":1,"stats":{"Line":4},"fn_name":null},{"line":22,"address":[2706066,2704207,2704124,2706200,2705041,2705294],"length":1,"stats":{"Line":5},"fn_name":null},{"line":24,"address":[2706186,2706610,2706555],"length":1,"stats":{"Line":2},"fn_name":null},{"line":26,"address":[1676512,1676172,1676232,1676127],"length":1,"stats":{"Line":7},"fn_name":null}],"covered":9,"coverable":9},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","get_intersecting.rs"],"content":"use std::borrow::Cow;\n\nuse ql2::term::TermType;\nuse reql_macros::CommandOptions;\nuse serde::Serialize;\n\nuse crate::prelude::Geometry;\nuse crate::Command;\n\npub(crate) fn new(args: impl GetIntersectingArg, index: \u0026'static str) -\u003e Command {\n    let opts = GetIntersectingOption::default().index(index);\n\n    Command::new(TermType::GetIntersecting)\n        .with_arg(args.into_get_intersecting_opts())\n        .with_opts(opts)\n}\n\npub trait GetIntersectingArg {\n    fn into_get_intersecting_opts(self) -\u003e Command;\n}\n\nimpl GetIntersectingArg for Command {\n    fn into_get_intersecting_opts(self) -\u003e Command {\n        self\n    }\n}\n\nimpl\u003cT\u003e GetIntersectingArg for T\nwhere\n    T: Geometry,\n{\n    fn into_get_intersecting_opts(self) -\u003e Command {\n        self.cmd()\n    }\n}\n\n#[derive(Debug, Clone, Serialize, Default, CommandOptions)]\npub struct GetIntersectingOption {\n    pub index: Option\u003cCow\u003c'static, str\u003e\u003e,\n}\n\n#[cfg(test)]\nmod tests {\n    use serde::{Deserialize, Serialize};\n    use uuid::Uuid;\n\n    use crate::cmd::index_create::IndexCreateOption;\n    use crate::cmd::point::Point;\n    use crate::cmd::polygon::Polygon;\n    use crate::prelude::Converter;\n    use crate::{args, r, Result};\n\n    #[derive(Debug, Serialize, Deserialize, PartialEq)]\n    struct Park {\n        id: u8,\n        area: Point,\n    }\n\n    impl Park {\n        fn new(id: u8, area: Point) -\u003e Self {\n            Self { id, area }\n        }\n    }\n\n    #[tokio::test]\n    async fn test_get_intersecting_ops() -\u003e Result\u003c()\u003e {\n        let data = vec![\n            Park::new(1, r.point(-0.1, 5.3)),\n            Park::new(2, r.point(-117.220406, 32.719464)),\n            Park::new(2, r.point(-120.6, 58.9)),\n            Park::new(3, r.point(-11.220, 25.764)),\n        ];\n        let table_name = Uuid::new_v4().to_string();\n        let conn = r.connection().connect().await?;\n        let table = r.table(table_name.as_str());\n        let circle: Polygon = r\n            .circle(args!(r.point(-117.220406, 32.719464), 10.))\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n        r.table_create(table_name.as_str()).run(\u0026conn).await?;\n        table\n            .clone()\n            .index_create(args!(\"area\", IndexCreateOption::default().geo(true)))\n            .run(\u0026conn)\n            .await?;\n        table.clone().index_wait(()).run(\u0026conn).await?;\n        table.clone().insert(\u0026data).run(\u0026conn).await?;\n\n        let response: Vec\u003cPark\u003e = table\n            .get_intersecting(circle, \"area\")\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(response.len() == 1);\n\n        r.table_drop(table_name.as_str()).run(\u0026conn).await?;\n        Ok(())\n    }\n}\n","traces":[{"line":10,"address":[1652381,1651920,1652428],"length":1,"stats":{"Line":1},"fn_name":"new\u003creql_rust::cmd::polygon::Polygon\u003e"},{"line":11,"address":[1651968,1652073],"length":1,"stats":{"Line":2},"fn_name":null},{"line":13,"address":[1652164,1652356,1652260,1652088],"length":1,"stats":{"Line":4},"fn_name":null},{"line":14,"address":[1652301,1652371,1652172],"length":1,"stats":{"Line":2},"fn_name":null},{"line":15,"address":[1652309],"length":1,"stats":{"Line":1},"fn_name":null},{"line":23,"address":[2255952],"length":1,"stats":{"Line":0},"fn_name":"into_get_intersecting_opts"},{"line":24,"address":[4040712],"length":1,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[2062240],"length":1,"stats":{"Line":1},"fn_name":"into_get_intersecting_opts\u003creql_rust::cmd::polygon::Polygon\u003e"},{"line":33,"address":[2062251],"length":1,"stats":{"Line":1},"fn_name":null},{"line":60,"address":[2047216],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":66,"address":[2048949,2048583,2048997,2048544],"length":1,"stats":{"Line":6},"fn_name":"test_get_intersecting_ops"},{"line":67,"address":[1664423,1663366,1664173],"length":1,"stats":{"Line":2},"fn_name":null},{"line":68,"address":[1664158,1664223],"length":1,"stats":{"Line":2},"fn_name":null},{"line":69,"address":[1664254],"length":1,"stats":{"Line":1},"fn_name":null},{"line":70,"address":[1664313],"length":1,"stats":{"Line":1},"fn_name":null},{"line":71,"address":[1664372],"length":1,"stats":{"Line":1},"fn_name":null},{"line":73,"address":[1664608,1664541],"length":1,"stats":{"Line":2},"fn_name":null},{"line":74,"address":[1663446,1664635,1663963,1665194,1664703],"length":1,"stats":{"Line":4},"fn_name":null},{"line":75,"address":[1665450,1665164],"length":1,"stats":{"Line":2},"fn_name":null},{"line":76,"address":[1665667,1665790,1665873,1666373,1666074,1665632,1666293,1666625,1666350],"length":1,"stats":{"Line":6},"fn_name":null},{"line":77,"address":[1665500,1665534],"length":1,"stats":{"Line":2},"fn_name":null},{"line":78,"address":[6789786],"length":1,"stats":{"Line":6},"fn_name":null},{"line":79,"address":[1666197],"length":1,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[6789640,6789583],"length":1,"stats":{"Line":4},"fn_name":null},{"line":83,"address":[1667547,1667870,1668035,1667795,1668527,1668118,1668319],"length":1,"stats":{"Line":6},"fn_name":null},{"line":85,"address":[1667592,1667635,1667842,1667885],"length":1,"stats":{"Line":2},"fn_name":null},{"line":86,"address":[6789500],"length":1,"stats":{"Line":6},"fn_name":null},{"line":87,"address":[6789557,6789514],"length":1,"stats":{"Line":1},"fn_name":null},{"line":88,"address":[6789474,6789417],"length":1,"stats":{"Line":4},"fn_name":null},{"line":89,"address":[6789394,6789340],"length":1,"stats":{"Line":4},"fn_name":null},{"line":91,"address":[1670980,1670354,1671037,1670477,1670761,1670263,1671060,1671303,1670560,1670169],"length":1,"stats":{"Line":7},"fn_name":null},{"line":92,"address":[1670226],"length":1,"stats":{"Line":1},"fn_name":null},{"line":93,"address":[1670688,1663572,1663657,1670516,1670334,1670377],"length":1,"stats":{"Line":6},"fn_name":null},{"line":94,"address":[1670884],"length":1,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[1671468,1671420,1671189],"length":1,"stats":{"Line":2},"fn_name":null},{"line":100,"address":[1663590,1671551,1671441],"length":1,"stats":{"Line":3},"fn_name":null},{"line":101,"address":[1672477],"length":1,"stats":{"Line":5},"fn_name":null}],"covered":33,"coverable":37},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","get_nearest.rs"],"content":"use std::borrow::Cow;\n\nuse ql2::term::TermType;\nuse reql_macros::CommandOptions;\nuse serde::Serialize;\n\nuse crate::arguments::{Args, Unit};\nuse crate::prelude::Geometry;\nuse crate::types::GeoSystem;\nuse crate::Command;\n\npub(crate) fn new(args: impl GetNearestArg) -\u003e Command {\n    let (arg, opts) = args.into_get_nearest_opts();\n\n    Command::new(TermType::GetNearest)\n        .with_arg(arg)\n        .with_opts(opts)\n}\n\npub trait GetNearestArg {\n    fn into_get_nearest_opts(self) -\u003e (Command, GetNearestOption);\n}\n\nimpl\u003cT: Geometry\u003e GetNearestArg for Args\u003c(T, \u0026str)\u003e {\n    fn into_get_nearest_opts(self) -\u003e (Command, GetNearestOption) {\n        let index_name = GetNearestOption::default().index(self.0 .1.to_owned());\n\n        (self.0 .0.into(), index_name)\n    }\n}\n\nimpl GetNearestArg for Args\u003c(Command, \u0026str)\u003e {\n    fn into_get_nearest_opts(self) -\u003e (Command, GetNearestOption) {\n        let index_name = GetNearestOption::default().index(self.0 .1.to_owned());\n\n        (self.0 .0, index_name)\n    }\n}\n\nimpl\u003cT: Geometry\u003e GetNearestArg for Args\u003c(T, \u0026str, GetNearestOption)\u003e {\n    fn into_get_nearest_opts(self) -\u003e (Command, GetNearestOption) {\n        let index_name = self.0 .2.index(self.0 .1.to_owned());\n\n        (self.0 .0.into(), index_name)\n    }\n}\n\nimpl GetNearestArg for Args\u003c(Command, \u0026str, GetNearestOption)\u003e {\n    fn into_get_nearest_opts(self) -\u003e (Command, GetNearestOption) {\n        let index_name = self.0 .2.index(self.0 .1.to_owned());\n\n        (self.0 .0, index_name)\n    }\n}\n\n#[derive(Debug, Clone, Serialize, Default, CommandOptions)]\npub struct GetNearestOption {\n    pub index: Cow\u003c'static, str\u003e,\n    /// the maximum number of results to return (default 100).\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub max_results: Option\u003cusize\u003e,\n    /// Unit for the distance.\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub unit: Option\u003cUnit\u003e,\n    /// distance from an object to the specified point (default 100 km).\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub max_dist: Option\u003cusize\u003e,\n    /// the reference ellipsoid to use for geographic coordinates.\n    /// Possible values are `GeoSystem::WGS84` (the default),\n    /// a common standard for Earth’s geometry, or `GeoSystem::UnitSphere`,\n    /// a perfect sphere of 1 meter radius.\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub geo_system: Option\u003cGeoSystem\u003e,\n}\n\n#[cfg(test)]\nmod tests {\n    use serde::{Deserialize, Serialize};\n    use uuid::Uuid;\n\n    use crate::cmd::index_create::IndexCreateOption;\n    use crate::cmd::point::Point;\n    use crate::prelude::Converter;\n    use crate::types::ClosestDocumentResponse;\n    use crate::{args, r, Result};\n\n    #[derive(Debug, Serialize, Deserialize, PartialEq)]\n    struct Park {\n        id: u8,\n        area: Point,\n    }\n\n    impl Park {\n        fn new(id: u8, area: Point) -\u003e Self {\n            Self { id, area }\n        }\n    }\n\n    #[tokio::test]\n    async fn test_get_nearest_ops() -\u003e Result\u003c()\u003e {\n        let data = vec![\n            Park::new(1, r.point(-121.886420, 37.329898)),\n            Park::new(2, r.point(-117.220406, 32.719464)),\n            Park::new(3, r.point(-122.422876, 37.777128)),\n            Park::new(4, r.point(-122.423246, 37.779388)),\n        ];\n        let table_name = Uuid::new_v4().to_string();\n        let conn = r.connection().connect().await?;\n        let table = r.table(table_name.as_str());\n        r.table_create(table_name.as_str()).run(\u0026conn).await?;\n        table\n            .clone()\n            .index_create(args!(\"area\", IndexCreateOption::default().geo(true)))\n            .run(\u0026conn)\n            .await?;\n        table.clone().index_wait(()).run(\u0026conn).await?;\n        table.clone().insert(\u0026data).run(\u0026conn).await?;\n\n        let secret_base = r.point(-122.422876, 37.777128);\n        let response: Vec\u003cClosestDocumentResponse\u003cPark\u003e\u003e = table\n            .get_nearest(args!(secret_base, \"area\"))\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(response.len() \u003e 0);\n\n        r.table_drop(table_name.as_str()).run(\u0026conn).await?;\n        Ok(())\n    }\n}\n","traces":[{"line":12,"address":[4535168,4535675],"length":1,"stats":{"Line":1},"fn_name":"new\u003creql_rust::arguments::Args\u003c(reql_rust::cmd::point::Point, \u0026str)\u003e\u003e"},{"line":13,"address":[4535185],"length":1,"stats":{"Line":1},"fn_name":null},{"line":15,"address":[4535612,4535496,4535363],"length":1,"stats":{"Line":3},"fn_name":null},{"line":16,"address":[4535437],"length":1,"stats":{"Line":1},"fn_name":null},{"line":17,"address":[4535508],"length":1,"stats":{"Line":1},"fn_name":null},{"line":25,"address":[1817900,1817616,1818037],"length":1,"stats":{"Line":1},"fn_name":"into_get_nearest_opts\u003creql_rust::cmd::point::Point\u003e"},{"line":26,"address":[1817638,1817890,1817720],"length":1,"stats":{"Line":2},"fn_name":null},{"line":28,"address":[1817831,1817948],"length":1,"stats":{"Line":2},"fn_name":null},{"line":33,"address":[6661891,6661568],"length":1,"stats":{"Line":0},"fn_name":"into_get_nearest_opts"},{"line":34,"address":[6661589,6661649,6661881],"length":1,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[6661769],"length":1,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[6661920,6662274],"length":1,"stats":{"Line":0},"fn_name":"into_get_nearest_opts"},{"line":50,"address":[6661944,6662267],"length":1,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[6662144],"length":1,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[2047296],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":100,"address":[2050037,2050085,2049632,2049671],"length":1,"stats":{"Line":6},"fn_name":"test_get_nearest_ops"},{"line":101,"address":[4429358,4428630,4429608],"length":1,"stats":{"Line":2},"fn_name":null},{"line":102,"address":[4429408,4429343],"length":1,"stats":{"Line":2},"fn_name":null},{"line":103,"address":[4429439],"length":1,"stats":{"Line":1},"fn_name":null},{"line":104,"address":[4429498],"length":1,"stats":{"Line":1},"fn_name":null},{"line":105,"address":[4429557],"length":1,"stats":{"Line":1},"fn_name":null},{"line":107,"address":[4429793,4429726],"length":1,"stats":{"Line":2},"fn_name":null},{"line":108,"address":[6774063],"length":1,"stats":{"Line":4},"fn_name":null},{"line":109,"address":[4430623,4430349],"length":1,"stats":{"Line":2},"fn_name":null},{"line":110,"address":[6773875,6773818],"length":1,"stats":{"Line":4},"fn_name":null},{"line":111,"address":[4431751,4431452,4431916,4431993,4432402,4432194,4431676],"length":1,"stats":{"Line":6},"fn_name":null},{"line":113,"address":[4431497,4431540,4431766,4431723],"length":1,"stats":{"Line":2},"fn_name":null},{"line":114,"address":[6773735],"length":1,"stats":{"Line":6},"fn_name":null},{"line":115,"address":[4432284,4432432],"length":1,"stats":{"Line":1},"fn_name":null},{"line":116,"address":[6773709,6773652],"length":1,"stats":{"Line":4},"fn_name":null},{"line":117,"address":[4428944,4433318,4433248,4428787],"length":1,"stats":{"Line":4},"fn_name":null},{"line":119,"address":[4434048],"length":1,"stats":{"Line":1},"fn_name":null},{"line":120,"address":[4434749,4435048,4434968,4434088,4434471,4434548,4435288,4435025,4434348,4434286],"length":1,"stats":{"Line":7},"fn_name":null},{"line":121,"address":[4434131],"length":1,"stats":{"Line":1},"fn_name":null},{"line":122,"address":[4434504,4434371,4434328,4428808,4434676,4428893],"length":1,"stats":{"Line":6},"fn_name":null},{"line":123,"address":[4434872],"length":1,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[4435402,4435177,4435444],"length":1,"stats":{"Line":2},"fn_name":null},{"line":129,"address":[4428826,4435423,4435518],"length":1,"stats":{"Line":3},"fn_name":null},{"line":130,"address":[2050048,2049708,2049768,2049663],"length":1,"stats":{"Line":5},"fn_name":null}],"covered":32,"coverable":42},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","get_write_hook.rs"],"content":"use ql2::term::TermType;\n\nuse crate::Command;\n\npub(crate) fn new() -\u003e Command {\n    Command::new(TermType::GetWriteHook)\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::*;\n    use crate::spec::{set_up, tear_down};\n    use crate::types::GetWriteHookResponse;\n    use crate::Result;\n\n    #[tokio::test]\n    async fn test_get_write_hook_ops() -\u003e Result\u003c()\u003e {\n        let (conn, table, table_name) = set_up(false).await?;\n        table\n            .clone()\n            .set_write_hook(func!(|_, _, new_val| new_val))\n            .run(\u0026conn)\n            .await?;\n\n        let response: GetWriteHookResponse =\n            table.get_write_hook().run(\u0026conn).await?.unwrap().parse()?;\n\n        assert!(!response.query.is_empty());\n\n        tear_down(conn, \u0026table_name).await\n    }\n}\n","traces":[{"line":5,"address":[2719376],"length":1,"stats":{"Line":0},"fn_name":"new"},{"line":6,"address":[2719388],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":2},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","grant.rs"],"content":"use ql2::term::TermType;\n\nuse crate::arguments::Permission;\nuse crate::Command;\n\npub(crate) fn new(username: \u0026str, permission: Permission) -\u003e Command {\n    Command::new(TermType::Grant)\n        .with_arg(Command::from_json(username))\n        .with_arg(Command::from_json(permission))\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::arguments::Permission;\n    use crate::prelude::Converter;\n    use crate::spec::{set_up, tear_down};\n    use crate::types::{ConfigChange, GrantChangeValue, GrantResponse};\n    use crate::Result;\n\n    #[tokio::test]\n    async fn test_grant_permission() -\u003e Result\u003c()\u003e {\n        let (conn, table, table_name) = set_up(false).await?;\n        let expected = GrantResponse {\n            granted: 1,\n            permissions_changes: vec![ConfigChange {\n                old_val: None,\n                new_val: Some(GrantChangeValue {\n                    write: Some(true),\n                    read: Some(true),\n                    config: None,\n                    connect: None,\n                }),\n            }],\n        };\n        let permissions = Permission::default().read(true).write(true);\n        // TODO Replace current user when test user should be created\n        let response: GrantResponse = table\n            .grant(\"bob\", permissions)\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(response == expected);\n\n        tear_down(conn, \u0026table_name).await\n    }\n}\n","traces":[{"line":6,"address":[3069370,3069088,3069340],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":7,"address":[2686065,2685766,2685888],"length":1,"stats":{"Line":3},"fn_name":null},{"line":8,"address":[2685928,2685996,2685831],"length":1,"stats":{"Line":2},"fn_name":null},{"line":9,"address":[2767766,2767750,2767592,2767674],"length":1,"stats":{"Line":2},"fn_name":null},{"line":21,"address":[7012112,7012181,7012793,7012089,7012501,7012080,7012275],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":22,"address":[7012305,7012458,7012626,7012804,7013188,7012243],"length":1,"stats":{"Line":4},"fn_name":null},{"line":25,"address":[7013170,7013560],"length":1,"stats":{"Line":2},"fn_name":null},{"line":35,"address":[7013714,7013655],"length":1,"stats":{"Line":2},"fn_name":null},{"line":37,"address":[7014591,7014688,7013897,7013983,7014177,7014100,7013839,7014922,7014372,7014648],"length":1,"stats":{"Line":7},"fn_name":null},{"line":38,"address":[7013883],"length":1,"stats":{"Line":1},"fn_name":null},{"line":39,"address":[6761500],"length":1,"stats":{"Line":5},"fn_name":null},{"line":40,"address":[7014495],"length":1,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[7014808,7015122,7015176],"length":1,"stats":{"Line":2},"fn_name":null},{"line":46,"address":[4768319,4768364,4768704,4768424],"length":1,"stats":{"Line":7},"fn_name":null}],"covered":13,"coverable":14},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","group.rs"],"content":"use std::borrow::Cow;\n\nuse ql2::term::TermType;\nuse reql_macros::CommandOptions;\nuse serde::Serialize;\n\nuse crate::arguments::Args;\nuse crate::prelude::Func;\nuse crate::Command;\n\nuse super::CmdOpts;\n\npub(crate) fn new(args: impl GroupArg) -\u003e Command {\n    let (args, opts) = args.into_group_opts();\n\n    args.add_to_cmd(Command::new(TermType::Group))\n        .with_opts(opts)\n}\n\npub trait GroupArg {\n    fn into_group_opts(self) -\u003e (CmdOpts, GroupOption);\n}\n\nimpl GroupArg for \u0026str {\n    fn into_group_opts(self) -\u003e (CmdOpts, GroupOption) {\n        let arg = Command::from_json(self);\n\n        (CmdOpts::Single(arg), Default::default())\n    }\n}\n\nimpl\u003cconst N: usize\u003e GroupArg for [\u0026str; N] {\n    fn into_group_opts(self) -\u003e (CmdOpts, GroupOption) {\n        let args = self.into_iter().map(Command::from_json).collect();\n\n        (CmdOpts::Many(args), Default::default())\n    }\n}\n\nimpl GroupArg for Func {\n    fn into_group_opts(self) -\u003e (CmdOpts, GroupOption) {\n        (CmdOpts::Single(self.0), Default::default())\n    }\n}\n\nimpl\u003cconst N: usize\u003e GroupArg for [Func; N] {\n    fn into_group_opts(self) -\u003e (CmdOpts, GroupOption) {\n        let args = self.into_iter().map(|func| func.0).collect();\n\n        (CmdOpts::Many(args), Default::default())\n    }\n}\n\nimpl GroupArg for Args\u003c(\u0026str, GroupOption)\u003e {\n    fn into_group_opts(self) -\u003e (CmdOpts, GroupOption) {\n        let arg = Command::from_json(self.0 .0);\n\n        (CmdOpts::Single(arg), self.0 .1)\n    }\n}\n\nimpl\u003cconst N: usize\u003e GroupArg for Args\u003c([\u0026str; N], GroupOption)\u003e {\n    fn into_group_opts(self) -\u003e (CmdOpts, GroupOption) {\n        let args = self.0 .0.into_iter().map(Command::from_json).collect();\n\n        (CmdOpts::Many(args), self.0 .1)\n    }\n}\n\nimpl GroupArg for Args\u003c(Func, GroupOption)\u003e {\n    fn into_group_opts(self) -\u003e (CmdOpts, GroupOption) {\n        let Func(func) = self.0 .0;\n\n        (CmdOpts::Single(func), self.0 .1)\n    }\n}\n\nimpl\u003cconst N: usize\u003e GroupArg for Args\u003c([Func; N], GroupOption)\u003e {\n    fn into_group_opts(self) -\u003e (CmdOpts, GroupOption) {\n        let funcs = self.0 .0.into_iter().map(|func| func.0).collect();\n\n        (CmdOpts::Many(funcs), self.0 .1)\n    }\n}\n\n#[derive(Debug, Clone, Serialize, Default, PartialEq, PartialOrd, CommandOptions)]\npub struct GroupOption {\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub index: Option\u003cCow\u003c'static, str\u003e\u003e,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub multi: Option\u003cbool\u003e,\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::Converter;\n    use crate::spec::{set_up, tear_down, Post};\n    use crate::types::GroupedStream;\n    use crate::Result;\n\n    #[tokio::test]\n    async fn test_group_data() -\u003e Result\u003c()\u003e {\n        let (conn, table, table_name) = set_up(true).await?;\n        let data_obtained: GroupedStream\u003cString, Post\u003e =\n            table.group(\"title\").run(\u0026conn).await?.unwrap().parse()?;\n\n        let data_obtained = data_obtained.collect();\n\n        assert!(data_obtained.len() == 4);\n\n        tear_down(conn, \u0026table_name).await\n    }\n}\n","traces":[{"line":12,"address":[4374385,4374474,4373936],"length":1,"stats":{"Line":1},"fn_name":"new\u003c\u0026str\u003e"},{"line":13,"address":[4373969],"length":1,"stats":{"Line":1},"fn_name":null},{"line":15,"address":[4374351,4374127,4374378],"length":1,"stats":{"Line":2},"fn_name":null},{"line":16,"address":[4374279],"length":1,"stats":{"Line":1},"fn_name":null},{"line":24,"address":[2882309,2882064],"length":1,"stats":{"Line":1},"fn_name":"into_group_opts"},{"line":25,"address":[2800449],"length":1,"stats":{"Line":1},"fn_name":null},{"line":27,"address":[2800500],"length":1,"stats":{"Line":1},"fn_name":null},{"line":32,"address":[4438448,4438722],"length":1,"stats":{"Line":0},"fn_name":"into_group_opts"},{"line":33,"address":[4438464],"length":1,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[4438536],"length":1,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[2827728,2827926],"length":1,"stats":{"Line":0},"fn_name":"into_group_opts"},{"line":41,"address":[2827779],"length":1,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[2882336,2882583],"length":1,"stats":{"Line":0},"fn_name":"into_group_opts"},{"line":47,"address":[2882361],"length":1,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[2882425],"length":1,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[4438752,4439079],"length":1,"stats":{"Line":0},"fn_name":"into_group_opts"},{"line":55,"address":[4438773,4438864],"length":1,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[4438892],"length":1,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[7018928],"length":1,"stats":{"Line":0},"fn_name":"into_group_opts"},{"line":63,"address":[7018950],"length":1,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[2827989],"length":1,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[1712885,1712519,1712480,1712933],"length":1,"stats":{"Line":6},"fn_name":"test_group_data"},{"line":88,"address":[4758620,4758941,4758773,4758547,4759119,4759563],"length":1,"stats":{"Line":4},"fn_name":null},{"line":89,"address":[4758724,4760731,4760537,4759503,4759820,4758641],"length":1,"stats":{"Line":5},"fn_name":null},{"line":92,"address":[4760669],"length":1,"stats":{"Line":1},"fn_name":null},{"line":94,"address":[4761156,4761033,4761095],"length":1,"stats":{"Line":2},"fn_name":null},{"line":96,"address":[1712616,1712511,1712556,1712896],"length":1,"stats":{"Line":7},"fn_name":null}],"covered":13,"coverable":27},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","gt.rs"],"content":"use ql2::term::TermType;\nuse serde::Serialize;\n\nuse crate::arguments::Args;\nuse crate::Command;\n\nuse super::CmdOpts;\n\npub(crate) fn new(args: impl GtArg) -\u003e Command {\n    args.into_gt_opts().add_to_cmd(Command::new(TermType::Gt))\n}\n\npub trait GtArg {\n    fn into_gt_opts(self) -\u003e CmdOpts;\n}\n\nimpl\u003cT: Serialize\u003e GtArg for T {\n    fn into_gt_opts(self) -\u003e CmdOpts {\n        CmdOpts::Single(Command::from_json(self))\n    }\n}\n\nimpl GtArg for Command {\n    fn into_gt_opts(self) -\u003e CmdOpts {\n        CmdOpts::Single(self)\n    }\n}\n\nimpl\u003cS, T\u003e GtArg for Args\u003cT\u003e\nwhere\n    S: Serialize,\n    T: IntoIterator\u003cItem = S\u003e,\n{\n    fn into_gt_opts(self) -\u003e CmdOpts {\n        let commands = self.0.into_iter().map(Command::from_json).collect();\n\n        CmdOpts::Many(commands)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::Converter;\n    use crate::spec::{set_up, tear_down};\n    use crate::{args, r, Result};\n\n    #[tokio::test]\n    async fn test_gt_data() -\u003e Result\u003c()\u003e {\n        let (conn, table, table_name) = set_up(true).await?;\n        let data_obtained: bool = table\n            .get(1)\n            .g(\"view\")\n            .gt(5)\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(data_obtained);\n\n        tear_down(conn, \u0026table_name).await\n    }\n\n    #[tokio::test]\n    async fn test_gt_data_r() -\u003e Result\u003c()\u003e {\n        let conn = r.connection().connect().await?;\n        let data_obtained: bool = r.gt(args!([7, 6, 5])).run(\u0026conn).await?.unwrap().parse()?;\n\n        assert!(data_obtained);\n\n        Ok(())\n    }\n}\n","traces":[{"line":9,"address":[2391624,2391844,2391648,2391817,2391392,2391597],"length":1,"stats":{"Line":2},"fn_name":"new\u003creql_rust::arguments::Args\u003calloc::vec::Vec\u003ci32, alloc::alloc::Global\u003e\u003e\u003e"},{"line":10,"address":[2391408,2391837,2391671,2391617],"length":1,"stats":{"Line":2},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":27,"address":[1818237],"length":1,"stats":{"Line":1},"fn_name":null},{"line":38,"address":[6687461,6687047,6687008,6687413],"length":1,"stats":{"Line":6},"fn_name":"test_gt_data"},{"line":39,"address":[7039581,7039927,7039363,7040364,7039428,7039749],"length":1,"stats":{"Line":4},"fn_name":null},{"line":40,"address":[7041393,7040801,7040597,7041349,7041292,7040878,7041583,7040311,7041073],"length":1,"stats":{"Line":6},"fn_name":null},{"line":44,"address":[7039532,7041006,7039449,7040707,7040834],"length":1,"stats":{"Line":5},"fn_name":null},{"line":45,"address":[7041196],"length":1,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[7041472,7041786],"length":1,"stats":{"Line":1},"fn_name":null},{"line":51,"address":[7042004,7041880,7041743,7042116,7039467,7042250,7042064],"length":1,"stats":{"Line":7},"fn_name":null},{"line":55,"address":[6687957,6687543,6687909,6687504],"length":1,"stats":{"Line":6},"fn_name":"test_gt_data_r"},{"line":56,"address":[7042764,7043114,7042925,7042659,7042693,7043382],"length":1,"stats":{"Line":4},"fn_name":null},{"line":57,"address":[7043912,7043698,7044316,7044600,7044097,7044410,7043730,7043841,7044373],"length":1,"stats":{"Line":6},"fn_name":null},{"line":58,"address":[7043367,7043610],"length":1,"stats":{"Line":2},"fn_name":null},{"line":59,"address":[6858105],"length":1,"stats":{"Line":5},"fn_name":null},{"line":60,"address":[7044220],"length":1,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[7044712,7044489],"length":1,"stats":{"Line":1},"fn_name":null},{"line":66,"address":[6687920,6687580,6687535,6687640],"length":1,"stats":{"Line":5},"fn_name":null}],"covered":20,"coverable":22},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","has_fields.rs"],"content":"use ql2::term::TermType;\nuse serde::Serialize;\n\nuse crate::Command;\n\npub(crate) fn new(selector: impl Serialize) -\u003e Command {\n    let arg = Command::from_json(selector);\n\n    Command::new(TermType::HasFields).with_arg(arg)\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::Converter;\n    use crate::spec::{set_up, tear_down};\n    use crate::Result;\n\n    #[tokio::test]\n    async fn test_has_fields() -\u003e Result\u003c()\u003e {\n        let (conn, table, table_name) = set_up(true).await?;\n        let data_obtained: bool = table\n            .get(1)\n            .has_fields(\"title\")\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(data_obtained);\n\n        tear_down(conn, \u0026table_name).await\n    }\n}\n","traces":[{"line":6,"address":[4353312,4353524,4353551],"length":1,"stats":{"Line":1},"fn_name":"new\u003c\u0026str\u003e"},{"line":7,"address":[4353345],"length":1,"stats":{"Line":1},"fn_name":null},{"line":9,"address":[4353438,4353371],"length":1,"stats":{"Line":2},"fn_name":null},{"line":19,"address":[2256389,2255984,2256437,2256023],"length":1,"stats":{"Line":6},"fn_name":"test_has_fields"},{"line":20,"address":[4100373,4100988,4100052,4100205,4100551,4099987],"length":1,"stats":{"Line":4},"fn_name":null},{"line":21,"address":[4102179,4101989,4101945,4101888,4100935,4101474,4101669,4101397,4101221],"length":1,"stats":{"Line":6},"fn_name":null},{"line":24,"address":[4100156,4101430,4101303,4100073,4101602],"length":1,"stats":{"Line":5},"fn_name":null},{"line":25,"address":[4101792],"length":1,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[4102068,4102382],"length":1,"stats":{"Line":1},"fn_name":null},{"line":31,"address":[2256060,2256120,2256400,2256015],"length":1,"stats":{"Line":7},"fn_name":null}],"covered":9,"coverable":10},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","hash_map.rs"],"content":"use std::collections::HashMap;\n\nuse ql2::term::TermType;\n\nuse crate::Command;\n\npub(crate) fn new\u003cT\u003e(args: HashMap\u003cT, Command\u003e) -\u003e Command\nwhere\n    T: Into\u003cString\u003e,\n{\n    args.into_iter()\n        .flat_map(|(key, value)| [Command::from_json(key.into()), value])\n        .fold(Command::new(TermType::Object), |command, arg| {\n            command.with_arg(arg)\n        })\n}\n","traces":[{"line":7,"address":[5126179,5125968,5126206],"length":1,"stats":{"Line":1},"fn_name":"new\u003c\u0026str\u003e"},{"line":11,"address":[5125985,5126130],"length":1,"stats":{"Line":2},"fn_name":null},{"line":12,"address":[5126224,5126050,5126262],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}\u003c\u0026str\u003e"},{"line":13,"address":[5126528,5126058],"length":1,"stats":{"Line":2},"fn_name":"{closure#1}\u003c\u0026str\u003e"},{"line":14,"address":[5126569],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":5,"coverable":5},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","hours.rs"],"content":"use ql2::term::TermType;\n\nuse crate::Command;\n\npub(crate) fn new() -\u003e Command {\n    Command::new(TermType::Hours)\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::Converter;\n    use crate::{r, Result};\n\n    #[tokio::test]\n    async fn test_hours_ops() -\u003e Result\u003c()\u003e {\n        let conn = r.connection().connect().await?;\n\n        let hours = r.now().hours();\n        let hours1 = hours.clone().value();\n        let hours2: u8 = hours.cmd().run(\u0026conn).await?.unwrap().parse()?;\n\n        assert!(hours1 == hours2);\n\n        Ok(())\n    }\n}\n","traces":[{"line":5,"address":[2719424],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":6,"address":[2719436],"length":1,"stats":{"Line":1},"fn_name":null},{"line":15,"address":[1537594,1537001,1537024,1536992,1537158,1537081,1537295],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":16,"address":[1537416,1537136,1537605,1537182,1537255,1537866],"length":1,"stats":{"Line":4},"fn_name":null},{"line":18,"address":[1537856,1538112],"length":1,"stats":{"Line":2},"fn_name":null},{"line":19,"address":[1538140,1538203],"length":1,"stats":{"Line":2},"fn_name":null},{"line":20,"address":[1537197,1538247,1539047,1538334,1539142],"length":1,"stats":{"Line":4},"fn_name":null},{"line":22,"address":[1539121,1539335],"length":1,"stats":{"Line":1},"fn_name":null},{"line":24,"address":[1539305],"length":1,"stats":{"Line":5},"fn_name":null}],"covered":9,"coverable":9},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","http.rs"],"content":"use ql2::term::TermType;\nuse serde::Serialize;\n\nuse crate::arguments::Args;\nuse crate::Command;\n\npub(crate) fn new\u003cT\u003e(args: impl HttpArg\u003cT\u003e) -\u003e Command\nwhere\n    T: Serialize,\n{\n    let (arg, opts) = args.into_http_opts();\n    let mut command = Command::new(TermType::Http).with_arg(arg);\n\n    if let Some(opts) = opts {\n        command = command.with_opts(opts);\n    }\n\n    command\n}\n\npub trait HttpArg\u003cT: Serialize\u003e {\n    fn into_http_opts(self) -\u003e (Command, Option\u003cT\u003e);\n}\n\nimpl\u003cT\u003e HttpArg\u003cT\u003e for T\nwhere\n    T: Into\u003cString\u003e + Serialize,\n{\n    fn into_http_opts(self) -\u003e (Command, Option\u003cT\u003e) {\n        (Command::from_json(self.into()), None)\n    }\n}\n\nimpl\u003cS, T\u003e HttpArg\u003cT\u003e for Args\u003c(S, T)\u003e\nwhere\n    S: Into\u003cString\u003e,\n    T: Serialize,\n{\n    fn into_http_opts(self) -\u003e (Command, Option\u003cT\u003e) {\n        (Command::from_json(self.0 .0.into()), Some(self.0 .1))\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use serde_json::json;\n\n    use crate::{args, r, Result};\n\n    #[tokio::test]\n    async fn test_http_ops() -\u003e Result\u003c()\u003e {\n        let conn = r.connection().connect().await?;\n        let response = r.http(\"http://httpbin.org/get\").run(\u0026conn).await?;\n\n        assert!(response.is_some());\n\n        Ok(())\n    }\n\n    #[tokio::test]\n    async fn test_http_ops_with_params() -\u003e Result\u003c()\u003e {\n        let conn = r.connection().connect().await?;\n        let response = r\n            .http(args!(\n                \"http://httpbin.org/get\",\n                json!({\n                    \"params\": {\n                        \"user\": 1\n                    }\n                })\n            ))\n            .run(\u0026conn)\n            .await?;\n\n        assert!(response.is_some());\n\n        Ok(())\n    }\n}\n","traces":[{"line":7,"address":[2220869,2220176,2220778,2221501,2220896,2221474],"length":1,"stats":{"Line":2},"fn_name":"new\u003cserde_json::value::Value, reql_rust::arguments::Args\u003c(\u0026str, serde_json::value::Value)\u003e\u003e"},{"line":11,"address":[2220929,2220193],"length":1,"stats":{"Line":2},"fn_name":null},{"line":12,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":14,"address":[2220735,2220485,2221407,2221191],"length":1,"stats":{"Line":3},"fn_name":null},{"line":15,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":39,"address":[1818352,1818680],"length":1,"stats":{"Line":1},"fn_name":"into_http_opts\u003c\u0026str, serde_json::value::Value\u003e"},{"line":40,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":51,"address":[1552624,1552749,1552592,1552681,1553183,1552884,1552601],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":52,"address":[1553005,1553467,1552773,1553194,1552844,1552739],"length":1,"stats":{"Line":4},"fn_name":null},{"line":53,"address":[1553437,1554208,1552788,1553709],"length":1,"stats":{"Line":3},"fn_name":null},{"line":55,"address":[1554428,1554194,1554465],"length":1,"stats":{"Line":2},"fn_name":null},{"line":57,"address":[1554434],"length":1,"stats":{"Line":5},"fn_name":null},{"line":61,"address":[1554528,1555135,1554836,1554617,1554537,1554560,1554701],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":62,"address":[1554667,1555407,1555146,1554725,1554957,1554796],"length":1,"stats":{"Line":4},"fn_name":null},{"line":63,"address":[1557099,1556635,1556891,1556524,1556706,1556492],"length":1,"stats":{"Line":5},"fn_name":null},{"line":64,"address":[1556369],"length":1,"stats":{"Line":1},"fn_name":null},{"line":66,"address":[1555644,1555710,1556041,1555834,1555397],"length":1,"stats":{"Line":4},"fn_name":null},{"line":72,"address":[1556834,1556504,1556547,1556665,1554740],"length":1,"stats":{"Line":5},"fn_name":null},{"line":73,"address":[1557003,1557129],"length":1,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[1557260,1556989,1557223],"length":1,"stats":{"Line":2},"fn_name":null},{"line":77,"address":[1557229],"length":1,"stats":{"Line":5},"fn_name":null}],"covered":23,"coverable":24},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","in_timezone.rs"],"content":"use ql2::term::TermType;\nuse time::UtcOffset;\n\nuse crate::types::timezone_to_string;\nuse crate::Command;\n\npub(crate) fn new(timezone: UtcOffset) -\u003e Command {\n    Command::new(TermType::InTimezone).with_arg(Command::from_json(timezone_to_string(timezone)))\n}\n\n#[cfg(test)]\nmod tests {\n    use time::macros::offset;\n\n    use crate::prelude::Converter;\n    use crate::types::Time;\n    use crate::{r, Result};\n\n    #[tokio::test]\n    async fn test_in_timezone_ops() -\u003e Result\u003c()\u003e {\n        let conn = r.connection().connect().await?;\n\n        let date_time = r.now().in_timezone(offset!(-08:00));\n        let time1 = date_time.clone().value();\n        let time2: Time = date_time.cmd().run(\u0026conn).await?.unwrap().parse()?;\n\n        assert!(time1.is_valid());\n        assert!(time2.is_valid());\n\n        Ok(())\n    }\n}\n","traces":[{"line":7,"address":[4481424,4481719,4481692],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":8,"address":[4481477,4481712],"length":1,"stats":{"Line":1},"fn_name":null},{"line":20,"address":[4183024,4183594,4182992,4183158,4183295,4183081,4183001],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":21,"address":[4183182,4183416,4183866,4183255,4183136,4183605],"length":1,"stats":{"Line":4},"fn_name":null},{"line":23,"address":[4184112,4183856],"length":1,"stats":{"Line":2},"fn_name":null},{"line":24,"address":[4184189,4184255],"length":1,"stats":{"Line":2},"fn_name":null},{"line":25,"address":[4183197,4184369,4184282,4185252,4185081],"length":1,"stats":{"Line":4},"fn_name":null},{"line":27,"address":[4185231,4185521,4185496],"length":1,"stats":{"Line":2},"fn_name":null},{"line":28,"address":[4185557,4185590,4185510],"length":1,"stats":{"Line":2},"fn_name":null},{"line":30,"address":[4185563],"length":1,"stats":{"Line":5},"fn_name":null}],"covered":10,"coverable":10},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","includes.rs"],"content":"use ql2::term::TermType;\n\nuse crate::{prelude::Geometry, Command};\n\nuse super::CmdOpts;\n\npub(crate) fn new(geometry: impl IncludesArg) -\u003e Command {\n    geometry\n        .into_includes_opts()\n        .add_to_cmd(Command::new(TermType::Includes))\n}\n\npub trait IncludesArg {\n    fn into_includes_opts(self) -\u003e CmdOpts;\n}\n\nimpl\u003cT: Geometry\u003e IncludesArg for T {\n    fn into_includes_opts(self) -\u003e CmdOpts {\n        CmdOpts::Single(self.into())\n    }\n}\n\nimpl IncludesArg for Command {\n    fn into_includes_opts(self) -\u003e CmdOpts {\n        CmdOpts::Single(self)\n    }\n}\n\nimpl\u003cT: Geometry\u003e IncludesArg for Vec\u003cT\u003e {\n    fn into_includes_opts(self) -\u003e CmdOpts {\n        CmdOpts::Many(self.into_iter().map(|geo| geo.cmd()).collect())\n    }\n}\n\nimpl IncludesArg for Vec\u003cCommand\u003e {\n    fn into_includes_opts(self) -\u003e CmdOpts {\n        CmdOpts::Many(self)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::Converter;\n    use crate::{args, r, Result};\n\n    #[tokio::test]\n    async fn test_includes_geo() -\u003e Result\u003c()\u003e {\n        let conn = r.connection().connect().await?;\n        let point1 = r.point(-117.220406, 32.719464);\n        let point2 = r.point(-117.206201, 32.725186);\n\n        let response: bool = r\n            .circle(args!(point1, 2000.))\n            .includes(point2)\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(response);\n\n        Ok(())\n    }\n}\n","traces":[{"line":7,"address":[4533453,4533480,4533248],"length":1,"stats":{"Line":1},"fn_name":"new\u003creql_rust::cmd::point::Point\u003e"},{"line":8,"address":[4533404,4533264],"length":1,"stats":{"Line":2},"fn_name":null},{"line":10,"address":[4533437,4533473,4533333],"length":1,"stats":{"Line":2},"fn_name":null},{"line":18,"address":[1646704],"length":1,"stats":{"Line":1},"fn_name":"into_includes_opts\u003creql_rust::cmd::point::Point\u003e"},{"line":19,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":24,"address":[2174336],"length":1,"stats":{"Line":0},"fn_name":"into_includes_opts"},{"line":25,"address":[2174352],"length":1,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[4439120],"length":1,"stats":{"Line":0},"fn_name":"into_includes_opts"},{"line":37,"address":[4439127],"length":1,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[4794181,4793776,4794229,4793815],"length":1,"stats":{"Line":6},"fn_name":"test_includes_geo"},{"line":48,"address":[2668211,2668477,2668943,2668666,2668316,2668245],"length":1,"stats":{"Line":4},"fn_name":null},{"line":49,"address":[2668933],"length":1,"stats":{"Line":1},"fn_name":null},{"line":50,"address":[2669204],"length":1,"stats":{"Line":1},"fn_name":null},{"line":52,"address":[2670333,2669341,2669463,2670106,2670049,2669645,2669574,2669431,2669830,2670143],"length":1,"stats":{"Line":7},"fn_name":null},{"line":53,"address":[2669211],"length":1,"stats":{"Line":1},"fn_name":null},{"line":54,"address":[2669375],"length":1,"stats":{"Line":1},"fn_name":null},{"line":55,"address":[2669604,2669443,2669486,2668260,2669773],"length":1,"stats":{"Line":5},"fn_name":null},{"line":56,"address":[2669953],"length":1,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[2670222,2670426],"length":1,"stats":{"Line":1},"fn_name":null},{"line":62,"address":[2670400],"length":1,"stats":{"Line":5},"fn_name":null}],"covered":15,"coverable":22},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","index_create.rs"],"content":"use ql2::term::TermType;\nuse reql_macros::CommandOptions;\nuse serde::Serialize;\n\nuse crate::arguments::Args;\nuse crate::prelude::Func;\nuse crate::Command;\n\npub(crate) fn new(args: impl IndexCreateArg) -\u003e Command {\n    let (arg, func, opts) = args.into_table_create_opts();\n    let mut command = Command::new(TermType::IndexCreate).with_arg(arg);\n\n    if let Some(Func(func)) = func {\n        command = command.with_arg(func);\n    }\n\n    command.with_opts(opts)\n}\n\npub trait IndexCreateArg {\n    fn into_table_create_opts(self) -\u003e (Command, Option\u003cFunc\u003e, IndexCreateOption);\n}\n\nimpl\u003cT\u003e IndexCreateArg for T\nwhere\n    T: Into\u003cString\u003e,\n{\n    fn into_table_create_opts(self) -\u003e (Command, Option\u003cFunc\u003e, IndexCreateOption) {\n        (Command::from_json(self.into()), None, Default::default())\n    }\n}\n\nimpl\u003cT\u003e IndexCreateArg for Args\u003c(T, Func)\u003e\nwhere\n    T: Into\u003cString\u003e,\n{\n    fn into_table_create_opts(self) -\u003e (Command, Option\u003cFunc\u003e, IndexCreateOption) {\n        (\n            Command::from_json(self.0 .0.into()),\n            Some(self.0 .1),\n            Default::default(),\n        )\n    }\n}\n\nimpl\u003cT\u003e IndexCreateArg for Args\u003c(T, IndexCreateOption)\u003e\nwhere\n    T: Into\u003cString\u003e,\n{\n    fn into_table_create_opts(self) -\u003e (Command, Option\u003cFunc\u003e, IndexCreateOption) {\n        (Command::from_json(self.0 .0.into()), None, self.0 .1)\n    }\n}\n\nimpl\u003cT\u003e IndexCreateArg for Args\u003c(T, Func, IndexCreateOption)\u003e\nwhere\n    T: Into\u003cString\u003e,\n{\n    fn into_table_create_opts(self) -\u003e (Command, Option\u003cFunc\u003e, IndexCreateOption) {\n        (\n            Command::from_json(self.0 .0.into()),\n            Some(self.0 .1),\n            self.0 .2,\n        )\n    }\n}\n\n#[derive(Debug, Clone, Copy, Serialize, Default, PartialEq, PartialOrd, CommandOptions)]\npub struct IndexCreateOption {\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub multi: Option\u003cbool\u003e,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub geo: Option\u003cbool\u003e,\n}\n\n#[cfg(test)]\nmod tests {\n    use uuid::Uuid;\n\n    use crate::prelude::*;\n    use crate::types::IndexResponse;\n    use crate::{args, r, Command, Result, Session};\n\n    use super::IndexCreateOption;\n\n    #[tokio::test]\n    async fn test_create_index() -\u003e Result\u003c()\u003e {\n        let table_name = Uuid::new_v4().to_string();\n        let conn = r.connection().connect().await?;\n        let index_created = r.table(table_name.as_str()).index_create(\"author\");\n\n        setup(\u0026table_name, index_created, \u0026conn).await\n    }\n\n    #[tokio::test]\n    async fn test_create_index_with_options() -\u003e Result\u003c()\u003e {\n        let table_name = Uuid::new_v4().to_string();\n        let conn = r.connection().connect().await?;\n        let index_option = IndexCreateOption::default().multi(true);\n        let index_created = r\n            .table(table_name.as_str())\n            .index_create(args!(\"author\", index_option));\n\n        setup(\u0026table_name, index_created, \u0026conn).await\n    }\n\n    /* #[tokio::test]\n    async fn test_create_index_with_func() -\u003e Result\u003c()\u003e {\n        let table_name = Uuid::new_v4().to_string();\n        let conn = r.connection().connect().await?;\n        let index_created = r\n            .table(table_name.as_str())\n            .index_create((\"author\", func!(|row| row.bracket(\"author\").bracket(\"name\"))));\n\n        setup(\u0026table_name, index_created, \u0026conn).await\n    }\n\n    #[tokio::test]\n    async fn test_create_index_with_func_and_options() -\u003e Result\u003c()\u003e {\n        let table_name = Uuid::new_v4().to_string();\n        let conn = r.connection().connect().await?;\n        let index_option = IndexCreateOption::default().multi(true);\n        let index_created = r.table(table_name.as_str()).index_create((\n            \"author\",\n            func!(|row| row.bracket(\"author\").bracket(\"name\")),\n            index_option,\n        ));\n\n        setup(\u0026table_name, index_created, \u0026conn).await\n    } */\n\n    async fn setup(table_name: \u0026str, index_created: Command, conn: \u0026Session) -\u003e Result\u003c()\u003e {\n        r.table_create(table_name).run(conn).await?;\n\n        let index_created: IndexResponse = index_created.run(conn).await?.unwrap().parse()?;\n\n        assert!(index_created.created \u003e Some(0));\n\n        r.table_drop(table_name).run(conn).await?;\n        Ok(())\n    }\n}\n","traces":[{"line":10,"address":[4458320,4459203,4460090,4459232,4459680,4458795],"length":1,"stats":{"Line":2},"fn_name":"new\u003c(\u0026str, reql_rust::cmd::index_create::IndexCreateOption)\u003e"},{"line":11,"address":[4458337,4459265],"length":1,"stats":{"Line":2},"fn_name":null},{"line":13,"address":[4458654,4458709,4459442,4459539,4459594,4458557],"length":1,"stats":{"Line":6},"fn_name":null},{"line":14,"address":[4458788,4459468,4459586,4458701,4459673,4458583],"length":1,"stats":{"Line":4},"fn_name":null},{"line":17,"address":[4459088,4458828,4459713,4459975],"length":1,"stats":{"Line":2},"fn_name":null},{"line":18,"address":[4459949,4459062,4459834,4458948],"length":1,"stats":{"Line":0},"fn_name":null},{"line":21,"address":[4459009,4459896],"length":1,"stats":{"Line":2},"fn_name":null},{"line":29,"address":[4574997,4575023,4574720],"length":1,"stats":{"Line":1},"fn_name":"into_table_create_opts"},{"line":30,"address":[4574753],"length":1,"stats":{"Line":1},"fn_name":null},{"line":32,"address":[4575016,4574802],"length":1,"stats":{"Line":1},"fn_name":null},{"line":37,"address":[7019136,7019526,7019555],"length":1,"stats":{"Line":0},"fn_name":"into_table_create_opts"},{"line":38,"address":[7019161],"length":1,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[7019276,7019545],"length":1,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[4575040],"length":1,"stats":{"Line":1},"fn_name":"into_table_create_opts"},{"line":46,"address":[4575065],"length":1,"stats":{"Line":1},"fn_name":null},{"line":48,"address":[4575082],"length":1,"stats":{"Line":1},"fn_name":null},{"line":53,"address":[7019917,7019600],"length":1,"stats":{"Line":0},"fn_name":"into_table_create_opts"},{"line":54,"address":[7019625],"length":1,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[7019681],"length":1,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[6644101,6644149,6643696,6643735],"length":1,"stats":{"Line":6},"fn_name":"test_create_index"},{"line":80,"address":[2568404,2568134],"length":1,"stats":{"Line":2},"fn_name":null},{"line":81,"address":[6767585],"length":1,"stats":{"Line":4},"fn_name":null},{"line":82,"address":[2568913,2569203],"length":1,"stats":{"Line":2},"fn_name":null},{"line":84,"address":[2569530,2569250,2569337,2568192,2569654,2569467],"length":1,"stats":{"Line":8},"fn_name":null},{"line":88,"address":[2569936,2570237,2569904,2570634,2569913,2570005,2570081],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":89,"address":[2570362,2570059],"length":1,"stats":{"Line":2},"fn_name":null},{"line":90,"address":[2570441,2570928,2570377,2570111,2570194,2570645],"length":1,"stats":{"Line":4},"fn_name":null},{"line":91,"address":[2570904,2571209],"length":1,"stats":{"Line":2},"fn_name":null},{"line":92,"address":[2571428,2571342],"length":1,"stats":{"Line":2},"fn_name":null},{"line":93,"address":[2571295],"length":1,"stats":{"Line":1},"fn_name":null},{"line":94,"address":[2571363],"length":1,"stats":{"Line":1},"fn_name":null},{"line":96,"address":[2571539,2571892,2570129,2571762,2571443,2571690],"length":1,"stats":{"Line":8},"fn_name":null},{"line":124,"address":[2564866,2567809,2565362,2564699,2567958,2565066,2565942,2564656,2565841],"length":1,"stats":{"Line":5},"fn_name":"{async_fn#0}"},{"line":125,"address":[2564893,2565158,2564834,2565373,2565026],"length":1,"stats":{"Line":4},"fn_name":null},{"line":127,"address":[2566837,2565864,2564981,2566000,2566656,2564908],"length":1,"stats":{"Line":5},"fn_name":null},{"line":129,"address":[2567064,2567024,2566816],"length":1,"stats":{"Line":2},"fn_name":null},{"line":131,"address":[2567128,2564923,2567035],"length":1,"stats":{"Line":3},"fn_name":null},{"line":132,"address":[2567946],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":31,"coverable":38},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","index_drop.rs"],"content":"use crate::Command;\nuse ql2::term::TermType;\n\npub(crate) fn new(index_name: impl Into\u003cString\u003e) -\u003e Command {\n    Command::new(TermType::IndexDrop).with_arg(Command::from_json(index_name.into()))\n}\n\n#[cfg(test)]\nmod tests {\n    use uuid::Uuid;\n\n    use crate::prelude::*;\n    use crate::types::IndexResponse;\n    use crate::{r, Result};\n\n    #[tokio::test]\n    async fn test_drop_db() -\u003e Result\u003c()\u003e {\n        let table_name = Uuid::new_v4().to_string();\n        let index_name = \"author\";\n        let conn = r.connection().connect().await?;\n        let table = r.table(table_name.as_str());\n\n        r.table_create(table_name.as_str()).run(\u0026conn).await?;\n        table.clone().index_create(index_name).run(\u0026conn).await?;\n\n        let index_dropped: IndexResponse = table\n            .index_drop(index_name)\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(index_dropped.dropped \u003e Some(0));\n\n        r.table_drop(table_name.as_str()).run(\u0026conn).await?;\n        Ok(())\n    }\n}\n","traces":[{"line":4,"address":[2231760,2231504,2231729],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":5,"address":[2231537],"length":1,"stats":{"Line":1},"fn_name":null},{"line":7,"address":[2231564,2231639],"length":1,"stats":{"Line":2},"fn_name":null},{"line":19,"address":[4111017,4110457,4110448,4110480,4111450,4110549,4110643],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":20,"address":[4110614,4111145],"length":1,"stats":{"Line":2},"fn_name":null},{"line":21,"address":[4111160],"length":1,"stats":{"Line":1},"fn_name":null},{"line":22,"address":[4110673,4111187,4111752,4110974,4111254,4111461],"length":1,"stats":{"Line":4},"fn_name":null},{"line":23,"address":[4112004,4111726],"length":1,"stats":{"Line":2},"fn_name":null},{"line":25,"address":[6886708,6886765],"length":1,"stats":{"Line":4},"fn_name":null},{"line":26,"address":[4110872,4112918,4110715,4112841],"length":1,"stats":{"Line":4},"fn_name":null},{"line":28,"address":[4113656,4113985,4113785,4114405,4113908,4114462,4114186,4114762,4114485,4113723],"length":1,"stats":{"Line":7},"fn_name":null},{"line":29,"address":[4113707],"length":1,"stats":{"Line":1},"fn_name":null},{"line":30,"address":[4113808,4114113,4110736,4113941,4110821,4113765],"length":1,"stats":{"Line":6},"fn_name":null},{"line":31,"address":[4114309],"length":1,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[4114853,4114645,4114884],"length":1,"stats":{"Line":2},"fn_name":null},{"line":37,"address":[4110754,4114867,4114961],"length":1,"stats":{"Line":3},"fn_name":null},{"line":38,"address":[4115777],"length":1,"stats":{"Line":5},"fn_name":null}],"covered":16,"coverable":17},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","index_list.rs"],"content":"use ql2::term::TermType;\n\nuse crate::Command;\n\npub(crate) fn new() -\u003e Command {\n    Command::new(TermType::IndexList)\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::*;\n    use crate::spec::{set_up, tear_down};\n    use crate::Result;\n\n    #[tokio::test]\n    async fn test_list_index() -\u003e Result\u003c()\u003e {\n        let (conn, table, table_name) = set_up(false).await?;\n        table.clone().index_create(\"author\").run(\u0026conn).await?;\n        let index_list: Vec\u003cString\u003e = table\n            .clone()\n            .index_list()\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(index_list.len() \u003e 0);\n\n        tear_down(conn, \u0026table_name).await\n    }\n}\n","traces":[{"line":5,"address":[2719472],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":6,"address":[2719484],"length":1,"stats":{"Line":1},"fn_name":null},{"line":16,"address":[2256933,2256885,2256519,2256480],"length":1,"stats":{"Line":6},"fn_name":"test_list_index"},{"line":17,"address":[6999016,6999245,6999597,6998958,7000003,6999416],"length":1,"stats":{"Line":4},"fn_name":null},{"line":18,"address":[6755988,6756042],"length":1,"stats":{"Line":4},"fn_name":null},{"line":19,"address":[7001251,7001009,7001535,7001097,7001811,7002078,7001334,7001834,7001754],"length":1,"stats":{"Line":6},"fn_name":null},{"line":22,"address":[6755865],"length":1,"stats":{"Line":5},"fn_name":null},{"line":23,"address":[7001658],"length":1,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[7001963,7002378,7002314],"length":1,"stats":{"Line":2},"fn_name":null},{"line":29,"address":[2256616,2256556,2256896,2256511],"length":1,"stats":{"Line":7},"fn_name":null}],"covered":9,"coverable":10},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","index_rename.rs"],"content":"use ql2::term::TermType;\nuse reql_macros::CommandOptions;\nuse serde::Serialize;\n\nuse crate::arguments::Args;\nuse crate::Command;\n\npub(crate) fn new(args: impl IndexRenameArg) -\u003e Command {\n    let (old_index_arg, new_index_arg, opts) = args.into_index_rename_opts();\n\n    Command::new(TermType::IndexRename)\n        .with_arg(old_index_arg)\n        .with_arg(new_index_arg)\n        .with_opts(opts)\n}\n\npub trait IndexRenameArg {\n    fn into_index_rename_opts(self) -\u003e (Command, Command, IndexRenameOption);\n}\n\nimpl\u003cO, N\u003e IndexRenameArg for Args\u003c(O, N)\u003e\nwhere\n    O: Into\u003cString\u003e,\n    N: Into\u003cString\u003e,\n{\n    fn into_index_rename_opts(self) -\u003e (Command, Command, IndexRenameOption) {\n        (\n            Command::from_json(self.0 .0.into()),\n            Command::from_json(self.0 .1.into()),\n            Default::default(),\n        )\n    }\n}\n\nimpl\u003cO, N\u003e IndexRenameArg for Args\u003c(O, N, IndexRenameOption)\u003e\nwhere\n    O: Into\u003cString\u003e,\n    N: Into\u003cString\u003e,\n{\n    fn into_index_rename_opts(self) -\u003e (Command, Command, IndexRenameOption) {\n        (\n            Command::from_json(self.0 .0.into()),\n            Command::from_json(self.0 .1.into()),\n            self.0 .2,\n        )\n    }\n}\n\n#[derive(Debug, Default, Clone, Copy, PartialEq, Serialize, CommandOptions)]\npub struct IndexRenameOption {\n    pub overwrite: Option\u003cbool\u003e,\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::*;\n    use crate::spec::{set_up, tear_down};\n    use crate::types::IndexResponse;\n    use crate::{args, Result};\n\n    use super::IndexRenameOption;\n\n    #[tokio::test]\n    async fn test_rename_index() -\u003e Result\u003c()\u003e {\n        let (conn, table, table_name) = set_up(false).await?;\n        table.clone().index_create(\"author\").run(\u0026conn).await?;\n        let index_renamed: IndexResponse = table\n            .clone()\n            .index_rename(args!(\"author\", \"author_name\"))\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(index_renamed.renamed \u003e Some(0));\n\n        tear_down(conn, \u0026table_name).await\n    }\n\n    #[tokio::test]\n    async fn test_rename_index_with_overwrite() -\u003e Result\u003c()\u003e {\n        let (conn, table, table_name) = set_up(false).await?;\n        table.clone().index_create(\"author\").run(\u0026conn).await?;\n        table.clone().index_create(\"author_name\").run(\u0026conn).await?;\n\n        let index_renamed: IndexResponse = table\n            .clone()\n            .index_rename(args!(\n                \"author\",\n                \"author_name\",\n                IndexRenameOption::default().overwrite(true)\n            ))\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(index_renamed.renamed \u003e Some(0));\n\n        tear_down(conn, \u0026table_name).await\n    }\n}\n","traces":[{"line":9,"address":[1636016,1636802,1637050,1638091,1637843,1637088],"length":1,"stats":{"Line":2},"fn_name":"new\u003c(\u0026str, \u0026str)\u003e"},{"line":10,"address":[1636033,1637105],"length":1,"stats":{"Line":2},"fn_name":null},{"line":11,"address":[1637311,1637395,1636268,1636352],"length":1,"stats":{"Line":4},"fn_name":null},{"line":12,"address":[1636461,1637504,1637403,1636360],"length":1,"stats":{"Line":4},"fn_name":null},{"line":14,"address":[1637891,1636659,1637702,1637512,1637947,1636540,1636850,1637583,1636906,1636469],"length":1,"stats":{"Line":10},"fn_name":null},{"line":15,"address":[1637741,1637833,1636792,1637591,1636698,1636548],"length":1,"stats":{"Line":4},"fn_name":null},{"line":16,"address":[1637973,1636714,1636813,1636932,1637854,1636898,1637757,1637939],"length":1,"stats":{"Line":4},"fn_name":null},{"line":25,"address":[2673667,2673248,2673696],"length":1,"stats":{"Line":1},"fn_name":"into_index_rename_opts"},{"line":26,"address":[2673273],"length":1,"stats":{"Line":1},"fn_name":null},{"line":27,"address":[2673311],"length":1,"stats":{"Line":1},"fn_name":null},{"line":30,"address":[2673375],"length":1,"stats":{"Line":1},"fn_name":null},{"line":31,"address":[2673491],"length":1,"stats":{"Line":1},"fn_name":null},{"line":32,"address":[2673530],"length":1,"stats":{"Line":1},"fn_name":null},{"line":38,"address":[2674061,2673728],"length":1,"stats":{"Line":1},"fn_name":"into_index_rename_opts"},{"line":39,"address":[2673753],"length":1,"stats":{"Line":1},"fn_name":null},{"line":40,"address":[2673775],"length":1,"stats":{"Line":1},"fn_name":null},{"line":42,"address":[2673835],"length":1,"stats":{"Line":1},"fn_name":null},{"line":62,"address":[2580048,2580453,2580087,2580501],"length":1,"stats":{"Line":6},"fn_name":"test_rename_index"},{"line":63,"address":[4168813,4168632,4168232,4169219,4168461,4168174],"length":1,"stats":{"Line":4},"fn_name":null},{"line":64,"address":[4168253,4169455,4169209,4168410],"length":1,"stats":{"Line":4},"fn_name":null},{"line":65,"address":[4171089,4171032,4170375,4170813,4171389,4170225,4170529,4170612,4171112],"length":1,"stats":{"Line":6},"fn_name":null},{"line":67,"address":[4170297],"length":1,"stats":{"Line":1},"fn_name":null},{"line":68,"address":[6768005],"length":1,"stats":{"Line":5},"fn_name":null},{"line":69,"address":[4170936],"length":1,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[4171598,4171272,4171655],"length":1,"stats":{"Line":2},"fn_name":null},{"line":75,"address":[6767817],"length":1,"stats":{"Line":7},"fn_name":null},{"line":79,"address":[2580544,2580997,2580583,2580949],"length":1,"stats":{"Line":6},"fn_name":"test_rename_index_with_overwrite"},{"line":80,"address":[4173064,4172592,4172526,4173245,4172893,4173651],"length":1,"stats":{"Line":4},"fn_name":null},{"line":81,"address":[6793656,6793713],"length":1,"stats":{"Line":4},"fn_name":null},{"line":82,"address":[4174729,4172791,4174657,4172634],"length":1,"stats":{"Line":4},"fn_name":null},{"line":84,"address":[4175979,4176180,4175467,4176456,4175902,4176756,4176399,4175737,4175666,4176479],"length":1,"stats":{"Line":7},"fn_name":null},{"line":86,"address":[4175605],"length":1,"stats":{"Line":1},"fn_name":null},{"line":89,"address":[4175529,4175582],"length":1,"stats":{"Line":2},"fn_name":null},{"line":91,"address":[4172655,4175935,4172740,4175805,4176107],"length":1,"stats":{"Line":5},"fn_name":null},{"line":92,"address":[4176303],"length":1,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[4176639,4177022,4176965],"length":1,"stats":{"Line":2},"fn_name":null},{"line":98,"address":[2580680,2580960,2580575,2580620],"length":1,"stats":{"Line":7},"fn_name":null}],"covered":35,"coverable":37},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","index_status.rs"],"content":"use crate::Command;\nuse ql2::term::TermType;\n\nuse super::CmdOpts;\n\npub(crate) fn new(args: impl IndexStatusArg) -\u003e Command {\n    let mut command = Command::new(TermType::IndexStatus);\n    let args = args.into_index_status_opts();\n\n    if let Some(args) = args {\n        command = args.add_to_cmd(command)\n    }\n\n    command\n}\n\npub trait IndexStatusArg {\n    fn into_index_status_opts(self) -\u003e Option\u003cCmdOpts\u003e;\n}\n\nimpl IndexStatusArg for () {\n    fn into_index_status_opts(self) -\u003e Option\u003cCmdOpts\u003e {\n        None\n    }\n}\n\nimpl IndexStatusArg for \u0026str {\n    fn into_index_status_opts(self) -\u003e Option\u003cCmdOpts\u003e {\n        let arg = Command::from_json(self);\n\n        Some(CmdOpts::Single(arg))\n    }\n}\n\nimpl\u003cconst N: usize\u003e IndexStatusArg for [\u0026str; N] {\n    fn into_index_status_opts(self) -\u003e Option\u003cCmdOpts\u003e {\n        let args = self.into_iter().map(Command::from_json).collect();\n\n        Some(CmdOpts::Many(args))\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::spec::{set_up, tear_down};\n    use crate::types::IndexStatusResponse;\n    use crate::Result;\n    use crate::{prelude::*, Command, Session};\n\n    #[tokio::test]\n    async fn test_get_index_status() -\u003e Result\u003c()\u003e {\n        let (conn, table, table_name) = set_up(false).await?;\n        generate_index(\u0026conn, \u0026table).await?;\n\n        let index_status: Vec\u003cIndexStatusResponse\u003e = table\n            .clone()\n            .index_status(())\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(index_status.len() == 3);\n\n        tear_down(conn, \u0026table_name).await\n    }\n\n    #[tokio::test]\n    async fn test_get_index_status_with_param() -\u003e Result\u003c()\u003e {\n        let (conn, table, table_name) = set_up(false).await?;\n        generate_index(\u0026conn, \u0026table).await?;\n\n        let index_status: Vec\u003cIndexStatusResponse\u003e = table\n            .clone()\n            .index_status(\"author\")\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(index_status.len() == 1);\n        assert!(index_status.first().unwrap().index == \"author\");\n\n        tear_down(conn, \u0026table_name).await\n    }\n\n    #[tokio::test]\n    async fn test_get_index_status_with_params() -\u003e Result\u003c()\u003e {\n        let (conn, table, table_name) = set_up(false).await?;\n        generate_index(\u0026conn, \u0026table).await?;\n\n        let index_status: Vec\u003cIndexStatusResponse\u003e = table\n            .clone()\n            .index_status([\"age\", \"name\"])\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(index_status.len() == 2);\n        assert!(index_status.first().unwrap().index == \"age\");\n        assert!(index_status.last().unwrap().index == \"name\");\n\n        tear_down(conn, \u0026table_name).await\n    }\n\n    async fn generate_index(conn: \u0026Session, table: \u0026Command) -\u003e Result\u003c()\u003e {\n        table.clone().index_create(\"author\").run(conn).await?;\n        table.clone().index_create(\"name\").run(conn).await?;\n        table.clone().index_create(\"age\").run(conn).await?;\n\n        Ok(())\n    }\n}\n","traces":[{"line":6,"address":[7010784,7010176,7011472,7010816,7011427,7012042],"length":1,"stats":{"Line":3},"fn_name":"new\u003c\u0026str\u003e"},{"line":7,"address":[7010838,7010332,7011489,7010946,7010219,7011592],"length":1,"stats":{"Line":6},"fn_name":null},{"line":8,"address":[7010340,7011600,7010954,7010401,7011661,7011046],"length":1,"stats":{"Line":6},"fn_name":null},{"line":10,"address":[7011054,7011669,7011356,7010713,7010409,7011971],"length":1,"stats":{"Line":5},"fn_name":null},{"line":11,"address":[7011325,7011170,7010527,7010682,7011940,7011785],"length":1,"stats":{"Line":4},"fn_name":null},{"line":14,"address":[7010597,7011855,7011240],"length":1,"stats":{"Line":3},"fn_name":null},{"line":22,"address":[2578240],"length":1,"stats":{"Line":1},"fn_name":"into_index_status_opts"},{"line":23,"address":[2578244],"length":1,"stats":{"Line":1},"fn_name":null},{"line":28,"address":[2578256],"length":1,"stats":{"Line":1},"fn_name":"into_index_status_opts"},{"line":29,"address":[2578289],"length":1,"stats":{"Line":1},"fn_name":null},{"line":31,"address":[2578299],"length":1,"stats":{"Line":1},"fn_name":null},{"line":36,"address":[4439200],"length":1,"stats":{"Line":1},"fn_name":"into_index_status_opts"},{"line":37,"address":[4439216],"length":1,"stats":{"Line":1},"fn_name":null},{"line":39,"address":[4439292],"length":1,"stats":{"Line":1},"fn_name":null},{"line":51,"address":[2053749,2053383,2053797,2053344],"length":1,"stats":{"Line":6},"fn_name":"test_get_index_status"},{"line":52,"address":[2754595,2754008,2753608,2753837,2754189,2753550],"length":1,"stats":{"Line":4},"fn_name":null},{"line":53,"address":[2755283,2753629,2753786,2754585,2754871],"length":1,"stats":{"Line":4},"fn_name":null},{"line":55,"address":[2756224,2756167,2756247,2755948,2755664,2755510,2755747,2756487,2755261],"length":1,"stats":{"Line":6},"fn_name":null},{"line":58,"address":[2753650,2755564,2755703,2753735,2755875],"length":1,"stats":{"Line":5},"fn_name":null},{"line":59,"address":[2756071],"length":1,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[2756783,2756376,2756719],"length":1,"stats":{"Line":2},"fn_name":null},{"line":65,"address":[2053760,2053420,2053375,2053480],"length":1,"stats":{"Line":7},"fn_name":null},{"line":69,"address":[2053879,2054245,2053840,2054293],"length":1,"stats":{"Line":6},"fn_name":"test_get_index_status_with_param"},{"line":70,"address":[2758029,2758200,2758381,2758787,2757742,2757800],"length":1,"stats":{"Line":4},"fn_name":null},{"line":71,"address":[2757821,2758777,2757978,2759063,2759475],"length":1,"stats":{"Line":4},"fn_name":null},{"line":73,"address":[2759951,2760451,2760691,2759686,2760428,2760152,2759868,2760371,2759453],"length":1,"stats":{"Line":6},"fn_name":null},{"line":76,"address":[2757927,2760079,2759768,2759907,2757842],"length":1,"stats":{"Line":5},"fn_name":null},{"line":77,"address":[2760275],"length":1,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[2760968,2760580,2760923],"length":1,"stats":{"Line":2},"fn_name":null},{"line":82,"address":[2761010,2761134,2760944],"length":1,"stats":{"Line":2},"fn_name":null},{"line":84,"address":[2053871,2054256,2053976,2053916],"length":1,"stats":{"Line":7},"fn_name":null},{"line":88,"address":[2054789,2054336,2054741,2054375],"length":1,"stats":{"Line":6},"fn_name":"test_get_index_status_with_params"},{"line":89,"address":[2763147,2762560,2762094,2762389,2762741,2762160],"length":1,"stats":{"Line":4},"fn_name":null},{"line":90,"address":[2762338,2763835,2763137,2763423,2762181],"length":1,"stats":{"Line":4},"fn_name":null},{"line":92,"address":[2765026,2764472,2765049,2763813,2765289,2764969,2764549,2764228,2764750,2764299],"length":1,"stats":{"Line":7},"fn_name":null},{"line":94,"address":[2764275,2764306,2764072,2764324,2764194,2764019],"length":1,"stats":{"Line":2},"fn_name":null},{"line":95,"address":[2762202,2764677,2764372,2762287,2764505],"length":1,"stats":{"Line":5},"fn_name":null},{"line":96,"address":[2764873],"length":1,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[2765178,2765566,2765521],"length":1,"stats":{"Line":2},"fn_name":null},{"line":101,"address":[2765542,2765713,2765608],"length":1,"stats":{"Line":2},"fn_name":null},{"line":102,"address":[2765880,2765689,2765756],"length":1,"stats":{"Line":2},"fn_name":null},{"line":104,"address":[2054752,2054412,2054367,2054472],"length":1,"stats":{"Line":7},"fn_name":null},{"line":107,"address":[2053264,2053294],"length":1,"stats":{"Line":5},"fn_name":"generate_index"},{"line":108,"address":[2750845,2751345,2750974,2751099,2750796],"length":1,"stats":{"Line":4},"fn_name":null},{"line":109,"address":[2751849,2750860,2751916,2750931],"length":1,"stats":{"Line":4},"fn_name":null},{"line":110,"address":[2750875,2752668,2752622],"length":1,"stats":{"Line":3},"fn_name":null},{"line":112,"address":[2753369],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":44,"coverable":47},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","index_wait.rs"],"content":"use crate::Command;\nuse ql2::term::TermType;\n\nuse super::CmdOpts;\n\npub(crate) fn new(args: impl IndexWaitArg) -\u003e Command {\n    let mut command = Command::new(TermType::IndexWait);\n\n    if let Some(args) = args.into_index_wait_opts() {\n        command = args.add_to_cmd(command)\n    }\n\n    command\n}\n\npub trait IndexWaitArg {\n    fn into_index_wait_opts(self) -\u003e Option\u003cCmdOpts\u003e;\n}\n\nimpl IndexWaitArg for () {\n    fn into_index_wait_opts(self) -\u003e Option\u003cCmdOpts\u003e {\n        None\n    }\n}\n\nimpl IndexWaitArg for \u0026str {\n    fn into_index_wait_opts(self) -\u003e Option\u003cCmdOpts\u003e {\n        let arg = Command::from_json(self);\n\n        Some(CmdOpts::Single(arg))\n    }\n}\n\nimpl\u003cconst N: usize\u003e IndexWaitArg for [\u0026str; N] {\n    fn into_index_wait_opts(self) -\u003e Option\u003cCmdOpts\u003e {\n        let args = self.into_iter().map(Command::from_json).collect();\n\n        Some(CmdOpts::Many(args))\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::spec::{set_up, tear_down};\n    use crate::types::IndexStatusResponse;\n    use crate::Result;\n    use crate::{prelude::*, Command, Session};\n\n    #[tokio::test]\n    async fn test_get_index_waited() -\u003e Result\u003c()\u003e {\n        let (conn, table, table_name) = set_up(false).await?;\n        generate_data(\u0026conn, \u0026table).await?;\n\n        let indexes_waited: Vec\u003cIndexStatusResponse\u003e = table\n            .clone()\n            .index_wait(())\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(indexes_waited.len() == 3);\n        indexes_waited\n            .iter()\n            .for_each(|index_waited| assert!(index_waited.ready));\n\n        tear_down(conn, \u0026table_name).await\n    }\n\n    #[tokio::test]\n    async fn test_get_index_status_with_param() -\u003e Result\u003c()\u003e {\n        let (conn, table, table_name) = set_up(false).await?;\n        generate_data(\u0026conn, \u0026table).await?;\n\n        let index_waited = table\n            .clone()\n            .index_wait(\"author\")\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse::\u003cVec\u003cIndexStatusResponse\u003e\u003e()?;\n\n        let index_waited = index_waited.first().unwrap();\n\n        assert!(index_waited.index == \"author\");\n        assert!(index_waited.ready);\n\n        tear_down(conn, \u0026table_name).await\n    }\n\n    #[tokio::test]\n    async fn test_get_index_status_with_params() -\u003e Result\u003c()\u003e {\n        let (conn, table, table_name) = set_up(false).await?;\n        generate_data(\u0026conn, \u0026table).await?;\n\n        let indexes_waited: Vec\u003cIndexStatusResponse\u003e = table\n            .clone()\n            .index_wait([\"age\", \"name\"])\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(indexes_waited.len() == 2);\n        indexes_waited\n            .iter()\n            .for_each(|index_waited| assert!(index_waited.ready));\n\n        tear_down(conn, \u0026table_name).await\n    }\n\n    async fn generate_data(conn: \u0026Session, table: \u0026Command) -\u003e Result\u003c()\u003e {\n        table.clone().index_create(\"author\").run(conn).await?;\n        table.clone().index_create(\"name\").run(conn).await?;\n        table.clone().index_create(\"age\").run(conn).await?;\n        Ok(())\n    }\n}\n","traces":[{"line":6,"address":[2697936,2699066,2698496,2698465,2699120,2699683],"length":1,"stats":{"Line":3},"fn_name":"new\u003c()\u003e"},{"line":7,"address":[2698618,2699166,2698521,2699268,2698048,2697956],"length":1,"stats":{"Line":6},"fn_name":null},{"line":9,"address":[2698056,2699276,2698990,2698389,2699607,2699334,2698626,2698715,2698114],"length":1,"stats":{"Line":8},"fn_name":null},{"line":10,"address":[2699452,2698964,2698363,2698234,2699581,2698835],"length":1,"stats":{"Line":4},"fn_name":null},{"line":13,"address":[2699015,2698414,2699632],"length":1,"stats":{"Line":3},"fn_name":null},{"line":21,"address":[2578400],"length":1,"stats":{"Line":1},"fn_name":"into_index_wait_opts"},{"line":22,"address":[2578404],"length":1,"stats":{"Line":1},"fn_name":null},{"line":27,"address":[2578416],"length":1,"stats":{"Line":1},"fn_name":"into_index_wait_opts"},{"line":28,"address":[2578449],"length":1,"stats":{"Line":1},"fn_name":null},{"line":30,"address":[2578459],"length":1,"stats":{"Line":1},"fn_name":null},{"line":35,"address":[4439424],"length":1,"stats":{"Line":1},"fn_name":"into_index_wait_opts"},{"line":36,"address":[4439440],"length":1,"stats":{"Line":1},"fn_name":null},{"line":38,"address":[4439516],"length":1,"stats":{"Line":1},"fn_name":null},{"line":50,"address":[4326469,4326400,4326856,4327154,4326377,4326368,4326554],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":51,"address":[4327165,4326584,4327571,4326526,4326813,4326984],"length":1,"stats":{"Line":4},"fn_name":null},{"line":52,"address":[4327561,4328259,4327847,4326762,4326605],"length":1,"stats":{"Line":4},"fn_name":null},{"line":54,"address":[4329463,4328640,4328486,4328924,4329223,4328237,4329200,4329143,4328723],"length":1,"stats":{"Line":6},"fn_name":null},{"line":57,"address":[4326711,4326626,4328679,4328540,4328851],"length":1,"stats":{"Line":5},"fn_name":null},{"line":58,"address":[4329047],"length":1,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[4329352,4329740,4329695],"length":1,"stats":{"Line":2},"fn_name":null},{"line":63,"address":[4329716,4329782],"length":1,"stats":{"Line":2},"fn_name":null},{"line":65,"address":[4330624,4330638],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":67,"address":[4330136,4330050,4326644,4330272,4329824,4329991],"length":1,"stats":{"Line":7},"fn_name":null},{"line":71,"address":[4330789,4331176,4330720,4330874,4330688,4330697,4331474],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":72,"address":[4331133,4331304,4331891,4331485,4330846,4330904],"length":1,"stats":{"Line":4},"fn_name":null},{"line":73,"address":[4330925,4331082,4332579,4331881,4332167],"length":1,"stats":{"Line":4},"fn_name":null},{"line":75,"address":[4333256,4333532,4332790,4332557,4333800,4333055,4332972,4333555,4333475],"length":1,"stats":{"Line":6},"fn_name":null},{"line":78,"address":[4331031,4332872,4333183,4333011,4330946],"length":1,"stats":{"Line":5},"fn_name":null},{"line":79,"address":[4333379],"length":1,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[4333684,4334037],"length":1,"stats":{"Line":2},"fn_name":null},{"line":85,"address":[4334086,4334134],"length":1,"stats":{"Line":1},"fn_name":null},{"line":86,"address":[4334123,4334217],"length":1,"stats":{"Line":1},"fn_name":null},{"line":88,"address":[4334174,4334430,4334247,4334516,4330964,4334371,4334652],"length":1,"stats":{"Line":7},"fn_name":null},{"line":92,"address":[4335802,4335008,4335109,4335040,4335017,4335202,4335504],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":93,"address":[4335632,4335232,4335813,4335461,4336219,4335166],"length":1,"stats":{"Line":4},"fn_name":null},{"line":94,"address":[4336209,4335410,4336495,4335253,4336907],"length":1,"stats":{"Line":4},"fn_name":null},{"line":96,"address":[4338098,4336885,4338361,4338041,4337371,4337544,4338121,4337822,4337621,4337300],"length":1,"stats":{"Line":7},"fn_name":null},{"line":98,"address":[4337347,4337378,4337396,4337266,4337091,4337144],"length":1,"stats":{"Line":2},"fn_name":null},{"line":99,"address":[4335274,4337577,4335359,4337749,4337444],"length":1,"stats":{"Line":5},"fn_name":null},{"line":100,"address":[4337945],"length":1,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[4338593,4338250,4338638],"length":1,"stats":{"Line":2},"fn_name":null},{"line":105,"address":[4338614,4338680],"length":1,"stats":{"Line":2},"fn_name":null},{"line":107,"address":[4339520,4339534],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":109,"address":[4338948,4338722,4335292,4338889,4339170,4339034],"length":1,"stats":{"Line":7},"fn_name":null},{"line":112,"address":[4323794,4324310,4326357,4323707,4324849,4323664,4323988],"length":1,"stats":{"Line":5},"fn_name":"{async_fn#0}"},{"line":113,"address":[4323821,4324321,4323772,4324075,4323950],"length":1,"stats":{"Line":4},"fn_name":null},{"line":114,"address":[4323907,4323836,4324825,4324892],"length":1,"stats":{"Line":4},"fn_name":null},{"line":115,"address":[4325644,4323851,4325598],"length":1,"stats":{"Line":3},"fn_name":null},{"line":116,"address":[4326345],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":46,"coverable":49},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","info.rs"],"content":"use ql2::term::TermType;\n\nuse crate::Command;\n\npub(crate) fn new() -\u003e Command {\n    Command::new(TermType::Info)\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::Converter;\n    use crate::spec::{set_up, tear_down};\n    use crate::types::{InfoResponse, TypeOf};\n    use crate::Result;\n\n    #[tokio::test]\n    async fn test_info_table() -\u003e Result\u003c()\u003e {\n        let (conn, table, table_name) = set_up(false).await?;\n        let data_obtained: InfoResponse = table.info().run(\u0026conn).await?.unwrap().parse()?;\n\n        assert!(data_obtained.typ == TypeOf::Table);\n\n        tear_down(conn, \u0026table_name).await\n    }\n}\n","traces":[{"line":5,"address":[2719520],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":6,"address":[2719532],"length":1,"stats":{"Line":1},"fn_name":null},{"line":17,"address":[2257381,2257015,2257429,2256976],"length":1,"stats":{"Line":6},"fn_name":"test_info_table"},{"line":18,"address":[2296454,2296022,2295459,2295521,2295844,2295676],"length":1,"stats":{"Line":4},"fn_name":null},{"line":19,"address":[2297420,2295542,2296406,2295627,2297579,2296711],"length":1,"stats":{"Line":5},"fn_name":null},{"line":21,"address":[2297926,2297872,2297551],"length":1,"stats":{"Line":2},"fn_name":null},{"line":23,"address":[2257112,2257007,2257392,2257052],"length":1,"stats":{"Line":7},"fn_name":null}],"covered":7,"coverable":7},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","inner_join.rs"],"content":"use ql2::term::TermType;\n\nuse crate::prelude::Func;\nuse crate::Command;\n\npub(crate) fn new(other_table: Command, func: Func) -\u003e Command {\n    let Func(func) = func;\n\n    Command::new(TermType::InnerJoin)\n        .with_arg(other_table)\n        .with_arg(func)\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::*;\n    use crate::spec::{Comment, Post};\n    use crate::types::JoinResponse;\n    use crate::Result;\n\n    #[tokio::test]\n    pub async fn test_inner_join_ops() -\u003e Result\u003c()\u003e {\n        let data = JoinResponse {\n            left: Some(Comment {\n                id: 4,\n                text: \"comment4\".to_string(),\n                post_id: 2,\n            }),\n            right: Some(Post {\n                id: 2,\n                title: \"title2\".to_string(),\n                content: Some(\"content2\".to_string()),\n                view: 2,\n            }),\n        };\n        let (conn, comment_table, post_table, comment_tablename, post_tablename) =\n            Comment::own_set_up().await?;\n\n        let response: Vec\u003cJoinResponse\u003cComment, Post\u003e\u003e = comment_table\n            .inner_join(\n                post_table,\n                func!(|comment, post| comment.g(\"post_id\").eq(post.g(\"id\"))),\n            )\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(response.len() \u003e 0);\n        assert_eq!(response.first(), Some(\u0026data));\n\n        Comment::own_tear_down(conn, comment_tablename, post_tablename).await\n    }\n}\n","traces":[{"line":6,"address":[1551088,1551424],"length":1,"stats":{"Line":0},"fn_name":"new"},{"line":7,"address":[1551123],"length":1,"stats":{"Line":0},"fn_name":null},{"line":9,"address":[1551309,1551174,1551372],"length":1,"stats":{"Line":0},"fn_name":null},{"line":10,"address":[1551253],"length":1,"stats":{"Line":0},"fn_name":null},{"line":11,"address":[1551316],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":5},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","insert.rs"],"content":"use ql2::term::TermType;\nuse reql_macros::CommandOptions;\nuse serde::Serialize;\n\nuse crate::arguments::{Args, Conflict, Durability, ReturnChanges};\nuse crate::Command;\n\npub(crate) fn new(args: impl InsertArg) -\u003e Command {\n    let (arg, opts) = args.into_insert_opts();\n\n    Command::new(TermType::Insert).with_arg(arg).with_opts(opts)\n}\n\npub trait InsertArg {\n    fn into_insert_opts(self) -\u003e (Command, InsertOption);\n}\n\nimpl\u003cT\u003e InsertArg for T\nwhere\n    T: Serialize,\n{\n    fn into_insert_opts(self) -\u003e (Command, InsertOption) {\n        (Command::from_json(self), Default::default())\n    }\n}\n\nimpl InsertArg for Command {\n    fn into_insert_opts(self) -\u003e (Command, InsertOption) {\n        (self, Default::default())\n    }\n}\n\nimpl\u003cT\u003e InsertArg for Args\u003c(T, InsertOption)\u003e\nwhere\n    T: Serialize,\n{\n    fn into_insert_opts(self) -\u003e (Command, InsertOption) {\n        (Command::from_json(self.0 .0), self.0 .1)\n    }\n}\n\nimpl InsertArg for Args\u003c(Command, InsertOption)\u003e {\n    fn into_insert_opts(self) -\u003e (Command, InsertOption) {\n        (self.0 .0, self.0 .1)\n    }\n}\n\n// TODO finish this struct\n#[derive(Debug, Clone, Copy, Serialize, Default, PartialEq, PartialOrd, CommandOptions)]\n#[non_exhaustive]\npub struct InsertOption {\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub durability: Option\u003cDurability\u003e,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub return_changes: Option\u003cReturnChanges\u003e,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub conflict: Option\u003cConflict\u003e,\n    // #[serde(skip_serializing_if = \"Option::is_none\")]\n    // pub conflict_func: Command,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub ignore_write_hook: Option\u003cbool\u003e,\n}\n\n#[cfg(test)]\nmod tests {\n    use uuid::Uuid;\n\n    use crate::arguments::ReturnChanges;\n    use crate::prelude::*;\n    use crate::spec::{set_up, tear_down, Post};\n    use crate::types::MutationResponse;\n    use crate::{args, r, Result};\n\n    use super::InsertOption;\n\n    #[tokio::test]\n    async fn test_insert_data() -\u003e Result\u003c()\u003e {\n        let data = Post::get_one_data();\n        let (conn, table, table_name) = set_up(false).await?;\n        let data_inserted: MutationResponse = table\n            .clone()\n            .insert(\u0026data)\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(data_inserted.inserted == 1);\n\n        tear_down(conn, \u0026table_name).await\n    }\n\n    #[tokio::test]\n    async fn test_insert_many_data() -\u003e Result\u003c()\u003e {\n        let data = Post::get_many_data();\n        let (conn, table, table_name) = set_up(false).await?;\n        let data_inserted: MutationResponse = table\n            .clone()\n            .insert(\u0026data)\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(data_inserted.inserted == data.len());\n\n        tear_down(conn, \u0026table_name).await\n    }\n\n    #[tokio::test]\n    async fn test_insert_data_by_copy() -\u003e Result\u003c()\u003e {\n        let data = Post::get_many_data();\n        let table_name2 = Uuid::new_v4().to_string();\n        let (conn, table, table_name) = set_up(false).await?;\n\n        r.table_create(table_name2.as_str()).run(\u0026conn).await?;\n        table.clone().insert(\u0026data).run(\u0026conn).await?;\n\n        let data_inserted: MutationResponse = r\n            .table(table_name2.as_str())\n            .insert(table.clone())\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(data_inserted.inserted == data.len());\n\n        r.table_drop(table_name2.as_str()).run(\u0026conn).await?;\n        tear_down(conn, \u0026table_name).await\n    }\n\n    #[tokio::test]\n    async fn test_insert_data_with_opts() -\u003e Result\u003c()\u003e {\n        let data = Post::get_one_data();\n        let (conn, table, table_name) = set_up(false).await?;\n        let insert_options = InsertOption::default().return_changes(ReturnChanges::Bool(true));\n        let data_inserted: MutationResponse = table\n            .clone()\n            .insert(args!(\u0026data, insert_options))\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!((\u0026data_inserted).inserted == 1);\n        let expected_data: Post = data_inserted\n            .changes\n            .unwrap()\n            .first()\n            .unwrap()\n            .clone()\n            .new_val\n            .unwrap()\n            .parse()?;\n        assert!(expected_data == data);\n\n        tear_down(conn, \u0026table_name).await\n    }\n}\n","traces":[{"line":10,"address":[4602880,4602427,4600696,4599733,4598472,4600736,4598512,4602032,4603253,4600165,4598418,4601563,4597509,4598960,4598871,4602373,4599824,4598925,4599392,4599787,4601077,4601995,4597941,4601600,4597995,4599355,4597168,4602912,4597563,4601941,4601168,4597600,4602826,4600219,4602464,4600642,4601131,4603307,4601509,4599301,4598032,4600256],"length":1,"stats":{"Line":14},"fn_name":"new\u003c\u0026reql_rust::cmd::geojson::tests::User\u003e"},{"line":11,"address":[4598049,4599417,4598985,4598529,4601193,4600273,4601625,4597193,4599849,4602057,4600761,4602481,4602937,4597625],"length":1,"stats":{"Line":14},"fn_name":null},{"line":13,"address":[4602777,4601460,4603045,4603246,4600158,4597934,4599684,4599093,4601733,4599525,4599957,4597733,4600116,4602165,4600593,4601301,4600434,4599726,4597502,4600869,4602324,4601028,4597892,4601502,4600635,4597460,4598864,4599294,4603204,4601892,4602366,4598411,4602618,4602819,4597301,4599252,4601070,4598210,4598663,4598369,4598822,4601934],"length":1,"stats":{"Line":28},"fn_name":null},{"line":14,"address":[4601878,4602310,4602763,4598808,4603190,4597878,4600579,4599238,4598355,4601446,4597446,4601014,4600102,4599670],"length":1,"stats":{"Line":14},"fn_name":null},{"line":25,"address":[1320739,1320544],"length":1,"stats":{"Line":11},"fn_name":"into_insert_opts\u003c\u0026reql_rust::cmd::polygon::tests::Rectangle\u003e"},{"line":27,"address":[1320569],"length":1,"stats":{"Line":11},"fn_name":null},{"line":28,"address":[1320618,1320672],"length":1,"stats":{"Line":22},"fn_name":null},{"line":37,"address":[1818864,1818720],"length":1,"stats":{"Line":2},"fn_name":"into_insert_opts\u003c\u0026reql_rust::spec::Post\u003e"},{"line":38,"address":[1818886,1818741],"length":1,"stats":{"Line":2},"fn_name":null},{"line":43,"address":[4040816,4041019],"length":1,"stats":{"Line":1},"fn_name":"into_insert_opts"},{"line":44,"address":[4040867],"length":1,"stats":{"Line":1},"fn_name":null},{"line":49,"address":[6662304],"length":1,"stats":{"Line":0},"fn_name":"into_insert_opts"},{"line":50,"address":[6662325],"length":1,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[2731979,2731400,2731225,2731630,2731317,2731248,2731216],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":84,"address":[2731382],"length":1,"stats":{"Line":1},"fn_name":null},{"line":85,"address":[2731587,2731752,2731430,2732397,2731812,2731990],"length":1,"stats":{"Line":4},"fn_name":null},{"line":86,"address":[2733628,2732621,2733339,2732779,2733282,2732387,2732862,2732656,2733386,2733063],"length":1,"stats":{"Line":7},"fn_name":null},{"line":89,"address":[2732990,2732636,2732679,2731536,2732818,2731451],"length":1,"stats":{"Line":6},"fn_name":null},{"line":90,"address":[2733186],"length":1,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[2733954,2733506],"length":1,"stats":{"Line":1},"fn_name":null},{"line":96,"address":[2734222,2731469,2734033,2733904,2734163,2734323,2734459],"length":1,"stats":{"Line":7},"fn_name":null},{"line":100,"address":[2734864,2735278,2735627,2734896,2734965,2735048,2734873],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":101,"address":[2735030],"length":1,"stats":{"Line":1},"fn_name":null},{"line":102,"address":[2735235,2735638,2735400,2736045,2735460,2735078],"length":1,"stats":{"Line":4},"fn_name":null},{"line":103,"address":[2736510,2736304,2736711,2736427,2737034,2737297,2736930,2736987,2736269,2736035],"length":1,"stats":{"Line":7},"fn_name":null},{"line":106,"address":[2735184,2736327,2735099,2736284,2736638,2736466],"length":1,"stats":{"Line":6},"fn_name":null},{"line":107,"address":[2736834],"length":1,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[2737692,2737628,2737168],"length":1,"stats":{"Line":2},"fn_name":null},{"line":113,"address":[2737848,2738008,2737648,2738144,2737724,2737907,2735117],"length":1,"stats":{"Line":7},"fn_name":null},{"line":117,"address":[2738592,2738569,2739638,2738661,2738752,2738560,2739198],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":118,"address":[2738726],"length":1,"stats":{"Line":1},"fn_name":null},{"line":119,"address":[2739374,2739310],"length":1,"stats":{"Line":2},"fn_name":null},{"line":120,"address":[2738782,2739649,2740052,2739403,2739471,2739155],"length":1,"stats":{"Line":4},"fn_name":null},{"line":122,"address":[2740022,2739104,2740284,2738803],"length":1,"stats":{"Line":4},"fn_name":null},{"line":123,"address":[2741030,2738824,2741126,2739053],"length":1,"stats":{"Line":4},"fn_name":null},{"line":125,"address":[2742808,2743115,2742248,2742083,2742008,2742331,2742751,2741932,2742532,2742831],"length":1,"stats":{"Line":7},"fn_name":null},{"line":126,"address":[2741947,2741846],"length":1,"stats":{"Line":2},"fn_name":null},{"line":127,"address":[2742098,2742055,2741955,2741873],"length":1,"stats":{"Line":2},"fn_name":null},{"line":128,"address":[2742063,2742459,2742287,2738845,2742151,2739002],"length":1,"stats":{"Line":6},"fn_name":null},{"line":129,"address":[2742655],"length":1,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[2743240,2742986,2743287],"length":1,"stats":{"Line":2},"fn_name":null},{"line":135,"address":[2738951,2743260,2738866,2743370],"length":1,"stats":{"Line":4},"fn_name":null},{"line":136,"address":[2744498,2744330,2744681,2744557,2744817,2738884],"length":1,"stats":{"Line":7},"fn_name":null},{"line":140,"address":[2745718,2745296,2745305,2745488,2746067,2745328,2745397],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":141,"address":[2745462],"length":1,"stats":{"Line":1},"fn_name":null},{"line":142,"address":[2746468,2746078,2745675,2745518,2745900,2745840],"length":1,"stats":{"Line":4},"fn_name":null},{"line":143,"address":[2746699,2746451],"length":1,"stats":{"Line":2},"fn_name":null},{"line":144,"address":[2747584,2746793,2747081,2746923,2747914,2747164,2747641,2747664,2746958,2747365],"length":1,"stats":{"Line":7},"fn_name":null},{"line":146,"address":[2746847],"length":1,"stats":{"Line":1},"fn_name":null},{"line":147,"address":[2745539,2746981,2746938,2747120,2747292,2745624],"length":1,"stats":{"Line":6},"fn_name":null},{"line":148,"address":[2747488],"length":1,"stats":{"Line":0},"fn_name":null},{"line":152,"address":[2748102,2747792],"length":1,"stats":{"Line":1},"fn_name":null},{"line":153,"address":[2748441,2748743,2748034,2748193,2748263],"length":1,"stats":{"Line":4},"fn_name":null},{"line":162,"address":[2749310,2749396],"length":1,"stats":{"Line":1},"fn_name":null},{"line":164,"address":[2749512,2749636,2749349,2749695,2749874,2750010,2745557],"length":1,"stats":{"Line":7},"fn_name":null}],"covered":49,"coverable":55},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","insert_at.rs"],"content":"use ql2::term::TermType;\nuse serde::Serialize;\n\nuse crate::Command;\n\npub(crate) fn new(offset: isize, value: impl Serialize) -\u003e Command {\n    let arg_offset = Command::from_json(offset);\n    let arg_value = Command::from_json(value);\n\n    Command::new(TermType::InsertAt)\n        .with_arg(arg_offset)\n        .with_arg(arg_value)\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::Converter;\n    use crate::{r, Result};\n\n    #[tokio::test]\n    async fn test_insert_at_ops() -\u003e Result\u003c()\u003e {\n        let conn = r.connection().connect().await?;\n        let response: [String; 4] = r\n            .expr([\"Moussa\", \"Ali\", \"Fati\"])\n            .insert_at(1, \"Alima\")\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(response == [\"Moussa\", \"Alima\", \"Ali\", \"Fati\"]);\n\n        Ok(())\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","intersects.rs"],"content":"use ql2::term::TermType;\n\nuse crate::prelude::Geometry;\nuse crate::Command;\n\nuse super::CmdOpts;\n\npub(crate) fn new(geometry: impl IntersectsArg) -\u003e Command {\n    let (arg1, arg) = geometry.into_intersects_opts();\n    let mut command = Command::new(TermType::Intersects);\n\n    if let Some(arg) = arg1 {\n        command = arg.add_to_cmd(command);\n    }\n\n    command.with_arg(arg)\n}\n\npub trait IntersectsArg {\n    fn into_intersects_opts(self) -\u003e (Option\u003cCmdOpts\u003e, Command);\n}\n\nimpl IntersectsArg for Command {\n    fn into_intersects_opts(self) -\u003e (Option\u003cCmdOpts\u003e, Command) {\n        (None, self)\n    }\n}\n\nimpl\u003cT\u003e IntersectsArg for T\nwhere\n    T: Geometry,\n{\n    fn into_intersects_opts(self) -\u003e (Option\u003cCmdOpts\u003e, Command) {\n        (None, self.into())\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::Converter;\n    use crate::{args, r, Result};\n\n    #[tokio::test]\n    async fn test_intersects_geo() -\u003e Result\u003c()\u003e {\n        let conn = r.connection().connect().await?;\n        let point1 = r.point(-117.220406, 32.719464);\n        let point2 = r.point(-117.206201, 32.725186);\n\n        let response: bool = r\n            .circle(args!(point1, 2000.))\n            .intersects(point2)\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(response);\n\n        Ok(())\n    }\n}\n","traces":[{"line":8,"address":[4207808,4208445,4208466],"length":1,"stats":{"Line":1},"fn_name":"new\u003creql_rust::cmd::point::Point\u003e"},{"line":9,"address":[4207825],"length":1,"stats":{"Line":1},"fn_name":null},{"line":10,"address":[4207973],"length":1,"stats":{"Line":1},"fn_name":null},{"line":12,"address":[4208047,4208353],"length":1,"stats":{"Line":1},"fn_name":null},{"line":13,"address":[4208327,4208159],"length":1,"stats":{"Line":0},"fn_name":null},{"line":16,"address":[4208262],"length":1,"stats":{"Line":1},"fn_name":null},{"line":24,"address":[2174656],"length":1,"stats":{"Line":0},"fn_name":"into_intersects_opts"},{"line":25,"address":[4041072],"length":1,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":44,"address":[4794311,4794272,4794725,4794677],"length":1,"stats":{"Line":6},"fn_name":"test_intersects_geo"},{"line":45,"address":[6679868,6680218,6679763,6679797,6680029,6680495],"length":1,"stats":{"Line":4},"fn_name":null},{"line":46,"address":[6680485],"length":1,"stats":{"Line":1},"fn_name":null},{"line":47,"address":[6680756],"length":1,"stats":{"Line":1},"fn_name":null},{"line":49,"address":[6681695,6680893,6681197,6681126,6681658,6681885,6680983,6681015,6681382,6681601],"length":1,"stats":{"Line":7},"fn_name":null},{"line":50,"address":[6680763],"length":1,"stats":{"Line":1},"fn_name":null},{"line":51,"address":[6680927],"length":1,"stats":{"Line":1},"fn_name":null},{"line":52,"address":[6681156,6680995,6681325,6681038,6679812],"length":1,"stats":{"Line":5},"fn_name":null},{"line":53,"address":[6681505],"length":1,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[6681774,6681978],"length":1,"stats":{"Line":1},"fn_name":null},{"line":59,"address":[4794408,4794348,4794688,4794303],"length":1,"stats":{"Line":5},"fn_name":null}],"covered":17,"coverable":21},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","is_empty.rs"],"content":"use ql2::term::TermType;\n\nuse crate::Command;\n\npub(crate) fn new() -\u003e Command {\n    Command::new(TermType::IsEmpty)\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::Converter;\n    use crate::spec::{set_up, tear_down};\n    use crate::Result;\n\n    #[tokio::test]\n    async fn test_is_empty() -\u003e Result\u003c()\u003e {\n        let (conn, table, table_name) = set_up(true).await?;\n        let data_obtained: bool = table.is_empty().run(\u0026conn).await?.unwrap().parse()?;\n\n        assert!(!data_obtained);\n\n        tear_down(conn, \u0026table_name).await\n    }\n}\n","traces":[{"line":5,"address":[2719568],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":6,"address":[2719580],"length":1,"stats":{"Line":1},"fn_name":null},{"line":16,"address":[1677541,1677493,1677127,1677088],"length":1,"stats":{"Line":6},"fn_name":"test_is_empty"},{"line":17,"address":[6994077,6994245,6994855,6993859,6993924,6994423],"length":1,"stats":{"Line":4},"fn_name":null},{"line":18,"address":[6884912,6884986],"length":1,"stats":{"Line":5},"fn_name":null},{"line":20,"address":[6995900,6996216],"length":1,"stats":{"Line":1},"fn_name":null},{"line":22,"address":[1677119,1677504,1677224,1677164],"length":1,"stats":{"Line":7},"fn_name":null}],"covered":7,"coverable":7},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","iso8601.rs"],"content":"use ql2::term::TermType;\nuse time::{format_description, UtcOffset};\n\nuse crate::{arguments::Args, constants::TIMEZONE_FORMAT, Command};\n\npub(crate) fn new(iso_datetime: \u0026str) -\u003e Command {\n    Command::new(TermType::Iso8601).with_arg(Command::from_json(iso_datetime))\n}\n\npub trait Iso8601 {\n    fn into_iso8601_opts(self) -\u003e crate::Result\u003cString\u003e;\n}\n\nimpl\u003cT\u003e Iso8601 for T\nwhere\n    T: Into\u003cString\u003e,\n{\n    fn into_iso8601_opts(self) -\u003e crate::Result\u003cString\u003e {\n        Ok(self.into())\n    }\n}\n\nimpl\u003cT\u003e Iso8601 for Args\u003c(T, UtcOffset)\u003e\nwhere\n    T: Into\u003cString\u003e,\n{\n    fn into_iso8601_opts(self) -\u003e crate::Result\u003cString\u003e {\n        let timezone_format = format_description::parse(TIMEZONE_FORMAT)?;\n        let timezone = self.0 .1.format(\u0026timezone_format)?;\n\n        Ok(format!(\"{}{}\", self.0 .0.into(), timezone))\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use time::macros::offset;\n\n    use crate::prelude::Converter;\n    use crate::types::Time;\n    use crate::{args, r, Result};\n\n    #[tokio::test]\n    async fn test_iso8601_ops() -\u003e Result\u003c()\u003e {\n        let conn = r.connection().connect().await?;\n\n        let date_time = r.iso8601(\"1986-11-03T08:30:00-07:00\")?;\n        let time1 = date_time.clone().value();\n        let time2: Time = date_time.cmd().run(\u0026conn).await?.unwrap().parse()?;\n\n        assert!(time2 == time1);\n\n        Ok(())\n    }\n\n    #[tokio::test]\n    async fn test_iso8601_ops_with_default_timezone() -\u003e Result\u003c()\u003e {\n        let conn = r.connection().connect().await?;\n\n        let date_time = r.iso8601(args!(\"1986-11-03T08:30:00\", offset!(+01:00)))?;\n        let time1 = date_time.clone().value();\n        let time2: Time = date_time.cmd().run(\u0026conn).await?.unwrap().parse()?;\n\n        assert!(time2 == time1);\n\n        Ok(())\n    }\n}\n","traces":[{"line":6,"address":[2042912,2043152,2043121],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":7,"address":[2124603,2124784],"length":1,"stats":{"Line":1},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":44,"address":[4486377,4486970,4486368,4486457,4486400,4486534,4486671],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":45,"address":[4486558,4487254,4486512,4486981,4486792,4486631],"length":1,"stats":{"Line":4},"fn_name":null},{"line":47,"address":[4487224,4487640,4487511],"length":1,"stats":{"Line":2},"fn_name":null},{"line":48,"address":[4487630,4487865],"length":1,"stats":{"Line":2},"fn_name":null},{"line":49,"address":[4487979,4487892,4488873,4486573,4488691],"length":1,"stats":{"Line":4},"fn_name":null},{"line":51,"address":[4489127,4489094,4488844],"length":1,"stats":{"Line":2},"fn_name":null},{"line":53,"address":[4489100],"length":1,"stats":{"Line":5},"fn_name":null},{"line":57,"address":[2581989,2581536,2581575,2581941],"length":1,"stats":{"Line":6},"fn_name":"test_iso8601_ops_with_default_timezone"},{"line":58,"address":[4489672,4489392,4489861,4489511,4489438,4490250],"length":1,"stats":{"Line":4},"fn_name":null},{"line":60,"address":[4490636,4490107,4490507],"length":1,"stats":{"Line":2},"fn_name":null},{"line":61,"address":[4490626,4490861],"length":1,"stats":{"Line":2},"fn_name":null},{"line":62,"address":[4489453,4491687,4490975,4491869,4490888],"length":1,"stats":{"Line":4},"fn_name":null},{"line":64,"address":[4492090,4492123,4491840],"length":1,"stats":{"Line":2},"fn_name":null},{"line":66,"address":[2581952,2581672,2581612,2581567],"length":1,"stats":{"Line":5},"fn_name":null}],"covered":22,"coverable":22},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","js.rs"],"content":"use ql2::term::TermType;\nuse reql_macros::CommandOptions;\nuse serde::Serialize;\n\nuse crate::arguments::Args;\nuse crate::Command;\n\npub(crate) fn new(args: impl JsArg) -\u003e Command {\n    let (arg, opts) = args.into_js_opts();\n\n    Command::new(TermType::Javascript)\n        .with_arg(arg)\n        .with_opts(opts)\n}\n\npub trait JsArg {\n    fn into_js_opts(self) -\u003e (Command, JsOption);\n}\n\nimpl\u003cT\u003e JsArg for T\nwhere\n    T: Into\u003cString\u003e,\n{\n    fn into_js_opts(self) -\u003e (Command, JsOption) {\n        (Command::from_json(self.into()), Default::default())\n    }\n}\n\nimpl\u003cT\u003e JsArg for Args\u003c(T, JsOption)\u003e\nwhere\n    T: Into\u003cString\u003e,\n{\n    fn into_js_opts(self) -\u003e (Command, JsOption) {\n        (Command::from_json(self.0 .0.into()), self.0 .1)\n    }\n}\n\n#[derive(Debug, Clone, Serialize, Default, PartialEq, PartialOrd, CommandOptions)]\npub struct JsOption {\n    /// `timeout` is the number of seconds before r.js times out.\n    /// The default value is 5 seconds.\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub timeout: Option\u003cf64\u003e,\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::Converter;\n    use crate::{r, Result};\n\n    #[tokio::test]\n    async fn test_js_ops() -\u003e Result\u003c()\u003e {\n        let conn = r.connection().connect().await?;\n        let response: String = r.js(\"'str1' + 'str2'\").run(\u0026conn).await?.unwrap().parse()?;\n\n        assert!(response.eq(\"str1str2\"));\n\n        Ok(())\n    }\n}\n","traces":[{"line":8,"address":[2047376,2047731,2047704],"length":1,"stats":{"Line":1},"fn_name":"new\u003c\u0026str\u003e"},{"line":9,"address":[2047409],"length":1,"stats":{"Line":1},"fn_name":null},{"line":11,"address":[2047510,2047645],"length":1,"stats":{"Line":2},"fn_name":null},{"line":12,"address":[2047584],"length":1,"stats":{"Line":1},"fn_name":null},{"line":24,"address":[2047925,2047744],"length":1,"stats":{"Line":1},"fn_name":"into_js_opts\u003c\u0026str\u003e"},{"line":25,"address":[2047777],"length":1,"stats":{"Line":1},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[4794768,4795221,4795173,4794807],"length":1,"stats":{"Line":6},"fn_name":"test_js_ops"},{"line":53,"address":[6918219,6917525,6917491,6917946,6917757,6917596],"length":1,"stats":{"Line":4},"fn_name":null},{"line":54,"address":[6849401,6849469],"length":1,"stats":{"Line":4},"fn_name":null},{"line":56,"address":[6919553,6919516,6919260],"length":1,"stats":{"Line":2},"fn_name":null},{"line":58,"address":[4794799,4795184,4794904,4794844],"length":1,"stats":{"Line":5},"fn_name":null}],"covered":11,"coverable":13},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","json.rs"],"content":"use ql2::term::TermType;\n\nuse crate::Command;\n\npub(crate) fn new\u003cT\u003e(value: T) -\u003e Command\nwhere\n    T: Into\u003cString\u003e,\n{\n    Command::new(TermType::Json).with_arg(Command::from_json(value.into()))\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::Converter;\n    use crate::{r, Result};\n\n    #[tokio::test]\n    async fn test_json_table() -\u003e Result\u003c()\u003e {\n        let data = [1, 2, 3];\n        let conn = r.connection().connect().await?;\n        let data_obtained: [u8; 3] = r.json(\"[1, 2, 3]\").run(\u0026conn).await?.unwrap().parse()?;\n\n        assert!(data_obtained == data);\n\n        Ok(())\n    }\n}\n","traces":[{"line":5,"address":[1684243,1683936],"length":1,"stats":{"Line":1},"fn_name":"new\u003c\u0026str\u003e"},{"line":9,"address":[1684233,1684082,1683978],"length":1,"stats":{"Line":2},"fn_name":null},{"line":18,"address":[1804560,1804537,1804702,1804528,1804617,1804837,1805136],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":19,"address":[1804672],"length":1,"stats":{"Line":1},"fn_name":null},{"line":20,"address":[1804797,1805147,1804692,1805420,1804726,1804958],"length":1,"stats":{"Line":4},"fn_name":null},{"line":21,"address":[1804741,1806487,1805390,1806348,1805648],"length":1,"stats":{"Line":4},"fn_name":null},{"line":23,"address":[1806461,1806727,1806690],"length":1,"stats":{"Line":2},"fn_name":null},{"line":25,"address":[1806701],"length":1,"stats":{"Line":5},"fn_name":null}],"covered":8,"coverable":8},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","keys.rs"],"content":"use ql2::term::TermType;\n\nuse crate::Command;\n\npub(crate) fn new() -\u003e Command {\n    Command::new(TermType::Keys)\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::Converter;\n    use crate::spec::{set_up, tear_down};\n    use crate::Result;\n\n    #[tokio::test]\n    async fn test_keys_values() -\u003e Result\u003c()\u003e {\n        let (conn, table, table_name) = set_up(true).await?;\n        let data_obtained: Vec\u003cString\u003e = table.get(1).keys().run(\u0026conn).await?.unwrap().parse()?;\n\n        assert!(data_obtained == vec![\"content\", \"id\", \"title\", \"view\"]);\n\n        tear_down(conn, \u0026table_name).await\n    }\n}\n","traces":[{"line":5,"address":[2719616],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":6,"address":[2719628],"length":1,"stats":{"Line":1},"fn_name":null},{"line":16,"address":[2258373,2258421,2257968,2258007],"length":1,"stats":{"Line":6},"fn_name":"test_keys_values"},{"line":17,"address":[4745555,4746119,4745620,4746556,4745941,4745773],"length":1,"stats":{"Line":4},"fn_name":null},{"line":18,"address":[4747545,4746503,4745724,4746805,4747695,4745641],"length":1,"stats":{"Line":5},"fn_name":null},{"line":20,"address":[4748243,4747993,4747680],"length":1,"stats":{"Line":2},"fn_name":null},{"line":22,"address":[2258104,2258044,2257999,2258384],"length":1,"stats":{"Line":7},"fn_name":null}],"covered":7,"coverable":7},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","le.rs"],"content":"use ql2::term::TermType;\nuse serde::Serialize;\n\nuse crate::arguments::Args;\nuse crate::Command;\n\nuse super::CmdOpts;\n\npub(crate) fn new(args: impl LeArg) -\u003e Command {\n    args.into_le_opts().add_to_cmd(Command::new(TermType::Le))\n}\n\npub trait LeArg {\n    fn into_le_opts(self) -\u003e CmdOpts;\n}\n\nimpl\u003cT: Serialize\u003e LeArg for T {\n    fn into_le_opts(self) -\u003e CmdOpts {\n        CmdOpts::Single(Command::from_json(self))\n    }\n}\n\nimpl LeArg for Command {\n    fn into_le_opts(self) -\u003e CmdOpts {\n        CmdOpts::Single(self)\n    }\n}\n\nimpl\u003cS, T\u003e LeArg for Args\u003cT\u003e\nwhere\n    S: Serialize,\n    T: IntoIterator\u003cItem = S\u003e,\n{\n    fn into_le_opts(self) -\u003e CmdOpts {\n        let commands = self.0.into_iter().map(Command::from_json).collect();\n\n        CmdOpts::Many(commands)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::Converter;\n    use crate::spec::{set_up, tear_down};\n    use crate::{args, r, Result};\n\n    #[tokio::test]\n    async fn test_le_data() -\u003e Result\u003c()\u003e {\n        let (conn, table, table_name) = set_up(true).await?;\n        let data_obtained: bool = table\n            .get(1)\n            .g(\"view\")\n            .le(10)\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(data_obtained);\n\n        tear_down(conn, \u0026table_name).await\n    }\n\n    #[tokio::test]\n    async fn test_le_data_r() -\u003e Result\u003c()\u003e {\n        let conn = r.connection().connect().await?;\n        let data_obtained: bool = r.le(args!([5, 6, 7])).run(\u0026conn).await?.unwrap().parse()?;\n\n        assert!(data_obtained);\n\n        Ok(())\n    }\n}\n","traces":[{"line":9,"address":[2392184,2391952,2392377,2392208,2392157,2392404],"length":1,"stats":{"Line":2},"fn_name":"new\u003creql_rust::arguments::Args\u003calloc::vec::Vec\u003ci32, alloc::alloc::Global\u003e\u003e\u003e"},{"line":10,"address":[2392231,2392397,2391968,2392177],"length":1,"stats":{"Line":2},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":27,"address":[1820477],"length":1,"stats":{"Line":1},"fn_name":null},{"line":38,"address":[4416261,4415895,4415856,4416309],"length":1,"stats":{"Line":6},"fn_name":"test_le_data"},{"line":39,"address":[2341549,2342332,2341717,2341396,2341895,2341331],"length":1,"stats":{"Line":4},"fn_name":null},{"line":40,"address":[2343317,2342846,2343260,2343041,2342279,2343361,2343551,2342769,2342565],"length":1,"stats":{"Line":6},"fn_name":null},{"line":44,"address":[2342974,2342675,2342802,2341417,2341500],"length":1,"stats":{"Line":5},"fn_name":null},{"line":45,"address":[2343164],"length":1,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[2343440,2343754],"length":1,"stats":{"Line":1},"fn_name":null},{"line":51,"address":[6852001],"length":1,"stats":{"Line":7},"fn_name":null},{"line":55,"address":[2344637,2344512,2345071,2344489,2344569,2344772,2344480],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":56,"address":[2344893,2344627,2345082,2344732,2344661,2345350],"length":1,"stats":{"Line":4},"fn_name":null},{"line":57,"address":[2346568,2345666,2345809,2346378,2345880,2346341,2345698,2346284,2346065],"length":1,"stats":{"Line":6},"fn_name":null},{"line":58,"address":[2345578,2345335],"length":1,"stats":{"Line":2},"fn_name":null},{"line":59,"address":[2346008,2345721,2344676,2345678,2345839],"length":1,"stats":{"Line":5},"fn_name":null},{"line":60,"address":[2346188],"length":1,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[2346457,2346680],"length":1,"stats":{"Line":1},"fn_name":null},{"line":66,"address":[2346654],"length":1,"stats":{"Line":5},"fn_name":null}],"covered":20,"coverable":22},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","limit.rs"],"content":"use ql2::term::TermType;\n\nuse crate::Command;\n\npub(crate) fn new(step: usize) -\u003e Command {\n    let arg = Command::from_json(step);\n\n    Command::new(TermType::Limit).with_arg(arg)\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::cmd::order_by::OrderByOption;\n    use crate::prelude::Converter;\n    use crate::spec::{set_up, tear_down, Post};\n    use crate::Result;\n\n    #[tokio::test]\n    async fn test_limit_data() -\u003e Result\u003c()\u003e {\n        let data = Post::get_many_data();\n        let (conn, table, table_name) = set_up(true).await?;\n        let data_obtained: Vec\u003cPost\u003e = table\n            .order_by(OrderByOption::default().index(\"title\"))\n            .limit(1)\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(data_obtained.first() == data.first());\n\n        tear_down(conn, \u0026table_name).await\n    }\n}\n","traces":[{"line":5,"address":[2502640,2502851,2502882],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":6,"address":[2502665],"length":1,"stats":{"Line":1},"fn_name":null},{"line":8,"address":[2502692,2502763],"length":1,"stats":{"Line":2},"fn_name":null},{"line":19,"address":[4215879,4216245,4216293,4215840],"length":1,"stats":{"Line":6},"fn_name":"test_limit_data"},{"line":20,"address":[4893027],"length":1,"stats":{"Line":1},"fn_name":null},{"line":21,"address":[4894071,4893465,4893405,4893240,4893087,4893640],"length":1,"stats":{"Line":4},"fn_name":null},{"line":22,"address":[4894592,4894320,4894864,4895420,4895184,4895140,4895083,4894475,4894031,4894669,4894388],"length":1,"stats":{"Line":8},"fn_name":null},{"line":23,"address":[4894413,4894395,4894244,4894359,4894061],"length":1,"stats":{"Line":2},"fn_name":null},{"line":25,"address":[4894797,4894625,4893108,4894455,4894498,4893191],"length":1,"stats":{"Line":6},"fn_name":null},{"line":26,"address":[4894987],"length":1,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[4895852,4895304,4895681],"length":1,"stats":{"Line":2},"fn_name":null},{"line":32,"address":[4215916,4215871,4216256,4215976],"length":1,"stats":{"Line":7},"fn_name":null}],"covered":11,"coverable":12},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","line.rs"],"content":"use ql2::term::TermType;\nuse serde::{Deserialize, Serialize};\n\nuse crate::prelude::Geometry;\nuse crate::types::{GeoType, ReqlType};\nuse crate::Command;\n\nuse super::point::Point;\n\n#[derive(Debug, Serialize, Deserialize, Clone, PartialEq, PartialOrd, Geometry)]\npub struct Line {\n    #[serde(rename = \"$reql_type$\")]\n    pub reql_type: ReqlType,\n    pub coordinates: Vec\u003c[f64; 2]\u003e,\n    #[serde(rename = \"type\")]\n    pub typ: GeoType,\n}\n\nimpl Line {\n    pub fn new(points: \u0026[Point]) -\u003e Self {\n        assert!(points.len() \u003e= 2);\n\n        Self {\n            reql_type: ReqlType::Geometry,\n            typ: GeoType::LineString,\n            coordinates: points.iter().map(|point| point.coordinates).collect(),\n        }\n    }\n\n    /// Convert a Line object into a Polygon object.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// line.fill() → polygon\n    /// ```\n    ///\n    /// Where:\n    /// - polygon: [Polygon](crate::cmd::polygon::Polygon)\n    ///\n    /// # Description\n    ///\n    /// If the last point does not specify the same coordinates as the first point,\n    /// `polygon` will close the polygon by connecting them.\n    ///\n    /// Longitude (−180 to 180) and latitude (−90 to 90)\n    /// of vertices are plotted on a perfect sphere.\n    /// See [Geospatial support](https://rethinkdb.com/docs/geo-support/python/)\n    /// for more information on ReQL’s coordinate system.\n    ///\n    /// If the last point does not specify the same coordinates as the first point,\n    /// `polygon` will close the polygon by connecting them.\n    /// You cannot directly construct a polygon with holes in it using `polygon`,\n    /// but you can use [polygon_sub](crate::types::Polygon::polygon_sub)\n    /// to use a second polygon within the interior of the first to define a hole.\n    ///\n    /// ## Examples\n    ///\n    /// Create a line object and then convert it to a polygon.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{args, r, Result};\n    /// use serde_json::json;\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///\n    ///     let response = r.line(\u0026[\n    ///         r.point(-122.423246, 37.779388),\n    ///         r.point(-122.423246, 37.329898),\n    ///         r.point(-121.886420, 37.329898),\n    ///         r.point(-121.886420, 37.779388),\n    ///     ])\n    ///     .fill()\n    ///     .run(\u0026conn)\n    ///     .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [polygon](crate::r::polygon)\n    /// - [line](crate::r::line)\n    pub fn fill(self) -\u003e Command {\n        super::fill::new().with_parent(self.into())\n    }\n}\n\nimpl From\u003cLine\u003e for Command {\n    fn from(line: Line) -\u003e Self {\n        line.coordinates\n            .iter()\n            .fold(Command::new(TermType::Line), |command, coord| {\n                let point: Command = Point::new(coord[0], coord[1]).into();\n\n                command.with_arg(point)\n            })\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use serde::{Deserialize, Serialize};\n\n    use crate::prelude::Converter;\n    use crate::spec::{set_up, tear_down};\n    use crate::types::{Line, Point};\n    use crate::{r, Result};\n\n    #[derive(Debug, Serialize, Deserialize, PartialEq)]\n    struct Route {\n        id: u8,\n        route: Line,\n    }\n\n    #[tokio::test]\n    async fn test_line_data() -\u003e Result\u003c()\u003e {\n        let route = Route {\n            id: 1,\n            route: r.line(\u0026[\n                Point::new(-122.423246, 37.779388),\n                Point::new(-121.886420, 37.329898),\n            ]),\n        };\n        let (conn, table, table_name) = set_up(false).await?;\n        table.clone().insert(\u0026route).run(\u0026conn).await?;\n        let response: Route = table.get(1).run(\u0026conn).await?.unwrap().parse()?;\n\n        assert!(response == route);\n\n        tear_down(conn, \u0026table_name).await\n    }\n}\n","traces":[{"line":20,"address":[4744848],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":21,"address":[2108229,2108178],"length":1,"stats":{"Line":1},"fn_name":null},{"line":26,"address":[2573200,2573216],"length":1,"stats":{"Line":4},"fn_name":"{closure#0}"},{"line":88,"address":[2027001,2026720],"length":1,"stats":{"Line":1},"fn_name":"fill"},{"line":89,"address":[4745094,4745331,4745176],"length":1,"stats":{"Line":2},"fn_name":null},{"line":94,"address":[2174987,2174768],"length":1,"stats":{"Line":1},"fn_name":"from"},{"line":95,"address":[2174958,2174870,2174798],"length":1,"stats":{"Line":3},"fn_name":null},{"line":97,"address":[2174910],"length":1,"stats":{"Line":2},"fn_name":null},{"line":98,"address":[4190326,4190420],"length":1,"stats":{"Line":2},"fn_name":null},{"line":100,"address":[2573400],"length":1,"stats":{"Line":1},"fn_name":null},{"line":121,"address":[4420821,4420455,4420416,4420869],"length":1,"stats":{"Line":6},"fn_name":"test_line_data"},{"line":124,"address":[4682420],"length":1,"stats":{"Line":1},"fn_name":null},{"line":129,"address":[6869595],"length":1,"stats":{"Line":4},"fn_name":null},{"line":130,"address":[4683202,4682183,4683436,4682026],"length":1,"stats":{"Line":4},"fn_name":null},{"line":131,"address":[4685020,4682047,4682132,4685194,4684300,4684176],"length":1,"stats":{"Line":5},"fn_name":null},{"line":133,"address":[4685180,4685676,4685618],"length":1,"stats":{"Line":2},"fn_name":null},{"line":135,"address":[4420447,4420552,4420832,4420492],"length":1,"stats":{"Line":7},"fn_name":null}],"covered":17,"coverable":17},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","literal.rs"],"content":"use ql2::term::TermType;\nuse serde::Serialize;\n\nuse crate::Command;\n\npub(crate) fn new(selector: impl Serialize) -\u003e Command {\n    let arg = Command::from_json(selector);\n\n    Command::new(TermType::Literal).with_arg(arg)\n}\n\n// TODO write test\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","lt.rs"],"content":"use ql2::term::TermType;\nuse serde::Serialize;\n\nuse crate::arguments::Args;\nuse crate::Command;\n\nuse super::CmdOpts;\n\npub(crate) fn new(args: impl LtArg) -\u003e Command {\n    args.into_lt_opts().add_to_cmd(Command::new(TermType::Lt))\n}\n\npub trait LtArg {\n    fn into_lt_opts(self) -\u003e CmdOpts;\n}\n\nimpl\u003cT: Serialize\u003e LtArg for T {\n    fn into_lt_opts(self) -\u003e CmdOpts {\n        CmdOpts::Single(Command::from_json(self))\n    }\n}\n\nimpl LtArg for Command {\n    fn into_lt_opts(self) -\u003e CmdOpts {\n        CmdOpts::Single(self)\n    }\n}\n\nimpl\u003cS, T\u003e LtArg for Args\u003cT\u003e\nwhere\n    S: Serialize,\n    T: IntoIterator\u003cItem = S\u003e,\n{\n    fn into_lt_opts(self) -\u003e CmdOpts {\n        let commands = self.0.into_iter().map(Command::from_json).collect();\n\n        CmdOpts::Many(commands)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::Converter;\n    use crate::spec::{set_up, tear_down};\n    use crate::{args, r, Result};\n\n    #[tokio::test]\n    async fn test_lt_data() -\u003e Result\u003c()\u003e {\n        let (conn, table, table_name) = set_up(true).await?;\n        let data_obtained: bool = table\n            .get(1)\n            .g(\"view\")\n            .lt(15)\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(data_obtained);\n\n        tear_down(conn, \u0026table_name).await\n    }\n\n    #[tokio::test]\n    async fn test_lt_data_r() -\u003e Result\u003c()\u003e {\n        let conn = r.connection().connect().await?;\n        let data_obtained: bool = r.lt(args!([5, 6, 7])).run(\u0026conn).await?.unwrap().parse()?;\n\n        assert!(data_obtained);\n\n        Ok(())\n    }\n}\n","traces":[{"line":9,"address":[6679496,6679056,6679225,6679264,6679469,6679252],"length":1,"stats":{"Line":2},"fn_name":"new\u003ci32\u003e"},{"line":10,"address":[6679489,6679245,6679280,6679079],"length":1,"stats":{"Line":2},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":27,"address":[1820765],"length":1,"stats":{"Line":1},"fn_name":null},{"line":38,"address":[2582032,2582071,2582437,2582485],"length":1,"stats":{"Line":6},"fn_name":"test_lt_data"},{"line":39,"address":[3589501,3589847,3589283,3590284,3589348,3589669],"length":1,"stats":{"Line":4},"fn_name":null},{"line":40,"address":[3590721,3590993,3590517,3591313,3590231,3591212,3590798,3591503,3591269],"length":1,"stats":{"Line":6},"fn_name":null},{"line":44,"address":[3589452,3590627,3590926,3590754,3589369],"length":1,"stats":{"Line":5},"fn_name":null},{"line":45,"address":[3591116],"length":1,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[3591392,3591706],"length":1,"stats":{"Line":1},"fn_name":null},{"line":51,"address":[6852513],"length":1,"stats":{"Line":7},"fn_name":null},{"line":55,"address":[2582528,2582567,2582933,2582981],"length":1,"stats":{"Line":6},"fn_name":"test_lt_data_r"},{"line":56,"address":[3592845,3593034,3592613,3592684,3593302,3592579],"length":1,"stats":{"Line":4},"fn_name":null},{"line":57,"address":[3593618,3594293,3594330,3593650,3593761,3594017,3593832,3594520,3594236],"length":1,"stats":{"Line":6},"fn_name":null},{"line":58,"address":[3593287,3593530],"length":1,"stats":{"Line":2},"fn_name":null},{"line":59,"address":[3593630,3593960,3592628,3593673,3593791],"length":1,"stats":{"Line":5},"fn_name":null},{"line":60,"address":[3594140],"length":1,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[3594632,3594409],"length":1,"stats":{"Line":1},"fn_name":null},{"line":66,"address":[2582559,2582664,2582604,2582944],"length":1,"stats":{"Line":5},"fn_name":null}],"covered":20,"coverable":22},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","map.rs"],"content":"use ql2::term::TermType;\n\nuse crate::arguments::Args;\nuse crate::prelude::Func;\nuse crate::Command;\n\nuse super::CmdOpts;\n\npub(crate) fn new(args: impl MapArg) -\u003e Command {\n    let (args, func) = args.into_map_opts();\n    let mut command = Command::new(TermType::Map);\n\n    if let Some(args) = args {\n        command = args.add_to_cmd(command);\n    }\n\n    command.with_arg(func)\n}\n\npub trait MapArg {\n    fn into_map_opts(self) -\u003e (Option\u003cCmdOpts\u003e, Command);\n}\n\nimpl MapArg for Func {\n    fn into_map_opts(self) -\u003e (Option\u003cCmdOpts\u003e, Command) {\n        (None, self.0)\n    }\n}\n\nimpl MapArg for Args\u003c(Command, Func)\u003e {\n    fn into_map_opts(self) -\u003e (Option\u003cCmdOpts\u003e, Command) {\n        let Func(func) = self.0 .1;\n\n        (Some(CmdOpts::Single(self.0 .0)), func)\n    }\n}\n\nimpl\u003cT\u003e MapArg for Args\u003c(T, Func)\u003e\nwhere\n    T: AsRef\u003c[Command]\u003e,\n{\n    fn into_map_opts(self) -\u003e (Option\u003cCmdOpts\u003e, Command) {\n        let Func(func) = self.0 .1;\n\n        (Some(CmdOpts::Many(self.0 .0.as_ref().to_vec())), func)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::*;\n    use crate::{r, Result};\n\n    #[tokio::test]\n    async fn test_map_ops() -\u003e Result\u003c()\u003e {\n        let conn = r.connection().connect().await?;\n        let data_obtained: Vec\u003cu8\u003e = r\n            .expr([1, 2, 3, 4, 5])\n            .map(func!(|val| val.clone() * val))\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(data_obtained == vec![1, 4, 9, 16, 25]);\n\n        Ok(())\n    }\n}\n","traces":[{"line":9,"address":[4208544,4209164,4209185],"length":1,"stats":{"Line":1},"fn_name":"new\u003creql_rust::cmd::func::Func\u003e"},{"line":10,"address":[4208561],"length":1,"stats":{"Line":1},"fn_name":null},{"line":11,"address":[4208692],"length":1,"stats":{"Line":1},"fn_name":null},{"line":13,"address":[4209072,4208766],"length":1,"stats":{"Line":1},"fn_name":null},{"line":14,"address":[4208878,4209046],"length":1,"stats":{"Line":0},"fn_name":null},{"line":17,"address":[4208981],"length":1,"stats":{"Line":1},"fn_name":null},{"line":25,"address":[2747344],"length":1,"stats":{"Line":1},"fn_name":"into_map_opts"},{"line":26,"address":[7019968],"length":1,"stats":{"Line":1},"fn_name":null},{"line":31,"address":[2742256],"length":1,"stats":{"Line":0},"fn_name":"into_map_opts"},{"line":32,"address":[6662470],"length":1,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[6662497],"length":1,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[6662672],"length":1,"stats":{"Line":0},"fn_name":"into_map_opts"},{"line":40,"address":[6662694],"length":1,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[6662718],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":7,"coverable":14},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","match_.rs"],"content":"use ql2::term::TermType;\nuse regex::Regex;\n\nuse crate::Command;\n\npub(crate) fn new(regex: Regex) -\u003e Command {\n    let arg = Command::from_json(regex.as_str());\n\n    Command::new(TermType::Match).with_arg(arg)\n}\n\n#[cfg(test)]\nmod tests {\n    use regex::Regex;\n\n    use crate::prelude::*;\n    use crate::types::{MatchItem, MatchResponse};\n    use crate::{r, Result};\n\n    #[tokio::test]\n    async fn test_match_ops() -\u003e Result\u003c()\u003e {\n        let conn = r.connection().connect().await?;\n        let regexp = Regex::new(\".*@(.*)\")?;\n        let data = MatchResponse {\n            start: 0,\n            end: 15,\n            str: \"name@domain.com\".static_string(),\n            groups: vec![MatchItem {\n                start: 5,\n                end: 15,\n                str: \"domain.com\".static_string(),\n            }],\n        };\n        let response: MatchResponse = r\n            .expr(\"name@domain.com\")\n            .match_(regexp)\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(response == data);\n\n        Ok(())\n    }\n\n    #[tokio::test]\n    async fn test_match_ops_return_none() -\u003e Result\u003c()\u003e {\n        let conn = r.connection().connect().await?;\n        let regexp = Regex::new(\".*@(.*)\")?;\n        let response: Option\u003cMatchResponse\u003e = r\n            .expr(\"name[at]domain.com\")\n            .match_(regexp)\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(response == None);\n\n        Ok(())\n    }\n}\n","traces":[{"line":6,"address":[4751244,4750944],"length":1,"stats":{"Line":0},"fn_name":"new"},{"line":7,"address":[4751061,4750971],"length":1,"stats":{"Line":0},"fn_name":null},{"line":9,"address":[4751143,4751076],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":3},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","max.rs"],"content":"use std::borrow::Cow;\n\nuse ql2::term::TermType;\nuse reql_macros::CommandOptions;\nuse serde::Serialize;\n\nuse crate::arguments::Args;\nuse crate::prelude::Func;\nuse crate::Command;\n\npub(crate) fn new(args: impl MaxArg) -\u003e Command {\n    let (arg, opts) = args.into_max_opts();\n    let mut command = Command::new(TermType::Max);\n\n    if let Some(arg) = arg {\n        command = command.with_arg(arg)\n    }\n\n    command.with_opts(opts)\n}\n\npub trait MaxArg {\n    fn into_max_opts(self) -\u003e (Option\u003cCommand\u003e, MaxOption);\n}\n\nimpl MaxArg for () {\n    fn into_max_opts(self) -\u003e (Option\u003cCommand\u003e, MaxOption) {\n        (None, Default::default())\n    }\n}\n\nimpl\u003cT\u003e MaxArg for Args\u003cT\u003e\nwhere\n    T: Into\u003cString\u003e,\n{\n    fn into_max_opts(self) -\u003e (Option\u003cCommand\u003e, MaxOption) {\n        let arg = Command::from_json(self.0.into());\n\n        (Some(arg), Default::default())\n    }\n}\n\nimpl MaxArg for Func {\n    fn into_max_opts(self) -\u003e (Option\u003cCommand\u003e, MaxOption) {\n        (Some(self.0), Default::default())\n    }\n}\n\nimpl MaxArg for MaxOption {\n    fn into_max_opts(self) -\u003e (Option\u003cCommand\u003e, MaxOption) {\n        (None, self)\n    }\n}\n\nimpl MaxArg for Command {\n    fn into_max_opts(self) -\u003e (Option\u003cCommand\u003e, MaxOption) {\n        (Some(self), Default::default())\n    }\n}\n\n#[derive(Debug, Clone, Serialize, Default, PartialEq, PartialOrd, CommandOptions)]\npub struct MaxOption {\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub index: Option\u003cCow\u003c'static, str\u003e\u003e,\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::Converter;\n    use crate::spec::{set_up, tear_down, Post};\n    use crate::{args, Result};\n\n    #[tokio::test]\n    async fn test_max_data() -\u003e Result\u003c()\u003e {\n        let data = Post::get_many_data();\n        let (conn, table, table_name) = set_up(true).await?;\n        let data_obtained: Post = table\n            .max(args!(\"view\"))\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(Some(\u0026data_obtained) == data.first());\n\n        tear_down(conn, \u0026table_name).await\n    }\n}\n","traces":[{"line":10,"address":[2305840,2306891,2306717],"length":1,"stats":{"Line":1},"fn_name":"new\u003c\u0026str\u003e"},{"line":11,"address":[2305873],"length":1,"stats":{"Line":1},"fn_name":null},{"line":12,"address":[2306034],"length":1,"stats":{"Line":1},"fn_name":null},{"line":14,"address":[2306350,2306108],"length":1,"stats":{"Line":1},"fn_name":null},{"line":15,"address":[2306324,2306229],"length":1,"stats":{"Line":0},"fn_name":null},{"line":18,"address":[2306619,2306352,2306286],"length":1,"stats":{"Line":3},"fn_name":null},{"line":19,"address":[2306436,2306593],"length":1,"stats":{"Line":2},"fn_name":null},{"line":22,"address":[2306526],"length":1,"stats":{"Line":1},"fn_name":null},{"line":30,"address":[2541783,2541472,2541813],"length":1,"stats":{"Line":1},"fn_name":"into_max_opts"},{"line":31,"address":[4789169],"length":1,"stats":{"Line":1},"fn_name":null},{"line":33,"address":[2541516,2541794],"length":1,"stats":{"Line":1},"fn_name":null},{"line":38,"address":[2829379,2829406,2829104],"length":1,"stats":{"Line":0},"fn_name":"into_max_opts"},{"line":39,"address":[2829121,2829390],"length":1,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[4789488],"length":1,"stats":{"Line":0},"fn_name":"into_max_opts"},{"line":45,"address":[4789508],"length":1,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[2256688,2257118,2257151],"length":1,"stats":{"Line":0},"fn_name":"into_max_opts"},{"line":51,"address":[2256713],"length":1,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[4041849,4041521],"length":1,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[4042209,4041888,4042168],"length":1,"stats":{"Line":0},"fn_name":"into_max_opts"},{"line":59,"address":[2257240,2257480],"length":1,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[2257552],"length":1,"stats":{"Line":0},"fn_name":"into_max_opts"},{"line":65,"address":[2257574],"length":1,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[4795717,4795264,4795669,4795303],"length":1,"stats":{"Line":6},"fn_name":"test_max_data"},{"line":83,"address":[4584355],"length":1,"stats":{"Line":1},"fn_name":null},{"line":84,"address":[4584785,4584960,4585405,4584407,4584560,4584725],"length":1,"stats":{"Line":4},"fn_name":null},{"line":85,"address":[4584511,4584428,4585345,4586549,4585613,4586342],"length":1,"stats":{"Line":5},"fn_name":null},{"line":87,"address":[4586521,4587017,4586906],"length":1,"stats":{"Line":2},"fn_name":null},{"line":89,"address":[4587270,4587090,4587350,4586976,4584446,4587480,4587214],"length":1,"stats":{"Line":7},"fn_name":null}],"covered":16,"coverable":28},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","merge.rs"],"content":"use ql2::term::TermType;\nuse serde::Serialize;\n\nuse crate::arguments::Args;\nuse crate::prelude::Func;\nuse crate::Command;\n\nuse super::CmdOpts;\n\npub(crate) fn new(args: impl MergeArg) -\u003e Command {\n    args.into_merge_opts()\n        .add_to_cmd(Command::new(TermType::Merge))\n}\n\npub trait MergeArg {\n    fn into_merge_opts(self) -\u003e CmdOpts;\n}\n\nimpl\u003cT\u003e MergeArg for T\nwhere\n    T: Serialize,\n{\n    fn into_merge_opts(self) -\u003e CmdOpts {\n        CmdOpts::Single(Command::from_json(self))\n    }\n}\n\nimpl MergeArg for Command {\n    fn into_merge_opts(self) -\u003e CmdOpts {\n        CmdOpts::Single(self)\n    }\n}\n\nimpl MergeArg for Func {\n    fn into_merge_opts(self) -\u003e CmdOpts {\n        CmdOpts::Single(self.0)\n    }\n}\n\nimpl\u003cS, T\u003e MergeArg for Args\u003cT\u003e\nwhere\n    S: Into\u003cCommand\u003e,\n    T: IntoIterator\u003cItem = S\u003e,\n{\n    fn into_merge_opts(self) -\u003e CmdOpts {\n        CmdOpts::Many(self.0.into_iter().map(|cmd| cmd.into()).collect())\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use std::collections::HashMap;\n\n    use serde::{Deserialize, Serialize};\n    use uuid::Uuid;\n\n    use crate::args;\n    use crate::prelude::*;\n    use crate::spec::*;\n    use crate::Session;\n    use crate::{r, Result};\n\n    #[derive(Debug, Serialize, Deserialize, PartialEq, Eq)]\n    struct Comment {\n        id: u8,\n        post_id: u8,\n        message: String,\n    }\n\n    impl Comment {\n        fn new(id: u8, post_id: u8, message: \u0026str) -\u003e Self {\n            Self {\n                id,\n                post_id,\n                message: String::from(message),\n            }\n        }\n    }\n\n    #[derive(Debug, Serialize, Deserialize, PartialEq, Eq)]\n    struct MergePostToComment {\n        id: u8,\n        post_id: u8,\n        message: String,\n        post: Post,\n    }\n\n    #[tokio::test]\n    async fn test_merge_ops() -\u003e Result\u003c()\u003e {\n        let (\n            conn,\n            comment_table,\n            post_table,\n            merged_post_comments,\n            comment_table_name,\n            post_table_name,\n        ) = set_up2().await?;\n\n        let response: Vec\u003cMergePostToComment\u003e = comment_table\n            .merge(func!(|comment| {\n                let mut posts = HashMap::new();\n\n                posts.insert(\"post\", post_table.get(comment.g(\"post_id\")));\n\n                r.hash_map(posts)\n            }))\n            .order_by(r.expr(\"id\"))\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(response == merged_post_comments);\n\n        tear_down2(conn, comment_table_name, post_table_name).await\n    }\n\n    #[tokio::test]\n    async fn test_merge_ops_multi() -\u003e Result\u003c()\u003e {\n        let (conn, comment_table, post_table, _, comment_table_name, post_table_name) =\n            set_up2().await?;\n\n        let response = post_table\n            .get(1)\n            .merge(args!([comment_table.clone().get(1), comment_table.get(2),]))\n            .run(\u0026conn)\n            .await?;\n\n        assert!(response.is_some());\n\n        tear_down2(conn, comment_table_name, post_table_name).await\n    }\n\n    async fn set_up2() -\u003e Result\u003c(\n        Session,\n        Command,\n        Command,\n        Vec\u003cMergePostToComment\u003e,\n        String,\n        String,\n    )\u003e {\n        let comment_table_name = Uuid::new_v4().to_string();\n        let posts = Post::get_many_data();\n        let comments = vec![\n            Comment::new(1, 1, \"Hello\"),\n            Comment::new(2, 1, \"Hello\"),\n            Comment::new(3, 2, \"Bueno dias\"),\n        ];\n        let merged_post_comments: Vec\u003cMergePostToComment\u003e = comments\n            .iter()\n            .map(|comment| MergePostToComment {\n                id: comment.id,\n                post_id: comment.post_id,\n                message: String::from(\u0026comment.message),\n                post: posts\n                    .clone()\n                    .into_iter()\n                    .find(|post| post.id == comment.post_id)\n                    .unwrap(),\n            })\n            .collect();\n\n        let (conn, post_table, post_table_name) = set_up(true).await?;\n        r.table_create(comment_table_name.as_str())\n            .run(\u0026conn)\n            .await?;\n        let comment_table = r.table(comment_table_name.as_str());\n        comment_table.clone().insert(comments).run(\u0026conn).await?;\n\n        Ok((\n            conn,\n            comment_table,\n            post_table,\n            merged_post_comments,\n            comment_table_name,\n            post_table_name,\n        ))\n    }\n\n    async fn tear_down2(\n        conn: Session,\n        comment_table_name: String,\n        post_table_name: String,\n    ) -\u003e Result\u003c()\u003e {\n        r.table_drop(\u0026comment_table_name).run(\u0026conn).await?;\n        tear_down(conn, \u0026post_table_name).await\n    }\n}\n","traces":[{"line":9,"address":[2719664,2719852,2719879],"length":1,"stats":{"Line":1},"fn_name":"new\u003creql_rust::proto::Command\u003e"},{"line":10,"address":[2719803,2719680],"length":1,"stats":{"Line":2},"fn_name":null},{"line":11,"address":[2719872,2719836,2719732],"length":1,"stats":{"Line":2},"fn_name":null},{"line":19,"address":[5126656],"length":1,"stats":{"Line":0},"fn_name":"into_merge_opts"},{"line":20,"address":[2775137],"length":1,"stats":{"Line":0},"fn_name":null},{"line":25,"address":[4042512],"length":1,"stats":{"Line":1},"fn_name":"into_merge_opts"},{"line":26,"address":[4042528],"length":1,"stats":{"Line":1},"fn_name":null},{"line":31,"address":[7020384],"length":1,"stats":{"Line":0},"fn_name":"into_merge_opts"},{"line":32,"address":[7020400],"length":1,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[4439648],"length":1,"stats":{"Line":0},"fn_name":"into_merge_opts"},{"line":38,"address":[4439655],"length":1,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[4439728],"length":1,"stats":{"Line":0},"fn_name":"into_merge_opts"},{"line":44,"address":[2719904,2719932],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":46,"address":[4439824],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":5,"coverable":14},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","min.rs"],"content":"use std::borrow::Cow;\n\nuse ql2::term::TermType;\nuse reql_macros::CommandOptions;\nuse serde::Serialize;\n\nuse crate::arguments::Args;\nuse crate::prelude::Func;\nuse crate::Command;\n\npub(crate) fn new(args: impl MinArg) -\u003e Command {\n    let (arg, opts) = args.into_min_opts();\n    let mut command = Command::new(TermType::Min);\n\n    if let Some(arg) = arg {\n        command = command.with_arg(arg)\n    }\n\n    command.with_opts(opts)\n}\n\npub trait MinArg {\n    fn into_min_opts(self) -\u003e (Option\u003cCommand\u003e, MinOption);\n}\n\nimpl MinArg for () {\n    fn into_min_opts(self) -\u003e (Option\u003cCommand\u003e, MinOption) {\n        (None, Default::default())\n    }\n}\n\nimpl\u003cT\u003e MinArg for Args\u003cT\u003e\nwhere\n    T: Into\u003cString\u003e,\n{\n    fn into_min_opts(self) -\u003e (Option\u003cCommand\u003e, MinOption) {\n        let arg = Command::from_json(self.0.into());\n\n        (Some(arg), Default::default())\n    }\n}\n\nimpl MinArg for Func {\n    fn into_min_opts(self) -\u003e (Option\u003cCommand\u003e, MinOption) {\n        (Some(self.0), Default::default())\n    }\n}\n\nimpl MinArg for MinOption {\n    fn into_min_opts(self) -\u003e (Option\u003cCommand\u003e, MinOption) {\n        (None, self)\n    }\n}\n\nimpl MinArg for Command {\n    fn into_min_opts(self) -\u003e (Option\u003cCommand\u003e, MinOption) {\n        (Some(self), Default::default())\n    }\n}\n\n#[derive(Debug, Clone, Serialize, Default, PartialEq, PartialOrd, CommandOptions)]\npub struct MinOption {\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub index: Option\u003cCow\u003c'static, str\u003e\u003e,\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::Converter;\n    use crate::spec::{set_up, tear_down, Post};\n    use crate::{args, Result};\n\n    #[tokio::test]\n    async fn test_min_data() -\u003e Result\u003c()\u003e {\n        let data = Post::get_many_data();\n        let (conn, table, table_name) = set_up(true).await?;\n        let data_obtained: Post = table\n            .min(args!(\"view\"))\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(Some(\u0026data_obtained) == data.last());\n\n        tear_down(conn, \u0026table_name).await\n    }\n}\n","traces":[{"line":10,"address":[4669499,4669325,4668448],"length":1,"stats":{"Line":1},"fn_name":"new\u003c\u0026str\u003e"},{"line":11,"address":[4668481],"length":1,"stats":{"Line":1},"fn_name":null},{"line":12,"address":[4668642],"length":1,"stats":{"Line":1},"fn_name":null},{"line":14,"address":[4668716,4668958],"length":1,"stats":{"Line":1},"fn_name":null},{"line":15,"address":[4668837,4668932],"length":1,"stats":{"Line":0},"fn_name":null},{"line":18,"address":[4668894,4668960,4669227],"length":1,"stats":{"Line":3},"fn_name":null},{"line":19,"address":[4669044,4669201],"length":1,"stats":{"Line":2},"fn_name":null},{"line":22,"address":[4669134],"length":1,"stats":{"Line":1},"fn_name":null},{"line":30,"address":[2813557,2813216,2813527],"length":1,"stats":{"Line":1},"fn_name":"into_min_opts"},{"line":31,"address":[4789745],"length":1,"stats":{"Line":1},"fn_name":null},{"line":33,"address":[2813260,2813538],"length":1,"stats":{"Line":1},"fn_name":null},{"line":38,"address":[2829806,2829779,2829504],"length":1,"stats":{"Line":0},"fn_name":"into_min_opts"},{"line":39,"address":[2829521,2829790],"length":1,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[4790064],"length":1,"stats":{"Line":0},"fn_name":"into_min_opts"},{"line":45,"address":[4790084],"length":1,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[2258367,2257904,2258334],"length":1,"stats":{"Line":0},"fn_name":"into_min_opts"},{"line":51,"address":[2257929],"length":1,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[4042705,4043033],"length":1,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[4043393,4043352,4043072],"length":1,"stats":{"Line":0},"fn_name":"into_min_opts"},{"line":59,"address":[2258696,2258456],"length":1,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[2258768],"length":1,"stats":{"Line":0},"fn_name":"into_min_opts"},{"line":65,"address":[2258790],"length":1,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[4796165,4796213,4795799,4795760],"length":1,"stats":{"Line":6},"fn_name":"test_min_data"},{"line":83,"address":[4762147],"length":1,"stats":{"Line":1},"fn_name":null},{"line":84,"address":[4762517,4763197,4762199,4762352,4762752,4762577],"length":1,"stats":{"Line":4},"fn_name":null},{"line":85,"address":[4762303,4763137,4764134,4762220,4763405,4764341],"length":1,"stats":{"Line":5},"fn_name":null},{"line":87,"address":[4764313,4764809,4764698],"length":1,"stats":{"Line":2},"fn_name":null},{"line":89,"address":[4764768,4765142,4765062,4765006,4762238,4765272,4764882],"length":1,"stats":{"Line":7},"fn_name":null}],"covered":16,"coverable":28},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","minutes.rs"],"content":"use ql2::term::TermType;\n\nuse crate::Command;\n\npub(crate) fn new() -\u003e Command {\n    Command::new(TermType::Minutes)\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::Converter;\n    use crate::{r, Result};\n\n    #[tokio::test]\n    async fn test_minutes_ops() -\u003e Result\u003c()\u003e {\n        let conn = r.connection().connect().await?;\n\n        let minutes = r.now().minutes();\n        let minutes1 = minutes.clone().value();\n        let minutes2: u8 = minutes.cmd().run(\u0026conn).await?.unwrap().parse()?;\n\n        assert!(minutes1 == minutes2);\n\n        Ok(())\n    }\n}\n","traces":[{"line":5,"address":[2719952],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":6,"address":[2719964],"length":1,"stats":{"Line":1},"fn_name":null},{"line":15,"address":[4540975,4541274,4540672,4540838,4540681,4540704,4540761],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":16,"address":[4540935,4540862,4540816,4541096,4541285,4541546],"length":1,"stats":{"Line":4},"fn_name":null},{"line":18,"address":[4541792,4541536],"length":1,"stats":{"Line":2},"fn_name":null},{"line":19,"address":[4541883,4541820],"length":1,"stats":{"Line":2},"fn_name":null},{"line":20,"address":[4540877,4541927,4542727,4542822,4542014],"length":1,"stats":{"Line":4},"fn_name":null},{"line":22,"address":[4543015,4542801],"length":1,"stats":{"Line":1},"fn_name":null},{"line":24,"address":[4542985],"length":1,"stats":{"Line":5},"fn_name":null}],"covered":9,"coverable":9},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","month.rs"],"content":"use ql2::term::TermType;\n\nuse crate::Command;\n\npub(crate) fn new() -\u003e Command {\n    Command::new(TermType::Month)\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::Converter;\n    use crate::{r, Result};\n\n    #[tokio::test]\n    async fn test_month_ops() -\u003e Result\u003c()\u003e {\n        let conn = r.connection().connect().await?;\n\n        let month = r.now().month();\n        let month1 = month.clone().value();\n        let month2: u8 = month.cmd().run(\u0026conn).await?.unwrap().parse()?;\n\n        assert!(month1 == month2);\n\n        Ok(())\n    }\n}\n","traces":[{"line":5,"address":[2720000],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":6,"address":[2720012],"length":1,"stats":{"Line":1},"fn_name":null},{"line":15,"address":[1539392,1539481,1539994,1539401,1539424,1539558,1539695],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":16,"address":[1540005,1539582,1540266,1539655,1539536,1539816],"length":1,"stats":{"Line":4},"fn_name":null},{"line":18,"address":[1540512,1540256],"length":1,"stats":{"Line":2},"fn_name":null},{"line":19,"address":[1540540,1540603],"length":1,"stats":{"Line":2},"fn_name":null},{"line":20,"address":[1540647,1541542,1539597,1541447,1540734],"length":1,"stats":{"Line":4},"fn_name":null},{"line":22,"address":[1541521,1541735],"length":1,"stats":{"Line":1},"fn_name":null},{"line":24,"address":[1541705],"length":1,"stats":{"Line":5},"fn_name":null}],"covered":9,"coverable":9},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","mul.rs"],"content":"use std::ops::Mul;\n\nuse ql2::term::TermType;\nuse serde::Serialize;\n\nuse crate::Command;\n\nimpl\u003cT: MulArg\u003e Mul\u003cT\u003e for Command {\n    type Output = Self;\n\n    fn mul(self, arg: T) -\u003e Self {\n        Command::new(TermType::Mul)\n            .with_arg(arg.into_mul_opts())\n            .with_parent(self)\n    }\n}\n\npub trait MulArg {\n    fn into_mul_opts(self) -\u003e Command;\n}\n\nimpl\u003cT: AsRef\u003c[f64]\u003e + Serialize\u003e MulArg for T {\n    fn into_mul_opts(self) -\u003e Command {\n        Command::from_json(self)\n    }\n}\n\nimpl MulArg for Command {\n    fn into_mul_opts(self) -\u003e Command {\n        self\n    }\n}\n\n// TODO write test\n","traces":[{"line":11,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":12,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":13,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":14,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[4043696],"length":1,"stats":{"Line":0},"fn_name":"into_mul_opts"},{"line":30,"address":[4043704],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":8},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","ne.rs"],"content":"use ql2::term::TermType;\nuse serde::Serialize;\n\nuse crate::arguments::Args;\nuse crate::Command;\n\nuse super::CmdOpts;\n\npub(crate) fn new(args: impl NeArg) -\u003e Command {\n    args.into_ne_opts().add_to_cmd(Command::new(TermType::Ne))\n}\n\npub trait NeArg {\n    fn into_ne_opts(self) -\u003e CmdOpts;\n}\n\nimpl\u003cT\u003e NeArg for T\nwhere\n    T: Serialize,\n{\n    fn into_ne_opts(self) -\u003e CmdOpts {\n        CmdOpts::Single(Command::from_json(self))\n    }\n}\n\nimpl NeArg for Command {\n    fn into_ne_opts(self) -\u003e CmdOpts {\n        CmdOpts::Single(self)\n    }\n}\n\nimpl\u003cS, T\u003e NeArg for Args\u003cT\u003e\nwhere\n    S: Serialize,\n    T: IntoIterator\u003cItem = S\u003e,\n{\n    fn into_ne_opts(self) -\u003e CmdOpts {\n        let commands = self.0.into_iter().map(Command::from_json).collect();\n\n        CmdOpts::Many(commands)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::Converter;\n    use crate::spec::{set_up, tear_down};\n    use crate::{args, r, Result};\n\n    #[tokio::test]\n    async fn test_ne_data() -\u003e Result\u003c()\u003e {\n        let (conn, table, table_name) = set_up(true).await?;\n        let data_obtained: bool = table\n            .get(1)\n            .g(\"title\")\n            .ne(\"title\")\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(data_obtained);\n\n        tear_down(conn, \u0026table_name).await\n    }\n\n    #[tokio::test]\n    async fn test_ne_data_r() -\u003e Result\u003c()\u003e {\n        let conn = r.connection().connect().await?;\n        let data_obtained: bool = r.ne(args!([5, 6, 7])).run(\u0026conn).await?.unwrap().parse()?;\n\n        assert!(data_obtained);\n\n        Ok(())\n    }\n}\n","traces":[{"line":9,"address":[6643644,6643456,6643432,6643405,6643671,6643200],"length":1,"stats":{"Line":2},"fn_name":"new\u003calloc::vec::Vec\u003ci32, alloc::alloc::Global\u003e\u003e"},{"line":10,"address":[6643425,6643664,6643472,6643216],"length":1,"stats":{"Line":2},"fn_name":null},{"line":18,"address":[2775232],"length":1,"stats":{"Line":1},"fn_name":"into_ne_opts"},{"line":19,"address":[2775249],"length":1,"stats":{"Line":1},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":39,"address":[1653392,1653797,1653845,1653431],"length":1,"stats":{"Line":6},"fn_name":"test_ne_data"},{"line":40,"address":[5129685,5129532,5129853,5129459,5130468,5130031],"length":1,"stats":{"Line":4},"fn_name":null},{"line":41,"address":[5131120,5131043,5131635,5130813,5131315,5131825,5130709,5130884,5131534,5130415,5131591],"length":1,"stats":{"Line":8},"fn_name":null},{"line":44,"address":[5130674,5130899,5130752,5130860],"length":1,"stats":{"Line":2},"fn_name":null},{"line":45,"address":[6853168],"length":1,"stats":{"Line":5},"fn_name":null},{"line":46,"address":[5131438],"length":1,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[5131714,5132028],"length":1,"stats":{"Line":1},"fn_name":null},{"line":52,"address":[1653528,1653423,1653468,1653808],"length":1,"stats":{"Line":7},"fn_name":null},{"line":56,"address":[1653927,1654293,1653888,1654341],"length":1,"stats":{"Line":6},"fn_name":"test_ne_data_r"},{"line":57,"address":[5132915,5132949,5133370,5133638,5133181,5133020],"length":1,"stats":{"Line":4},"fn_name":null},{"line":58,"address":[5133623,5133866,5132964,5134634,5134728],"length":1,"stats":{"Line":4},"fn_name":null},{"line":60,"address":[5134713,5134936],"length":1,"stats":{"Line":1},"fn_name":null},{"line":62,"address":[1654024,1653919,1653964,1654304],"length":1,"stats":{"Line":5},"fn_name":null}],"covered":19,"coverable":20},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","now.rs"],"content":"use ql2::term::TermType;\n\nuse crate::Command;\n\npub(crate) fn new() -\u003e Command {\n    Command::new(TermType::Now)\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::Converter;\n    use crate::types::Time;\n    use crate::{r, Result};\n\n    #[tokio::test]\n    async fn test_now_time() -\u003e Result\u003c()\u003e {\n        let conn = r.connection().connect().await?;\n        let time1 = r.now().value();\n        let time2: Time = r.now().cmd().run(\u0026conn).await?.unwrap().parse()?;\n\n        assert!(time1.is_valid());\n        assert!(time2.is_valid());\n\n        Ok(())\n    }\n}\n","traces":[{"line":5,"address":[2720048],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":6,"address":[2720060],"length":1,"stats":{"Line":1},"fn_name":null},{"line":16,"address":[1678119,1678533,1678080,1678485],"length":1,"stats":{"Line":6},"fn_name":"test_now_time"},{"line":17,"address":[1783749,1783820,1784431,1784170,1783715,1783981],"length":1,"stats":{"Line":4},"fn_name":null},{"line":18,"address":[1784673,1784421],"length":1,"stats":{"Line":2},"fn_name":null},{"line":19,"address":[1785630,1784700,1783764,1785462,1784750],"length":1,"stats":{"Line":4},"fn_name":null},{"line":21,"address":[1785867,1785612,1785892],"length":1,"stats":{"Line":2},"fn_name":null},{"line":22,"address":[1785961,1785928,1785881],"length":1,"stats":{"Line":2},"fn_name":null},{"line":24,"address":[1678156,1678111,1678216,1678496],"length":1,"stats":{"Line":5},"fn_name":null}],"covered":9,"coverable":9},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","nth.rs"],"content":"use ql2::term::TermType;\n\nuse crate::Command;\n\npub(crate) fn new(index: isize) -\u003e Command {\n    let arg = Command::from_json(index);\n\n    Command::new(TermType::Nth).with_arg(arg)\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::cmd::order_by::OrderByOption;\n    use crate::prelude::Converter;\n    use crate::spec::{set_up, tear_down, Post};\n    use crate::Result;\n\n    #[tokio::test]\n    async fn test_nth_data() -\u003e Result\u003c()\u003e {\n        let data = Post::get_many_data();\n        let (conn, table, table_name) = set_up(true).await?;\n        let data_obtained: Post = table\n            .order_by(OrderByOption::default().index(\"title\"))\n            .nth(-1)\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(data.last() == Some(\u0026data_obtained));\n\n        tear_down(conn, \u0026table_name).await\n    }\n}\n","traces":[{"line":5,"address":[2232018,2231776,2231987],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":6,"address":[2231801],"length":1,"stats":{"Line":1},"fn_name":null},{"line":8,"address":[2231899,2231828],"length":1,"stats":{"Line":2},"fn_name":null},{"line":19,"address":[4495841,4495648,4496413,4495657,4495680,4495749,4496067],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":20,"address":[4495811],"length":1,"stats":{"Line":1},"fn_name":null},{"line":21,"address":[4496024,4496189,4496249,4496855,4495871,4496424],"length":1,"stats":{"Line":4},"fn_name":null},{"line":22,"address":[4497650,4497104,4497970,4498258,4496815,4497261,4497926,4497174,4497869,4497378,4497455],"length":1,"stats":{"Line":8},"fn_name":null},{"line":23,"address":[4496845,4497028,4497199,4497181,4497143],"length":1,"stats":{"Line":2},"fn_name":null},{"line":25,"address":[4497241,4495892,4497284,4497583,4497411,4495975],"length":1,"stats":{"Line":6},"fn_name":null},{"line":26,"address":[4497773],"length":1,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[4498519,4498650,4498142],"length":1,"stats":{"Line":2},"fn_name":null},{"line":32,"address":[4498847,4498723,4499113,4498609,4498983,4498903,4495910],"length":1,"stats":{"Line":7},"fn_name":null}],"covered":11,"coverable":12},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","object.rs"],"content":"use ql2::term::TermType;\nuse serde::Serialize;\n\nuse crate::Command;\n\npub(crate) fn new\u003cS, T\u003e(values: T) -\u003e Command\nwhere\n    S: Serialize,\n    T: IntoIterator\u003cItem = S\u003e,\n{\n    let mut command = Command::new(TermType::Object);\n\n    for value in values {\n        let arg = Command::from_json(value);\n\n        command = command.with_arg(arg);\n    }\n\n    command\n}\n\n#[cfg(test)]\nmod tests {\n    use serde::{Deserialize, Serialize};\n\n    use crate::prelude::Converter;\n    use crate::{r, Result};\n\n    #[derive(Debug, PartialEq, Eq, Serialize, Deserialize)]\n    struct InnerPost {\n        id: String,\n        title: String,\n    }\n\n    #[tokio::test]\n    async fn test_object_converted() -\u003e Result\u003c()\u003e {\n        let post = InnerPost {\n            id: \"id1\".to_string(),\n            title: \"title1\".to_string(),\n        };\n        let object = vec![\"id\", \"id1\", \"title\", \"title1\"];\n\n        let conn = r.connection().connect().await?;\n        let data_obtained: InnerPost = r.object(object).run(\u0026conn).await?.unwrap().parse()?;\n\n        assert!(data_obtained == post);\n\n        Ok(())\n    }\n}\n","traces":[{"line":6,"address":[3586047,3585424,3586102],"length":1,"stats":{"Line":1},"fn_name":"new\u003c\u0026str\u003e"},{"line":7,"address":[3585538,3585449],"length":1,"stats":{"Line":2},"fn_name":null},{"line":9,"address":[3585878,3586042,3585546,3585633],"length":1,"stats":{"Line":3},"fn_name":null},{"line":10,"address":[3585871],"length":1,"stats":{"Line":1},"fn_name":null},{"line":12,"address":[3585910],"length":1,"stats":{"Line":1},"fn_name":null},{"line":15,"address":[3586063],"length":1,"stats":{"Line":1},"fn_name":null},{"line":32,"address":[4097578,4097040,4097072,4097345,4097210,4097129,4097049],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":34,"address":[4097183],"length":1,"stats":{"Line":1},"fn_name":null},{"line":35,"address":[4097451],"length":1,"stats":{"Line":1},"fn_name":null},{"line":37,"address":[4097566,4097640],"length":1,"stats":{"Line":2},"fn_name":null},{"line":39,"address":[4097234,4097748,4097813,4098289,4097305],"length":1,"stats":{"Line":4},"fn_name":null},{"line":40,"address":[4099369,4097249,4099197,4098496,4098235],"length":1,"stats":{"Line":4},"fn_name":null},{"line":42,"address":[4099665,4099355,4099698],"length":1,"stats":{"Line":2},"fn_name":null},{"line":44,"address":[4099671],"length":1,"stats":{"Line":5},"fn_name":null}],"covered":14,"coverable":14},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","offsets_of.rs"],"content":"use ql2::term::TermType;\nuse serde::Serialize;\n\nuse crate::prelude::Func;\nuse crate::Command;\n\npub(crate) fn new(args: impl OffsetsOfArg) -\u003e Command {\n    Command::new(TermType::OffsetsOf).with_arg(args.into_offsets_of_opts())\n}\n\npub trait OffsetsOfArg {\n    fn into_offsets_of_opts(self) -\u003e Command;\n}\n\nimpl\u003cT\u003e OffsetsOfArg for T\nwhere\n    T: Serialize,\n{\n    fn into_offsets_of_opts(self) -\u003e Command {\n        Command::from_json(self)\n    }\n}\n\nimpl OffsetsOfArg for Func {\n    fn into_offsets_of_opts(self) -\u003e Command {\n        self.0\n    }\n}\n\nimpl OffsetsOfArg for Command {\n    fn into_offsets_of_opts(self) -\u003e Command {\n        self\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::Converter;\n    use crate::{r, Result};\n\n    #[tokio::test]\n    async fn test_offset_of_ops() -\u003e Result\u003c()\u003e {\n        let conn = r.connection().connect().await?;\n        let response: Vec\u003cusize\u003e = r\n            .expr(['a', 'b', 'c'])\n            .offsets_of('c')\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(response.first() == Some(\u00262));\n\n        Ok(())\n    }\n}\n","traces":[{"line":19,"address":[5126880],"length":1,"stats":{"Line":0},"fn_name":"into_offsets_of_opts"},{"line":20,"address":[5126897],"length":1,"stats":{"Line":0},"fn_name":null},{"line":25,"address":[7020784],"length":1,"stats":{"Line":0},"fn_name":"into_offsets_of_opts"},{"line":26,"address":[7020800],"length":1,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[4043728],"length":1,"stats":{"Line":0},"fn_name":"into_offsets_of_opts"},{"line":32,"address":[4043744],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":6},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","or.rs"],"content":"use ql2::term::TermType;\n\nuse crate::{arguments::Args, Command};\n\nuse super::CmdOpts;\n\npub(crate) fn new(args: impl OrArg) -\u003e Command {\n    args.into_or_opts().add_to_cmd(Command::new(TermType::Or))\n}\n\npub trait OrArg {\n    fn into_or_opts(self) -\u003e CmdOpts;\n}\n\nimpl OrArg for bool {\n    fn into_or_opts(self) -\u003e CmdOpts {\n        CmdOpts::Single(Command::from_json(self))\n    }\n}\n\nimpl OrArg for Command {\n    fn into_or_opts(self) -\u003e CmdOpts {\n        CmdOpts::Single(self)\n    }\n}\n\nimpl\u003cT\u003e OrArg for Args\u003cT\u003e\nwhere\n    T: IntoIterator\u003cItem = bool\u003e,\n{\n    fn into_or_opts(self) -\u003e CmdOpts {\n        let commands = self.0.into_iter().map(Command::from_json).collect();\n\n        CmdOpts::Many(commands)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::Converter;\n    use crate::{args, r, Result};\n\n    #[tokio::test]\n    async fn test_or_ops() -\u003e Result\u003c()\u003e {\n        let conn = r.connection().connect().await?;\n        let data_obtained: bool = r\n            .or(args!([true, false]))\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(data_obtained);\n\n        Ok(())\n    }\n}\n","traces":[{"line":7,"address":[4533976,4533744,4533949],"length":1,"stats":{"Line":1},"fn_name":"new\u003calloc::vec::Vec\u003cbool, alloc::alloc::Global\u003e\u003e"},{"line":8,"address":[4533969,4533760],"length":1,"stats":{"Line":1},"fn_name":null},{"line":16,"address":[2039536],"length":1,"stats":{"Line":0},"fn_name":"into_or_opts"},{"line":17,"address":[2039568],"length":1,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[2177504],"length":1,"stats":{"Line":0},"fn_name":"into_or_opts"},{"line":23,"address":[4043824],"length":1,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[4439920,4440169],"length":1,"stats":{"Line":1},"fn_name":"into_or_opts"},{"line":29,"address":[4439950,4440019],"length":1,"stats":{"Line":2},"fn_name":null},{"line":31,"address":[4440097],"length":1,"stats":{"Line":1},"fn_name":null},{"line":36,"address":[4440208],"length":1,"stats":{"Line":0},"fn_name":"into_or_opts"},{"line":37,"address":[4440215],"length":1,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[4121309,4121161,4121444,4121743,4121152,4121184,4121241],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":48,"address":[4121333,4122022,4121754,4121404,4121299,4121565],"length":1,"stats":{"Line":4},"fn_name":null},{"line":49,"address":[4122250,4121348,4123005,4122007,4123099],"length":1,"stats":{"Line":4},"fn_name":null},{"line":51,"address":[4123307,4123084],"length":1,"stats":{"Line":1},"fn_name":null},{"line":53,"address":[4123281],"length":1,"stats":{"Line":5},"fn_name":null}],"covered":10,"coverable":16},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","order_by.rs"],"content":"use std::borrow::Cow;\n\nuse ql2::term::TermType;\nuse reql_macros::CommandOptions;\nuse serde::Serialize;\n\nuse crate::arguments::Args;\nuse crate::prelude::Func;\nuse crate::Command;\n\nuse super::CmdOpts;\n\npub(crate) fn new(args: impl OrderByArg) -\u003e Command {\n    let (args, opts) = args.into_order_by_opts();\n    let mut command = Command::new(TermType::OrderBy);\n\n    if let Some(args) = args {\n        command = args.add_to_cmd(command)\n    }\n\n    command.with_opts(opts)\n}\n\npub trait OrderByArg {\n    fn into_order_by_opts(self) -\u003e (Option\u003cCmdOpts\u003e, OrderByOption);\n}\n\nimpl OrderByArg for OrderByOption {\n    fn into_order_by_opts(self) -\u003e (Option\u003cCmdOpts\u003e, OrderByOption) {\n        (Default::default(), self)\n    }\n}\n\nimpl OrderByArg for Func {\n    fn into_order_by_opts(self) -\u003e (Option\u003cCmdOpts\u003e, OrderByOption) {\n        (Some(CmdOpts::Single(self.0)), Default::default())\n    }\n}\n\nimpl OrderByArg for Command {\n    fn into_order_by_opts(self) -\u003e (Option\u003cCmdOpts\u003e, OrderByOption) {\n        (Some(CmdOpts::Single(self)), Default::default())\n    }\n}\n\nimpl OrderByArg for Args\u003c(Func, OrderByOption)\u003e {\n    fn into_order_by_opts(self) -\u003e (Option\u003cCmdOpts\u003e, OrderByOption) {\n        let Func(func) = self.0 .0;\n\n        (Some(CmdOpts::Single(func)), self.0 .1)\n    }\n}\n\nimpl OrderByArg for Args\u003c(Command, OrderByOption)\u003e {\n    fn into_order_by_opts(self) -\u003e (Option\u003cCmdOpts\u003e, OrderByOption) {\n        (Some(CmdOpts::Single(self.0 .0)), self.0 .1)\n    }\n}\n\nimpl OrderByArg for Args\u003c(Command, Command)\u003e {\n    fn into_order_by_opts(self) -\u003e (Option\u003cCmdOpts\u003e, OrderByOption) {\n        (\n            Some(CmdOpts::Many(vec![self.0 .0, self.0 .1])),\n            Default::default(),\n        )\n    }\n}\n\nimpl OrderByArg for Args\u003c(Func, Command)\u003e {\n    fn into_order_by_opts(self) -\u003e (Option\u003cCmdOpts\u003e, OrderByOption) {\n        let Func(func) = self.0 .0;\n        (\n            Some(CmdOpts::Many(vec![func, self.0 .1])),\n            Default::default(),\n        )\n    }\n}\n\n#[derive(Debug, Clone, Serialize, Default, PartialEq, PartialOrd, CommandOptions)]\n#[non_exhaustive]\npub struct OrderByOption {\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub index: Option\u003cCow\u003c'static, str\u003e\u003e,\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::Converter;\n    use crate::spec::{set_up, tear_down, Post};\n    use crate::{args, r, Result};\n\n    use super::OrderByOption;\n\n    #[tokio::test]\n    async fn test_order_by_with_opts() -\u003e Result\u003c()\u003e {\n        let data = Post::get_many_data();\n        let (conn, table, table_name) = set_up(true).await?;\n        let data_obtained: Vec\u003cPost\u003e = table\n            .order_by(OrderByOption::default().index(\"id\"))\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(data_obtained == data);\n\n        tear_down(conn, \u0026table_name).await\n    }\n\n    #[tokio::test]\n    async fn test_order_by_title_with_opts() -\u003e Result\u003c()\u003e {\n        let data = Post::get_many_data();\n        let (conn, table, table_name) = set_up(true).await?;\n        let order_by_option = OrderByOption::default().index(\"title\");\n        let data_obtained: Vec\u003cPost\u003e = table\n            .order_by(args!(r.expr(\"id\"), order_by_option))\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(data_obtained == data);\n\n        tear_down(conn, \u0026table_name).await\n    }\n}\n","traces":[{"line":13,"address":[2768640,2769979,2769267,2769344,2767936,2768563,2770000,2767859,2767838,2768542,2767232,2769246],"length":1,"stats":{"Line":4},"fn_name":"new\u003creql_rust::proto::Command\u003e"},{"line":14,"address":[2767953,2768657,2769361,2767249],"length":1,"stats":{"Line":4},"fn_name":null},{"line":15,"address":[2768787,2769520,2768083,2767379],"length":1,"stats":{"Line":4},"fn_name":null},{"line":17,"address":[2767453,2769157,2769594,2768453,2769890,2768157,2768861,2767749],"length":1,"stats":{"Line":7},"fn_name":null},{"line":18,"address":[2768427,2769706,2768973,2767565,2767723,2769131,2769864,2768269],"length":1,"stats":{"Line":6},"fn_name":null},{"line":21,"address":[2768361,2767657,2769798,2769065],"length":1,"stats":{"Line":4},"fn_name":null},{"line":29,"address":[2544544,2544762],"length":1,"stats":{"Line":1},"fn_name":"into_order_by_opts"},{"line":30,"address":[2544622,2544570],"length":1,"stats":{"Line":2},"fn_name":null},{"line":35,"address":[7020864,7021130],"length":1,"stats":{"Line":0},"fn_name":"into_order_by_opts"},{"line":36,"address":[7020916],"length":1,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[4043888,4044154],"length":1,"stats":{"Line":1},"fn_name":"into_order_by_opts"},{"line":42,"address":[4043940],"length":1,"stats":{"Line":1},"fn_name":null},{"line":47,"address":[6662928],"length":1,"stats":{"Line":0},"fn_name":"into_order_by_opts"},{"line":48,"address":[6662949],"length":1,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[6662964],"length":1,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[6663232],"length":1,"stats":{"Line":1},"fn_name":"into_order_by_opts"},{"line":56,"address":[6663254],"length":1,"stats":{"Line":1},"fn_name":null},{"line":61,"address":[6664013,6664048,6663504],"length":1,"stats":{"Line":1},"fn_name":"into_order_by_opts"},{"line":63,"address":[6663626,6663526],"length":1,"stats":{"Line":2},"fn_name":null},{"line":64,"address":[6663871],"length":1,"stats":{"Line":1},"fn_name":null},{"line":70,"address":[6664096,6664674,6664639],"length":1,"stats":{"Line":0},"fn_name":"into_order_by_opts"},{"line":71,"address":[6664118],"length":1,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[6664232,6664179],"length":1,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[6664483],"length":1,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[4417879,4418293,4418245,4417840],"length":1,"stats":{"Line":6},"fn_name":"test_order_by_with_opts"},{"line":96,"address":[2287923],"length":1,"stats":{"Line":1},"fn_name":null},{"line":97,"address":[2287983,2288136,2288536,2288967,2288301,2288361],"length":1,"stats":{"Line":4},"fn_name":null},{"line":98,"address":[2289729,2289948,2289291,2290049,2290279,2289216,2289457,2289534,2290005,2288927],"length":1,"stats":{"Line":7},"fn_name":null},{"line":99,"address":[2289140,2288957,2289298,2289316,2289263],"length":1,"stats":{"Line":2},"fn_name":null},{"line":100,"address":[2288004,2289366,2289490,2289662,2289271,2288087],"length":1,"stats":{"Line":6},"fn_name":null},{"line":101,"address":[2289852],"length":1,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[2290169,2290589,2290534],"length":1,"stats":{"Line":2},"fn_name":null},{"line":107,"address":[6775409],"length":1,"stats":{"Line":7},"fn_name":null},{"line":111,"address":[2292161,2291424,2291815,2291401,2291589,2291493,2291392],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":112,"address":[2291555],"length":1,"stats":{"Line":1},"fn_name":null},{"line":113,"address":[2292172,2291619,2292553,2291937,2291772,2291997],"length":1,"stats":{"Line":4},"fn_name":null},{"line":114,"address":[2292543,2292778],"length":1,"stats":{"Line":2},"fn_name":null},{"line":115,"address":[2293396,2293867,2292825,2293810,2293319,2293086,2293153,2294145,2293591,2293915],"length":1,"stats":{"Line":7},"fn_name":null},{"line":116,"address":[2293125,2293160,2293178,2292867],"length":1,"stats":{"Line":2},"fn_name":null},{"line":117,"address":[2293133,2291640,2293352,2293228,2291723,2293524],"length":1,"stats":{"Line":6},"fn_name":null},{"line":118,"address":[2293714],"length":1,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[2294035,2294455,2294400],"length":1,"stats":{"Line":2},"fn_name":null},{"line":124,"address":[2291658,2294670,2294810,2294726,2294546,2294940,2294414],"length":1,"stats":{"Line":7},"fn_name":null}],"covered":32,"coverable":43},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","outer_join.rs"],"content":"use ql2::term::TermType;\n\nuse crate::prelude::Func;\nuse crate::Command;\n\npub(crate) fn new(other_table: Command, func: Func) -\u003e Command {\n    let Func(func) = func;\n\n    Command::new(TermType::OuterJoin)\n        .with_arg(other_table)\n        .with_arg(func)\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::*;\n    use crate::spec::{Comment, Post};\n    use crate::types::JoinResponse;\n    use crate::Result;\n\n    #[tokio::test]\n    pub async fn test_outer_join_ops() -\u003e Result\u003c()\u003e {\n        let data = JoinResponse {\n            left: Some(Comment {\n                id: 4,\n                text: \"comment4\".to_string(),\n                post_id: 2,\n            }),\n            right: Some(Post {\n                id: 2,\n                title: \"title2\".to_string(),\n                content: Some(\"content2\".to_string()),\n                view: 2,\n            }),\n        };\n        let (conn, comment_table, post_table, comment_tablename, post_tablename) =\n            Comment::own_set_up().await?;\n\n        let response: Vec\u003cJoinResponse\u003cComment, Post\u003e\u003e = comment_table\n            .outer_join(\n                post_table,\n                func!(|comment, post| comment.g(\"post_id\").eq(post.g(\"id\"))),\n            )\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(response.len() \u003e 0);\n        assert_eq!(response.first(), Some(\u0026data));\n\n        Comment::own_tear_down(conn, comment_tablename, post_tablename).await\n    }\n}\n","traces":[{"line":6,"address":[6929616,6929280],"length":1,"stats":{"Line":0},"fn_name":"new"},{"line":7,"address":[6929315],"length":1,"stats":{"Line":0},"fn_name":null},{"line":9,"address":[6929501,6929366,6929564],"length":1,"stats":{"Line":0},"fn_name":null},{"line":10,"address":[6929445],"length":1,"stats":{"Line":0},"fn_name":null},{"line":11,"address":[6929508],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":5},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","pluck.rs"],"content":"use ql2::term::TermType;\nuse serde::Serialize;\n\nuse crate::arguments::Args;\nuse crate::Command;\n\nuse super::CmdOpts;\n\npub(crate) fn new(args: impl PluckArg) -\u003e Command {\n    args.into_pluck_opts()\n        .add_to_cmd(Command::new(TermType::Pluck))\n}\n\npub trait PluckArg {\n    fn into_pluck_opts(self) -\u003e CmdOpts;\n}\n\nimpl\u003cT\u003e PluckArg for T\nwhere\n    T: Serialize,\n{\n    fn into_pluck_opts(self) -\u003e CmdOpts {\n        CmdOpts::Single(Command::from_json(self))\n    }\n}\n\nimpl PluckArg for Command {\n    fn into_pluck_opts(self) -\u003e CmdOpts {\n        CmdOpts::Single(self)\n    }\n}\n\nimpl\u003cT\u003e PluckArg for Args\u003cT\u003e\nwhere\n    T: IntoIterator\u003cItem = Command\u003e,\n{\n    fn into_pluck_opts(self) -\u003e CmdOpts {\n        CmdOpts::Many(self.0.into_iter().collect())\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use serde::{Deserialize, Serialize};\n\n    use crate::prelude::Converter;\n    use crate::spec::{set_up, tear_down, Post};\n    use crate::Result;\n\n    #[derive(Debug, Serialize, Deserialize, PartialEq, Eq)]\n    struct InnerPost {\n        id: u8,\n        title: String,\n    }\n\n    #[tokio::test]\n    async fn test_pluck_data() -\u003e Result\u003c()\u003e {\n        let data = Post::get_one_data();\n        let data = InnerPost {\n            id: data.id,\n            title: data.title,\n        };\n        let (conn, table, table_name) = set_up(true).await?;\n        let data_obtained: InnerPost = table\n            .get(1)\n            .pluck([\"id\", \"title\"])\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(data_obtained == data);\n\n        tear_down(conn, \u0026table_name).await\n    }\n}\n","traces":[{"line":6,"address":[4354315,4354342,4354064],"length":1,"stats":{"Line":1},"fn_name":"new\u003c[\u0026str; 2]\u003e"},{"line":7,"address":[4354081],"length":1,"stats":{"Line":1},"fn_name":null},{"line":9,"address":[4354229,4354162],"length":1,"stats":{"Line":2},"fn_name":null},{"line":27,"address":[4369593,4369685,4370413,4369616,4369769,4369999,4369584],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":28,"address":[4369747],"length":1,"stats":{"Line":1},"fn_name":null},{"line":30,"address":[4370116],"length":1,"stats":{"Line":1},"fn_name":null},{"line":31,"address":[4370119],"length":1,"stats":{"Line":1},"fn_name":null},{"line":33,"address":[4370832,4370249,4369799,4370424,4370182,4369956],"length":1,"stats":{"Line":4},"fn_name":null},{"line":34,"address":[4370785,4371861,4371269,4371541,4372101,4371149,4371817,4371346,4371760,4371114],"length":1,"stats":{"Line":7},"fn_name":null},{"line":36,"address":[4371036],"length":1,"stats":{"Line":1},"fn_name":null},{"line":37,"address":[4369820,4371172,4371302,4371129,4369905,4371474],"length":1,"stats":{"Line":6},"fn_name":null},{"line":38,"address":[4371664],"length":1,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[4372482,4372427,4371987],"length":1,"stats":{"Line":2},"fn_name":null},{"line":44,"address":[4372978,4372555,4372845,4372441,4369838,4372679,4372735],"length":1,"stats":{"Line":7},"fn_name":null}],"covered":13,"coverable":14},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","point.rs"],"content":"use ql2::term::TermType;\nuse serde::{Deserialize, Serialize};\n\nuse crate::constants::{MAX_LATITUDE_VALUE, MAX_LONGITUDE_VALUE};\nuse crate::prelude::Geometry;\nuse crate::types::{GeoType, ReqlType};\nuse crate::Command;\n\n#[derive(Debug, Serialize, Deserialize, Clone, PartialEq, PartialOrd, Geometry)]\npub struct Point {\n    #[serde(rename = \"$reql_type$\")]\n    pub reql_type: ReqlType,\n    pub coordinates: [f64; 2],\n    #[serde(rename = \"type\")]\n    pub typ: GeoType,\n}\n\nimpl Point {\n    pub fn new(longitude: f64, latitude: f64) -\u003e Self {\n        assert!((-MAX_LONGITUDE_VALUE..=MAX_LONGITUDE_VALUE).contains(\u0026longitude));\n        assert!((-MAX_LATITUDE_VALUE..=MAX_LATITUDE_VALUE).contains(\u0026latitude));\n\n        Self {\n            reql_type: ReqlType::Geometry,\n            coordinates: [longitude, latitude],\n            typ: GeoType::Point,\n        }\n    }\n}\n\nimpl From\u003cPoint\u003e for Command {\n    fn from(point: Point) -\u003e Self {\n        point\n            .coordinates\n            .iter()\n            .fold(Command::new(TermType::Point), |command, coord| {\n                command.with_arg(Command::from_json(coord))\n            })\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use serde::{Deserialize, Serialize};\n\n    use crate::prelude::Converter;\n    use crate::spec::{set_up, tear_down};\n    use crate::types::Point;\n    use crate::{r, Result};\n\n    #[derive(Debug, Serialize, Deserialize, PartialEq)]\n    struct User {\n        id: u8,\n        name: String,\n        location: Point,\n    }\n\n    #[tokio::test]\n    async fn test_point_data() -\u003e Result\u003c()\u003e {\n        let user = User {\n            id: 1,\n            name: \"Yaoundé\".to_string(),\n            location: r.point(-122.423246, 37.779388),\n        };\n        let (conn, table, table_name) = set_up(false).await?;\n        table.clone().insert(\u0026user).run(\u0026conn).await?;\n        let response: User = table.get(1).run(\u0026conn).await?.unwrap().parse()?;\n\n        assert!(response == user);\n\n        tear_down(conn, \u0026table_name).await\n    }\n}\n","traces":[{"line":19,"address":[2608144],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":20,"address":[2689818,2689874],"length":1,"stats":{"Line":1},"fn_name":null},{"line":21,"address":[4407000,4406873,4406930],"length":1,"stats":{"Line":2},"fn_name":null},{"line":25,"address":[2689924],"length":1,"stats":{"Line":1},"fn_name":null},{"line":32,"address":[4044192],"length":1,"stats":{"Line":1},"fn_name":"from"},{"line":33,"address":[2259564,2259629],"length":1,"stats":{"Line":2},"fn_name":null},{"line":36,"address":[1647232,1647040,1647259],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":37,"address":[2700487,2700321],"length":1,"stats":{"Line":1},"fn_name":null},{"line":59,"address":[4594421,4594469,4594016,4594055],"length":1,"stats":{"Line":6},"fn_name":"test_point_data"},{"line":62,"address":[1630805],"length":1,"stats":{"Line":1},"fn_name":null},{"line":63,"address":[1631273],"length":1,"stats":{"Line":1},"fn_name":null},{"line":65,"address":[1631094,1630865,1632012,1631390,1631464],"length":1,"stats":{"Line":4},"fn_name":null},{"line":66,"address":[1631043,1630886,1632236,1632002],"length":1,"stats":{"Line":4},"fn_name":null},{"line":67,"address":[1632976,1630992,1630907,1633820,1634028,1633100],"length":1,"stats":{"Line":5},"fn_name":null},{"line":69,"address":[1634014,1634452,1634510],"length":1,"stats":{"Line":2},"fn_name":null},{"line":71,"address":[1634972,1634466,1634836,1630925,1634688,1634747,1634564],"length":1,"stats":{"Line":7},"fn_name":null}],"covered":16,"coverable":16},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","polygon.rs"],"content":"use ql2::term::TermType;\nuse serde::{Deserialize, Serialize};\n\nuse crate::prelude::Geometry;\nuse crate::types::{GeoType, ReqlType};\nuse crate::Command;\n\nuse super::point::Point;\nuse super::polygon_sub;\n\n#[derive(Debug, Serialize, Deserialize, Clone, PartialEq, PartialOrd, Geometry)]\npub struct Polygon {\n    #[serde(rename = \"$reql_type$\")]\n    pub reql_type: ReqlType,\n    pub coordinates: Vec\u003cVec\u003c[f64; 2]\u003e\u003e,\n    #[serde(rename = \"type\")]\n    pub typ: GeoType,\n}\n\nimpl Polygon {\n    pub fn new(points: \u0026[Point]) -\u003e Self {\n        assert!(points.len() \u003e= 3);\n\n        Self {\n            reql_type: ReqlType::Geometry,\n            typ: GeoType::Polygon,\n            coordinates: vec![points.iter().map(|point| point.coordinates).collect()],\n        }\n    }\n\n    pub fn new_from_vec(coordinates: Vec\u003cVec\u003c[f64; 2]\u003e\u003e) -\u003e Self {\n        Self {\n            reql_type: ReqlType::Geometry,\n            typ: GeoType::Polygon,\n            coordinates,\n        }\n    }\n\n    /// Use `polygon2` to “punch out” a hole in `polygon1`.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// polygon1.polygon_sub(polygon2) → polygon\n    /// ```\n    ///\n    /// Where:\n    /// - polygon1, polygon1, polygon: [Polygon](crate::cmd::polygon::Polygon)\n    ///\n    /// # Description\n    ///\n    /// `polygon2` must be completely contained within `polygon1` and must\n    /// have no holes itself (it must not be the output of `polygon_sub` itself).\n    ///\n    /// ## Examples\n    ///\n    /// Define a polygon with a hole punched in it.\n    ///\n    /// ```\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::types::Polygon;\n    /// use reql_rust::{args, r, Result};\n    /// use serde_json::json;\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let expected_data = Polygon::new_from_vec(vec![\n    ///         vec![\n    ///             [-122.4, 37.7],\n    ///             [-122.4, 37.3],\n    ///             [-121.8, 37.3],\n    ///             [-121.8, 37.7],\n    ///             [-122.4, 37.7],\n    ///         ],\n    ///         vec![\n    ///             [-122.3, 37.4],\n    ///             [-122.3, 37.6],\n    ///             [-122.0, 37.6],\n    ///             [-122.0, 37.4],\n    ///             [-122.3, 37.4],\n    ///         ],\n    ///     ]);\n    ///     let outer_polygon = r.polygon(\u0026[\n    ///         r.point(-122.4, 37.7),\n    ///         r.point(-122.4, 37.3),\n    ///         r.point(-121.8, 37.3),\n    ///         r.point(-121.8, 37.7),\n    ///     ]);\n    ///     let inner_polygon = r.polygon(\u0026[\n    ///         r.point(-122.3, 37.4),\n    ///         r.point(-122.3, 37.6),\n    ///         r.point(-122.0, 37.6),\n    ///         r.point(-122.0, 37.4),\n    ///     ]);\n    ///\n    ///     let response: Polygon = outer_polygon\n    ///         .polygon_sub(inner_polygon)\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == expected_data);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [polygon](crate::r::polygon)\n    pub fn polygon_sub(self, polygon: Polygon) -\u003e Command {\n        polygon_sub::new(polygon).with_parent(self.into())\n    }\n}\n\nimpl From\u003cPolygon\u003e for Command {\n    fn from(polygon: Polygon) -\u003e Self {\n        polygon.coordinates.iter().flatten().fold(\n            Command::new(TermType::Polygon),\n            |command, coord| {\n                let point: Command = Point::new(coord[0], coord[1]).into();\n\n                command.with_arg(point)\n            },\n        )\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use serde::{Deserialize, Serialize};\n\n    use crate::prelude::Converter;\n    use crate::spec::{set_up, tear_down};\n    use crate::types::{Point, Polygon};\n    use crate::{r, Result};\n\n    #[derive(Debug, Serialize, Deserialize, PartialEq)]\n    struct Rectangle {\n        id: u8,\n        rectangle: Polygon,\n    }\n\n    #[tokio::test]\n    async fn test_polygon_data() -\u003e Result\u003c()\u003e {\n        let rectangle = Rectangle {\n            id: 1,\n            rectangle: r.polygon(\u0026[\n                Point::new(-122.423246, 37.779388),\n                Point::new(-122.423246, 37.329898),\n                Point::new(-121.886420, 37.329898),\n                Point::new(-121.886420, 37.779388),\n            ]),\n        };\n        let (conn, table, table_name) = set_up(false).await?;\n        table.clone().insert(\u0026rectangle).run(\u0026conn).await?;\n        let response: Rectangle = table.get(1).run(\u0026conn).await?.unwrap().parse()?;\n\n        assert!(response == rectangle);\n\n        tear_down(conn, \u0026table_name).await\n    }\n}\n","traces":[{"line":21,"address":[2044560,2044850],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":22,"address":[2243768,2243723],"length":1,"stats":{"Line":1},"fn_name":null},{"line":27,"address":[2162170,2162098],"length":1,"stats":{"Line":4},"fn_name":null},{"line":31,"address":[2162432],"length":1,"stats":{"Line":1},"fn_name":"new_from_vec"},{"line":111,"address":[2244470,2244160],"length":1,"stats":{"Line":1},"fn_name":"polygon_sub"},{"line":112,"address":[2162803,2162533,2162645],"length":1,"stats":{"Line":2},"fn_name":null},{"line":117,"address":[4044320,4044515],"length":1,"stats":{"Line":1},"fn_name":"from"},{"line":118,"address":[4044496,4044414,4044350],"length":1,"stats":{"Line":3},"fn_name":null},{"line":119,"address":[2178163],"length":1,"stats":{"Line":1},"fn_name":null},{"line":120,"address":[2062320,2062574,2062601],"length":1,"stats":{"Line":1},"fn_name":"{closure#0}"},{"line":121,"address":[2062358,2062452],"length":1,"stats":{"Line":2},"fn_name":null},{"line":123,"address":[2062464],"length":1,"stats":{"Line":1},"fn_name":null},{"line":145,"address":[1324823,1325125,1324640,1325761,1324709,1324617,1324608],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":148,"address":[1325330],"length":1,"stats":{"Line":1},"fn_name":null},{"line":155,"address":[1325531,1325772,1324853,1326186,1325082,1325594],"length":1,"stats":{"Line":4},"fn_name":null},{"line":156,"address":[1325031,1326410,1324874,1326176],"length":1,"stats":{"Line":4},"fn_name":null},{"line":157,"address":[1324980,1328012,1327286,1327156,1324895,1328192],"length":1,"stats":{"Line":5},"fn_name":null},{"line":159,"address":[1328175,1328677,1328619],"length":1,"stats":{"Line":2},"fn_name":null},{"line":161,"address":[1329139,1328633,1324913,1328855,1328914,1329003,1328731],"length":1,"stats":{"Line":7},"fn_name":null}],"covered":19,"coverable":19},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","polygon_sub.rs"],"content":"use ql2::term::TermType;\n\nuse crate::types::Polygon;\nuse crate::Command;\n\npub(crate) fn new(polygon: Polygon) -\u003e Command {\n    let arg: Command = polygon.into();\n\n    Command::new(TermType::PolygonSub).with_arg(arg)\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::cmd::polygon::Polygon;\n    use crate::prelude::Converter;\n    use crate::types::Point;\n    use crate::{r, Result};\n\n    #[tokio::test]\n    async fn test_polygon_sub_ops() -\u003e Result\u003c()\u003e {\n        let conn = r.connection().connect().await?;\n        let expected_data = Polygon::new_from_vec(vec![\n            vec![\n                [-122.4, 37.7],\n                [-122.4, 37.3],\n                [-121.8, 37.3],\n                [-121.8, 37.7],\n                [-122.4, 37.7],\n            ],\n            vec![\n                [-122.3, 37.4],\n                [-122.3, 37.6],\n                [-122.0, 37.6],\n                [-122.0, 37.4],\n                [-122.3, 37.4],\n            ],\n        ]);\n        let outer_polygon = r.polygon(\u0026[\n            Point::new(-122.4, 37.7),\n            Point::new(-122.4, 37.3),\n            Point::new(-121.8, 37.3),\n            Point::new(-121.8, 37.7),\n        ]);\n        let inner_polygon = r.polygon(\u0026[\n            Point::new(-122.3, 37.4),\n            Point::new(-122.3, 37.6),\n            Point::new(-122.0, 37.6),\n            Point::new(-122.0, 37.4),\n        ]);\n        let response: Polygon = outer_polygon\n            .polygon_sub(inner_polygon)\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(response == expected_data);\n\n        Ok(())\n    }\n}\n","traces":[{"line":6,"address":[4354368,4354646,4354619],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":7,"address":[2313697],"length":1,"stats":{"Line":1},"fn_name":null},{"line":9,"address":[4354533,4354466],"length":1,"stats":{"Line":2},"fn_name":null},{"line":20,"address":[1762553,1762464,1762765,1762473,1762630,1763064,1762496],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":21,"address":[1762886,1763075,1763343,1762725,1762654,1762608],"length":1,"stats":{"Line":4},"fn_name":null},{"line":22,"address":[1763328,1763880,1763617,1764121],"length":1,"stats":{"Line":2},"fn_name":null},{"line":23,"address":[1763600,1763771],"length":1,"stats":{"Line":2},"fn_name":null},{"line":24,"address":[1763661],"length":1,"stats":{"Line":1},"fn_name":null},{"line":25,"address":[1763687],"length":1,"stats":{"Line":1},"fn_name":null},{"line":26,"address":[1763723],"length":1,"stats":{"Line":1},"fn_name":null},{"line":27,"address":[1763739],"length":1,"stats":{"Line":1},"fn_name":null},{"line":28,"address":[1763755],"length":1,"stats":{"Line":1},"fn_name":null},{"line":30,"address":[1763860,1764037],"length":1,"stats":{"Line":2},"fn_name":null},{"line":31,"address":[1763927],"length":1,"stats":{"Line":1},"fn_name":null},{"line":32,"address":[1763953],"length":1,"stats":{"Line":1},"fn_name":null},{"line":33,"address":[1763989],"length":1,"stats":{"Line":1},"fn_name":null},{"line":34,"address":[1764005],"length":1,"stats":{"Line":1},"fn_name":null},{"line":35,"address":[1764021],"length":1,"stats":{"Line":1},"fn_name":null},{"line":38,"address":[1764381],"length":1,"stats":{"Line":1},"fn_name":null},{"line":39,"address":[1764236],"length":1,"stats":{"Line":1},"fn_name":null},{"line":40,"address":[1764312],"length":1,"stats":{"Line":1},"fn_name":null},{"line":41,"address":[1764343],"length":1,"stats":{"Line":1},"fn_name":null},{"line":42,"address":[1764374],"length":1,"stats":{"Line":1},"fn_name":null},{"line":44,"address":[1764712],"length":1,"stats":{"Line":1},"fn_name":null},{"line":45,"address":[1764570],"length":1,"stats":{"Line":1},"fn_name":null},{"line":46,"address":[1764643],"length":1,"stats":{"Line":1},"fn_name":null},{"line":47,"address":[1764674],"length":1,"stats":{"Line":1},"fn_name":null},{"line":48,"address":[1764705],"length":1,"stats":{"Line":1},"fn_name":null},{"line":50,"address":[1764965,1765024,1765708,1765948,1765206,1764873,1765135,1765610,1765667,1765391],"length":1,"stats":{"Line":7},"fn_name":null},{"line":51,"address":[1764909],"length":1,"stats":{"Line":1},"fn_name":null},{"line":52,"address":[1765004,1765334,1765047,1765165,1762669],"length":1,"stats":{"Line":5},"fn_name":null},{"line":53,"address":[1765514],"length":1,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[1766106,1765826,1766073],"length":1,"stats":{"Line":2},"fn_name":null},{"line":59,"address":[1766079],"length":1,"stats":{"Line":5},"fn_name":null}],"covered":33,"coverable":34},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","prepend.rs"],"content":"use ql2::term::TermType;\nuse serde::Serialize;\n\nuse crate::Command;\n\npub(crate) fn new(args: impl PrependArg) -\u003e Command {\n    Command::new(TermType::Prepend).with_arg(args.into_prepend_opts())\n}\n\npub trait PrependArg {\n    fn into_prepend_opts(self) -\u003e Command;\n}\n\nimpl\u003cT\u003e PrependArg for T\nwhere\n    T: Serialize,\n{\n    fn into_prepend_opts(self) -\u003e Command {\n        Command::from_json(self)\n    }\n}\n\nimpl PrependArg for Command {\n    fn into_prepend_opts(self) -\u003e Command {\n        self\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::Converter;\n    use crate::{r, Result};\n\n    #[tokio::test]\n    async fn test_prepend_ops() -\u003e Result\u003c()\u003e {\n        let conn = r.connection().connect().await?;\n        let response: [u8; 6] = r\n            .expr([10, 20, 30, 40, 50])\n            .prepend(0)\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(response == [0, 10, 20, 30, 40, 50]);\n\n        Ok(())\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","random.rs"],"content":"use ql2::term::TermType;\nuse reql_macros::CommandOptions;\nuse serde::Serialize;\n\nuse crate::arguments::Args;\nuse crate::Command;\n\npub(crate) fn new(args: impl RandomArg) -\u003e Command {\n    let (arg1, arg2, opts) = args.into_random_opts();\n    let mut command = Command::new(TermType::Random);\n\n    if let Some(arg) = arg1 {\n        command = command.with_arg(arg)\n    }\n\n    if let Some(arg) = arg2 {\n        command = command.with_arg(arg)\n    }\n\n    command.with_opts(opts)\n}\n\npub trait RandomArg {\n    fn into_random_opts(self) -\u003e (Option\u003cCommand\u003e, Option\u003cCommand\u003e, RandomOption);\n}\n\nimpl RandomArg for () {\n    fn into_random_opts(self) -\u003e (Option\u003cCommand\u003e, Option\u003cCommand\u003e, RandomOption) {\n        (None, None, Default::default())\n    }\n}\n\nimpl RandomArg for f64 {\n    fn into_random_opts(self) -\u003e (Option\u003cCommand\u003e, Option\u003cCommand\u003e, RandomOption) {\n        (Some(Command::from_json(self)), None, Default::default())\n    }\n}\n\nimpl RandomArg for Command {\n    fn into_random_opts(self) -\u003e (Option\u003cCommand\u003e, Option\u003cCommand\u003e, RandomOption) {\n        (Some(self), None, Default::default())\n    }\n}\n\nimpl RandomArg for Args\u003c(f64, f64)\u003e {\n    fn into_random_opts(self) -\u003e (Option\u003cCommand\u003e, Option\u003cCommand\u003e, RandomOption) {\n        (\n            Some(Command::from_json(self.0 .0)),\n            Some(Command::from_json(self.0 .1)),\n            Default::default(),\n        )\n    }\n}\n\nimpl RandomArg for Args\u003c(Command, Command)\u003e {\n    fn into_random_opts(self) -\u003e (Option\u003cCommand\u003e, Option\u003cCommand\u003e, RandomOption) {\n        (Some(self.0 .0), Some(self.0 .1), Default::default())\n    }\n}\n\nimpl RandomArg for Args\u003c(f64, f64, RandomOption)\u003e {\n    fn into_random_opts(self) -\u003e (Option\u003cCommand\u003e, Option\u003cCommand\u003e, RandomOption) {\n        (\n            Some(Command::from_json(self.0 .0)),\n            Some(Command::from_json(self.0 .1)),\n            self.0 .2,\n        )\n    }\n}\n\nimpl RandomArg for Args\u003c(Command, Command, RandomOption)\u003e {\n    fn into_random_opts(self) -\u003e (Option\u003cCommand\u003e, Option\u003cCommand\u003e, RandomOption) {\n        (Some(self.0 .0), Some(self.0 .1), self.0 .2)\n    }\n}\n\n#[derive(\n    Debug, Default, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Serialize, CommandOptions,\n)]\npub struct RandomOption {\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub float: Option\u003cbool\u003e,\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::Converter;\n    use crate::{args, r, Result};\n\n    use super::RandomOption;\n\n    #[tokio::test]\n    async fn test_random_data() -\u003e Result\u003c()\u003e {\n        let conn = r.connection().connect().await?;\n        let data_obtained1: f64 = r.random(()).run(\u0026conn).await?.unwrap().parse()?;\n        let data_obtained2: isize = r.random(100.).run(\u0026conn).await?.unwrap().parse()?;\n        let data_obtained3: f64 = r\n            .random(args!(-100.52, -10.71, RandomOption::default().float(true)))\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(data_obtained1.is_normal());\n        assert!(data_obtained2 \u003e= 0);\n        assert!(data_obtained3.is_normal());\n\n        Ok(())\n    }\n}\n","traces":[{"line":7,"address":[2386077,2388114,2387296,2385216,2388228,2387207,2386191,2386272,2387093],"length":1,"stats":{"Line":3},"fn_name":"new\u003c(f64, f64, reql_rust::cmd::random::RandomOption)\u003e"},{"line":8,"address":[2385236,2387316,2386297],"length":1,"stats":{"Line":3},"fn_name":null},{"line":9,"address":[2386428,2387447,2385410],"length":1,"stats":{"Line":3},"fn_name":null},{"line":11,"address":[2386767,2386525,2387786,2385507,2385749,2387544],"length":1,"stats":{"Line":5},"fn_name":null},{"line":12,"address":[2387665,2387760,2386741,2386646,2385628,2385723],"length":1,"stats":{"Line":4},"fn_name":null},{"line":15,"address":[2387788,2385751,2385685,2385977,2386703,2386993,2388014,2387722,2386769],"length":1,"stats":{"Line":5},"fn_name":null},{"line":16,"address":[2387872,2386853,2385835,2386967,2385951,2387988],"length":1,"stats":{"Line":2},"fn_name":null},{"line":19,"address":[2387962,2385925,2386942],"length":1,"stats":{"Line":3},"fn_name":null},{"line":27,"address":[4891131,4890944,4891108],"length":1,"stats":{"Line":1},"fn_name":"into_random_opts"},{"line":28,"address":[4890961,4891124],"length":1,"stats":{"Line":1},"fn_name":null},{"line":33,"address":[4891378,4891355,4891152],"length":1,"stats":{"Line":1},"fn_name":"into_random_opts"},{"line":34,"address":[4891371,4891177],"length":1,"stats":{"Line":1},"fn_name":null},{"line":39,"address":[4891635,4891408,4891612],"length":1,"stats":{"Line":0},"fn_name":"into_random_opts"},{"line":40,"address":[4891434,4891628],"length":1,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[4891955,4891664],"length":1,"stats":{"Line":0},"fn_name":"into_random_opts"},{"line":47,"address":[4891702],"length":1,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[4891755,4891827],"length":1,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[4891829],"length":1,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[4891984,4892279],"length":1,"stats":{"Line":0},"fn_name":"into_random_opts"},{"line":57,"address":[4892025],"length":1,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[4892151,4892079],"length":1,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[4892153],"length":1,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[4892320,4892562],"length":1,"stats":{"Line":0},"fn_name":"into_random_opts"},{"line":67,"address":[4892342],"length":1,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[4892446,4892390],"length":1,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[4892482],"length":1,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[4892592,4892836],"length":1,"stats":{"Line":1},"fn_name":"into_random_opts"},{"line":77,"address":[4892614],"length":1,"stats":{"Line":1},"fn_name":null},{"line":78,"address":[4892720,4892663],"length":1,"stats":{"Line":2},"fn_name":null},{"line":79,"address":[4892756],"length":1,"stats":{"Line":1},"fn_name":null},{"line":100,"address":[1678615,1678576,1679029,1678981],"length":1,"stats":{"Line":6},"fn_name":"test_random_data"},{"line":101,"address":[2214630,2214089,2214891,2214441,2214279,2214052],"length":1,"stats":{"Line":4},"fn_name":null},{"line":102,"address":[2215900,2215800,2214881,2215136,2214107,2214236],"length":1,"stats":{"Line":5},"fn_name":null},{"line":103,"address":[6888065,6888014],"length":1,"stats":{"Line":5},"fn_name":null},{"line":104,"address":[2218053,2217552,2217851,2217366,2217156,2217828,2217771,2217295],"length":1,"stats":{"Line":5},"fn_name":null},{"line":105,"address":[2216871,2217074],"length":1,"stats":{"Line":2},"fn_name":null},{"line":106,"address":[2217207,2214137,2217494,2217325],"length":1,"stats":{"Line":4},"fn_name":null},{"line":107,"address":[2217675],"length":1,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[2218144,2218171,2217938],"length":1,"stats":{"Line":2},"fn_name":null},{"line":112,"address":[2218220,2218155],"length":1,"stats":{"Line":1},"fn_name":null},{"line":113,"address":[2218209,2218287,2218254],"length":1,"stats":{"Line":2},"fn_name":null},{"line":115,"address":[1678992,1678712,1678607,1678652],"length":1,"stats":{"Line":5},"fn_name":null}],"covered":27,"coverable":42},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","range.rs"],"content":"use ql2::term::TermType;\n\nuse crate::{arguments::Args, Command};\n\npub(crate) fn new(args: impl RangeArg) -\u003e Command {\n    let (arg1, arg2) = args.into_range_opts();\n    let mut command = Command::new(TermType::Range);\n\n    if let Some(arg) = arg1 {\n        command = command.with_arg(arg)\n    }\n\n    if let Some(arg) = arg2 {\n        command = command.with_arg(arg)\n    }\n\n    command\n}\n\npub trait RangeArg {\n    fn into_range_opts(self) -\u003e (Option\u003cCommand\u003e, Option\u003cCommand\u003e);\n}\n\nimpl RangeArg for () {\n    fn into_range_opts(self) -\u003e (Option\u003cCommand\u003e, Option\u003cCommand\u003e) {\n        (None, None)\n    }\n}\n\nimpl RangeArg for isize {\n    fn into_range_opts(self) -\u003e (Option\u003cCommand\u003e, Option\u003cCommand\u003e) {\n        (None, Some(Command::from_json(self)))\n    }\n}\n\nimpl RangeArg for Args\u003c(isize, isize)\u003e {\n    fn into_range_opts(self) -\u003e (Option\u003cCommand\u003e, Option\u003cCommand\u003e) {\n        (\n            Some(Command::from_json(self.0 .0)),\n            Some(Command::from_json(self.0 .1)),\n        )\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::Converter;\n    use crate::{args, r, Result};\n\n    #[tokio::test]\n    async fn test_range_data() -\u003e Result\u003c()\u003e {\n        let data = [0, 1, 2, 3];\n        let data2 = [-5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5];\n        let conn = r.connection().connect().await?;\n        let response: [isize; 4] = r.range(4).run(\u0026conn).await?.unwrap().parse()?;\n        let response2: [isize; 4] = r.range(()).limit(4).run(\u0026conn).await?.unwrap().parse()?;\n        let response3: [isize; 11] = r.range(args!(-5, 6)).run(\u0026conn).await?.unwrap().parse()?;\n\n        assert!(response == data);\n        assert!(response2 == data);\n        assert!(response3 == data2);\n\n        Ok(())\n    }\n}\n","traces":[{"line":5,"address":[2266153,2263408,2264273,2264352,2266042,2265296,2265112,2265223,2264162],"length":1,"stats":{"Line":3},"fn_name":"new\u003cisize\u003e"},{"line":6,"address":[2265313,2263433,2264385],"length":1,"stats":{"Line":3},"fn_name":null},{"line":7,"address":[2264495,2263543,2265423],"length":1,"stats":{"Line":3},"fn_name":null},{"line":9,"address":[2265520,2265756,2263876,2263640,2264828,2264592],"length":1,"stats":{"Line":4},"fn_name":null},{"line":10,"address":[2265635,2263755,2264802,2265730,2263850,2264707],"length":1,"stats":{"Line":2},"fn_name":null},{"line":13,"address":[2265983,2265692,2264103,2264830,2263878,2264764,2265758,2265053,2263812],"length":1,"stats":{"Line":7},"fn_name":null},{"line":14,"address":[2265842,2263962,2265957,2265027,2264913,2264077],"length":1,"stats":{"Line":4},"fn_name":null},{"line":17,"address":[2265904,2264974,2264024],"length":1,"stats":{"Line":3},"fn_name":null},{"line":25,"address":[6929664],"length":1,"stats":{"Line":1},"fn_name":"into_range_opts"},{"line":26,"address":[2838563],"length":1,"stats":{"Line":1},"fn_name":null},{"line":31,"address":[2757008,2757188],"length":1,"stats":{"Line":1},"fn_name":"into_range_opts"},{"line":32,"address":[2838681],"length":1,"stats":{"Line":1},"fn_name":null},{"line":37,"address":[6664720,6664939],"length":1,"stats":{"Line":1},"fn_name":"into_range_opts"},{"line":39,"address":[2662949],"length":1,"stats":{"Line":1},"fn_name":null},{"line":40,"address":[6664809,6664850],"length":1,"stats":{"Line":2},"fn_name":null},{"line":51,"address":[4796791,4796752,4797157,4797205],"length":1,"stats":{"Line":6},"fn_name":"test_range_data"},{"line":52,"address":[6392964],"length":1,"stats":{"Line":1},"fn_name":null},{"line":53,"address":[6392995],"length":1,"stats":{"Line":1},"fn_name":null},{"line":54,"address":[6393954,6393128,6393489,6393681,6393091,6393324],"length":1,"stats":{"Line":4},"fn_name":null},{"line":55,"address":[6394186,6393944,6393279,6395019,6393146,6394885],"length":1,"stats":{"Line":5},"fn_name":null},{"line":56,"address":[6395260,6395009,6393234,6395971,6393161,6396180],"length":1,"stats":{"Line":5},"fn_name":null},{"line":57,"address":[6397069,6397339,6393176,6396090,6396370],"length":1,"stats":{"Line":4},"fn_name":null},{"line":59,"address":[6397558,6397526,6397318],"length":1,"stats":{"Line":2},"fn_name":null},{"line":60,"address":[6397594,6397628,6397537],"length":1,"stats":{"Line":2},"fn_name":null},{"line":61,"address":[6397699,6397605,6397662],"length":1,"stats":{"Line":2},"fn_name":null},{"line":63,"address":[4796888,4797168,4796783,4796828],"length":1,"stats":{"Line":5},"fn_name":null}],"covered":26,"coverable":26},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","rebalance.rs"],"content":"use ql2::term::TermType;\n\nuse crate::Command;\n\npub(crate) fn new() -\u003e Command {\n    Command::new(TermType::Rebalance)\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::Converter;\n    use crate::spec::{set_up, tear_down};\n    use crate::types::RebalanceResponse;\n    use crate::Result;\n\n    #[tokio::test]\n    async fn test_rebalance_table() -\u003e Result\u003c()\u003e {\n        let (conn, table, table_name) = set_up(true).await?;\n        let response: RebalanceResponse = table.rebalance().run(\u0026conn).await?.unwrap().parse()?;\n\n        assert!(response.rebalanced == 1);\n\n        tear_down(conn, \u0026table_name).await\n    }\n}\n","traces":[{"line":5,"address":[2720096],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":6,"address":[2720108],"length":1,"stats":{"Line":1},"fn_name":null},{"line":17,"address":[3069912,3070204,3069497,3069520,3069686,3069488,3069589],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":18,"address":[3069651,3070037,3070215,3070647,3069716,3069869],"length":1,"stats":{"Line":4},"fn_name":null},{"line":19,"address":[3069820,3071807,3070904,3070599,3069737,3071613],"length":1,"stats":{"Line":5},"fn_name":null},{"line":21,"address":[3072106,3071785],"length":1,"stats":{"Line":1},"fn_name":null},{"line":23,"address":[3072604,3072474,3069755,3072063,3072219,3072343,3072399],"length":1,"stats":{"Line":7},"fn_name":null}],"covered":7,"coverable":7},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","reconfigure.rs"],"content":"use std::borrow::Cow;\nuse std::collections::HashMap;\n\nuse ql2::term::TermType;\nuse reql_macros::CommandOptions;\nuse serde::{Serialize, Serializer};\n\nuse crate::arguments::{EmergencyRepair, Replicas};\nuse crate::Command;\n\npub(crate) fn new(opts: ReconfigureOption) -\u003e Command {\n    Command::new(TermType::Reconfigure).with_opts(opts)\n}\n\n#[derive(Debug, Clone, Default, PartialEq, CommandOptions)]\n#[non_exhaustive]\npub struct ReconfigureOption {\n    /// the number of shards, an integer from 1-64. Required.\n    pub shards: Option\u003cu8\u003e,\n    /// either an usize or a mapping struct. Required.\n    /// - If `replicas` is an usize, it specifies the number of replicas per shard.\n    /// Specifying more replicas than there are servers will return an error.\n    /// - If `replicas` is an struct, it specifies key-value pairs of server tags\n    /// and the number of replicas to assign to those servers:\n    /// `{\"tag1\": 2, \"tag2\": 4, \"tag3\": 2, ...}`.\n    /// For more information about server tags, read\n    /// [Administration tools](https://rethinkdb.com/docs/administration-tools/).\n    pub replicas: Option\u003cReplicas\u003e,\n    /// the generated configuration will not be applied to the table, only returned.\n    pub dry_run: Option\u003cbool\u003e,\n    /// Used for the Emergency Repair mode.\n    /// See \u003chttps://rethinkdb.com/api/python/reconfigure#emergency-repair-mode\u003e\n    /// for more information.\n    pub emergency_repair: Option\u003cEmergencyRepair\u003e,\n}\n\nimpl Serialize for ReconfigureOption {\n    fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    where\n        S: Serializer,\n    {\n        #[derive(Serialize)]\n        struct InnerOptions\u003c'a\u003e {\n            #[serde(skip_serializing_if = \"Option::is_none\")]\n            dry_run: Option\u003cbool\u003e,\n            #[serde(skip_serializing_if = \"Option::is_none\")]\n            emergency_repair: Option\u003cEmergencyRepair\u003e,\n            #[serde(skip_serializing_if = \"Option::is_none\")]\n            shards: Option\u003cu8\u003e,\n            #[serde(skip_serializing_if = \"Option::is_none\")]\n            replicas: Option\u003cInnerReplicas\u003c'a\u003e\u003e,\n            /// the primary server specified by its server tag.\n            /// Required if `replicas` is an object; the tag must be in the object.\n            /// This must not be specified if `replicas` is an usize.\n            #[serde(skip_serializing_if = \"Option::is_none\")]\n            primary_replica_tag: Option\u003c\u0026'a Cow\u003c'static, str\u003e\u003e,\n        }\n\n        #[derive(Serialize)]\n        #[serde(untagged)]\n        enum InnerReplicas\u003c'a\u003e {\n            Int(usize),\n            Map(\u0026'a HashMap\u003cCow\u003c'static, str\u003e, usize\u003e),\n        }\n\n        let (replicas, primary_replica_tag) = match \u0026self.replicas {\n            Some(Replicas::Int(i)) =\u003e (Some(InnerReplicas::Int(*i)), None),\n            Some(Replicas::Map {\n                replicas,\n                primary_replica_tag,\n            }) =\u003e (\n                Some(InnerReplicas::Map(replicas)),\n                Some(primary_replica_tag),\n            ),\n            None =\u003e (None, None),\n        };\n\n        let opts = InnerOptions {\n            dry_run: self.dry_run,\n            emergency_repair: self.emergency_repair,\n            replicas,\n            primary_replica_tag,\n            shards: self.shards,\n        };\n\n        opts.serialize(serializer)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::arguments::Replicas;\n    use crate::prelude::Converter;\n    use crate::spec::{set_up, tear_down};\n    use crate::types::ReconfigureResponse;\n    use crate::Result;\n\n    use super::ReconfigureOption;\n\n    #[tokio::test]\n    async fn test_reconfigure_table() -\u003e Result\u003c()\u003e {\n        let (conn, table, table_name) = set_up(true).await?;\n        let reconfigure_option = ReconfigureOption::default()\n            .shards(2)\n            .replicas(Replicas::Int(1));\n        let response: ReconfigureResponse = table\n            .reconfigure(reconfigure_option)\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(response.reconfigured == 1);\n\n        tear_down(conn, \u0026table_name).await\n    }\n}\n","traces":[{"line":11,"address":[4310864,4311095,4311122],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":12,"address":[2516507,2516406],"length":1,"stats":{"Line":2},"fn_name":null},{"line":38,"address":[2306928],"length":1,"stats":{"Line":1},"fn_name":"serialize\u003cserde_json::value::ser::Serializer\u003e"},{"line":66,"address":[5117476,5117390,5117706],"length":1,"stats":{"Line":3},"fn_name":null},{"line":67,"address":[5117493],"length":1,"stats":{"Line":1},"fn_name":null},{"line":68,"address":[2388798],"length":1,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[2388825],"length":1,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[5117655],"length":1,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[2388635],"length":1,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[2388955],"length":1,"stats":{"Line":1},"fn_name":null},{"line":80,"address":[2388959],"length":1,"stats":{"Line":1},"fn_name":null},{"line":83,"address":[2388989],"length":1,"stats":{"Line":1},"fn_name":null},{"line":86,"address":[2389068],"length":1,"stats":{"Line":1},"fn_name":null},{"line":101,"address":[4505340,4504725,4504822,4504624,4504656,4504633,4505048],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":102,"address":[4505351,4504852,4505005,4504787,4505173,4505731],"length":1,"stats":{"Line":4},"fn_name":null},{"line":103,"address":[4505721,4506061,4506006],"length":1,"stats":{"Line":3},"fn_name":null},{"line":105,"address":[4506013],"length":1,"stats":{"Line":1},"fn_name":null},{"line":106,"address":[4506407,4507234,4506484,4506076,4506898,4506679,4506232,4506955,4506999,4506290],"length":1,"stats":{"Line":7},"fn_name":null},{"line":107,"address":[4506120],"length":1,"stats":{"Line":1},"fn_name":null},{"line":108,"address":[4506612,4504956,4506313,4506440,4504873],"length":1,"stats":{"Line":5},"fn_name":null},{"line":109,"address":[4506802],"length":1,"stats":{"Line":0},"fn_name":null},{"line":113,"address":[4507116,4507414],"length":1,"stats":{"Line":1},"fn_name":null},{"line":115,"address":[1679103,1679148,1679208,1679488],"length":1,"stats":{"Line":7},"fn_name":null}],"covered":18,"coverable":26},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","reduce.rs"],"content":"use ql2::term::TermType;\n\nuse crate::prelude::Func;\nuse crate::Command;\n\npub(crate) fn new(func: Func) -\u003e Command {\n    Command::new(TermType::Reduce).with_arg(func.0)\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::*;\n    use crate::spec::{set_up, tear_down, Post};\n    use crate::{r, Result};\n\n    #[tokio::test]\n    async fn test_reduce_ops() -\u003e Result\u003c()\u003e {\n        let post_number = Post::get_many_data().len();\n        let (conn, table, table_name) = set_up(true).await?;\n        let response: usize = table\n            .map(func!(|| r.expr(1)))\n            .reduce(func!(|left, right| left + right))\n            .default(0)\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(response == post_number);\n\n        tear_down(conn, \u0026table_name).await\n    }\n}\n","traces":[{"line":7,"address":[4209887,4209264,4209908],"length":1,"stats":{"Line":0},"fn_name":"new\u003creql_rust::cmd::func::Func\u003e"},{"line":8,"address":[4209281],"length":1,"stats":{"Line":0},"fn_name":null},{"line":9,"address":[2771786],"length":1,"stats":{"Line":0},"fn_name":null},{"line":11,"address":[4209491,4209795],"length":1,"stats":{"Line":0},"fn_name":null},{"line":12,"address":[2772150,2771979],"length":1,"stats":{"Line":0},"fn_name":null},{"line":15,"address":[4209705],"length":1,"stats":{"Line":0},"fn_name":null},{"line":23,"address":[7021168],"length":1,"stats":{"Line":0},"fn_name":"into_reduce_opts"},{"line":24,"address":[7021185],"length":1,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[4044560],"length":1,"stats":{"Line":0},"fn_name":"into_reduce_opts"},{"line":30,"address":[4044581],"length":1,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[4044607],"length":1,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[5127249,5126992],"length":1,"stats":{"Line":0},"fn_name":"into_reduce_opts"},{"line":38,"address":[5127013],"length":1,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[5127077,5127136],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":14},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","rem.rs"],"content":"use std::ops::Rem;\n\nuse ql2::term::TermType;\n\nuse crate::Command;\n\nimpl\u003cT: RemArg\u003e Rem\u003cT\u003e for Command {\n    type Output = Self;\n\n    fn rem(self, arg: T) -\u003e Self {\n        Command::new(TermType::Mod)\n            .with_arg(arg.into_rem_opts())\n            .with_parent(self)\n    }\n}\n\npub trait RemArg {\n    fn into_rem_opts(self) -\u003e Command;\n}\n\nimpl RemArg for f64 {\n    fn into_rem_opts(self) -\u003e Command {\n        Command::from_json(self)\n    }\n}\n\nimpl RemArg for Command {\n    fn into_rem_opts(self) -\u003e Command {\n        self\n    }\n}\n\n// TODO write test\n","traces":[{"line":10,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":11,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":12,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":13,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[6929984],"length":1,"stats":{"Line":0},"fn_name":"into_rem_opts"},{"line":23,"address":[6930002],"length":1,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[4044752],"length":1,"stats":{"Line":0},"fn_name":"into_rem_opts"},{"line":29,"address":[4044760],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":8},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","replace.rs"],"content":"use ql2::term::TermType;\nuse reql_macros::CommandOptions;\nuse serde::Serialize;\n\nuse crate::arguments::{Args, Durability, ReturnChanges};\nuse crate::Command;\n\nuse super::func::Func;\n\npub(crate) fn new(args: impl ReplaceArg) -\u003e Command {\n    let (arg, opts) = args.into_replace_opts();\n\n    Command::new(TermType::Replace)\n        .with_arg(arg)\n        .with_opts(opts)\n}\n\npub trait ReplaceArg {\n    fn into_replace_opts(self) -\u003e (Command, ReplaceOption);\n}\n\nimpl\u003cT\u003e ReplaceArg for T\nwhere\n    T: Serialize,\n{\n    fn into_replace_opts(self) -\u003e (Command, ReplaceOption) {\n        (Command::from_json(self), Default::default())\n    }\n}\n\nimpl ReplaceArg for Command {\n    fn into_replace_opts(self) -\u003e (Command, ReplaceOption) {\n        (self, Default::default())\n    }\n}\n\nimpl ReplaceArg for Func {\n    fn into_replace_opts(self) -\u003e (Command, ReplaceOption) {\n        (self.0, Default::default())\n    }\n}\n\nimpl\u003cT\u003e ReplaceArg for Args\u003c(T, ReplaceOption)\u003e\nwhere\n    T: Serialize,\n{\n    fn into_replace_opts(self) -\u003e (Command, ReplaceOption) {\n        (Command::from_json(self.0 .0), self.0 .1)\n    }\n}\n\nimpl ReplaceArg for Args\u003c(Command, ReplaceOption)\u003e {\n    fn into_replace_opts(self) -\u003e (Command, ReplaceOption) {\n        (self.0 .0, self.0 .1)\n    }\n}\n\nimpl ReplaceArg for Args\u003c(Func, ReplaceOption)\u003e {\n    fn into_replace_opts(self) -\u003e (Command, ReplaceOption) {\n        (self.0 .0 .0, self.0 .1)\n    }\n}\n\n#[derive(Debug, Clone, Copy, Serialize, Default, PartialEq, PartialOrd, CommandOptions)]\npub struct ReplaceOption {\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub durability: Option\u003cDurability\u003e,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub return_changes: Option\u003cReturnChanges\u003e,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub non_atomic: Option\u003cbool\u003e,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub ignore_write_hook: Option\u003cbool\u003e,\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::*;\n    use crate::spec::*;\n    use crate::types::MutationResponse;\n    use crate::Result;\n\n    #[tokio::test]\n    async fn test_replace_docs() -\u003e Result\u003c()\u003e {\n        let data = Post::get_one_data();\n        let (conn, table, table_name) = set_up(true).await?;\n        let response: MutationResponse = table\n            .get(1)\n            .replace(data)\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(response.replaced == 1);\n\n        tear_down(conn, \u0026table_name).await\n    }\n\n    #[tokio::test]\n    async fn test_replace_docs_with_func() -\u003e Result\u003c()\u003e {\n        let lenght = Post::get_many_data().len();\n        let (conn, table, table_name) = set_up(true).await?;\n        let response: MutationResponse = table\n            .replace(func!(|post| post.without(\"view\")))\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(response.replaced == lenght);\n\n        tear_down(conn, \u0026table_name).await\n    }\n}\n","traces":[{"line":22,"address":[5127493,5127280],"length":1,"stats":{"Line":0},"fn_name":"into_replace_opts"},{"line":23,"address":[5127297],"length":1,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[4044987,4044784],"length":1,"stats":{"Line":0},"fn_name":"into_replace_opts"},{"line":29,"address":[2260211],"length":1,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[5127520],"length":1,"stats":{"Line":0},"fn_name":"into_replace_opts"},{"line":35,"address":[5127542],"length":1,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[4045024],"length":1,"stats":{"Line":0},"fn_name":"into_replace_opts"},{"line":41,"address":[4045045],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":8},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","round.rs"],"content":"use ql2::term::TermType;\n\nuse crate::Command;\n\npub(crate) fn new(args: impl RoundArg) -\u003e Command {\n    let mut command = Command::new(TermType::Round);\n\n    if let Some(arg) = args.into_round_opts() {\n        command = command.with_arg(arg)\n    }\n\n    command\n}\n\npub trait RoundArg {\n    fn into_round_opts(self) -\u003e Option\u003cCommand\u003e;\n}\n\nimpl RoundArg for () {\n    fn into_round_opts(self) -\u003e Option\u003cCommand\u003e {\n        None\n    }\n}\n\nimpl RoundArg for Command {\n    fn into_round_opts(self) -\u003e Option\u003cCommand\u003e {\n        Some(self)\n    }\n}\n\nimpl RoundArg for f64 {\n    fn into_round_opts(self) -\u003e Option\u003cCommand\u003e {\n        Some(Command::from_json(self))\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::Converter;\n    use crate::{r, Result};\n\n    #[tokio::test]\n    async fn test_round_data() -\u003e Result\u003c()\u003e {\n        let conn = r.connection().connect().await?;\n        let data_obtained: u8 = r.round(12.345).run(\u0026conn).await?.unwrap().parse()?;\n        let data_obtained2: u8 = r.expr(12.345).round().run(\u0026conn).await?.unwrap().parse()?;\n        let data_obtained3: u8 = r.round(r.expr(12.345)).run(\u0026conn).await?.unwrap().parse()?;\n\n        assert!(\n            data_obtained == 12\n                \u0026\u0026 data_obtained == data_obtained2\n                \u0026\u0026 data_obtained == data_obtained3\n        );\n\n        Ok(())\n    }\n}\n","traces":[{"line":5,"address":[4470646,4471215,4470096,4470688],"length":1,"stats":{"Line":1},"fn_name":"new\u003cf64\u003e"},{"line":6,"address":[4470800,4470708,4470131,4470229],"length":1,"stats":{"Line":2},"fn_name":null},{"line":8,"address":[2610305,2611231,2610954,2610892,2610646,2610367],"length":1,"stats":{"Line":3},"fn_name":null},{"line":9,"address":[2692853,2692268,2692708,2692122],"length":1,"stats":{"Line":2},"fn_name":null},{"line":12,"address":[2611256,2610671],"length":1,"stats":{"Line":1},"fn_name":null},{"line":20,"address":[2839552],"length":1,"stats":{"Line":0},"fn_name":"into_round_opts"},{"line":21,"address":[2839556],"length":1,"stats":{"Line":0},"fn_name":null},{"line":26,"address":[4106752],"length":1,"stats":{"Line":1},"fn_name":"into_round_opts"},{"line":27,"address":[4106778],"length":1,"stats":{"Line":1},"fn_name":null},{"line":37,"address":[4218229,4218277,4217824,4217863],"length":1,"stats":{"Line":6},"fn_name":"test_round_data"},{"line":38,"address":[4595114,4594764,4595383,4594659,4594693,4594925],"length":1,"stats":{"Line":4},"fn_name":null},{"line":39,"address":[4595611,4594708,4596311,4596400,4595373],"length":1,"stats":{"Line":4},"fn_name":null},{"line":41,"address":[4596608,4596380],"length":1,"stats":{"Line":1},"fn_name":null},{"line":43,"address":[4217855,4217960,4218240,4217900],"length":1,"stats":{"Line":5},"fn_name":null}],"covered":12,"coverable":14},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","run.rs"],"content":"use std::borrow::Cow;\nuse std::sync::atomic::Ordering;\nuse std::{mem, str};\n\nuse async_stream::try_stream;\nuse futures::io::{AsyncReadExt, AsyncWriteExt};\nuse futures::stream::{Stream, StreamExt};\nuse futures::{AsyncRead, AsyncWrite};\nuse ql2::query::QueryType;\nuse ql2::response::{ErrorType, ResponseType};\nuse reql_macros::CommandOptions;\nuse serde::de::DeserializeOwned;\nuse serde::{Deserialize, Serialize};\nuse serde_json::Value;\nuse tracing::trace;\n\nuse crate::arguments::{Args, Durability, Format, ReadMode};\nuse crate::constants::{DATA_SIZE, DEFAULT_RETHINKDB_DBNAME, HEADER_SIZE, TOKEN_SIZE};\nuse crate::proto::{Payload, Query};\nuse crate::{err, Command, Connection, Result, Session};\n\n#[derive(Deserialize, Debug)]\n#[allow(dead_code)]\npub(crate) struct Response {\n    t: i32,\n    e: Option\u003ci32\u003e,\n    pub(crate) r: Value,\n    b: Option\u003cValue\u003e,\n    p: Option\u003cValue\u003e,\n    n: Option\u003cValue\u003e,\n}\n\nimpl Response {\n    fn new() -\u003e Self {\n        Self {\n            t: ResponseType::SuccessAtom as i32,\n            e: None,\n            r: Value::Array(Vec::new()),\n            b: None,\n            p: None,\n            n: None,\n        }\n    }\n}\n\n#[derive(Debug, Clone, CommandOptions, Serialize, Default, PartialEq, PartialOrd)]\npub struct RunOption {\n    /// One of three possible values affecting\n    /// the consistency guarantee for the query (default: `ReadMode::Single`).\n    /// - `ReadMode::Single` (the default) returns values that are in memory\n    /// (but not necessarily written to disk) on the primary replica.\n    /// - `ReadMode::Majority` will only return values that are safely\n    /// committed on disk on a majority of replicas.\n    /// This requires sending a message to every replica on each read,\n    /// so it is the slowest but most consistent.\n    /// - `ReadMode::Outdated` will return values that are in memory\n    /// on an arbitrarily-selected replica.\n    /// This is the fastest but least consistent.\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub read_mode: Option\u003cReadMode\u003e,\n    /// what format to return times in (default: `Format::Native`).\n    /// Set this to `Format::Raw`\n    /// if you want times returned as JSON objects for exporting.\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub time_format: Option\u003cFormat\u003e,\n    /// whether or not to return a profile\n    /// of the query’s execution (default: `false`).\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub profile: Option\u003cbool\u003e,\n    /// possible values are `Durability::Hard` and `Durability::Soft`.\n    /// In soft durability mode RethinkDB will acknowledge\n    /// the write immediately after receiving it,\n    /// but before the write has been committed to disk.\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub durability: Option\u003cDurability\u003e,\n    /// what format to return `grouped_data` and\n    /// `grouped_streams` in (default: `Format::Native`).\n    /// Set this to `Format::Raw` if you want the raw pseudotype.\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub group_format: Option\u003cFormat\u003e,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub noreply: Option\u003cbool\u003e,\n    /// the database to run this query against as a string.\n    /// The default is the database specified in\n    /// the `db` [connection](crate::connection::Connection)\n    /// method (which defaults to `test`).\n    /// The database may also be specified with the db command.\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub db: Option\u003cDb\u003e,\n    /// the maximum numbers of array elements\n    /// that can be returned by a query (default: 100,000).\n    /// This affects all ReQL commands that return arrays.\n    /// Note that it has no effect on the size of arrays\n    /// being **written** to the database;\n    /// those always have an upper limit of 100,000 elements.\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub array_limit: Option\u003cusize\u003e,\n    /// what format to return binary data in (default: `Format::Native`).\n    /// Set this to `Format::Raw` if you want the raw pseudotype.\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub binary_format: Option\u003cFormat\u003e,\n    /// minimum number of rows to wait for before batching\n    /// a result set (default: 8). This is an usize.\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub min_batch_rows: Option\u003cusize\u003e,\n    /// maximum number of rows to wait for before batching\n    /// a result set (default: unlimited). This is an usize.\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub max_batch_rows: Option\u003cusize\u003e,\n    /// maximum number of bytes to wait for before batching\n    /// a result set (default: 1MB). This is an usize.\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub max_batch_bytes: Option\u003cusize\u003e,\n    /// maximum number of seconds to wait before batching\n    /// a result set (default: 0.5).\n    /// This is a f64 and may be specified to the microsecond.\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub max_batch_seconds: Option\u003cf64\u003e,\n    /// factor to scale the other parameters down by on the first batch (default: 4).\n    /// For example, with this set to 8 and `max_batch_rows` set to 80,\n    /// on the first batch `max_batch_rows` will be adjusted to 10 (80 / 8).\n    /// This allows the first batch to return faster.\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub first_batch_scaledown_factor: Option\u003cusize\u003e,\n}\n\n#[derive(Debug, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]\npub struct Db(pub Cow\u003c'static, str\u003e);\n\nimpl RunOption {\n    async fn default_db(self, session: \u0026Session) -\u003e RunOption {\n        let session_db = session.inner.db.lock().await;\n        if self.db.is_none() \u0026\u0026 *session_db != DEFAULT_RETHINKDB_DBNAME {\n            return self.db(\u0026*session_db);\n        }\n        self\n    }\n}\n\npub trait RunArg {\n    fn into_run_opts(self) -\u003e Result\u003c(Connection, RunOption)\u003e;\n}\n\nimpl RunArg for \u0026Session {\n    fn into_run_opts(self) -\u003e Result\u003c(Connection, RunOption)\u003e {\n        let conn = self.connection()?;\n        Ok((conn, Default::default()))\n    }\n}\n\nimpl RunArg for Connection {\n    fn into_run_opts(self) -\u003e Result\u003c(Connection, RunOption)\u003e {\n        Ok((self, Default::default()))\n    }\n}\n\nimpl RunArg for Args\u003c(\u0026Session, RunOption)\u003e {\n    fn into_run_opts(self) -\u003e Result\u003c(Connection, RunOption)\u003e {\n        let Args((session, options)) = self;\n        let conn = session.connection()?;\n        Ok((conn, options))\n    }\n}\n\nimpl RunArg for Args\u003c(Connection, RunOption)\u003e {\n    fn into_run_opts(self) -\u003e Result\u003c(Connection, RunOption)\u003e {\n        let Args(arg) = self;\n        Ok(arg)\n    }\n}\n\nimpl RunArg for \u0026mut Session {\n    fn into_run_opts(self) -\u003e Result\u003c(Connection, RunOption)\u003e {\n        self.connection()?.into_run_opts()\n    }\n}\n\nimpl RunArg for Args\u003c(\u0026mut Session, RunOption)\u003e {\n    fn into_run_opts(self) -\u003e Result\u003c(Connection, RunOption)\u003e {\n        let Args((session, options)) = self;\n        let conn = session.connection()?;\n\n        Args((conn, options)).into_run_opts()\n    }\n}\n\npub(crate) fn new\u003cA, T\u003e(query: Command, arg: A) -\u003e impl Stream\u003cItem = Result\u003cT\u003e\u003e\nwhere\n    A: RunArg,\n    T: Unpin + DeserializeOwned,\n{\n    try_stream! {\n        let (mut conn, mut opts) = arg.into_run_opts()?;\n        opts = opts.default_db(\u0026conn.session).await;\n        let change_feed = query.change_feed();\n        if change_feed {\n            conn.session.inner.mark_change_feed();\n        }\n        let noreply = opts.noreply.unwrap_or_default();\n        let mut payload = Payload(QueryType::Start, Some(Query(\u0026query)), opts);\n\n        loop {\n            let (response_type, resp) = conn.request(\u0026payload, noreply).await?;\n            trace!(\"yielding response; token: {}\", conn.token);\n\n            match response_type {\n                ResponseType::SuccessAtom | ResponseType::ServerInfo =\u003e {\n                    for val in serde_json::from_value::\u003cVec\u003cT\u003e\u003e(resp.r)? {\n                        yield val;\n                    }\n                    break;\n                }\n                ResponseType::SuccessSequence =\u003e {\n                    yield serde_json::from_value::\u003cT\u003e(resp.r)?;\n                    break;\n                }\n                ResponseType::SuccessPartial =\u003e {\n                    if conn.closed() {\n                        // reopen so we can use the connection in future\n                        conn.set_closed(false);\n                        trace!(\"connection closed; token: {}\", conn.token);\n                        break;\n                    }\n                    payload = Payload(QueryType::Continue, None, Default::default());\n                    // for val in serde_json::from_value::\u003cVec\u003cT\u003e\u003e(resp.r)? {\n                    //     yield val;\n                    // }\n                    yield serde_json::from_value::\u003cT\u003e(resp.r)?;\n                    continue;\n                }\n                ResponseType::WaitComplete =\u003e { break; }\n                typ =\u003e {\n                    let msg = error_message(resp.r)?;\n                    match typ {\n                        // This feed has been closed by conn.close().\n                        ResponseType::ClientError if change_feed \u0026\u0026 msg.contains(\"not in stream cache\") =\u003e { break; }\n                        _ =\u003e Err(response_error(typ, resp.e, msg))?,\n                    }\n                }\n            }\n        }\n    }\n}\n\nimpl Payload\u003c'_\u003e {\n    fn encode(\u0026self, token: u64) -\u003e Result\u003cVec\u003cu8\u003e\u003e {\n        let bytes = self.to_bytes()?;\n        let data_len = bytes.len();\n        let mut buf = Vec::with_capacity(HEADER_SIZE + data_len);\n        buf.extend_from_slice(\u0026token.to_le_bytes());\n        buf.extend_from_slice(\u0026(data_len as u32).to_le_bytes());\n        buf.extend_from_slice(\u0026bytes);\n        Ok(buf)\n    }\n}\n\nimpl Connection {\n    fn send_response(\u0026self, db_token: u64, resp: Result\u003c(ResponseType, Response)\u003e) {\n        if let Some(tx) = self.session.inner.channels.get(\u0026db_token) {\n            if let Err(error) = tx.unbounded_send(resp) {\n                if error.is_disconnected() {\n                    self.session.inner.channels.remove(\u0026db_token);\n                }\n            }\n        }\n    }\n\n    pub(crate) async fn request\u003c'a\u003e(\n        \u0026mut self,\n        query: \u0026'a Payload\u003c'a\u003e,\n        noreply: bool,\n    ) -\u003e Result\u003c(ResponseType, Response)\u003e {\n        self.submit(query, noreply).await;\n        match self.rx.lock().await.next().await {\n            Some(resp) =\u003e resp,\n            None =\u003e Ok((ResponseType::SuccessAtom, Response::new())),\n        }\n    }\n\n    async fn submit\u003c'a\u003e(\u0026self, query: \u0026'a Payload\u003c'a\u003e, noreply: bool) {\n        let mut db_token = self.token;\n        let result = self.exec(query, noreply, \u0026mut db_token).await;\n        self.send_response(db_token, result);\n    }\n\n    async fn exec\u003c'a\u003e(\n        \u0026self,\n        query: \u0026'a Payload\u003c'a\u003e,\n        noreply: bool,\n        db_token: \u0026mut u64,\n    ) -\u003e Result\u003c(ResponseType, Response)\u003e {\n        let buf = query.encode(self.token)?;\n        let mut stream = self.session.inner.stream.lock().await;\n        let tls_stream = mem::take(\u0026mut stream.tls_stream);\n\n        trace!(\"sending query; token: {}, payload: {}\", self.token, query);\n        if let Some(tcp_stream) = tls_stream {\n            self.tcp_ops(tcp_stream, buf, noreply, db_token).await\n        } else {\n            self.tcp_ops(stream.stream.clone(), buf, noreply, db_token)\n                .await\n        }\n    }\n\n    async fn tcp_ops\u003cT\u003e(\n        \u0026self,\n        mut stream: T,\n        buf: Vec\u003cu8\u003e,\n        noreply: bool,\n        db_token: \u0026mut u64,\n    ) -\u003e Result\u003c(ResponseType, Response)\u003e\n    where\n        T: Unpin + AsyncWrite + AsyncReadExt + AsyncRead + AsyncReadExt,\n    {\n        stream.write_all(\u0026buf).await?;\n        trace!(\"query sent; token: {}\", self.token);\n\n        if noreply {\n            return Ok((ResponseType::SuccessAtom, Response::new()));\n        }\n\n        trace!(\"reading header; token: {}\", self.token);\n        let mut header = [0u8; HEADER_SIZE];\n        stream.read_exact(\u0026mut header).await?;\n\n        let mut buf = [0u8; TOKEN_SIZE];\n        buf.copy_from_slice(\u0026header[..TOKEN_SIZE]);\n        *db_token = {\n            let token = u64::from_le_bytes(buf);\n            trace!(\"db_token: {}\", token);\n            if token \u003e self.session.inner.token.load(Ordering::SeqCst) {\n                self.session.inner.mark_broken();\n                return Err(err::ReqlDriverError::ConnectionBroken.into());\n            }\n            token\n        };\n\n        let mut buf = [0u8; DATA_SIZE];\n        buf.copy_from_slice(\u0026header[TOKEN_SIZE..]);\n        let len = u32::from_le_bytes(buf) as usize;\n        trace!(\n            \"header read; token: {}, db_token: {}, response_len: {}\",\n            self.token,\n            db_token,\n            len\n        );\n\n        trace!(\"reading body; token: {}\", self.token);\n        let mut buf = vec![0u8; len];\n        stream.read_exact(\u0026mut buf).await?;\n\n        trace!(\n            \"body read; token: {}, db_token: {}, body: {}\",\n            self.token,\n            db_token,\n            super::bytes_to_string(\u0026buf),\n        );\n\n        let resp = serde_json::from_slice::\u003cResponse\u003e(\u0026buf)?;\n        trace!(\"response successfully parsed; token: {}\", self.token,);\n\n        let response_type = ResponseType::from_i32(resp.t).ok_or_else(|| {\n            err::ReqlDriverError::Other(format!(\"unknown response type `{}`\", resp.t))\n        })?;\n\n        if let Some(error_type) = resp.e {\n            let msg = error_message(resp.r)?;\n            return Err(response_error(response_type, Some(error_type), msg));\n        }\n\n        Ok((response_type, resp))\n    }\n}\n\nfn error_message(response: Value) -\u003e Result\u003cString\u003e {\n    let messages = serde_json::from_value::\u003cVec\u003cString\u003e\u003e(response)?;\n    Ok(messages.join(\" \"))\n}\n\nfn response_error(\n    response_type: ResponseType,\n    error_type: Option\u003ci32\u003e,\n    msg: String,\n) -\u003e err::ReqlError {\n    match response_type {\n        ResponseType::ClientError =\u003e err::ReqlDriverError::Other(msg).into(),\n        ResponseType::CompileError =\u003e err::ReqlError::Compile(msg),\n        ResponseType::RuntimeError =\u003e match error_type.map(ErrorType::from_i32).ok_or_else(|| {\n            err::ReqlDriverError::Other(format!(\"unexpected runtime error: {}\", msg))\n        }) {\n            Ok(Some(ErrorType::Internal)) =\u003e err::ReqlRuntimeError::Internal(msg).into(),\n            Ok(Some(ErrorType::ResourceLimit)) =\u003e err::ReqlRuntimeError::ResourceLimit(msg).into(),\n            Ok(Some(ErrorType::QueryLogic)) =\u003e err::ReqlRuntimeError::QueryLogic(msg).into(),\n            Ok(Some(ErrorType::NonExistence)) =\u003e err::ReqlRuntimeError::NonExistence(msg).into(),\n            Ok(Some(ErrorType::OpFailed)) =\u003e err::ReqlAvailabilityError::OpFailed(msg).into(),\n            Ok(Some(ErrorType::OpIndeterminate)) =\u003e {\n                err::ReqlAvailabilityError::OpIndeterminate(msg).into()\n            }\n            Ok(Some(ErrorType::User)) =\u003e err::ReqlRuntimeError::User(msg).into(),\n            Ok(Some(ErrorType::PermissionError)) =\u003e err::ReqlRuntimeError::Permission(msg).into(),\n            Err(error) =\u003e error.into(),\n            _ =\u003e err::ReqlDriverError::Other(format!(\"unexpected runtime error: {}\", msg)).into(),\n        },\n        _ =\u003e err::ReqlDriverError::Other(format!(\"unexpected response: {}\", msg)).into(),\n    }\n}\n","traces":[{"line":34,"address":[2274704],"length":1,"stats":{"Line":0},"fn_name":"new"},{"line":38,"address":[2274729],"length":1,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[2999118,2999072,3000205,2999642,3000142,2999332,2999258],"length":1,"stats":{"Line":50},"fn_name":"{async_fn#0}"},{"line":132,"address":[2999442,2999653,2999243,2999279],"length":1,"stats":{"Line":20},"fn_name":null},{"line":133,"address":[2999744,2999806],"length":1,"stats":{"Line":20},"fn_name":null},{"line":134,"address":[2999952,3000109,3000130],"length":1,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[2999893],"length":1,"stats":{"Line":10},"fn_name":null},{"line":145,"address":[4671360,4671848,4671827],"length":1,"stats":{"Line":3},"fn_name":"into_run_opts"},{"line":146,"address":[4671384,4671545],"length":1,"stats":{"Line":3},"fn_name":null},{"line":147,"address":[4671493,4671651],"length":1,"stats":{"Line":9},"fn_name":null},{"line":152,"address":[4672111,4671888],"length":1,"stats":{"Line":0},"fn_name":"into_run_opts"},{"line":153,"address":[4671905],"length":1,"stats":{"Line":0},"fn_name":null},{"line":158,"address":[6665645,6664976],"length":1,"stats":{"Line":2},"fn_name":"into_run_opts"},{"line":159,"address":[6664992],"length":1,"stats":{"Line":2},"fn_name":null},{"line":160,"address":[6665044,6665104,6665488],"length":1,"stats":{"Line":4},"fn_name":null},{"line":161,"address":[6665261],"length":1,"stats":{"Line":2},"fn_name":null},{"line":166,"address":[6665696],"length":1,"stats":{"Line":0},"fn_name":"into_run_opts"},{"line":167,"address":[6665713],"length":1,"stats":{"Line":0},"fn_name":null},{"line":168,"address":[6665728],"length":1,"stats":{"Line":0},"fn_name":null},{"line":173,"address":[4672144],"length":1,"stats":{"Line":0},"fn_name":"into_run_opts"},{"line":174,"address":[4672168],"length":1,"stats":{"Line":0},"fn_name":null},{"line":179,"address":[6665808,6666526],"length":1,"stats":{"Line":0},"fn_name":"into_run_opts"},{"line":180,"address":[6665825],"length":1,"stats":{"Line":0},"fn_name":null},{"line":181,"address":[6666269,6665901,6665965],"length":1,"stats":{"Line":0},"fn_name":null},{"line":183,"address":[6666066],"length":1,"stats":{"Line":0},"fn_name":null},{"line":187,"address":[3000515,3000272,3000542],"length":1,"stats":{"Line":5},"fn_name":"new\u003c\u0026reql_rust::connection::Session, serde_json::value::Value\u003e"},{"line":192,"address":[3000307,3000397],"length":1,"stats":{"Line":10},"fn_name":null},{"line":193,"address":[3053411,3054553],"length":1,"stats":{"Line":16},"fn_name":null},{"line":194,"address":[3054215,3053482,3054679,3055615,3055347,3055486],"length":1,"stats":{"Line":55},"fn_name":null},{"line":195,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":196,"address":[3055788],"length":1,"stats":{"Line":11},"fn_name":null},{"line":197,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":200,"address":[3055922,3055964],"length":1,"stats":{"Line":22},"fn_name":null},{"line":202,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":203,"address":[3053503,3056534,3056450,3054164,3056080,3056314,3056175,3056607],"length":1,"stats":{"Line":56},"fn_name":null},{"line":204,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":206,"address":[3058634],"length":1,"stats":{"Line":5},"fn_name":null},{"line":207,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":208,"address":[3058775,3065629],"length":1,"stats":{"Line":6},"fn_name":null},{"line":209,"address":[3065659],"length":1,"stats":{"Line":3},"fn_name":null},{"line":211,"address":[3066035],"length":1,"stats":{"Line":1},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":214,"address":[3058856],"length":1,"stats":{"Line":3},"fn_name":null},{"line":215,"address":[3064544],"length":1,"stats":{"Line":0},"fn_name":null},{"line":217,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":218,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":220,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":221,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":222,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":224,"address":[3060907,3062432],"length":1,"stats":{"Line":2},"fn_name":null},{"line":228,"address":[3062562],"length":1,"stats":{"Line":1},"fn_name":null},{"line":229,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":231,"address":[3058950],"length":1,"stats":{"Line":0},"fn_name":null},{"line":232,"address":[3058691],"length":1,"stats":{"Line":0},"fn_name":null},{"line":233,"address":[3058705],"length":1,"stats":{"Line":0},"fn_name":null},{"line":234,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":236,"address":[3059687],"length":1,"stats":{"Line":0},"fn_name":null},{"line":237,"address":[3059704],"length":1,"stats":{"Line":0},"fn_name":null},{"line":246,"address":[4045168,4045915],"length":1,"stats":{"Line":10},"fn_name":"encode"},{"line":247,"address":[4045332,4045206],"length":1,"stats":{"Line":10},"fn_name":null},{"line":248,"address":[4045308,4045471],"length":1,"stats":{"Line":8},"fn_name":null},{"line":249,"address":[4045479],"length":1,"stats":{"Line":4},"fn_name":null},{"line":250,"address":[4045556,4045617],"length":1,"stats":{"Line":20},"fn_name":null},{"line":251,"address":[4045678],"length":1,"stats":{"Line":10},"fn_name":null},{"line":252,"address":[4045748],"length":1,"stats":{"Line":10},"fn_name":null},{"line":253,"address":[4045808],"length":1,"stats":{"Line":10},"fn_name":null},{"line":258,"address":[4673052,4672432,4673207],"length":1,"stats":{"Line":4},"fn_name":"send_response"},{"line":259,"address":[4672552,4672462],"length":1,"stats":{"Line":8},"fn_name":null},{"line":260,"address":[4672640,4672726],"length":1,"stats":{"Line":8},"fn_name":null},{"line":261,"address":[4672969,4672875],"length":1,"stats":{"Line":0},"fn_name":null},{"line":262,"address":[4672995],"length":1,"stats":{"Line":0},"fn_name":null},{"line":268,"address":[4673264],"length":1,"stats":{"Line":10},"fn_name":"request"},{"line":273,"address":[3000715,3001259,3000920,3000767,3001086],"length":1,"stats":{"Line":32},"fn_name":null},{"line":274,"address":[3000871,3001737,3001331,3000788,3001383],"length":1,"stats":{"Line":16},"fn_name":null},{"line":275,"address":[3002027],"length":1,"stats":{"Line":4},"fn_name":null},{"line":276,"address":[3002001,3002125],"length":1,"stats":{"Line":0},"fn_name":null},{"line":280,"address":[3002512,3002440,3002272,3002783,3002305],"length":1,"stats":{"Line":40},"fn_name":"{async_fn#0}"},{"line":281,"address":[3002399],"length":1,"stats":{"Line":10},"fn_name":null},{"line":282,"address":[3002461,3002637,3002794,3002418],"length":1,"stats":{"Line":22},"fn_name":null},{"line":283,"address":[3002918],"length":1,"stats":{"Line":4},"fn_name":null},{"line":286,"address":[4673456],"length":1,"stats":{"Line":10},"fn_name":"exec"},{"line":292,"address":[3003561,3003677,3003178],"length":1,"stats":{"Line":20},"fn_name":null},{"line":293,"address":[3004200,3003391,3003238,3003655,3003949],"length":1,"stats":{"Line":31},"fn_name":null},{"line":294,"address":[3004292,3004375],"length":1,"stats":{"Line":20},"fn_name":null},{"line":296,"address":[3005357,3005441,3004570,3005096,3004932,3005246],"length":1,"stats":{"Line":30},"fn_name":null},{"line":297,"address":[3005918],"length":1,"stats":{"Line":10},"fn_name":null},{"line":298,"address":[3003342,3006520,3003259,3005961],"length":1,"stats":{"Line":0},"fn_name":null},{"line":300,"address":[3003277,3006042],"length":1,"stats":{"Line":12},"fn_name":null},{"line":301,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":305,"address":[4482176,4481984],"length":1,"stats":{"Line":10},"fn_name":"tcp_ops\u003casync_native_tls::tls_stream::TlsStream\u003casync_net::tcp::TcpStream\u003e\u003e"},{"line":315,"address":[3007280,3023078,3022646,3022246,3007623,3008058,3007220,3022306,3022463,3007437],"length":1,"stats":{"Line":30},"fn_name":null},{"line":316,"address":[3023178,3008687,3023854,3009032,3008837,3023704,3008161,3023965,3023540,3024049,3008948,3008523],"length":1,"stats":{"Line":30},"fn_name":null},{"line":318,"address":[3009443,3024457],"length":1,"stats":{"Line":10},"fn_name":null},{"line":319,"address":[3009564,3024575],"length":1,"stats":{"Line":0},"fn_name":null},{"line":322,"address":[3025061,3025486,3010559,3010475,3009688,3024699,3025375,3025225,3025570,3010050,3010214,3010364],"length":1,"stats":{"Line":30},"fn_name":null},{"line":323,"address":[3025978,3010970],"length":1,"stats":{"Line":10},"fn_name":null},{"line":324,"address":[3022327,3011001,3007386,3026000,3022412,3007301,3026425,3011437],"length":1,"stats":{"Line":22},"fn_name":null},{"line":326,"address":[3026345,3011352],"length":1,"stats":{"Line":4},"fn_name":null},{"line":327,"address":[3026371,3011380,3011531,3026519],"length":1,"stats":{"Line":8},"fn_name":null},{"line":328,"address":[3028110,3013125],"length":1,"stats":{"Line":4},"fn_name":null},{"line":329,"address":[3026550,3011562],"length":1,"stats":{"Line":4},"fn_name":null},{"line":330,"address":[3012409,3026721,3027508,3012604,3012095,3027592,3012259,3027397,3027247,3012520,3027083,3011733],"length":1,"stats":{"Line":12},"fn_name":null},{"line":331,"address":[3013004,3027992],"length":1,"stats":{"Line":4},"fn_name":null},{"line":332,"address":[3028206,3013227],"length":1,"stats":{"Line":0},"fn_name":null},{"line":333,"address":[3028240,3013264],"length":1,"stats":{"Line":0},"fn_name":null},{"line":335,"address":[3028102,3013117],"length":1,"stats":{"Line":4},"fn_name":null},{"line":338,"address":[3013135,3028117],"length":1,"stats":{"Line":4},"fn_name":null},{"line":339,"address":[3013162,3028342,3028144,3013366],"length":1,"stats":{"Line":8},"fn_name":null},{"line":340,"address":[3013397,3028373],"length":1,"stats":{"Line":4},"fn_name":null},{"line":341,"address":[3029335,3014098,3013934,3029074,3028548,3029419,3013572,3014248,3014359,3014443,3028910,3029224],"length":1,"stats":{"Line":12},"fn_name":null},{"line":343,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":344,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":345,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":348,"address":[3030817,3015533,3015697,3015171,3030928,3030141,3031012,3015847,3016042,3015958,3030667,3030503],"length":1,"stats":{"Line":12},"fn_name":null},{"line":349,"address":[3031420,3016453],"length":1,"stats":{"Line":4},"fn_name":null},{"line":350,"address":[3031587,3017057,3007319,3016622,3032019,3022345,3031455,3016488],"length":1,"stats":{"Line":8},"fn_name":null},{"line":352,"address":[3017686,3032484,3018340,3032122,3032648,3018031,3018780,3017836,3032798,3032993,3033736,3017160,3017522,3032909,3017947,3033296],"length":1,"stats":{"Line":12},"fn_name":null},{"line":354,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":355,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":356,"address":[3033231,3018275],"length":1,"stats":{"Line":0},"fn_name":null},{"line":359,"address":[3034067,3018883,3018790,3019111,3033746,3033839],"length":1,"stats":{"Line":8},"fn_name":null},{"line":360,"address":[3034195,3034835,3035006,3019879,3034551,3034703,3019978,3020050,3034934,3019747,3019239,3019595],"length":1,"stats":{"Line":12},"fn_name":null},{"line":362,"address":[3020652,3035605,3035388,3037184,3036960,3020435],"length":1,"stats":{"Line":4},"fn_name":"{closure#0}\u003casync_native_tls::tls_stream::TlsStream\u003casync_net::tcp::TcpStream\u003e\u003e"},{"line":363,"address":[3036998,3037222],"length":1,"stats":{"Line":0},"fn_name":null},{"line":366,"address":[3035519,3020566,3020730,3035683],"length":1,"stats":{"Line":5},"fn_name":null},{"line":367,"address":[3021235,3021442,3036372,3020748,3035701,3036165],"length":1,"stats":{"Line":2},"fn_name":null},{"line":368,"address":[3036274,3036577,3021647,3021344],"length":1,"stats":{"Line":2},"fn_name":null},{"line":371,"address":[3035767,3020814],"length":1,"stats":{"Line":4},"fn_name":null},{"line":375,"address":[2275104,2275485],"length":1,"stats":{"Line":1},"fn_name":"error_message"},{"line":376,"address":[2275121,2275299],"length":1,"stats":{"Line":1},"fn_name":null},{"line":377,"address":[2275389,2275269],"length":1,"stats":{"Line":2},"fn_name":null},{"line":380,"address":[2277616,2277670,2275520],"length":1,"stats":{"Line":1},"fn_name":"response_error"},{"line":385,"address":[2275568],"length":1,"stats":{"Line":1},"fn_name":null},{"line":386,"address":[2277665,2275672],"length":1,"stats":{"Line":0},"fn_name":null},{"line":387,"address":[2275753],"length":1,"stats":{"Line":0},"fn_name":null},{"line":388,"address":[2276160,2276380,2276178,2276121,2275852],"length":1,"stats":{"Line":5},"fn_name":null},{"line":389,"address":[3037446],"length":1,"stats":{"Line":0},"fn_name":null},{"line":391,"address":[2276736,2277579],"length":1,"stats":{"Line":0},"fn_name":null},{"line":392,"address":[2276839,2277574],"length":1,"stats":{"Line":0},"fn_name":null},{"line":393,"address":[2276942,2277569],"length":1,"stats":{"Line":2},"fn_name":null},{"line":394,"address":[2277045,2277564],"length":1,"stats":{"Line":0},"fn_name":null},{"line":395,"address":[2277559,2277148],"length":1,"stats":{"Line":0},"fn_name":null},{"line":397,"address":[2277554,2277251],"length":1,"stats":{"Line":0},"fn_name":null},{"line":399,"address":[2277354,2277549],"length":1,"stats":{"Line":2},"fn_name":null},{"line":400,"address":[2277454],"length":1,"stats":{"Line":0},"fn_name":null},{"line":401,"address":[2276356,2276225],"length":1,"stats":{"Line":0},"fn_name":null},{"line":402,"address":[2276516,2276176],"length":1,"stats":{"Line":0},"fn_name":null},{"line":404,"address":[2275638,2275917],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":88,"coverable":149},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","sample.rs"],"content":"use ql2::term::TermType;\n\nuse crate::Command;\n\npub(crate) fn new(number: usize) -\u003e Command {\n    let arg = Command::from_json(number);\n\n    Command::new(TermType::Sample).with_arg(arg)\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::Converter;\n    use crate::spec::{set_up, tear_down, Post};\n    use crate::Result;\n\n    #[tokio::test]\n    async fn test_sample_data() -\u003e Result\u003c()\u003e {\n        let (conn, table, table_name) = set_up(true).await?;\n        let data_obtained: Vec\u003cPost\u003e = table.sample(3).run(\u0026conn).await?.unwrap().parse()?;\n\n        assert!(data_obtained.len() == 3);\n\n        tear_down(conn, \u0026table_name).await\n    }\n}\n","traces":[{"line":5,"address":[4354901,4354874,4354672],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":6,"address":[4354697],"length":1,"stats":{"Line":1},"fn_name":null},{"line":8,"address":[4354790,4354723],"length":1,"stats":{"Line":2},"fn_name":null},{"line":18,"address":[4772165,4772213,4771760,4771799],"length":1,"stats":{"Line":6},"fn_name":"test_sample_data"},{"line":19,"address":[6691587,6691973,6691805,6691652,6692151,6692588],"length":1,"stats":{"Line":4},"fn_name":null},{"line":20,"address":[6692535,6691673,6693689,6692845,6693554,6691756],"length":1,"stats":{"Line":5},"fn_name":null},{"line":22,"address":[6693983,6693674,6694044],"length":1,"stats":{"Line":2},"fn_name":null},{"line":24,"address":[4771896,4771836,4772176,4771791],"length":1,"stats":{"Line":7},"fn_name":null}],"covered":8,"coverable":8},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","seconds.rs"],"content":"use ql2::term::TermType;\n\nuse crate::Command;\n\npub(crate) fn new() -\u003e Command {\n    Command::new(TermType::Seconds)\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::Converter;\n    use crate::{r, Result};\n\n    #[tokio::test]\n    async fn test_seconds_ops() -\u003e Result\u003c()\u003e {\n        let conn = r.connection().connect().await?;\n\n        let seconds = r.now().seconds();\n        let seconds1 = seconds.clone().value();\n        let seconds2: f64 = seconds.cmd().run(\u0026conn).await?.unwrap().parse()?;\n\n        assert!(seconds1.is_normal());\n        assert!(seconds2.is_normal());\n\n        Ok(())\n    }\n}\n","traces":[{"line":5,"address":[2720144],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":6,"address":[2720156],"length":1,"stats":{"Line":1},"fn_name":null},{"line":15,"address":[2258503,2258917,2258464,2258869],"length":1,"stats":{"Line":6},"fn_name":"test_seconds_ops"},{"line":16,"address":[4777706,4776976,4777445,4777022,4777095,4777256],"length":1,"stats":{"Line":4},"fn_name":null},{"line":18,"address":[4777696,4777952],"length":1,"stats":{"Line":2},"fn_name":null},{"line":19,"address":[4777980,4778043],"length":1,"stats":{"Line":2},"fn_name":null},{"line":20,"address":[4777037,4778895,4779004,4778095,4778182],"length":1,"stats":{"Line":4},"fn_name":null},{"line":22,"address":[4779166,4778982,4779189],"length":1,"stats":{"Line":2},"fn_name":null},{"line":23,"address":[4779178,4779266,4779225],"length":1,"stats":{"Line":2},"fn_name":null},{"line":25,"address":[2258495,2258880,2258540,2258600],"length":1,"stats":{"Line":5},"fn_name":null}],"covered":10,"coverable":10},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","set_difference.rs"],"content":"use ql2::term::TermType;\nuse serde::Serialize;\n\nuse crate::Command;\n\npub(crate) fn new(args: impl SetDifferenceArg) -\u003e Command {\n    Command::new(TermType::SetDifference).with_arg(args.into_set_difference_opts())\n}\n\npub trait SetDifferenceArg {\n    fn into_set_difference_opts(self) -\u003e Command;\n}\n\nimpl\u003cS, T\u003e SetDifferenceArg for T\nwhere\n    S: Serialize,\n    T: IntoIterator\u003cItem = S\u003e + Serialize,\n{\n    fn into_set_difference_opts(self) -\u003e Command {\n        Command::from_json(self)\n    }\n}\n\nimpl SetDifferenceArg for Command {\n    fn into_set_difference_opts(self) -\u003e Command {\n        self\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::Converter;\n    use crate::{r, Result};\n\n    #[tokio::test]\n    async fn test_set_difference_ops() -\u003e Result\u003c()\u003e {\n        let conn = r.connection().connect().await?;\n        let response: [u8; 3] = r\n            .expr([10, 20, 30, 40, 50])\n            .set_difference([20, 40])\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(response == [10, 30, 50]);\n\n        Ok(())\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","set_insert.rs"],"content":"use ql2::term::TermType;\nuse serde::Serialize;\n\nuse crate::Command;\n\npub(crate) fn new(value: impl Serialize) -\u003e Command {\n    let arg = Command::from_json(value);\n\n    Command::new(TermType::SetInsert).with_arg(arg)\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::Converter;\n    use crate::{r, Result};\n\n    #[tokio::test]\n    async fn test_set_insert_ops() -\u003e Result\u003c()\u003e {\n        let conn = r.connection().connect().await?;\n        let response: [u8; 6] = r\n            .expr([10, 20, 30, 40, 50])\n            .set_insert(60)\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(response == [10, 20, 30, 40, 50, 60]);\n\n        Ok(())\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","set_intersection.rs"],"content":"use ql2::term::TermType;\nuse serde::Serialize;\n\nuse crate::Command;\n\npub(crate) fn new(args: impl SetIntersectionArg) -\u003e Command {\n    Command::new(TermType::SetIntersection).with_arg(args.into_set_intersection_opts())\n}\n\npub trait SetIntersectionArg {\n    fn into_set_intersection_opts(self) -\u003e Command;\n}\n\nimpl\u003cS, T\u003e SetIntersectionArg for T\nwhere\n    S: Serialize,\n    T: IntoIterator\u003cItem = S\u003e + Serialize,\n{\n    fn into_set_intersection_opts(self) -\u003e Command {\n        Command::from_json(self)\n    }\n}\n\nimpl SetIntersectionArg for Command {\n    fn into_set_intersection_opts(self) -\u003e Command {\n        self\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::Converter;\n    use crate::{r, Result};\n\n    #[tokio::test]\n    async fn test_set_intersection_ops() -\u003e Result\u003c()\u003e {\n        let conn = r.connection().connect().await?;\n        let response: [u8; 2] = r\n            .expr([10, 20, 30, 40, 50])\n            .set_intersection([20, 40])\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(response == [20, 40]);\n\n        Ok(())\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","set_union.rs"],"content":"use ql2::term::TermType;\nuse serde::Serialize;\n\nuse crate::Command;\n\npub(crate) fn new(args: impl SetUnionArg) -\u003e Command {\n    Command::new(TermType::SetUnion).with_arg(args.into_set_union_opts())\n}\n\npub trait SetUnionArg {\n    fn into_set_union_opts(self) -\u003e Command;\n}\n\nimpl\u003cS, T\u003e SetUnionArg for T\nwhere\n    S: Serialize,\n    T: IntoIterator\u003cItem = S\u003e + Serialize,\n{\n    fn into_set_union_opts(self) -\u003e Command {\n        Command::from_json(self)\n    }\n}\n\nimpl SetUnionArg for Command {\n    fn into_set_union_opts(self) -\u003e Command {\n        self\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::Converter;\n    use crate::{r, Result};\n\n    #[tokio::test]\n    async fn test_set_union_ops() -\u003e Result\u003c()\u003e {\n        let conn = r.connection().connect().await?;\n        let response: [u8; 7] = r\n            .expr([10, 20, 30, 40, 50])\n            .set_union([60, 70])\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(response == [10, 20, 30, 40, 50, 60, 70]);\n\n        Ok(())\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","set_write_hook.rs"],"content":"use ql2::term::TermType;\n\nuse crate::prelude::Func;\nuse crate::{types::Binary, Command};\n\npub(crate) fn new(args: impl SetWriteHookArg) -\u003e Command {\n    Command::new(TermType::SetWriteHook).with_arg(args.into_set_write_hook_opts())\n}\n\npub trait SetWriteHookArg {\n    fn into_set_write_hook_opts(self) -\u003e Command;\n}\n\nimpl SetWriteHookArg for Command {\n    fn into_set_write_hook_opts(self) -\u003e Command {\n        self\n    }\n}\n\nimpl SetWriteHookArg for Option\u003cu8\u003e {\n    fn into_set_write_hook_opts(self) -\u003e Command {\n        Command::from_json(self)\n    }\n}\n\nimpl SetWriteHookArg for Func {\n    fn into_set_write_hook_opts(self) -\u003e Command {\n        self.0\n    }\n}\n\nimpl SetWriteHookArg for Binary {\n    fn into_set_write_hook_opts(self) -\u003e Command {\n        Command::from_json(self)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::*;\n    use crate::spec::{set_up, tear_down};\n    use crate::types::SetWriteHookResponse;\n    use crate::Result;\n\n    #[tokio::test]\n    async fn test_set_write_hook_ops() -\u003e Result\u003c()\u003e {\n        let (conn, table, table_name) = set_up(false).await?;\n\n        let response: SetWriteHookResponse = table\n            .set_write_hook(func!(|_, _, new_val| new_val))\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert_eq!(response.created, Some(1));\n\n        tear_down(conn, \u0026table_name).await\n    }\n}\n","traces":[{"line":23,"address":[7021280],"length":1,"stats":{"Line":0},"fn_name":"into_set_write_hook_opts"},{"line":24,"address":[7021296],"length":1,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[2212176],"length":1,"stats":{"Line":0},"fn_name":"into_set_write_hook_opts"},{"line":30,"address":[2212193],"length":1,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[2212258],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":5},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","skip.rs"],"content":"use ql2::term::TermType;\n\nuse crate::Command;\n\npub(crate) fn new(step: usize) -\u003e Command {\n    let arg = Command::from_json(step);\n\n    Command::new(TermType::Skip).with_arg(arg)\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::Converter;\n    use crate::spec::{set_up, tear_down, Post};\n    use crate::Result;\n\n    #[tokio::test]\n    async fn test_skip_data() -\u003e Result\u003c()\u003e {\n        let data = Post::get_many_data();\n        let (conn, table, table_name) = set_up(true).await?;\n        let data_obtained: Vec\u003cPost\u003e = table\n            .skip(data.len() - 1)\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(data_obtained.first() == data.first());\n\n        tear_down(conn, \u0026table_name).await\n    }\n}\n","traces":[{"line":5,"address":[2503107,2503138,2502896],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":6,"address":[2502921],"length":1,"stats":{"Line":1},"fn_name":null},{"line":8,"address":[2502948,2503019],"length":1,"stats":{"Line":2},"fn_name":null},{"line":18,"address":[4218725,4218773,4218359,4218320],"length":1,"stats":{"Line":6},"fn_name":"test_skip_data"},{"line":19,"address":[5138739],"length":1,"stats":{"Line":1},"fn_name":null},{"line":20,"address":[5139352,5139177,5139785,5138799,5138952,5139117],"length":1,"stats":{"Line":4},"fn_name":null},{"line":21,"address":[5140370,5140784,5140293,5140127,5140028,5140841,5141121,5140885,5139737,5140565],"length":1,"stats":{"Line":7},"fn_name":null},{"line":22,"address":[5140059,5140152,5139958,5139767,5140134],"length":1,"stats":{"Line":1},"fn_name":null},{"line":23,"address":[5138820,5140107,5140326,5140202,5140498,5138903],"length":1,"stats":{"Line":6},"fn_name":null},{"line":24,"address":[5140688],"length":1,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[5141553,5141005,5141382],"length":1,"stats":{"Line":2},"fn_name":null},{"line":30,"address":[4218456,4218396,4218351,4218736],"length":1,"stats":{"Line":7},"fn_name":null}],"covered":11,"coverable":12},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","slice.rs"],"content":"use ql2::term::TermType;\nuse reql_macros::CommandOptions;\nuse serde::Serialize;\n\nuse crate::{\n    arguments::{Args, Status},\n    Command,\n};\n\npub(crate) fn new(args: impl SliceArg) -\u003e Command {\n    let (start_offset, end_offset, opts) = args.into_slice_opts();\n    let mut command = Command::new(TermType::Slice).with_arg(start_offset);\n\n    if let Some(end_offset) = end_offset {\n        command = command.with_arg(end_offset);\n    }\n\n    command.with_opts(opts)\n}\n\npub trait SliceArg {\n    fn into_slice_opts(self) -\u003e (Command, Option\u003cCommand\u003e, SliceOption);\n}\n\nimpl SliceArg for isize {\n    fn into_slice_opts(self) -\u003e (Command, Option\u003cCommand\u003e, SliceOption) {\n        (Command::from_json(self), None, Default::default())\n    }\n}\n\nimpl SliceArg for Args\u003c(isize, isize)\u003e {\n    fn into_slice_opts(self) -\u003e (Command, Option\u003cCommand\u003e, SliceOption) {\n        (\n            Command::from_json(self.0 .0),\n            Some(Command::from_json(self.0 .1)),\n            Default::default(),\n        )\n    }\n}\n\nimpl SliceArg for Args\u003c(isize, SliceOption)\u003e {\n    fn into_slice_opts(self) -\u003e (Command, Option\u003cCommand\u003e, SliceOption) {\n        (Command::from_json(self.0 .0), None, self.0 .1)\n    }\n}\n\nimpl SliceArg for Args\u003c(isize, isize, SliceOption)\u003e {\n    fn into_slice_opts(self) -\u003e (Command, Option\u003cCommand\u003e, SliceOption) {\n        (\n            Command::from_json(self.0 .0),\n            Some(Command::from_json(self.0 .1)),\n            self.0 .2,\n        )\n    }\n}\n\n#[derive(Debug, Clone, Copy, Serialize, Default, PartialEq, PartialOrd, CommandOptions)]\npub struct SliceOption {\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub left_bound: Option\u003cStatus\u003e,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub right_bound: Option\u003cStatus\u003e,\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::cmd::order_by::OrderByOption;\n    use crate::prelude::Converter;\n    use crate::spec::{set_up, tear_down, Post};\n    use crate::{args, Result};\n\n    #[tokio::test]\n    async fn test_slice_data() -\u003e Result\u003c()\u003e {\n        let data = Post::get_many_data();\n        let (conn, table, table_name) = set_up(true).await?;\n        let data_obtained: Vec\u003cPost\u003e = table\n            .order_by(OrderByOption::default().index(\"id\"))\n            .slice(args!(4, 5))\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(data_obtained.last() == data.last());\n\n        tear_down(conn, \u0026table_name).await\n    }\n}\n","traces":[{"line":7,"address":[1330704,1331479,1331392],"length":1,"stats":{"Line":1},"fn_name":"new\u003c(isize, isize)\u003e"},{"line":8,"address":[1330737],"length":1,"stats":{"Line":1},"fn_name":null},{"line":9,"address":[1330980,1330883],"length":1,"stats":{"Line":2},"fn_name":null},{"line":11,"address":[1331318,1331048],"length":1,"stats":{"Line":2},"fn_name":null},{"line":12,"address":[1331292,1331169],"length":1,"stats":{"Line":2},"fn_name":null},{"line":15,"address":[1331259],"length":1,"stats":{"Line":1},"fn_name":null},{"line":23,"address":[2870528,2870722,2870749],"length":1,"stats":{"Line":0},"fn_name":"into_slice_opts"},{"line":24,"address":[2221885,2221705],"length":1,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[2870768,2871058],"length":1,"stats":{"Line":1},"fn_name":"into_slice_opts"},{"line":31,"address":[2870806],"length":1,"stats":{"Line":1},"fn_name":null},{"line":32,"address":[2870910,2870822],"length":1,"stats":{"Line":2},"fn_name":null},{"line":33,"address":[2870912],"length":1,"stats":{"Line":1},"fn_name":null},{"line":39,"address":[2222224],"length":1,"stats":{"Line":0},"fn_name":"into_slice_opts"},{"line":40,"address":[2222246],"length":1,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[2871280,2871520],"length":1,"stats":{"Line":0},"fn_name":"into_slice_opts"},{"line":47,"address":[2222438],"length":1,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[2871385,2871321],"length":1,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[2222548],"length":1,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[4797287,4797248,4797701,4797653],"length":1,"stats":{"Line":6},"fn_name":"test_slice_data"},{"line":71,"address":[5142515],"length":1,"stats":{"Line":1},"fn_name":null},{"line":72,"address":[5143559,5142953,5143128,5142893,5142728,5142575],"length":1,"stats":{"Line":4},"fn_name":null},{"line":73,"address":[5143879,5143998,5144943,5144192,5143519,5143808,5144115,5144606,5144707,5144387,5144663],"length":1,"stats":{"Line":8},"fn_name":null},{"line":74,"address":[5143732,5143918,5143549,5143936,5143847],"length":1,"stats":{"Line":2},"fn_name":null},{"line":75,"address":[5143855],"length":1,"stats":{"Line":1},"fn_name":null},{"line":76,"address":[5142596,5144148,5143978,5144021,5142679,5144320],"length":1,"stats":{"Line":6},"fn_name":null},{"line":77,"address":[5144510],"length":1,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[5145375,5144827,5145204],"length":1,"stats":{"Line":2},"fn_name":null},{"line":83,"address":[4797279,4797664,4797384,4797324],"length":1,"stats":{"Line":7},"fn_name":null}],"covered":19,"coverable":28},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","splice_at.rs"],"content":"use ql2::term::TermType;\nuse serde::Serialize;\n\nuse crate::{arguments::Args, Command};\n\npub(crate) fn new(args: impl SpliceAtArg) -\u003e Command {\n    let (arg_offset, arg_value) = args.into_splice_at_opts();\n\n    Command::new(TermType::SpliceAt)\n        .with_arg(arg_offset)\n        .with_arg(arg_value)\n}\n\npub trait SpliceAtArg {\n    fn into_splice_at_opts(self) -\u003e (Command, Command);\n}\n\nimpl\u003cS, T\u003e SpliceAtArg for Args\u003c(isize, T)\u003e\nwhere\n    S: Serialize,\n    T: IntoIterator\u003cItem = S\u003e + Serialize,\n{\n    fn into_splice_at_opts(self) -\u003e (Command, Command) {\n        (Command::from_json(self.0 .0), Command::from_json(self.0 .1))\n    }\n}\n\nimpl SpliceAtArg for Args\u003c(Command, Command)\u003e {\n    fn into_splice_at_opts(self) -\u003e (Command, Command) {\n        (self.0 .0, self.0 .1)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::Converter;\n    use crate::{args, r, Result};\n\n    #[tokio::test]\n    async fn test_splice_at_ops() -\u003e Result\u003c()\u003e {\n        let conn = r.connection().connect().await?;\n        let response: [String; 4] = r\n            .expr([\"Moussa\", \"Ali\"])\n            .splice_at(args!(1, [\"Fati\", \"Alima\"]))\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(response == [\"Moussa\", \"Fati\", \"Alima\", \"Ali\"]);\n\n        Ok(())\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","split.rs"],"content":"use ql2::term::TermType;\n\nuse crate::{arguments::Args, Command};\n\npub(crate) fn new(args: impl SplitArg) -\u003e Command {\n    let (arg1, arg2) = args.into_split_opts();\n    let mut command = Command::new(TermType::Split);\n\n    if let Some(arg) = arg1 {\n        command = command.with_arg(arg);\n    }\n\n    if let Some(arg1) = arg2 {\n        command = command.with_arg(arg1);\n    }\n\n    command\n}\n\npub trait SplitArg {\n    fn into_split_opts(self) -\u003e (Option\u003cCommand\u003e, Option\u003cCommand\u003e);\n}\n\nimpl SplitArg for () {\n    fn into_split_opts(self) -\u003e (Option\u003cCommand\u003e, Option\u003cCommand\u003e) {\n        (None, None)\n    }\n}\n\nimpl SplitArg for \u0026str {\n    fn into_split_opts(self) -\u003e (Option\u003cCommand\u003e, Option\u003cCommand\u003e) {\n        (Some(Command::from_json(self)), None)\n    }\n}\n\nimpl SplitArg for Command {\n    fn into_split_opts(self) -\u003e (Option\u003cCommand\u003e, Option\u003cCommand\u003e) {\n        (Some(self), None)\n    }\n}\n\nimpl SplitArg for Args\u003c(\u0026str, usize)\u003e {\n    fn into_split_opts(self) -\u003e (Option\u003cCommand\u003e, Option\u003cCommand\u003e) {\n        (\n            Some(Command::from_json(self.0 .0)),\n            Some(Command::from_json(self.0 .1)),\n        )\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::{args, prelude::Converter, r, Result};\n\n    #[tokio::test]\n    async fn test_split_ops() -\u003e Result\u003c()\u003e {\n        let conn = r.connection().connect().await?;\n        let data = [\"foo\".to_owned(), \"bar\".to_owned(), \"bax\".to_owned()];\n        let response: [String; 3] = r\n            .expr(\"foo bar bax\")\n            .split(())\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(response == data);\n\n        Ok(())\n    }\n\n    #[tokio::test]\n    async fn test_split_ops_entries() -\u003e Result\u003c()\u003e {\n        let conn = r.connection().connect().await?;\n        let data = [\n            \"12\".to_owned(),\n            \"37\".to_owned(),\n            String::new(),\n            \"22\".to_owned(),\n            String::new(),\n        ];\n        let response: [String; 5] = r\n            .expr(\"12,37,,22,\")\n            .split(\",\")\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(response == data);\n\n        Ok(())\n    }\n\n    #[tokio::test]\n    async fn test_split_ops_entries_limit() -\u003e Result\u003c()\u003e {\n        let conn = r.connection().connect().await?;\n        let data = [\n            \"12\".to_owned(),\n            \"37\".to_owned(),\n            String::new(),\n            \"22,\".to_owned(),\n        ];\n        let response: [String; 4] = r\n            .expr(\"12,37,,22,\")\n            .split(args!(\",\", 3))\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(response == data);\n\n        Ok(())\n    }\n}\n","traces":[{"line":25,"address":[2720192],"length":1,"stats":{"Line":0},"fn_name":"into_split_opts"},{"line":26,"address":[2720211],"length":1,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[2703280],"length":1,"stats":{"Line":0},"fn_name":"into_split_opts"},{"line":32,"address":[2703312],"length":1,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[2703424,2703641],"length":1,"stats":{"Line":0},"fn_name":"into_split_opts"},{"line":39,"address":[2703448],"length":1,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[2703552,2703499],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":7},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","status.rs"],"content":"use ql2::term::TermType;\n\nuse crate::Command;\n\npub(crate) fn new() -\u003e Command {\n    Command::new(TermType::Status)\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::Converter;\n    use crate::spec::{set_up, tear_down};\n    use crate::types::StatusResponse;\n    use crate::Result;\n\n    #[tokio::test]\n    async fn test_status_table() -\u003e Result\u003c()\u003e {\n        let (conn, table, table_name) = set_up(true).await?;\n        let response: StatusResponse = table.status().run(\u0026conn).await?.unwrap().parse()?;\n\n        assert!(response.name.unwrap() == table_name);\n\n        tear_down(conn, \u0026table_name).await\n    }\n}\n","traces":[{"line":5,"address":[2720304],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":6,"address":[2720316],"length":1,"stats":{"Line":1},"fn_name":null},{"line":17,"address":[1654818,1654384,1655110,1654590,1654393,1654485,1654416],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":18,"address":[1655553,1654620,1654943,1654775,1655121,1654547],"length":1,"stats":{"Line":4},"fn_name":null},{"line":19,"address":[1655810,1656734,1654641,1656527,1654726,1655505],"length":1,"stats":{"Line":5},"fn_name":null},{"line":21,"address":[1657046,1657200,1656669],"length":1,"stats":{"Line":2},"fn_name":null},{"line":23,"address":[1657560,1657500,1657717,1657854,1654659,1657157,1657376],"length":1,"stats":{"Line":7},"fn_name":null}],"covered":7,"coverable":7},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","sub.rs"],"content":"use std::ops::Sub;\n\nuse ql2::term::TermType;\n\nuse crate::Command;\n\nimpl\u003cT: SubArg\u003e Sub\u003cT\u003e for Command {\n    type Output = Self;\n\n    fn sub(self, arg: T) -\u003e Self {\n        Command::new(TermType::Sub)\n            .with_arg(arg.into_sub_opts())\n            .with_parent(self)\n    }\n}\n\npub trait SubArg {\n    fn into_sub_opts(self) -\u003e Command;\n}\n\nimpl SubArg for f64 {\n    fn into_sub_opts(self) -\u003e Command {\n        Command::from_json(self)\n    }\n}\n\nimpl SubArg for Vec\u003cf64\u003e {\n    fn into_sub_opts(self) -\u003e Command {\n        Command::from_json(self)\n    }\n}\n\nimpl SubArg for Command {\n    fn into_sub_opts(self) -\u003e Command {\n        self\n    }\n}\n\n// TODO write test\n","traces":[{"line":10,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":11,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":12,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":13,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[2674304],"length":1,"stats":{"Line":0},"fn_name":"into_sub_opts"},{"line":23,"address":[2674322],"length":1,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[4440288],"length":1,"stats":{"Line":0},"fn_name":"into_sub_opts"},{"line":29,"address":[4440300],"length":1,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[4045952],"length":1,"stats":{"Line":0},"fn_name":"into_sub_opts"},{"line":35,"address":[4045960],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":10},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","sum.rs"],"content":"use ql2::term::TermType;\n\nuse crate::prelude::Func;\nuse crate::Command;\n\npub(crate) fn new(args: impl SumArg) -\u003e Command {\n    let mut command = Command::new(TermType::Sum);\n\n    if let Some(arg) = args.into_sum_opts() {\n        command = command.with_arg(arg)\n    }\n\n    command\n}\n\npub trait SumArg {\n    fn into_sum_opts(self) -\u003e Option\u003cCommand\u003e;\n}\n\nimpl SumArg for () {\n    fn into_sum_opts(self) -\u003e Option\u003cCommand\u003e {\n        None\n    }\n}\n\nimpl SumArg for \u0026str {\n    fn into_sum_opts(self) -\u003e Option\u003cCommand\u003e {\n        let arg = Command::from_json(self);\n\n        Some(arg)\n    }\n}\n\nimpl SumArg for Func {\n    fn into_sum_opts(self) -\u003e Option\u003cCommand\u003e {\n        Some(self.0)\n    }\n}\n\nimpl SumArg for Command {\n    fn into_sum_opts(self) -\u003e Option\u003cCommand\u003e {\n        Some(self)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::Converter;\n    use crate::spec::{set_up, tear_down, Post};\n    use crate::Result;\n\n    #[tokio::test]\n    async fn test_sum_data() -\u003e Result\u003c()\u003e {\n        let data: u8 = Post::get_many_data().iter().map(|post| post.view).sum();\n        let (conn, table, table_name) = set_up(true).await?;\n        let data_obtained: u8 = table.sum(\"view\").run(\u0026conn).await?.unwrap().parse()?;\n\n        assert!(data_obtained == data);\n\n        tear_down(conn, \u0026table_name).await\n    }\n}\n","traces":[{"line":6,"address":[1761520,1762280,1762391],"length":1,"stats":{"Line":1},"fn_name":"new\u003c\u0026str\u003e"},{"line":7,"address":[1761553],"length":1,"stats":{"Line":1},"fn_name":null},{"line":8,"address":[1761663],"length":1,"stats":{"Line":1},"fn_name":null},{"line":10,"address":[1761996,1761760],"length":1,"stats":{"Line":1},"fn_name":null},{"line":11,"address":[1761875,1761970],"length":1,"stats":{"Line":0},"fn_name":null},{"line":14,"address":[1762221,1761998,1761932],"length":1,"stats":{"Line":3},"fn_name":null},{"line":15,"address":[1762081,1762195],"length":1,"stats":{"Line":2},"fn_name":null},{"line":18,"address":[1762142],"length":1,"stats":{"Line":1},"fn_name":null},{"line":26,"address":[1684272],"length":1,"stats":{"Line":0},"fn_name":"into_sum_opts"},{"line":27,"address":[1684291],"length":1,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[1684384],"length":1,"stats":{"Line":1},"fn_name":"into_sum_opts"},{"line":33,"address":[1684417],"length":1,"stats":{"Line":1},"fn_name":null},{"line":35,"address":[1684427],"length":1,"stats":{"Line":1},"fn_name":null},{"line":40,"address":[2830400],"length":1,"stats":{"Line":0},"fn_name":"into_sum_opts"},{"line":41,"address":[2830416],"length":1,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[2261360],"length":1,"stats":{"Line":0},"fn_name":"into_sum_opts"},{"line":47,"address":[2179728],"length":1,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[2179856,2180116],"length":1,"stats":{"Line":0},"fn_name":"into_sum_opts"},{"line":53,"address":[2261529],"length":1,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[4046221],"length":1,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[2261792],"length":1,"stats":{"Line":0},"fn_name":"into_sum_opts"},{"line":61,"address":[2261814],"length":1,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[2261841],"length":1,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[4219351,4219717,4219765,4219312],"length":1,"stats":{"Line":6},"fn_name":"test_sum_data"},{"line":75,"address":[2271283,2271656,2274656,2274669],"length":1,"stats":{"Line":4},"fn_name":"{closure#0}"},{"line":76,"address":[2272558,2271900,2271343,2271496],"length":1,"stats":{"Line":3},"fn_name":null},{"line":77,"address":[2271447,2272498,2273622,2273524,2271364,2272815],"length":1,"stats":{"Line":5},"fn_name":null},{"line":79,"address":[2273921,2273601],"length":1,"stats":{"Line":1},"fn_name":null},{"line":81,"address":[2274199,2274251,2271382,2274385,2273878,2274139,2274015],"length":1,"stats":{"Line":7},"fn_name":null}],"covered":16,"coverable":29},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","sync.rs"],"content":"use ql2::term::TermType;\n\nuse crate::Command;\n\npub(crate) fn new() -\u003e Command {\n    Command::new(TermType::Sync)\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::*;\n    use crate::spec::{set_up, tear_down};\n    use crate::types::SyncResponse;\n    use crate::Result;\n\n    #[tokio::test]\n    async fn test_sync_ops() -\u003e Result\u003c()\u003e {\n        let (conn, table, table_name) = set_up(true).await?;\n        let sync_response: SyncResponse = table.sync().run(\u0026conn).await?.unwrap().parse()?;\n\n        assert!(sync_response.synced == 1);\n\n        tear_down(conn, \u0026table_name).await\n    }\n}\n","traces":[{"line":5,"address":[2720352],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":6,"address":[2720364],"length":1,"stats":{"Line":1},"fn_name":null},{"line":17,"address":[1680021,1679568,1679973,1679607],"length":1,"stats":{"Line":6},"fn_name":"test_sync_ops"},{"line":18,"address":[4103501,4103847,4104279,4103669,4103283,4103348],"length":1,"stats":{"Line":4},"fn_name":null},{"line":19,"address":[4105334,4104536,4103452,4104231,4105245,4103369],"length":1,"stats":{"Line":5},"fn_name":null},{"line":21,"address":[4105314,4105633],"length":1,"stats":{"Line":1},"fn_name":null},{"line":23,"address":[1679704,1679984,1679599,1679644],"length":1,"stats":{"Line":7},"fn_name":null}],"covered":7,"coverable":7},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","table.rs"],"content":"use ql2::term::TermType;\nuse reql_macros::CommandOptions;\nuse serde::Serialize;\n\nuse crate::arguments::{Args, IdentifierFormat, ReadMode};\nuse crate::Command;\n\npub(crate) fn new(args: impl TableArg) -\u003e Command {\n    let (arg, opts) = args.into_table_opts();\n\n    Command::new(TermType::Table).with_arg(arg).with_opts(opts)\n}\n\npub trait TableArg {\n    fn into_table_opts(self) -\u003e (Command, TableOption);\n}\n\nimpl\u003cT\u003e TableArg for T\nwhere\n    T: Into\u003cString\u003e,\n{\n    fn into_table_opts(self) -\u003e (Command, TableOption) {\n        (Command::from_json(self.into()), Default::default())\n    }\n}\n\nimpl\u003cT\u003e TableArg for Args\u003c(T, TableOption)\u003e\nwhere\n    T: Into\u003cString\u003e,\n{\n    fn into_table_opts(self) -\u003e (Command, TableOption) {\n        (Command::from_json(self.0 .0.into()), self.0 .1)\n    }\n}\n\n#[derive(Debug, Clone, Copy, Serialize, Default, PartialEq, PartialOrd, CommandOptions)]\n#[non_exhaustive]\npub struct TableOption {\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub read_mode: Option\u003cReadMode\u003e,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub identifier_format: Option\u003cIdentifierFormat\u003e,\n}\n\n#[cfg(test)]\nmod tests {\n    use serde_json::Value;\n\n    use crate::arguments::ReadMode;\n    use crate::cmd::table::TableOption;\n    use crate::prelude::*;\n    use crate::{args, r, Result};\n\n    #[tokio::test]\n    async fn test_table() -\u003e Result\u003c()\u003e {\n        let conn = r.connection().connect().await?;\n        let table: Vec\u003cValue\u003e = r\n            .db(\"todo_app\")\n            .table(\"geo\")\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(table.len() \u003e 0);\n        Ok(())\n    }\n\n    #[tokio::test]\n    async fn test_table_with_options() -\u003e Result\u003c()\u003e {\n        let conn = r.connection().connect().await?;\n        let table_options = TableOption::default().read_mode(ReadMode::Outdated);\n        let table: Vec\u003cValue\u003e = r\n            .db(\"todo_app\")\n            .table(args!(\"geo\", table_options))\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(table.len() \u003e 0);\n        Ok(())\n    }\n}\n","traces":[{"line":10,"address":[3087011,3087040,3086592,3087488,3087434,3086957],"length":1,"stats":{"Line":9},"fn_name":"new\u003c\u0026str\u003e"},{"line":11,"address":[1775329],"length":1,"stats":{"Line":9},"fn_name":null},{"line":13,"address":[3087427,3086950,3086756,3087233],"length":1,"stats":{"Line":9},"fn_name":null},{"line":22,"address":[2474528,2474770],"length":1,"stats":{"Line":8},"fn_name":"into_table_opts"},{"line":23,"address":[2392913],"length":1,"stats":{"Line":8},"fn_name":null},{"line":25,"address":[2474612],"length":1,"stats":{"Line":8},"fn_name":null},{"line":30,"address":[2393152],"length":1,"stats":{"Line":1},"fn_name":"into_table_opts"},{"line":31,"address":[2474825],"length":1,"stats":{"Line":1},"fn_name":null},{"line":33,"address":[2545114],"length":1,"stats":{"Line":1},"fn_name":null},{"line":57,"address":[3089060,3089359,3088800,3088925,3088777,3088768,3088857],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":58,"address":[3089643,3089181,3088949,3088915,3089020,3089370],"length":1,"stats":{"Line":4},"fn_name":null},{"line":59,"address":[3089613,3090037,3090569,3090606,3090108,3089866,3089926,3090293,3090512,3090842],"length":1,"stats":{"Line":7},"fn_name":null},{"line":62,"address":[3090067,3089906,3089949,3090236,3088964],"length":1,"stats":{"Line":5},"fn_name":null},{"line":63,"address":[3090416],"length":1,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[3091013,3090719,3090969],"length":1,"stats":{"Line":2},"fn_name":null},{"line":68,"address":[4418863,4418968,4418908,4419248],"length":1,"stats":{"Line":5},"fn_name":null},{"line":72,"address":[4419781,4419328,4419367,4419733],"length":1,"stats":{"Line":6},"fn_name":"test_table_with_options"},{"line":73,"address":[3091285,3091356,3091251,3091706,3091517,3091967],"length":1,"stats":{"Line":4},"fn_name":null},{"line":74,"address":[3091949,3092212],"length":1,"stats":{"Line":2},"fn_name":null},{"line":75,"address":[3092624,3092283,3092809,3092442,3093085,3093028,3092410,3092553,3093122,3093358],"length":1,"stats":{"Line":7},"fn_name":null},{"line":77,"address":[3092345],"length":1,"stats":{"Line":1},"fn_name":null},{"line":78,"address":[3092752,3092465,3092422,3091300,3092583],"length":1,"stats":{"Line":5},"fn_name":null},{"line":79,"address":[3092932],"length":1,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[3093469,3093235,3093513],"length":1,"stats":{"Line":2},"fn_name":null},{"line":84,"address":[3093482],"length":1,"stats":{"Line":5},"fn_name":null}],"covered":23,"coverable":25},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","table_create.rs"],"content":"use std::borrow::Cow;\nuse std::collections::HashMap;\n\nuse ql2::term::TermType;\nuse reql_macros::CommandOptions;\nuse serde::{Serialize, Serializer};\n\nuse crate::arguments::{Args, Durability, Replicas};\nuse crate::Command;\n\npub(crate) fn new(args: impl TableCreateArg) -\u003e Command {\n    let (arg, opts) = args.into_table_create_opts();\n\n    Command::new(TermType::TableCreate)\n        .with_arg(arg)\n        .with_opts(opts)\n}\n\npub trait TableCreateArg {\n    fn into_table_create_opts(self) -\u003e (Command, TableCreateOption);\n}\n\nimpl\u003cT\u003e TableCreateArg for T\nwhere\n    T: Into\u003cString\u003e,\n{\n    fn into_table_create_opts(self) -\u003e (Command, TableCreateOption) {\n        (Command::from_json(self.into()), Default::default())\n    }\n}\n\nimpl\u003cT\u003e TableCreateArg for Args\u003c(T, TableCreateOption)\u003e\nwhere\n    T: Into\u003cString\u003e,\n{\n    fn into_table_create_opts(self) -\u003e (Command, TableCreateOption) {\n        (Command::from_json(self.0 .0.into()), self.0 .1)\n    }\n}\n\n#[derive(Debug, Default, Clone, PartialEq, CommandOptions)]\n#[non_exhaustive]\npub struct TableCreateOption {\n    pub primary_key: Option\u003cCow\u003c'static, str\u003e\u003e,\n    pub durability: Option\u003cDurability\u003e,\n    pub shards: Option\u003cu8\u003e,\n    pub replicas: Option\u003cReplicas\u003e,\n}\n\nimpl Serialize for TableCreateOption {\n    fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    where\n        S: Serializer,\n    {\n        #[derive(Serialize)]\n        struct InnerOptions\u003c'a\u003e {\n            #[serde(skip_serializing_if = \"Option::is_none\")]\n            primary_key: Option\u003c\u0026'a Cow\u003c'static, str\u003e\u003e,\n            #[serde(skip_serializing_if = \"Option::is_none\")]\n            durability: Option\u003cDurability\u003e,\n            #[serde(skip_serializing_if = \"Option::is_none\")]\n            shards: Option\u003cu8\u003e,\n            #[serde(skip_serializing_if = \"Option::is_none\")]\n            replicas: Option\u003cInnerReplicas\u003c'a\u003e\u003e,\n            #[serde(skip_serializing_if = \"Option::is_none\")]\n            primary_replica_tag: Option\u003c\u0026'a Cow\u003c'static, str\u003e\u003e,\n        }\n\n        #[derive(Serialize)]\n        #[serde(untagged)]\n        enum InnerReplicas\u003c'a\u003e {\n            Int(usize),\n            Map(\u0026'a HashMap\u003cCow\u003c'static, str\u003e, usize\u003e),\n        }\n\n        let (replicas, primary_replica_tag) = match \u0026self.replicas {\n            Some(Replicas::Int(i)) =\u003e (Some(InnerReplicas::Int(*i)), None),\n            Some(Replicas::Map {\n                replicas,\n                primary_replica_tag,\n            }) =\u003e (\n                Some(InnerReplicas::Map(replicas)),\n                Some(primary_replica_tag),\n            ),\n            None =\u003e (None, None),\n        };\n\n        let opts = InnerOptions {\n            replicas,\n            primary_replica_tag,\n            primary_key: self.primary_key.as_ref(),\n            durability: self.durability,\n            shards: self.shards,\n        };\n\n        opts.serialize(serializer)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use uuid::Uuid;\n\n    use crate::cmd::table_create::TableCreateOption;\n    use crate::types::DbResponse;\n    use crate::{args, prelude::*, Session};\n    use crate::{r, Result};\n\n    #[tokio::test]\n    async fn test_create_table() -\u003e Result\u003c()\u003e {\n        let table_name = Uuid::new_v4().to_string();\n        let conn = r.connection().connect().await?;\n        let table_created: DbResponse = r\n            .table_create(table_name.as_str())\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        drop_table(\u0026table_name, table_created, \u0026conn).await\n    }\n\n    #[tokio::test]\n    async fn test_create_table_with_options() -\u003e Result\u003c()\u003e {\n        let table_name = Uuid::new_v4().to_string();\n        let conn = r.connection().connect().await?;\n        let table_options = TableCreateOption::default().primary_key(\"id\");\n        let table_created = r\n            .db(\"test\")\n            .table_create(args!(table_name.as_str(), table_options))\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        drop_table(\u0026table_name, table_created, \u0026conn).await\n    }\n\n    async fn drop_table(table_name: \u0026str, table_created: DbResponse, conn: \u0026Session) -\u003e Result\u003c()\u003e {\n        assert!(table_created.tables_created \u003e Some(0));\n        r.table_drop(table_name).run(conn).await?;\n        Ok(())\n    }\n}\n","traces":[{"line":13,"address":[2687019,2687834,2687745,2687108,2686400,2687136],"length":1,"stats":{"Line":7},"fn_name":"new\u003c(\u0026str, reql_rust::cmd::table_create::TableCreateOption)\u003e"},{"line":14,"address":[2686417,2687169],"length":1,"stats":{"Line":7},"fn_name":null},{"line":16,"address":[2687012,2686985,2686681,2687407,2687711,2687738],"length":1,"stats":{"Line":14},"fn_name":null},{"line":17,"address":[2686833,2687559],"length":1,"stats":{"Line":7},"fn_name":null},{"line":25,"address":[4013744,4013982],"length":1,"stats":{"Line":6},"fn_name":"into_table_create_opts"},{"line":26,"address":[4013777],"length":1,"stats":{"Line":6},"fn_name":null},{"line":28,"address":[4013826],"length":1,"stats":{"Line":6},"fn_name":null},{"line":33,"address":[4014252,4014016],"length":1,"stats":{"Line":1},"fn_name":"into_table_create_opts"},{"line":34,"address":[4014040],"length":1,"stats":{"Line":1},"fn_name":null},{"line":36,"address":[4014095],"length":1,"stats":{"Line":1},"fn_name":null},{"line":50,"address":[2688465,2687872],"length":1,"stats":{"Line":6},"fn_name":"serialize\u003cserde_json::value::ser::Serializer\u003e"},{"line":75,"address":[2688249,2688009,2687902],"length":1,"stats":{"Line":12},"fn_name":null},{"line":76,"address":[2688026],"length":1,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[2688133],"length":1,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[2688145],"length":1,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[2688197],"length":1,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[2687952],"length":1,"stats":{"Line":6},"fn_name":null},{"line":90,"address":[2688289],"length":1,"stats":{"Line":6},"fn_name":null},{"line":91,"address":[2688365],"length":1,"stats":{"Line":6},"fn_name":null},{"line":92,"address":[2688369],"length":1,"stats":{"Line":6},"fn_name":null},{"line":95,"address":[2688429],"length":1,"stats":{"Line":6},"fn_name":null},{"line":109,"address":[4356645,4356693,4356240,4356279],"length":1,"stats":{"Line":6},"fn_name":"test_create_table"},{"line":110,"address":[2309617,2309286],"length":1,"stats":{"Line":2},"fn_name":null},{"line":111,"address":[2309332,2309461,2309693,2309632,2310146,2309882],"length":1,"stats":{"Line":4},"fn_name":null},{"line":112,"address":[2310411,2310779,2311092,2310379,2310522,2310593,2310998,2311055,2311457],"length":1,"stats":{"Line":6},"fn_name":null},{"line":113,"address":[2310126],"length":1,"stats":{"Line":1},"fn_name":null},{"line":114,"address":[6769564],"length":1,"stats":{"Line":6},"fn_name":null},{"line":115,"address":[2310902],"length":1,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[4356656,4356376,4356271,4356316],"length":1,"stats":{"Line":8},"fn_name":null},{"line":123,"address":[4356736,4356775,4357189,4357141],"length":1,"stats":{"Line":6},"fn_name":"test_create_table_with_options"},{"line":124,"address":[2312754,2312411],"length":1,"stats":{"Line":2},"fn_name":null},{"line":125,"address":[2312769,2313281,2312830,2312469,2313019,2312598],"length":1,"stats":{"Line":4},"fn_name":null},{"line":126,"address":[2313271,2313500],"length":1,"stats":{"Line":2},"fn_name":null},{"line":127,"address":[2315144,2313965,2314681,2314738,2314205,2314037,2313544,2314276,2314779,2314462],"length":1,"stats":{"Line":7},"fn_name":null},{"line":129,"address":[2313571,2313619,2314009,2314052],"length":1,"stats":{"Line":2},"fn_name":null},{"line":130,"address":[2314120,2312555,2314017,2314235,2312484,2314404],"length":1,"stats":{"Line":6},"fn_name":null},{"line":131,"address":[2314585],"length":1,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[2315028,2315321,2315541,2315730,2312499,2315604],"length":1,"stats":{"Line":8},"fn_name":null},{"line":138,"address":[2307824,2309128,2307867,2308135,2308061,2309003,2308529],"length":1,"stats":{"Line":5},"fn_name":"{async_fn#0}"},{"line":139,"address":[2308033,2308240,2308271],"length":1,"stats":{"Line":2},"fn_name":null},{"line":140,"address":[2308264,2308540,2308082,2308348],"length":1,"stats":{"Line":3},"fn_name":null},{"line":141,"address":[2309116],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":36,"coverable":45},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","table_drop.rs"],"content":"use ql2::term::TermType;\n\nuse crate::Command;\n\npub(crate) fn new(table_name: impl Into\u003cString\u003e) -\u003e Command {\n    Command::new(TermType::TableDrop).with_arg(Command::from_json(table_name.into()))\n}\n\n#[cfg(test)]\nmod tests {\n    use uuid::Uuid;\n\n    use crate::prelude::*;\n    use crate::types::DbResponse;\n    use crate::{r, Result};\n\n    #[tokio::test]\n    async fn test_drop_table() -\u003e Result\u003c()\u003e {\n        let table_name = Uuid::new_v4().to_string();\n        let conn = r.connection().connect().await?;\n\n        r.table_create(table_name.as_str()).run(\u0026conn).await?;\n\n        let table_dropped: DbResponse = r\n            .table_drop(table_name.as_str())\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(table_dropped.tables_dropped \u003e Some(0));\n\n        Ok(())\n    }\n}\n","traces":[{"line":5,"address":[4355268,4355056,4355295],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":6,"address":[2232913],"length":1,"stats":{"Line":1},"fn_name":null},{"line":8,"address":[2314588,2314663],"length":1,"stats":{"Line":2},"fn_name":null},{"line":20,"address":[1658949,1658496,1658535,1658901],"length":1,"stats":{"Line":6},"fn_name":"test_drop_table"},{"line":21,"address":[2298875,2299248],"length":1,"stats":{"Line":2},"fn_name":null},{"line":22,"address":[2299327,2299263,2299816,2299531,2298927,2299080],"length":1,"stats":{"Line":4},"fn_name":null},{"line":24,"address":[2299031,2300044,2298948,2299790],"length":1,"stats":{"Line":4},"fn_name":null},{"line":26,"address":[2301294,2300899,2301513,2300864,2301593,2301570,2301962,2301016,2301099],"length":1,"stats":{"Line":6},"fn_name":null},{"line":27,"address":[2300771],"length":1,"stats":{"Line":1},"fn_name":null},{"line":28,"address":[2300922,2301227,2298966,2300879,2301055],"length":1,"stats":{"Line":5},"fn_name":null},{"line":29,"address":[2301417],"length":1,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[2301837,2302119,2302152],"length":1,"stats":{"Line":2},"fn_name":null},{"line":35,"address":[1658632,1658912,1658527,1658572],"length":1,"stats":{"Line":5},"fn_name":null}],"covered":12,"coverable":13},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","table_list.rs"],"content":"use crate::Command;\nuse ql2::term::TermType;\n\npub(crate) fn new() -\u003e Command {\n    Command::new(TermType::TableList)\n}\n#[cfg(test)]\nmod tests {\n    use crate::prelude::*;\n    use crate::{r, Result};\n\n    #[tokio::test]\n    async fn test_list_table() -\u003e Result\u003c()\u003e {\n        let conn = r.connection().connect().await?;\n        let db_list: Vec\u003cString\u003e = r.table_list().run(\u0026conn).await?.unwrap().parse()?;\n\n        assert!(db_list.len() \u003e 0);\n        Ok(())\n    }\n}\n","traces":[{"line":4,"address":[2720400],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":5,"address":[2720412],"length":1,"stats":{"Line":1},"fn_name":null},{"line":13,"address":[2552665,2552576,2552608,2552733,2553167,2552585,2552868],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":14,"address":[2552723,2552989,2553439,2553178,2552757,2552828],"length":1,"stats":{"Line":4},"fn_name":null},{"line":15,"address":[2553667,2554507,2554367,2553429,2552772],"length":1,"stats":{"Line":4},"fn_name":null},{"line":17,"address":[2554480,2554730,2554774],"length":1,"stats":{"Line":2},"fn_name":null},{"line":18,"address":[2554743],"length":1,"stats":{"Line":5},"fn_name":null}],"covered":7,"coverable":7},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","time.rs"],"content":"use ql2::term::TermType;\nuse time::{Date, OffsetDateTime, PrimitiveDateTime, Time, UtcOffset};\n\nuse crate::{arguments::Args, types::timezone_to_string, Command};\n\npub(crate) fn new(\n    offset_datetime: OffsetDateTime,\n    timezone_formated: String,\n    with_time: bool,\n) -\u003e Command {\n    let date = offset_datetime.date();\n    let month: u8 = date.month().into();\n    let mut command = Command::new(TermType::Time);\n    command = command.with_arg(Command::from_json(date.year()));\n    command = command.with_arg(Command::from_json(month));\n    command = command.with_arg(Command::from_json(date.day()));\n\n    if with_time {\n        let time = offset_datetime.time();\n\n        command = command.with_arg(Command::from_json(time.hour()));\n        command = command.with_arg(Command::from_json(time.minute()));\n        command = command.with_arg(Command::from_json(time.second()));\n    }\n\n    command.with_arg(Command::from_json(timezone_formated))\n}\n\npub trait TimeArg {\n    fn into_time_opts(self) -\u003e (OffsetDateTime, String, bool);\n}\n\nimpl TimeArg for Args\u003c(Date, UtcOffset)\u003e {\n    fn into_time_opts(self) -\u003e (OffsetDateTime, String, bool) {\n        let (offset_datetime, timezone_formated) =\n            make_time(self.0 .0, time::macros::time!(0:00), self.0 .1);\n\n        (offset_datetime, timezone_formated, false)\n    }\n}\n\nimpl TimeArg for Args\u003c(Date, Time, UtcOffset)\u003e {\n    fn into_time_opts(self) -\u003e (OffsetDateTime, String, bool) {\n        let (offset_datetime, timezone_formated) = make_time(self.0 .0, self.0 .1, self.0 .2);\n\n        (offset_datetime, timezone_formated, true)\n    }\n}\n\nfn make_time(date: Date, time: Time, timezone: UtcOffset) -\u003e (OffsetDateTime, String) {\n    let timezone_formated = timezone_to_string(timezone);\n    let primetive_datetime = PrimitiveDateTime::new(date, time);\n    let offset_datetime = primetive_datetime.assume_offset(timezone);\n\n    (offset_datetime, timezone_formated)\n}\n\n#[cfg(test)]\nmod tests {\n    use time::macros::{date, offset, time};\n\n    use crate::prelude::Converter;\n    use crate::types::Time;\n    use crate::{args, r, Result};\n\n    #[tokio::test]\n    async fn test_time_ops() -\u003e Result\u003c()\u003e {\n        let conn = r.connection().connect().await?;\n        let date = date!(1986 - 11 - 3);\n        let timezone = offset!(+01:00);\n        let time = time!(09:30:40);\n\n        let date_time = r.time(args!(date, time, timezone));\n        let time1 = date_time.clone().value();\n        let time2: Time = date_time.cmd().run(\u0026conn).await?.unwrap().parse()?;\n\n        assert!(time2 == time1);\n\n        Ok(())\n    }\n}\n","traces":[{"line":6,"address":[1795466,1797001,1794800],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":11,"address":[2872686,2872521],"length":1,"stats":{"Line":2},"fn_name":null},{"line":12,"address":[1795029],"length":1,"stats":{"Line":1},"fn_name":null},{"line":13,"address":[1795085],"length":1,"stats":{"Line":1},"fn_name":null},{"line":14,"address":[1795126,1795459],"length":1,"stats":{"Line":1},"fn_name":null},{"line":15,"address":[1795477,1795381,1795686],"length":1,"stats":{"Line":1},"fn_name":null},{"line":16,"address":[1795696,1795630,1795865],"length":1,"stats":{"Line":1},"fn_name":null},{"line":18,"address":[1796834,1795847],"length":1,"stats":{"Line":2},"fn_name":null},{"line":19,"address":[1795994],"length":1,"stats":{"Line":1},"fn_name":null},{"line":21,"address":[1796419,1796083],"length":1,"stats":{"Line":1},"fn_name":null},{"line":22,"address":[1796429,1796346,1796680],"length":1,"stats":{"Line":1},"fn_name":null},{"line":23,"address":[1796847,1796690,1796607],"length":1,"stats":{"Line":1},"fn_name":null},{"line":26,"address":[1795875,1796973,1796857],"length":1,"stats":{"Line":1},"fn_name":null},{"line":34,"address":[6666576],"length":1,"stats":{"Line":1},"fn_name":"into_time_opts"},{"line":35,"address":[6666607],"length":1,"stats":{"Line":1},"fn_name":null},{"line":38,"address":[6666727],"length":1,"stats":{"Line":1},"fn_name":null},{"line":43,"address":[6666864],"length":1,"stats":{"Line":1},"fn_name":"into_time_opts"},{"line":44,"address":[6666883],"length":1,"stats":{"Line":1},"fn_name":null},{"line":46,"address":[6666999],"length":1,"stats":{"Line":1},"fn_name":null},{"line":50,"address":[1797040,1797472],"length":1,"stats":{"Line":1},"fn_name":"make_time"},{"line":51,"address":[1797118],"length":1,"stats":{"Line":1},"fn_name":null},{"line":52,"address":[1797165],"length":1,"stats":{"Line":1},"fn_name":null},{"line":53,"address":[1797237],"length":1,"stats":{"Line":1},"fn_name":null},{"line":55,"address":[1797340],"length":1,"stats":{"Line":1},"fn_name":null},{"line":67,"address":[4798149,4797783,4797744,4798197],"length":1,"stats":{"Line":6},"fn_name":"test_time_ops"},{"line":68,"address":[7044912,7045381,7045192,7044958,7045822,7045031],"length":1,"stats":{"Line":4},"fn_name":null},{"line":69,"address":[7045627],"length":1,"stats":{"Line":1},"fn_name":null},{"line":70,"address":[7045638],"length":1,"stats":{"Line":1},"fn_name":null},{"line":71,"address":[7045666],"length":1,"stats":{"Line":1},"fn_name":null},{"line":73,"address":[7045681,7046068],"length":1,"stats":{"Line":2},"fn_name":null},{"line":74,"address":[7046135,7046072],"length":1,"stats":{"Line":2},"fn_name":null},{"line":75,"address":[6866723,6866649],"length":1,"stats":{"Line":4},"fn_name":null},{"line":77,"address":[7047387,7047420,7047114],"length":1,"stats":{"Line":2},"fn_name":null},{"line":79,"address":[4797820,4797775,4798160,4797880],"length":1,"stats":{"Line":5},"fn_name":null}],"covered":34,"coverable":34},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","time_of_day.rs"],"content":"use ql2::term::TermType;\n\nuse crate::Command;\n\npub(crate) fn new() -\u003e Command {\n    Command::new(TermType::TimeOfDay)\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::Converter;\n    use crate::{r, Result};\n\n    #[tokio::test]\n    async fn test_date_ops() -\u003e Result\u003c()\u003e {\n        let conn = r.connection().connect().await?;\n\n        let datetime = r.now().time_of_day();\n        let date1 = datetime.clone().value();\n        let date2: f64 = datetime.cmd().run(\u0026conn).await?.unwrap().parse()?;\n\n        assert!(date1.is_normal());\n        assert!(date2.is_normal());\n\n        Ok(())\n    }\n}\n","traces":[{"line":5,"address":[2720448],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":6,"address":[2720460],"length":1,"stats":{"Line":1},"fn_name":null},{"line":15,"address":[2258999,2259413,2259365,2258960],"length":1,"stats":{"Line":6},"fn_name":"test_date_ops"},{"line":16,"address":[4451546,4450862,4450935,4451285,4451096,4450816],"length":1,"stats":{"Line":4},"fn_name":null},{"line":18,"address":[4451792,4451536],"length":1,"stats":{"Line":2},"fn_name":null},{"line":19,"address":[4451883,4451820],"length":1,"stats":{"Line":2},"fn_name":null},{"line":20,"address":[4450877,4452022,4451935,4452735,4452844],"length":1,"stats":{"Line":4},"fn_name":null},{"line":22,"address":[4452822,4453029,4453006],"length":1,"stats":{"Line":2},"fn_name":null},{"line":23,"address":[4453018,4453065,4453106],"length":1,"stats":{"Line":2},"fn_name":null},{"line":25,"address":[2259036,2259096,2258991,2259376],"length":1,"stats":{"Line":5},"fn_name":null}],"covered":10,"coverable":10},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","timezone.rs"],"content":"use ql2::term::TermType;\n\nuse crate::Command;\n\npub(crate) fn new() -\u003e Command {\n    Command::new(TermType::Timezone)\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::Converter;\n    use crate::{r, Result};\n\n    #[tokio::test]\n    async fn test_timezone_ops() -\u003e Result\u003c()\u003e {\n        let conn = r.connection().connect().await?;\n\n        let timezone = r.now().timezone();\n        let timezone2: String = timezone.clone().cmd().run(\u0026conn).await?.unwrap().parse()?;\n\n        assert!(timezone.value().to_string() != timezone2);\n\n        Ok(())\n    }\n}\n","traces":[{"line":5,"address":[2720496],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":6,"address":[2720508],"length":1,"stats":{"Line":1},"fn_name":null},{"line":15,"address":[1840073,1840096,1840367,1840230,1840153,1840666,1840064],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":16,"address":[1840677,1840938,1840208,1840254,1840327,1840488],"length":1,"stats":{"Line":4},"fn_name":null},{"line":18,"address":[1841184,1840928],"length":1,"stats":{"Line":2},"fn_name":null},{"line":19,"address":[1840269,1842167,1841212,1841274,1841995],"length":1,"stats":{"Line":4},"fn_name":null},{"line":21,"address":[1842628,1842413,1842113],"length":1,"stats":{"Line":2},"fn_name":null},{"line":23,"address":[1842597],"length":1,"stats":{"Line":5},"fn_name":null}],"covered":8,"coverable":8},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","to_epoch_time.rs"],"content":"use ql2::term::TermType;\n\nuse crate::Command;\n\npub(crate) fn new() -\u003e Command {\n    Command::new(TermType::ToEpochTime)\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::Converter;\n    use crate::{r, Result};\n\n    #[tokio::test]\n    async fn test_to_epoch_time_ops() -\u003e Result\u003c()\u003e {\n        let conn = r.connection().connect().await?;\n\n        let time = r.now().to_epoch_time();\n        let time1 = time.clone().value();\n        let time2: f64 = time.cmd().run(\u0026conn).await?.unwrap().parse()?;\n\n        assert!(time1.is_normal());\n        assert!(time2.is_normal());\n\n        Ok(())\n    }\n}\n","traces":[{"line":5,"address":[2720544],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":6,"address":[2720556],"length":1,"stats":{"Line":1},"fn_name":null},{"line":15,"address":[4453471,4453168,4453257,4453334,4453177,4453770,4453200],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":16,"address":[4453358,4453592,4453431,4453312,4453781,4454042],"length":1,"stats":{"Line":4},"fn_name":null},{"line":18,"address":[4454288,4454032],"length":1,"stats":{"Line":2},"fn_name":null},{"line":19,"address":[4454316,4454379],"length":1,"stats":{"Line":2},"fn_name":null},{"line":20,"address":[4455340,4455231,4454431,4453373,4454518],"length":1,"stats":{"Line":4},"fn_name":null},{"line":22,"address":[4455318,4455525,4455502],"length":1,"stats":{"Line":2},"fn_name":null},{"line":23,"address":[4455514,4455602,4455561],"length":1,"stats":{"Line":2},"fn_name":null},{"line":25,"address":[4455572],"length":1,"stats":{"Line":5},"fn_name":null}],"covered":10,"coverable":10},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","to_geojson.rs"],"content":"use ql2::term::TermType;\n\nuse crate::Command;\n\npub(crate) fn new() -\u003e Command {\n    Command::new(TermType::ToGeojson)\n}\n\n#[cfg(test)]\nmod tests {\n    use serde::{Deserialize, Serialize};\n\n    use crate::cmd::point::Point;\n    use crate::prelude::Converter;\n    use crate::spec::{set_up, tear_down};\n    use crate::types::{GeoJson, GeoType};\n    use crate::{r, Result};\n\n    #[derive(Debug, Serialize, Deserialize, PartialEq)]\n    struct User {\n        id: u8,\n        name: String,\n        location: Point,\n    }\n\n    #[tokio::test]\n    async fn test_to_geojson_ops() -\u003e Result\u003c()\u003e {\n        let user = User {\n            id: 1,\n            name: \"sfo\".to_string(),\n            location: r.point(-122.423246, 37.779388),\n        };\n        let geo: GeoJson\u003c[f64; 2]\u003e = GeoJson {\n            typ: GeoType::Point,\n            coordinates: [-122.423246, 37.779388],\n        };\n        let (conn, table, table_name) = set_up(false).await?;\n        table.clone().insert(\u0026user).run(\u0026conn).await?;\n        let location: GeoJson\u003c[f64; 2]\u003e = table\n            .get(1)\n            .g(\"location\")\n            .to_geojson()\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(location == geo);\n\n        tear_down(conn, \u0026table_name).await\n    }\n}\n","traces":[{"line":5,"address":[2720592],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":6,"address":[2156172],"length":1,"stats":{"Line":1},"fn_name":null},{"line":27,"address":[2244215,2243587,2243408,2243376,2243385,2243477,2243889],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":30,"address":[2243557],"length":1,"stats":{"Line":1},"fn_name":null},{"line":31,"address":[2244025],"length":1,"stats":{"Line":1},"fn_name":null},{"line":35,"address":[2244150],"length":1,"stats":{"Line":1},"fn_name":null},{"line":37,"address":[6770527],"length":1,"stats":{"Line":4},"fn_name":null},{"line":38,"address":[2245042,2243795,2243638,2244808],"length":1,"stats":{"Line":4},"fn_name":null},{"line":39,"address":[2246927,2246661,2245984,2246684,2245898,2246604,2246184,2246107,2246385,2245782],"length":1,"stats":{"Line":7},"fn_name":null},{"line":43,"address":[2243659,2246007,2246140,2246312,2245964,2243744],"length":1,"stats":{"Line":6},"fn_name":null},{"line":44,"address":[2246508],"length":1,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[2247233,2246813,2247291],"length":1,"stats":{"Line":2},"fn_name":null},{"line":50,"address":[2247247,2243677,2247345,2247469,2247595,2247735,2247532],"length":1,"stats":{"Line":7},"fn_name":null}],"covered":12,"coverable":13},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","to_iso8601.rs"],"content":"use ql2::term::TermType;\n\nuse crate::Command;\n\npub(crate) fn new() -\u003e Command {\n    Command::new(TermType::ToIso8601)\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::Converter;\n    use crate::{r, Result};\n\n    #[tokio::test]\n    async fn test_to_iso8601_ops() -\u003e Result\u003c()\u003e {\n        let conn = r.connection().connect().await?;\n\n        let iso8601 = r.now().to_iso8601();\n        let iso8601_1 = iso8601.clone().value();\n        let iso8601_2: String = iso8601.cmd().run(\u0026conn).await?.unwrap().parse()?;\n\n        assert!(!iso8601_1.is_empty());\n        assert!(!iso8601_2.is_empty());\n\n        Ok(())\n    }\n}\n","traces":[{"line":5,"address":[2720640],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":6,"address":[2720652],"length":1,"stats":{"Line":1},"fn_name":null},{"line":15,"address":[2266313,2266826,2266224,2266390,2266527,2266256,2266233],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":16,"address":[2266368,2266414,2266837,2267098,2266648,2266487],"length":1,"stats":{"Line":4},"fn_name":null},{"line":18,"address":[2267088,2267344],"length":1,"stats":{"Line":2},"fn_name":null},{"line":19,"address":[2267435,2267372],"length":1,"stats":{"Line":2},"fn_name":null},{"line":20,"address":[2266429,2268404,2267462,2267549,2268265],"length":1,"stats":{"Line":4},"fn_name":null},{"line":22,"address":[2268383,2268683,2268656],"length":1,"stats":{"Line":2},"fn_name":null},{"line":23,"address":[2268758,2268672,2268719],"length":1,"stats":{"Line":2},"fn_name":null},{"line":25,"address":[2268727],"length":1,"stats":{"Line":5},"fn_name":null}],"covered":10,"coverable":10},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","to_json.rs"],"content":"use ql2::term::TermType;\n\nuse crate::Command;\n\npub(crate) fn new() -\u003e Command {\n    Command::new(TermType::ToJsonString)\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::Converter;\n    use crate::spec::{set_up, tear_down};\n    use crate::Result;\n\n    #[tokio::test]\n    async fn test_to_json_string() -\u003e Result\u003c()\u003e {\n        let (conn, table, table_name) = set_up(true).await?;\n        let data_obtained: String = table.get(1).to_json().run(\u0026conn).await?.unwrap().parse()?;\n\n        assert!(!data_obtained.is_empty());\n\n        tear_down(conn, \u0026table_name).await\n    }\n}\n","traces":[{"line":5,"address":[2720688],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":6,"address":[2720700],"length":1,"stats":{"Line":1},"fn_name":null},{"line":16,"address":[4124454,4124288,4124256,4124357,4124265,4124680,4124972],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":17,"address":[4124805,4125420,4124983,4124419,4124637,4124484],"length":1,"stats":{"Line":4},"fn_name":null},{"line":18,"address":[4126543,4125669,4125367,4124588,4126409,4124505],"length":1,"stats":{"Line":5},"fn_name":null},{"line":20,"address":[4126840,4126529,4126896],"length":1,"stats":{"Line":2},"fn_name":null},{"line":22,"address":[4127358,4126965,4126856,4127149,4127224,4124523,4127089],"length":1,"stats":{"Line":7},"fn_name":null}],"covered":7,"coverable":7},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","type_of.rs"],"content":"use ql2::term::TermType;\n\nuse crate::Command;\n\npub(crate) fn new() -\u003e Command {\n    Command::new(TermType::TypeOf)\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::Converter;\n    use crate::types::TypeOf;\n    use crate::{r, Result};\n\n    #[tokio::test]\n    async fn test_type_of_ops() -\u003e Result\u003c()\u003e {\n        let conn = r.connection().connect().await?;\n        let array: TypeOf = r\n            .expr([1, 2, 3])\n            .type_of()\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n        let boolean: TypeOf = r.expr(true).type_of().run(\u0026conn).await?.unwrap().parse()?;\n        let db: TypeOf = r.db(\"test\").type_of().run(\u0026conn).await?.unwrap().parse()?;\n        let string: TypeOf = r.expr(\"foo\").type_of().run(\u0026conn).await?.unwrap().parse()?;\n\n        assert!(array == TypeOf::Array);\n        assert!(boolean == TypeOf::Bool);\n        assert!(db == TypeOf::Db);\n        assert!(string == TypeOf::String);\n\n        Ok(())\n    }\n}\n","traces":[{"line":5,"address":[2720736],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":6,"address":[2028732],"length":1,"stats":{"Line":1},"fn_name":null},{"line":16,"address":[2260357,2260405,2259952,2259991],"length":1,"stats":{"Line":6},"fn_name":"test_type_of_ops"},{"line":17,"address":[7030102,7030291,7030593,7029689,7029940,7029652],"length":1,"stats":{"Line":4},"fn_name":null},{"line":18,"address":[7031229,7031528,7031505,7030583,7031043,7030833,7031717,7031448,7030972],"length":1,"stats":{"Line":6},"fn_name":null},{"line":19,"address":[7030534],"length":1,"stats":{"Line":1},"fn_name":null},{"line":21,"address":[6894831],"length":1,"stats":{"Line":5},"fn_name":null},{"line":22,"address":[7031352],"length":1,"stats":{"Line":0},"fn_name":null},{"line":25,"address":[6894787,6894736],"length":1,"stats":{"Line":5},"fn_name":null},{"line":26,"address":[6894710,6894659],"length":1,"stats":{"Line":5},"fn_name":null},{"line":27,"address":[6894633,6894582],"length":1,"stats":{"Line":4},"fn_name":null},{"line":29,"address":[7034822,7034855,7034610],"length":1,"stats":{"Line":2},"fn_name":null},{"line":30,"address":[7034924,7034891,7034833],"length":1,"stats":{"Line":2},"fn_name":null},{"line":31,"address":[7034958,7034902,7034990],"length":1,"stats":{"Line":2},"fn_name":null},{"line":32,"address":[7035060,7034964,7035027],"length":1,"stats":{"Line":2},"fn_name":null},{"line":34,"address":[2260368,2260028,2260088,2259983],"length":1,"stats":{"Line":5},"fn_name":null}],"covered":15,"coverable":16},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","ungroup.rs"],"content":"use ql2::term::TermType;\n\nuse crate::Command;\n\npub(crate) fn new() -\u003e Command {\n    Command::new(TermType::Ungroup)\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::Converter;\n    use crate::spec::{set_up, tear_down, Post};\n    use crate::types::UngroupItem;\n    use crate::Result;\n\n    #[tokio::test]\n    async fn test_ungroup_data() -\u003e Result\u003c()\u003e {\n        let (conn, table, table_name) = set_up(true).await?;\n        let data_obtained: Vec\u003cUngroupItem\u003cString, Post\u003e\u003e = table\n            .group(\"title\")\n            .ungroup()\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(data_obtained.len() == 4);\n\n        tear_down(conn, \u0026table_name).await\n    }\n}\n","traces":[{"line":5,"address":[2720784],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":6,"address":[2720796],"length":1,"stats":{"Line":1},"fn_name":null},{"line":17,"address":[1680469,1680517,1680103,1680064],"length":1,"stats":{"Line":6},"fn_name":"test_ungroup_data"},{"line":18,"address":[2360979,2359971,2360357,2360036,2360535,2360189],"length":1,"stats":{"Line":4},"fn_name":null},{"line":19,"address":[2361924,2362199,2361376,2360919,2361867,2361453,2361968,2361228,2361648],"length":1,"stats":{"Line":6},"fn_name":null},{"line":22,"address":[2361409,2360057,2361581,2360140,2361282],"length":1,"stats":{"Line":5},"fn_name":null},{"line":23,"address":[2361771],"length":1,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[2362088,2362397,2362458],"length":1,"stats":{"Line":2},"fn_name":null},{"line":29,"address":[1680480,1680095,1680200,1680140],"length":1,"stats":{"Line":7},"fn_name":null}],"covered":8,"coverable":9},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","union.rs"],"content":"use ql2::term::TermType;\nuse reql_macros::CommandOptions;\nuse serde::Serialize;\n\nuse crate::arguments::{Args, Interleave};\nuse crate::Command;\n\nuse super::CmdOpts;\n\npub(crate) fn new(args: impl UnionArg) -\u003e Command {\n    let (args, opts) = args.into_union_opts();\n\n    args.add_to_cmd(Command::new(TermType::Union))\n        .with_opts(opts)\n}\n\npub trait UnionArg {\n    fn into_union_opts(self) -\u003e (CmdOpts, UnionOption);\n}\n\nimpl UnionArg for Command {\n    fn into_union_opts(self) -\u003e (CmdOpts, UnionOption) {\n        (CmdOpts::Single(self), Default::default())\n    }\n}\n\nimpl UnionArg for Vec\u003cCommand\u003e {\n    fn into_union_opts(self) -\u003e (CmdOpts, UnionOption) {\n        (CmdOpts::Many(self), Default::default())\n    }\n}\n\nimpl UnionArg for Args\u003c(Command, UnionOption)\u003e {\n    fn into_union_opts(self) -\u003e (CmdOpts, UnionOption) {\n        (CmdOpts::Single(self.0 .0), self.0 .1)\n    }\n}\n\nimpl UnionArg for Args\u003c(Vec\u003cCommand\u003e, UnionOption)\u003e {\n    fn into_union_opts(self) -\u003e (CmdOpts, UnionOption) {\n        (CmdOpts::Many(self.0 .0), self.0 .1)\n    }\n}\n\n#[derive(Debug, Clone, Serialize, Default, PartialEq, PartialOrd, CommandOptions)]\npub struct UnionOption {\n    /// The optional `interleave` argument controls\n    /// how the sequences will be merged:\n    /// - `Interleave::Bool(true)`: results will be mixed together;\n    /// this is the fastest setting, but ordering of elements is not guaranteed.\n    /// (This is the default.)\n    /// - `Interleave::Bool(false)`: input sequences will be appended to one another, left to right.\n    /// - `Interleave::FieldName(field_name)`: a string will be taken as the name of a field\n    /// to perform a merge-sort on. The input sequences must be ordered **before** being passed to `union`.\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub interleave: Option\u003cInterleave\u003e,\n}\n\n#[cfg(test)]\nmod tests {\n    use serde::{Deserialize, Serialize};\n    use serde_json::json;\n    use uuid::Uuid;\n\n    use crate::prelude::*;\n    use crate::spec::{set_up, tear_down};\n    use crate::{r, Result};\n\n    #[derive(Debug, Serialize, Deserialize, PartialEq, Eq)]\n    struct AuthorPost {\n        id: Option\u003cu8\u003e,\n        first_name: Option\u003cString\u003e,\n        last_name: Option\u003cString\u003e,\n        title: Option\u003cString\u003e,\n        content: Option\u003cString\u003e,\n        view: Option\u003cu8\u003e,\n    }\n\n    #[tokio::test]\n    async fn test_union_data() -\u003e Result\u003c()\u003e {\n        let authors_data = json!([\n            {\"id\": 1, \"first_name\": \"john\", \"last_name\": \"doe\"},\n            {\"id\": 2, \"first_name\": \"juan\", \"last_name\": \"don\"},\n            {\"id\": 3, \"first_name\": \"jean\", \"last_name\": \"dupont\"}\n        ]);\n        let table_name2 = Uuid::new_v4().to_string();\n        let (conn, table, table_name) = set_up(true).await?;\n\n        r.table_create(table_name2.as_str()).run(\u0026conn).await?;\n        r.table(table_name2.as_str())\n            .insert(authors_data)\n            .run(\u0026conn)\n            .await?;\n\n        let data_obtained: Vec\u003cAuthorPost\u003e = table\n            .union(r.table(table_name2.as_str()))\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(data_obtained.len() \u003e 0);\n\n        r.table_drop(table_name2.as_str()).run(\u0026conn).await?;\n        tear_down(conn, \u0026table_name).await\n    }\n}\n","traces":[{"line":11,"address":[2995408,2995811,2995865],"length":1,"stats":{"Line":1},"fn_name":"new\u003creql_rust::proto::Command\u003e"},{"line":12,"address":[2995425],"length":1,"stats":{"Line":1},"fn_name":null},{"line":14,"address":[2995804,2995777,2995577],"length":1,"stats":{"Line":2},"fn_name":null},{"line":15,"address":[2995729],"length":1,"stats":{"Line":1},"fn_name":null},{"line":23,"address":[4046624,4046838],"length":1,"stats":{"Line":1},"fn_name":"into_union_opts"},{"line":24,"address":[4046675],"length":1,"stats":{"Line":1},"fn_name":null},{"line":29,"address":[4440352,4440556],"length":1,"stats":{"Line":0},"fn_name":"into_union_opts"},{"line":30,"address":[4440368],"length":1,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[5127917,5127696],"length":1,"stats":{"Line":0},"fn_name":"into_union_opts"},{"line":36,"address":[5127712],"length":1,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[4046864],"length":1,"stats":{"Line":0},"fn_name":"into_union_opts"},{"line":42,"address":[4046885],"length":1,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[4440592],"length":1,"stats":{"Line":0},"fn_name":"into_union_opts"},{"line":48,"address":[4440612],"length":1,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[5127952],"length":1,"stats":{"Line":0},"fn_name":"into_union_opts"},{"line":54,"address":[5127974],"length":1,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[4084065,4082965,4092033,4083606,4082896,4082873,4083160,4082864],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":86,"address":[4084046,4084622,4086322,4086592,4083839,4083030,4084167,4085337,4084101,4085820,4086027,4085042,4083732,4084835,4086407,4085152,4086137,4084437,4085607,4085422,4084352],"length":1,"stats":{"Line":12},"fn_name":null},{"line":91,"address":[4086899,4086824],"length":1,"stats":{"Line":2},"fn_name":null},{"line":92,"address":[4087576,4086931,4083563,4086999,4083190],"length":1,"stats":{"Line":4},"fn_name":null},{"line":94,"address":[4087546,4083211,4083512,4087808],"length":1,"stats":{"Line":4},"fn_name":null},{"line":95,"address":[4089169,4088885,4088658,4088727,4088968,4089377,4088554,4088762],"length":1,"stats":{"Line":7},"fn_name":null},{"line":96,"address":[4088673],"length":1,"stats":{"Line":1},"fn_name":null},{"line":97,"address":[4088742,4083232,4088924,4083461,4089096,4088785],"length":1,"stats":{"Line":6},"fn_name":null},{"line":98,"address":[4089259,4089407],"length":1,"stats":{"Line":1},"fn_name":null},{"line":100,"address":[4089842,4090126,4089670,4090425,4089925,4090402,4089447,4090345,4090668,4089595],"length":1,"stats":{"Line":7},"fn_name":null},{"line":101,"address":[4089695,4089677,4089642,4089496],"length":1,"stats":{"Line":2},"fn_name":null},{"line":102,"address":[4089881,4090053,4089745,4083410,4089650,4083253],"length":1,"stats":{"Line":6},"fn_name":null},{"line":103,"address":[4090249],"length":1,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[4090785,4090830,4090554],"length":1,"stats":{"Line":2},"fn_name":null},{"line":109,"address":[4083359,4090910,4083274,4090806],"length":1,"stats":{"Line":4},"fn_name":null},{"line":110,"address":[1699312,1698972,1699032,1698927],"length":1,"stats":{"Line":7},"fn_name":null}],"covered":21,"coverable":32},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","upcase.rs"],"content":"use ql2::term::TermType;\n\nuse crate::Command;\n\npub(crate) fn new() -\u003e Command {\n    Command::new(TermType::Upcase)\n}\n\n// TODO write test\n","traces":[{"line":5,"address":[2720832],"length":1,"stats":{"Line":0},"fn_name":"new"},{"line":6,"address":[2720844],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":2},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","update.rs"],"content":"use ql2::term::TermType;\nuse reql_macros::CommandOptions;\nuse serde::Serialize;\n\nuse crate::arguments::{Args, Durability, ReturnChanges};\nuse crate::Command;\n\nuse super::func::Func;\n\npub(crate) fn new(args: impl UpdateArg) -\u003e Command {\n    let (arg, opts) = args.into_update_opts();\n\n    Command::new(TermType::Update).with_arg(arg).with_opts(opts)\n}\n\npub trait UpdateArg {\n    fn into_update_opts(self) -\u003e (Command, UpdateOption);\n}\n\nimpl\u003cT\u003e UpdateArg for T\nwhere\n    T: Serialize,\n{\n    fn into_update_opts(self) -\u003e (Command, UpdateOption) {\n        (Command::from_json(self), Default::default())\n    }\n}\n\nimpl UpdateArg for Command {\n    fn into_update_opts(self) -\u003e (Command, UpdateOption) {\n        (self, Default::default())\n    }\n}\n\nimpl UpdateArg for Func {\n    fn into_update_opts(self) -\u003e (Command, UpdateOption) {\n        (self.0, Default::default())\n    }\n}\n\nimpl\u003cT\u003e UpdateArg for Args\u003c(T, UpdateOption)\u003e\nwhere\n    T: Serialize,\n{\n    fn into_update_opts(self) -\u003e (Command, UpdateOption) {\n        (Command::from_json(self.0 .0), self.0 .1)\n    }\n}\n\nimpl UpdateArg for Args\u003c(Command, UpdateOption)\u003e {\n    fn into_update_opts(self) -\u003e (Command, UpdateOption) {\n        (self.0 .0, self.0 .1)\n    }\n}\n\nimpl UpdateArg for Args\u003c(Func, UpdateOption)\u003e {\n    fn into_update_opts(self) -\u003e (Command, UpdateOption) {\n        (self.0 .0 .0, self.0 .1)\n    }\n}\n\n#[derive(Debug, Clone, Copy, Serialize, Default, PartialEq, PartialOrd, CommandOptions)]\npub struct UpdateOption {\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub durability: Option\u003cDurability\u003e,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub return_changes: Option\u003cReturnChanges\u003e,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub non_atomic: Option\u003cbool\u003e,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub ignore_write_hook: Option\u003cbool\u003e,\n}\n\n#[cfg(test)]\nmod tests {\n    use serde_json::json;\n\n    use crate::prelude::*;\n    use crate::spec::*;\n    use crate::types::MutationResponse;\n    use crate::Result;\n\n    #[tokio::test]\n    async fn test_update_docs() -\u003e Result\u003c()\u003e {\n        let (conn, table, table_name) = set_up(true).await?;\n        let response: MutationResponse = table\n            .get(1)\n            .update(json!({\"view\": 0}))\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(response.replaced == 1);\n\n        tear_down(conn, \u0026table_name).await\n    }\n}\n","traces":[{"line":22,"address":[5128405,5128192],"length":1,"stats":{"Line":0},"fn_name":"into_update_opts"},{"line":23,"address":[5128209],"length":1,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[4047275,4047072],"length":1,"stats":{"Line":0},"fn_name":"into_update_opts"},{"line":29,"address":[2262515],"length":1,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[5128432],"length":1,"stats":{"Line":0},"fn_name":"into_update_opts"},{"line":35,"address":[5128454],"length":1,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[4047312],"length":1,"stats":{"Line":0},"fn_name":"into_update_opts"},{"line":41,"address":[4047333],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":8},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","uuid.rs"],"content":"use ql2::term::TermType;\n\nuse crate::Command;\n\npub(crate) fn new(args: impl UuidArg) -\u003e Command {\n    let mut command = Command::new(TermType::Uuid);\n\n    if let Some(arg) = args.into_uui_opts() {\n        command = command.with_arg(arg)\n    }\n\n    command\n}\n\npub trait UuidArg {\n    fn into_uui_opts(self) -\u003e Option\u003cCommand\u003e;\n}\n\nimpl UuidArg for () {\n    fn into_uui_opts(self) -\u003e Option\u003cCommand\u003e {\n        None\n    }\n}\n\nimpl UuidArg for \u0026str {\n    fn into_uui_opts(self) -\u003e Option\u003cCommand\u003e {\n        Some(Command::from_json(self))\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::Converter;\n    use crate::{r, Result};\n\n    #[tokio::test]\n    async fn test_uuid_ops() -\u003e Result\u003c()\u003e {\n        let conn = r.connection().connect().await?;\n        let response: String = r.uuid(()).run(\u0026conn).await?.unwrap().parse()?;\n\n        assert!(!response.is_empty());\n\n        Ok(())\n    }\n}\n","traces":[{"line":5,"address":[7028944,7029471],"length":1,"stats":{"Line":1},"fn_name":"new\u003c()\u003e"},{"line":6,"address":[7029056,7028964],"length":1,"stats":{"Line":2},"fn_name":null},{"line":8,"address":[7029064,7029395,7029122],"length":1,"stats":{"Line":2},"fn_name":null},{"line":9,"address":[7029369,7029228],"length":1,"stats":{"Line":0},"fn_name":null},{"line":12,"address":[7029420],"length":1,"stats":{"Line":1},"fn_name":null},{"line":20,"address":[4751296],"length":1,"stats":{"Line":1},"fn_name":"into_uui_opts"},{"line":21,"address":[2217364],"length":1,"stats":{"Line":1},"fn_name":null},{"line":26,"address":[4751312],"length":1,"stats":{"Line":0},"fn_name":"into_uui_opts"},{"line":27,"address":[4751344],"length":1,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[4799189,4798736,4798775,4799141],"length":1,"stats":{"Line":6},"fn_name":"test_uuid_ops"},{"line":38,"address":[6919813,6920234,6920045,6919779,6920495,6919884],"length":1,"stats":{"Line":4},"fn_name":null},{"line":39,"address":[6867017,6867085],"length":1,"stats":{"Line":4},"fn_name":null},{"line":41,"address":[6921819,6921544,6921780],"length":1,"stats":{"Line":2},"fn_name":null},{"line":43,"address":[4799152,4798872,4798812,4798767],"length":1,"stats":{"Line":5},"fn_name":null}],"covered":11,"coverable":14},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","values.rs"],"content":"use ql2::term::TermType;\n\nuse crate::Command;\n\npub(crate) fn new() -\u003e Command {\n    Command::new(TermType::Values)\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::spec::{set_up, tear_down};\n    use crate::Result;\n\n    #[tokio::test]\n    async fn test_values_fields() -\u003e Result\u003c()\u003e {\n        let (conn, table, table_name) = set_up(true).await?;\n        let data_obtained = table.get(1).values().run(\u0026conn).await?.unwrap();\n\n        assert!(data_obtained.is_array());\n\n        tear_down(conn, \u0026table_name).await\n    }\n}\n","traces":[{"line":5,"address":[2720880],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":6,"address":[2720892],"length":1,"stats":{"Line":1},"fn_name":null},{"line":15,"address":[2260853,2260487,2260901,2260448],"length":1,"stats":{"Line":6},"fn_name":"test_values_fields"},{"line":16,"address":[2694405,2694019,2694084,2694237,2694583,2695020],"length":1,"stats":{"Line":4},"fn_name":null},{"line":17,"address":[2694105,2694188,2695269,2694967],"length":1,"stats":{"Line":4},"fn_name":null},{"line":19,"address":[2696212,2696067,2696158],"length":1,"stats":{"Line":2},"fn_name":null},{"line":21,"address":[2260864,2260479,2260584,2260524],"length":1,"stats":{"Line":7},"fn_name":null}],"covered":7,"coverable":7},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","wait.rs"],"content":"use ql2::term::TermType;\nuse reql_macros::CommandOptions;\nuse serde::Serialize;\n\nuse crate::arguments::{Args, WaitFor};\nuse crate::Command;\n\npub(crate) fn new(args: impl WaitArg) -\u003e Command {\n    let (args, opts) = args.into_wait_opts();\n    let mut command = Command::new(TermType::Wait);\n\n    if let Some(arg) = args {\n        command = command.with_arg(arg)\n    }\n\n    command.with_opts(opts)\n}\n\npub trait WaitArg {\n    fn into_wait_opts(self) -\u003e (Option\u003cCommand\u003e, WaitOption);\n}\n\nimpl WaitArg for () {\n    fn into_wait_opts(self) -\u003e (Option\u003cCommand\u003e, WaitOption) {\n        Default::default()\n    }\n}\n\nimpl WaitArg for WaitOption {\n    fn into_wait_opts(self) -\u003e (Option\u003cCommand\u003e, WaitOption) {\n        (None, self)\n    }\n}\n\nimpl WaitArg for Command {\n    fn into_wait_opts(self) -\u003e (Option\u003cCommand\u003e, WaitOption) {\n        (Some(self), Default::default())\n    }\n}\n\nimpl WaitArg for Args\u003c(Command, WaitOption)\u003e {\n    fn into_wait_opts(self) -\u003e (Option\u003cCommand\u003e, WaitOption) {\n        (Some(self.0 .0), self.0 .1)\n    }\n}\n\n#[derive(Debug, Copy, Clone, Serialize, Default, PartialEq, PartialOrd, CommandOptions)]\npub struct WaitOption {\n    /// a enum indicating a table status to wait on before returning\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub wait_for: Option\u003cWaitFor\u003e,\n    /// a number indicating maximum time, in seconds,\n    /// to wait for the table to be ready.\n    /// If this value is exceeded, a ReqlRuntimeError will be thrown.\n    /// A value of0 means no timeout. The default is 0 (no timeout).\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub timeout: Option\u003cf64\u003e,\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::Converter;\n    use crate::spec::{set_up, tear_down};\n    use crate::types::WaitResponse;\n    use crate::Result;\n\n    #[tokio::test]\n    async fn test_wait_table() -\u003e Result\u003c()\u003e {\n        let (conn, table, table_name) = set_up(true).await?;\n        let response: WaitResponse = table.wait(()).run(\u0026conn).await?.unwrap().parse()?;\n\n        assert!(response.ready == 1);\n\n        tear_down(conn, \u0026table_name).await\n    }\n}\n","traces":[{"line":8,"address":[4510917,4510944,4510384],"length":1,"stats":{"Line":1},"fn_name":"new\u003c()\u003e"},{"line":9,"address":[4510401],"length":1,"stats":{"Line":1},"fn_name":null},{"line":10,"address":[4510489],"length":1,"stats":{"Line":1},"fn_name":null},{"line":12,"address":[4510583,4510873],"length":1,"stats":{"Line":1},"fn_name":null},{"line":13,"address":[4510698,4510847],"length":1,"stats":{"Line":0},"fn_name":null},{"line":16,"address":[4510788],"length":1,"stats":{"Line":1},"fn_name":null},{"line":24,"address":[2139040],"length":1,"stats":{"Line":1},"fn_name":"into_wait_opts"},{"line":25,"address":[2220700],"length":1,"stats":{"Line":1},"fn_name":null},{"line":30,"address":[2139072],"length":1,"stats":{"Line":0},"fn_name":"into_wait_opts"},{"line":31,"address":[2220740],"length":1,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[2262848,2263060],"length":1,"stats":{"Line":0},"fn_name":"into_wait_opts"},{"line":37,"address":[4047508],"length":1,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[6667136],"length":1,"stats":{"Line":0},"fn_name":"into_wait_opts"},{"line":43,"address":[6667158],"length":1,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[4220304,4220343,4220709,4220757],"length":1,"stats":{"Line":6},"fn_name":"test_wait_table"},{"line":69,"address":[6409191,6408692,6409013,6408627,6409623,6408845],"length":1,"stats":{"Line":4},"fn_name":null},{"line":70,"address":[6410678,6410589,6409880,6408796,6408713,6409575],"length":1,"stats":{"Line":5},"fn_name":null},{"line":72,"address":[6410977,6410658],"length":1,"stats":{"Line":1},"fn_name":null},{"line":74,"address":[4220380,4220720,4220440,4220335],"length":1,"stats":{"Line":7},"fn_name":null}],"covered":12,"coverable":19},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","with_fields.rs"],"content":"use ql2::term::TermType;\nuse serde::Serialize;\n\nuse crate::Command;\n\npub(crate) fn new(fields: impl Serialize) -\u003e Command {\n    Command::new(TermType::WithFields).with_arg(Command::from_json(fields))\n}\n\n#[cfg(test)]\nmod tests {\n    use serde::{Deserialize, Serialize};\n\n    use crate::prelude::Converter;\n    use crate::spec::{set_up, tear_down, Post};\n    use crate::Result;\n\n    #[derive(Debug, Serialize, Deserialize, PartialEq, Eq, PartialOrd, Ord)]\n    struct InnerPost {\n        id: u8,\n        title: String,\n    }\n\n    #[tokio::test]\n    async fn test_with_fields() -\u003e Result\u003c()\u003e {\n        let data: Vec\u003cInnerPost\u003e = Post::get_many_data()\n            .into_iter()\n            .map(|post| InnerPost {\n                id: post.id,\n                title: post.title,\n            })\n            .collect();\n        let (conn, table, table_name) = set_up(true).await?;\n        let mut data_obtained: Vec\u003cInnerPost\u003e = table\n            .with_fields([\"id\", \"title\"])\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        data_obtained.sort_by(|a, b| a.id.cmp(\u0026b.id));\n\n        assert!(data_obtained == data);\n\n        tear_down(conn, \u0026table_name).await\n    }\n}\n","traces":[{"line":6,"address":[2314800,2315060,2315029],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":7,"address":[2233169],"length":1,"stats":{"Line":1},"fn_name":null},{"line":9,"address":[2233293,2233222],"length":1,"stats":{"Line":2},"fn_name":null},{"line":28,"address":[2727417,2727248,2727225,2728061,2727216,2727317,2727643],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":29,"address":[2727379,2727768],"length":1,"stats":{"Line":2},"fn_name":null},{"line":31,"address":[2731083,2731024],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":32,"address":[2731054],"length":1,"stats":{"Line":1},"fn_name":null},{"line":33,"address":[2731057],"length":1,"stats":{"Line":1},"fn_name":null},{"line":36,"address":[6765176],"length":1,"stats":{"Line":4},"fn_name":null},{"line":37,"address":[2729309,2729114,2728790,2729031,2729585,2729528,2728865,2728481,2729629,2729865],"length":1,"stats":{"Line":7},"fn_name":null},{"line":38,"address":[2728756,2728837,2728503,2728872,2728890],"length":1,"stats":{"Line":2},"fn_name":null},{"line":39,"address":[2727551,2728845,2729070,2729242,2727468,2728940],"length":1,"stats":{"Line":6},"fn_name":null},{"line":40,"address":[2729432],"length":1,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[2730126,2731181,2729749,2731136],"length":1,"stats":{"Line":4},"fn_name":"{closure#1}"},{"line":46,"address":[2730141,2730218],"length":1,"stats":{"Line":1},"fn_name":null},{"line":48,"address":[2730177,2730471,2730551,2727486,2730415,2730681,2730291],"length":1,"stats":{"Line":7},"fn_name":null}],"covered":15,"coverable":16},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","without.rs"],"content":"use ql2::term::TermType;\nuse serde::Serialize;\n\nuse crate::arguments::Args;\nuse crate::Command;\n\nuse super::CmdOpts;\n\npub(crate) fn new(args: impl WithoutArg) -\u003e Command {\n    args.into_without_opts()\n        .add_to_cmd(Command::new(TermType::Without))\n}\n\npub trait WithoutArg {\n    fn into_without_opts(self) -\u003e CmdOpts;\n}\n\nimpl\u003cT\u003e WithoutArg for T\nwhere\n    T: Serialize,\n{\n    fn into_without_opts(self) -\u003e CmdOpts {\n        CmdOpts::Single(Command::from_json(self))\n    }\n}\n\nimpl WithoutArg for Command {\n    fn into_without_opts(self) -\u003e CmdOpts {\n        CmdOpts::Single(self)\n    }\n}\n\nimpl\u003cT\u003e WithoutArg for Args\u003cT\u003e\nwhere\n    T: IntoIterator\u003cItem = Command\u003e,\n{\n    fn into_without_opts(self) -\u003e CmdOpts {\n        CmdOpts::Many(self.0.into_iter().collect())\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use serde::{Deserialize, Serialize};\n\n    use crate::prelude::Converter;\n    use crate::spec::{set_up, tear_down, Post};\n    use crate::Result;\n\n    #[derive(Debug, Serialize, Deserialize, PartialEq, Eq)]\n    struct InnerPost {\n        id: u8,\n        title: String,\n    }\n\n    #[tokio::test]\n    async fn test_without_data() -\u003e Result\u003c()\u003e {\n        let data = Post::get_one_data();\n        let data = InnerPost {\n            id: data.id,\n            title: data.title,\n        };\n        let (conn, table, table_name) = set_up(true).await?;\n        let data_obtained: InnerPost = table\n            .get(1)\n            .without([\"content\", \"view\"])\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(data_obtained == data);\n\n        tear_down(conn, \u0026table_name).await\n    }\n}\n","traces":[{"line":6,"address":[4355584,4355862,4355835],"length":1,"stats":{"Line":1},"fn_name":"new\u003c[\u0026str; 2]\u003e"},{"line":7,"address":[4355601],"length":1,"stats":{"Line":1},"fn_name":null},{"line":9,"address":[4355749,4355682],"length":1,"stats":{"Line":2},"fn_name":null},{"line":27,"address":[4424213,4424165,4423760,4423799],"length":1,"stats":{"Line":6},"fn_name":"test_without_data"},{"line":28,"address":[4882883],"length":1,"stats":{"Line":1},"fn_name":null},{"line":30,"address":[4883252],"length":1,"stats":{"Line":1},"fn_name":null},{"line":31,"address":[4883255],"length":1,"stats":{"Line":1},"fn_name":null},{"line":33,"address":[4883560,4883968,4882935,4883092,4883385,4883318],"length":1,"stats":{"Line":4},"fn_name":null},{"line":34,"address":[4885237,4884677,4884482,4884896,4884250,4884405,4883921,4884953,4884285,4884997],"length":1,"stats":{"Line":7},"fn_name":null},{"line":36,"address":[4884172],"length":1,"stats":{"Line":1},"fn_name":null},{"line":37,"address":[4883041,4884438,4884610,4882956,4884308,4884265],"length":1,"stats":{"Line":6},"fn_name":null},{"line":38,"address":[4884800],"length":1,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[4885123,4885618,4885563],"length":1,"stats":{"Line":2},"fn_name":null},{"line":44,"address":[4424176,4423791,4423836,4423896],"length":1,"stats":{"Line":7},"fn_name":null}],"covered":13,"coverable":14},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","year.rs"],"content":"use ql2::term::TermType;\n\nuse crate::Command;\n\npub(crate) fn new() -\u003e Command {\n    Command::new(TermType::Year)\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::Converter;\n    use crate::{r, Result};\n\n    #[tokio::test]\n    async fn test_year_ops() -\u003e Result\u003c()\u003e {\n        let conn = r.connection().connect().await?;\n\n        let year = r.now().year();\n        let year1 = year.clone().value();\n        let year2: i32 = year.cmd().run(\u0026conn).await?.unwrap().parse()?;\n\n        assert!(year1 == year2);\n\n        Ok(())\n    }\n}\n","traces":[{"line":5,"address":[2720928],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":6,"address":[2720940],"length":1,"stats":{"Line":1},"fn_name":null},{"line":15,"address":[1541792,1542394,1541824,1541881,1542095,1541958,1541801],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":16,"address":[1542666,1542405,1541982,1542055,1542216,1541936],"length":1,"stats":{"Line":4},"fn_name":null},{"line":18,"address":[1542912,1542656],"length":1,"stats":{"Line":2},"fn_name":null},{"line":19,"address":[1542940,1543003],"length":1,"stats":{"Line":2},"fn_name":null},{"line":20,"address":[1543847,1543134,1541997,1543942,1543047],"length":1,"stats":{"Line":4},"fn_name":null},{"line":22,"address":[1543921,1544135],"length":1,"stats":{"Line":1},"fn_name":null},{"line":24,"address":[1544105],"length":1,"stats":{"Line":5},"fn_name":null}],"covered":9,"coverable":9},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd","zip.rs"],"content":"use ql2::term::TermType;\n\nuse crate::Command;\n\npub(crate) fn new() -\u003e Command {\n    Command::new(TermType::Zip)\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::prelude::Converter;\n    use crate::spec::{Comment, CommentWithPost};\n    use crate::{args, Result};\n\n    #[tokio::test]\n    pub async fn test_zip_ops() -\u003e Result\u003c()\u003e {\n        let data = CommentWithPost {\n            id: 1,\n            text: \"comment4\".to_string(),\n            post_id: 1,\n            title: \"title1\".to_string(),\n            content: Some(\"content1\".to_string()),\n            view: 10,\n        };\n        let (conn, comment_table, post_table, comment_tablename, post_tablename) =\n            Comment::own_set_up().await?;\n\n        let response: Vec\u003cCommentWithPost\u003e = comment_table\n            .eq_join(args!(\"post_id\", post_table))\n            .zip()\n            .run(\u0026conn)\n            .await?\n            .unwrap()\n            .parse()?;\n\n        assert!(response.len() \u003e 0);\n        assert_eq!(response.first(), Some(\u0026data));\n\n        Comment::own_tear_down(conn, comment_tablename, post_tablename).await\n    }\n}\n","traces":[{"line":5,"address":[2720976],"length":1,"stats":{"Line":0},"fn_name":"new"},{"line":6,"address":[2720988],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":2},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","cmd.rs"],"content":"pub mod add;\npub mod and;\npub mod append;\npub mod args;\npub mod asc;\npub mod avg;\npub mod between;\npub mod binary;\npub mod bit_and;\npub mod bit_not;\npub mod bit_or;\npub mod bit_sal;\npub mod bit_sar;\npub mod bit_xor;\npub mod bracket;\npub mod branch;\npub mod ceil;\npub mod change_at;\npub mod changes;\npub mod circle;\npub mod coerce_to;\npub mod concat_map;\npub mod config;\npub mod connect;\npub mod contains;\npub mod count;\npub mod date;\npub mod day;\npub mod day_of_week;\npub mod day_of_year;\npub mod db;\npub mod db_create;\npub mod db_drop;\npub mod db_list;\npub mod default;\npub mod delete;\npub mod delete_at;\npub mod desc;\npub mod difference;\npub mod distance;\npub mod distinct;\npub mod div;\npub mod do_;\npub mod downcase;\npub mod during;\npub mod epoch_time;\npub mod eq;\npub mod eq_join;\npub mod error;\npub mod expr;\npub mod fill;\npub mod filter;\npub mod floor;\npub mod fold;\npub mod for_each;\npub(crate) mod func;\npub mod ge;\npub mod geojson;\npub mod get;\npub mod get_all;\npub mod get_field;\npub mod get_intersecting;\npub mod get_nearest;\npub mod get_write_hook;\npub mod grant;\npub mod group;\npub mod gt;\npub mod has_fields;\npub mod hash_map;\npub mod hours;\npub mod http;\npub mod in_timezone;\npub mod includes;\npub mod index_create;\npub mod index_drop;\npub mod index_list;\npub mod index_rename;\npub mod index_status;\npub mod index_wait;\npub mod info;\npub mod inner_join;\npub mod insert;\npub mod insert_at;\npub mod intersects;\npub mod is_empty;\npub mod iso8601;\npub mod js;\npub mod json;\npub mod keys;\npub mod le;\npub mod limit;\npub mod line;\npub mod literal;\npub mod lt;\npub mod map;\npub mod match_;\npub mod max;\npub mod merge;\npub mod min;\npub mod minutes;\npub mod month;\npub mod mul;\npub mod ne;\npub mod not;\npub mod now;\npub mod nth;\npub mod object;\npub mod offsets_of;\npub mod or;\npub mod order_by;\npub mod outer_join;\npub mod pluck;\npub mod point;\npub mod polygon;\npub mod polygon_sub;\npub mod prepend;\npub mod random;\npub mod range;\npub mod rebalance;\npub mod reconfigure;\npub mod reduce;\npub mod rem;\npub mod replace;\npub mod round;\npub mod run;\npub mod sample;\npub mod seconds;\npub mod set_difference;\npub mod set_insert;\npub mod set_intersection;\npub mod set_union;\npub mod set_write_hook;\npub mod skip;\npub mod slice;\npub mod splice_at;\npub mod split;\npub mod status;\npub mod sub;\npub mod sum;\npub mod sync;\npub mod table;\npub mod table_create;\npub mod table_drop;\npub mod table_list;\npub mod time;\npub mod time_of_day;\npub mod timezone;\npub mod to_epoch_time;\npub mod to_geojson;\npub mod to_iso8601;\npub mod to_json;\npub mod type_of;\npub mod ungroup;\npub mod union;\npub mod upcase;\npub mod update;\npub mod uuid;\npub mod values;\npub mod wait;\npub mod with_fields;\npub mod without;\npub mod year;\npub mod zip;\n\nuse std::borrow::Cow;\nuse std::ops::{BitAnd, BitOr, BitXor};\nuse std::str;\n\nuse ::time::UtcOffset;\nuse async_native_tls::TlsStream;\nuse async_net::TcpStream;\nuse futures::stream::Stream;\nuse futures::TryStreamExt;\nuse regex::Regex;\nuse serde::Serialize;\nuse serde_json::Value;\n\nuse crate::arguments::Permission;\nuse crate::prelude::Func;\nuse crate::Command;\nuse crate::Result;\n\npub trait StaticString {\n    fn static_string(self) -\u003e Cow\u003c'static, str\u003e;\n}\n\n#[derive(Debug)]\npub(crate) struct TcpStreamConnection {\n    pub(crate) stream: TcpStream,\n    pub(crate) tls_stream: Option\u003cTlsStream\u003cTcpStream\u003e\u003e,\n}\n\nimpl StaticString for \u0026'static str {\n    fn static_string(self) -\u003e Cow\u003c'static, str\u003e {\n        Cow::from(self)\n    }\n}\n\nimpl StaticString for String {\n    fn static_string(self) -\u003e Cow\u003c'static, str\u003e {\n        Cow::from(self)\n    }\n}\n\nimpl StaticString for \u0026Cow\u003c'static, str\u003e {\n    fn static_string(self) -\u003e Cow\u003c'static, str\u003e {\n        match self {\n            Cow::Borrowed(string) =\u003e Cow::Borrowed(*string),\n            Cow::Owned(string) =\u003e Cow::Owned(string.to_owned()),\n        }\n    }\n}\n\nimpl\u003c'a\u003e Command {\n    pub fn changes(self, args: impl changes::ChangesArg) -\u003e Self {\n        changes::new(args).with_parent(self)\n    }\n\n    /// Create a table.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// db.table_create(table_name) → response\n    /// db.table_create(args!(table_name, options)) → response\n    /// ```\n    ///\n    /// Where:\n    /// - table_name: \u0026str | String | Cow\u003c'static, str\u003e\n    /// - options: [TableCreateOption](crate::cmd::table_create::TableCreateOption)\n    /// - response: [DbResponse](crate::types::DbResponse)\n    ///\n    /// # Description\n    ///\n    /// A RethinkDB table is a collection of JSON documents.\n    ///\n    /// If a table with the same name already exists,\n    /// the command throws `ReqlOpFailedError`.\n    ///\n    /// ```text\n    /// Note: Only alphanumeric characters and underscores are valid for the table name.\n    ///\n    /// Invoking table_create without specifying a database using db creates a table in\n    /// the database specified in connect, or test if no database was specified.\n    /// ```\n    ///\n    /// The [data type](https://rethinkdb.com/docs/data-types/) of a primary key is usually a string\n    /// (like a UUID) or a number, but it can also be a time, binary object, boolean or an array.\n    /// Data types can be mixed in the primary key field, but all values must be unique. Using an array\n    /// as a primary key causes the primary key to behave like a compound index; read the documentation on\n    /// [compound secondary indexes](https://rethinkdb.com/docs/secondary-indexes/python/#compound-indexes)\n    /// for more information, as it applies to primary keys as well.\n    /// (Note that the primary index still only covers a single field,\n    /// while compound secondary indexes can cover multiple fields in a single index.)\n    /// Primary keys cannot be objects.\n    ///\n    /// Tables will be available for writing when the command returns.\n    ///\n    /// ## Examples\n    ///\n    /// Create a table named ‘simbad’ with the default settings.\n    ///\n    /// ```\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::types::DbResponse;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: DbResponse = r.db(\"test\")\n    ///         .table_create(\"simbad\")\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response.tables_created \u003e Some(0));\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Create a table named ‘simbad’ using the field ‘name’ as primary key.\n    ///\n    /// ```\n    /// use reql_rust::cmd::table_create::TableCreateOption;\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::types::DbResponse;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let table_create_option = TableCreateOption::default().primary_key(\"name\");\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: DbResponse = r.db(\"test\")\n    ///         .table_create(args!(\"simbad\", table_create_option))\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response.tables_created \u003e Some(0));\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Create a table set up for two shards and three replicas per shard.\n    /// This requires three available servers.\n    ///\n    /// ```\n    /// use reql_rust::arguments::Replicas;\n    /// use reql_rust::cmd::table_create::TableCreateOption;\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::types::DbResponse;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let table_create_option = TableCreateOption::default()\n    ///         .shards(2)\n    ///         .replicas(Replicas::Int(3));\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: DbResponse = r.db(\"test\")\n    ///         .table_create(args!(\"simbad\", table_create_option))\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response.tables_created \u003e Some(0));\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// Read [Sharding and replication](https://rethinkdb.com/docs/sharding-and-replication/)\n    /// for a complete discussion of the subject, including advanced topics.\n    ///\n    /// # Related commands\n    /// - [table_drop](Self::table_drop)\n    /// - [table_list](Self::table_list)\n    pub fn table_create(self, args: impl table_create::TableCreateArg) -\u003e Self {\n        table_create::new(args).with_parent(self)\n    }\n\n    /// Drop a table.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// db.table_drop(table_name) → response\n    /// ```\n    ///\n    /// Where:\n    /// - table_name: \u0026str | String | Cow\u003c'static, str\u003e\n    /// - response: [DbResponse](crate::types::DbResponse)\n    ///\n    /// # Description\n    ///\n    /// The table and all its data will be deleted.\n    ///\n    /// If the given table does not exist in the database,\n    /// the command throws `ReqlRuntimeError`.\n    ///\n    /// ## Examples\n    ///\n    /// Drop a table named ‘simbad’.\n    ///\n    /// ```\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::types::DbResponse;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: DbResponse = r.db(\"test\")\n    ///         .table_drop(\"simbad\")\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response.tables_dropped \u003e Some(0));\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [table_create](Self::table_create)\n    /// - [table_list](Self::table_list)\n    pub fn table_drop(self, table_name: impl Into\u003cString\u003e) -\u003e Self {\n        table_drop::new(table_name).with_parent(self)\n    }\n\n    /// List all table names in a database.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// db.table_list() → response\n    /// ```\n    ///\n    /// Where:\n    /// - response: Vec\u003cString\u003e\n    ///\n    /// ## Examples\n    ///\n    /// List all tables of the ‘test’ database.\n    ///\n    /// ```\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: Vec\u003cString\u003e = r.db(\"test\")\n    ///         .table_list()\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response.len() \u003e 0);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [table_create](Self::table_create)\n    /// - [table_drop](Self::table_drop)\n    pub fn table_list(self) -\u003e Self {\n        table_list::new().with_parent(self)\n    }\n\n    /// Return all documents in a table.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// db.table(name) → table\n    /// db.table(args!(name, options)) → table\n    /// r.table(name) → table\n    /// r.table(args!(name, options)) → table\n    /// ```\n    ///\n    /// Where:\n    /// - name: impl Into\u003cString\u003e | [Command](crate::Command)\n    /// - options: [TableOption](crate::cmd::table::TableOption)\n    ///\n    /// # Description\n    ///\n    /// Other commands may be chained after `table` to return a subset of documents\n    /// (such as [get](crate::Command::get) and [filter](crate::Command::filter))\n    /// or perform further processing.\n    ///\n    /// ## Examples\n    ///\n    /// Return all documents in the table ‘simbad’ of the default database.\n    ///\n    /// ```\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"simbad\").run(\u0026conn).await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Return all documents in the table ‘simbad’ of the database ‘heroes’.\n    ///\n    /// ```\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.db(\"heroes\").table(\"simbad\").run(\u0026conn).await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Allow potentially out-of-date data in exchange for faster reads.\n    ///\n    /// ```\n    /// use reql_rust::cmd::table::TableOption;\n    /// use reql_rust::arguments::ReadMode;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let table_option = TableOption::default().read_mode(ReadMode::Outdated);\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.db(\"heroes\").table(args!(\"simbad\", table_option)).run(\u0026conn).await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [filter](Self::filter)\n    /// - [get](Self::get)\n    pub fn table(self, args: impl table::TableArg) -\u003e Self {\n        table::new(args).with_parent(self)\n    }\n\n    /// Create a new secondary index on a table.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// table.index_drop(index_name) → response\n    /// ```\n    ///\n    /// Where:\n    /// - index_name: \u0026str | String | Cow\u003c'static, str\u003e\n    /// - response: [IndexResponse](crate::types::IndexResponse)\n    ///\n    /// # Description\n    ///\n    /// Secondary indexes improve the speed of many read queries at the slight\n    /// cost of increased storage space and decreased write performance.\n    /// For more information about secondary indexes,  read the article\n    /// “[Using secondary indexes in RethinkDB](https://rethinkdb.com/docs/secondary-indexes/python/).”\n    ///\n    /// RethinkDB supports different types of secondary indexes:\n    /// - **Simple indexes** based on the value of a single field.\n    /// - **Compound indexes** based on multiple fields.\n    /// - **Multi indexes** based on arrays of values.\n    /// - **Geospatial indexes** based on indexes of geometry objects,\n    /// created when the geo optional argument is true.\n    /// - Indexes based on **arbitrary expressions**.\n    ///\n    /// The `index_function` can be an anonymous function or a binary\n    /// representation obtained from the `function` field of [index_status](Self::index_status).\n    /// The function must be deterministic, and so cannot use a subquery or the `r.js` command.\n    ///\n    /// If successful, `create_index` will return an object of the form `{\"created\": 1}`.\n    /// If an index by that name already exists on the table, a `ReqlRuntimeError` will be thrown.\n    ///\n    /// ```text\n    /// that an index may not be immediately available after creation.\n    /// If your application needs to use indexes immediately after creation,\n    /// use the index_wait command to ensure the indexes are ready before use.\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Create a simple index based on the field `post_id`.\n    ///\n    /// ```\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::types::IndexResponse;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: IndexResponse = r.table(\"comments\")\n    ///         .index_create(\"post_id\")\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response.created \u003e Some(0));\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Create a simple index based on the nested field `author \u003e name`.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::types::IndexResponse;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: IndexResponse = r.table(\"comments\")\n    ///         .index_create(args!(\"author_name\", func!(|comment| comment.g(\"author\").g(\"name\"))))\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response.created \u003e Some(0));\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Create a geospatial index based on the field `location`.\n    ///\n    /// ```\n    /// use reql_rust::cmd::index_create::IndexCreateOption;\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::types::IndexResponse;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let index_create_option = IndexCreateOption::default().geo(true);\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: IndexResponse = r.table(\"places\")\n    ///         .index_create(args!(\"location\", index_create_option))\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response.created \u003e Some(0));\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// A geospatial index field should contain only geometry objects.\n    /// It will work with geometry ReQL terms\n    /// ([get_intersecting](Self::get_intersecting) and [get_nearest](Self::get_nearest))\n    /// as well as index-specific terms  ([index_status](Self::index_status),\n    /// [index_wait](Self::index_wait), [index_drop](Self::index_drop) and [index_list](Self::index_list)).\n    /// Using terms that rely on non-geometric ordering such as [get_all](Self::get_all),\n    /// [order_by](Self::order_by) and [between](Self::between) will result in an error.\n    ///\n    /// ## Examples\n    ///\n    /// Create a compound index based on the fields `post_id` and `date`.\n    ///\n    /// ```\n    /// use reql_rust::cmd::index_create::IndexCreateOption;\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::types::IndexResponse;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let index_create_option = IndexCreateOption::default().geo(true);\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: IndexResponse = r.table(\"comments\")\n    ///         .index_create(args!(\"post_and_date\", index_create_option))\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response.created \u003e Some(0));\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [index_wait](Self::index_wait)\n    /// - [index_status](Self::index_status)\n    /// - [index_list](Self::index_list)\n    /// - [index_drop](Self::index_drop)\n    pub fn index_create(self, args: impl index_create::IndexCreateArg) -\u003e Self {\n        index_create::new(args).with_parent(self)\n    }\n\n    /// Delete a previously created secondary index of this table.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// table.index_drop(index_name) → response\n    /// ```\n    ///\n    /// Where:\n    /// - index_name: \u0026str | String | Cow\u003c'static, str\u003e\n    /// - response: [IndexResponse](crate::types::IndexResponse)\n    ///\n    /// ## Examples\n    ///\n    /// Drop a secondary index named ‘code_name’.\n    ///\n    /// ```\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::types::IndexResponse;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: IndexResponse = r.table(\"comments\")\n    ///         .index_drop(\"code_name\")\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response.dropped \u003e Some(0));\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [index_create](Self::index_create)\n    /// - [index_list](Self::index_list)\n    pub fn index_drop(self, index_name: impl Into\u003cString\u003e) -\u003e Self {\n        index_drop::new(index_name).with_parent(self)\n    }\n\n    /// List all the secondary indexes of this table.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// table.index_list() → response\n    /// ```\n    ///\n    /// Where:\n    /// - response: Vec\u003cString\u003e\n    ///\n    /// ## Examples\n    ///\n    /// List the available secondary indexes for this table.\n    ///\n    /// ```\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: Vec\u003cString\u003e = r.table(\"comments\")\n    ///         .index_list()\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response.len() \u003e 0);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [index_create](Self::index_create)\n    /// - [index_drop](Self::index_drop)\n    pub fn index_list(self) -\u003e Self {\n        index_list::new().with_parent(self)\n    }\n\n    /// Rename an existing secondary index on a table.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// table.index_rename(args!(old_index_name, new_index_name)) → response\n    /// table.index_rename(args!(old_index_name, new_index_name, options)) → response\n    /// ```\n    ///\n    /// Where:\n    /// - old_index_name, new_index_name: \u0026str | String | Cow\u003c'static, str\u003e\n    /// - options: [IndexRenameOption](crate::cmd::index_rename::IndexRenameOption)\n    /// - response: [IndexResponse](crate::types::IndexResponse)\n    ///\n    /// # Description\n    ///\n    /// If the optional argument `overwrite` is specified as `true`,\n    /// a previously existing index with the new name will be deleted\n    /// and the index will be renamed. If `overwrite` is `false` (the default)\n    /// an error will be raised if the new index name already exists.\n    ///\n    /// The return value on success will be an object of the format `{'renamed': 1}`,\n    /// or `{'renamed': 0}` if the old and new names are the same.\n    ///\n    /// An error will be raised if the old index name does not exist,\n    /// if the new index name is already in use and `overwrite` is `false`,\n    /// or if either the old or new index name are the same as the primary key field name.\n    ///\n    /// ## Examples\n    ///\n    /// Rename an index on the comments table.\n    ///\n    /// ```\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::types::IndexResponse;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: IndexResponse = r.table(\"comments\")\n    ///         .index_rename(args!(\"post_id\", \"message_id\"))\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response.renamed \u003e Some(0));\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [index_create](Self::index_create)\n    /// - [index_status](Self::index_status)\n    /// - [index_list](Self::index_list)\n    /// - [index_drop](Self::index_drop)\n    pub fn index_rename(self, args: impl index_rename::IndexRenameArg) -\u003e Self {\n        index_rename::new(args).with_parent(self)\n    }\n\n    /// Get the status of the specified indexes on this table,\n    /// or the status of all indexes on this table if no indexes are specified.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// table.index_status(()) → response\n    /// table.index_status(index) → response\n    /// ```\n    ///\n    /// Where:\n    /// - index: \u0026str | [\u0026str; N]\n    /// - response: Vec\u003c[IndexStatusResponse](crate::types::IndexStatusResponse)\u003e\n    ///\n    /// # Description\n    ///\n    /// The `multi` field will be `true` or `false` depending on whether\n    /// this index was created as a multi index\n    /// (see [index_create](Self::index_create) for details).\n    /// The `outdated` field will be true if the index is outdated in\n    /// the current version of RethinkDB and needs to be rebuilt.\n    /// The `progress` field is a float between `0` and `1`,\n    /// indicating how far along the server is in constructing indexes after\n    /// the most recent change to the table that would affect them.\n    /// (`0` indicates no such indexes have been constructed; `1` indicates all of them have.)\n    ///\n    /// The `function` field is a binary object containing an opaque representation\n    /// of the secondary index (including the `multi` argument if specified).\n    /// It can be passed as the second argument to [index_create](Self::index_create) to create\n    /// a new index with the same function; see `index_create` for more information.\n    ///\n    /// ## Examples\n    ///\n    /// Get the status of all the indexes on `test`:\n    ///\n    /// ```\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::types::IndexStatusResponse;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: Vec\u003cIndexStatusResponse\u003e = r.table(\"test\")\n    ///         .index_status(())\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response.len() \u003e 0);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Get the status of the `timestamp` index:\n    ///\n    /// ```\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::types::IndexStatusResponse;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: Vec\u003cIndexStatusResponse\u003e = r.table(\"test\")\n    ///         .index_status(\"timestamp\")\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response.len() \u003e 0);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Save the binary representation of the index:\n    ///\n    /// ```\n    /// use reql_rust::types::IndexStatusResponse;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"test\")\n    ///         .index_status(\"timestamp\")\n    ///         .nth(0)\n    ///         .g(\"function\")\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [index_wait](Self::index_wait)\n    pub fn index_status(self, args: impl index_status::IndexStatusArg) -\u003e Self {\n        index_status::new(args).with_parent(self)\n    }\n\n    /// Wait for the specified indexes on this table to be ready,\n    /// or for all indexes on this table to be ready if no indexes are specified.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// table.index_wait(()) → response\n    /// table.index_wait(index) → response\n    /// ```\n    ///\n    /// Where:\n    /// - index: \u0026str | [\u0026str; N]\n    /// - response: [IndexStatusResponse](crate::types::IndexStatusResponse)\n    ///\n    /// ## Examples\n    ///\n    /// Wait for all indexes on the table `test` to be ready:\n    ///\n    /// ```\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::types::IndexStatusResponse;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: IndexStatusResponse = r.table(\"test\")\n    ///         .index_wait(())\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response.ready);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Wait for the index `timestamp` to be ready:\n    ///\n    /// ```\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::types::IndexStatusResponse;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: IndexStatusResponse = r.table(\"test\")\n    ///         .index_wait(\"timestamp\")\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response.ready);\n    ///     assert_eq!(response.index, \"author\");\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [index_status](Self::index_status)\n    pub fn index_wait(self, args: impl index_wait::IndexWaitArg) -\u003e Self {\n        index_wait::new(args).with_parent(self)\n    }\n\n    /// Sets the write hook on a table or overwrites it if one already exists.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// table.set_write_hook(params) → response\n    /// ```\n    ///\n    /// Where:\n    /// - params: func!(...) | None |\n    /// [Binary](crate::types::Binary) | [Command](crate::Command)\n    /// - response: [SetWriteHookResponse](crate::types::SetWriteHookResponse)\n    ///\n    /// # Description\n    ///\n    /// The `function` can be an anonymous function with the signature\n    /// `(context: object, old_val: object, new_val: object) -\u003e object`\n    /// or a binary representation obtained from the `function` field\n    /// of [get_write_hook](Self::get_write_hook).\n    /// The function must be deterministic,\n    /// and so cannot use a subquery or the `r.js` command.\n    ///\n    /// The first argument, `context`,\n    /// is a ReQL object containing the following properties:\n    /// - `primary_key`: primary key of the document being deleted, inserted, or modified\n    /// - `timestamp`: a ReQL `time` object representing the current query execution time\n    ///\n    /// Whenever a write operation on the table inserts, deletes or modifies a given document,\n    /// the write hook function will be called with the context parameter, the old value of\n    /// the document (or `null` on inserts) and the new value of the document (or `null` on deletes).\n    /// It then returns the value that should actually be inserted and/or replaced instead of `newVal`.\n    /// It can also return `r.error(...)` to abort the write.\n    ///\n    /// For simplicity, the write hook function is allowed\n    /// to return `null` exactly if and only if `newVal` is `null`.\n    /// This is just a safeguard to ensure you don’t accidentally\n    /// turn an insert/update into a deletion, or a deletion into an update.\n    ///\n    /// ## Examples\n    ///\n    /// Create a write hook\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::types::SetWriteHookResponse;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: SetWriteHookResponse = r.table(\"comments\")\n    ///         .set_write_hook(func!(|_, _, new_val| new_val))\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert_eq!(response.created, Some(1));\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Delete the write hook associated with the comments table.\n    ///\n    /// ```\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::types::SetWriteHookResponse;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: SetWriteHookResponse = r.table(\"comments\")\n    ///         .set_write_hook(None)\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert_eq!(response.deleted, Some(1));\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [get_write_hook](Self::get_write_hook)\n    pub fn set_write_hook(self, args: impl set_write_hook::SetWriteHookArg) -\u003e Self {\n        set_write_hook::new(args).with_parent(self)\n    }\n\n    /// Gets the write hook of this table.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// table.get_write_hook() → response\n    /// ```\n    ///\n    /// Where:\n    /// - response: [GetWriteHookResponse](crate::types::GetWriteHookResponse)\n    ///\n    /// # Description\n    ///\n    /// If a write hook exists, the result is an object of the following form:\n    ///\n    /// ```text\n    /// {\n    ///     \"function\": \u003cbinary\u003e,\n    ///     \"query\": \"setWriteHook(function(_var1, _var2, _var3) { return ...; })\",\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Get the write hook for the `comments` table.\n    ///\n    /// ```\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::types::GetWriteHookResponse;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: GetWriteHookResponse = r.table(\"comments\")\n    ///         .get_write_hook()\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert_eq!(\n    ///         response.query,\n    ///         \"setWriteHook(function(var1, var2, var3) { return var3; })\"\n    ///     );\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [set_write_hook](Self::set_write_hook)\n    pub fn get_write_hook(self) -\u003e Self {\n        get_write_hook::new().with_parent(self)\n    }\n\n    /// Insert documents into a table.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// table.insert(object) → response\n    /// table.insert(args!(object, options)) → response\n    /// ```\n    ///\n    /// Where:\n    /// - object: impl Serialize | [Command](crate::Command)\n    /// - options: [InsertOption](crate::cmd::insert::InsertOption)\n    /// - response: [MutationResponse](crate::types::MutationResponse)\n    ///\n    /// # Description\n    ///\n    /// Accepts a single document or an array of documents.\n    ///\n    /// ## Examples\n    ///\n    /// Insert a document into the table `posts`.\n    ///\n    /// ```\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::types::MutationResponse;\n    /// use reql_rust::{r, Result};\n    /// use serde_json::json;\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: MutationResponse = r.table(\"posts\")\n    ///         .insert(json!({\n    ///             \"id\": 1,\n    ///             \"title\": \"Lorem ipsum\",\n    ///             \"content\": \"Dolor sit amet\",\n    ///         }))\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response.inserted == 1);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Insert a document without a defined primary key into\n    /// the table `posts` where the primary key is `id`.\n    ///\n    /// ```\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::types::MutationResponse;\n    /// use reql_rust::{r, Result};\n    /// use serde_json::json;\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: MutationResponse = r.table(\"posts\")\n    ///         .insert(json!({\n    ///             \"title\": \"Lorem ipsum\",\n    ///             \"content\": \"Dolor sit amet\",\n    ///         }))\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response.inserted == 1);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Insert multiple documents into the table `users`.\n    ///\n    /// ```\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::types::MutationResponse;\n    /// use reql_rust::{r, Result};\n    /// use serde_json::json;\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: MutationResponse = r.table(\"users\")\n    ///         .insert(json!([\n    ///             {\"id\": \"malika\", \"email\": \"malika@rethinkdb.com\"},\n    ///             {\"id\": \"moussa\", \"email\": \"moussa@rethinkdb.com\"}\n    ///         ]))\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response.inserted == 1);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Insert a document into the table `users`,\n    /// replacing the document if the document already exists.\n    ///\n    /// ```\n    /// use reql_rust::arguments::Conflict;\n    /// use reql_rust::cmd::insert::InsertOption;\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::types::MutationResponse;\n    /// use reql_rust::{args, r, Result};\n    /// use serde_json::json;\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let insert_option = InsertOption::default().conflict(Conflict::Replace);\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: MutationResponse = r.table(\"users\")\n    ///         .insert(args!(\n    ///             json!({\"id\": \"malika\", \"email\": \"malika@rethinkdb.com\"}),\n    ///             insert_option\n    ///         ))\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response.inserted == 1);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Copy the documents from `posts` to `posts_backup`.\n    ///\n    /// ```\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::types::MutationResponse;\n    /// use reql_rust::{r, Result};\n    /// use serde_json::json;\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: MutationResponse = r.table(\"posts_backup\")\n    ///         .insert(r.table(\"posts\"))\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response.inserted == 1);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Get back a copy of the inserted document (with its generated primary key).\n    ///\n    /// ```\n    /// use reql_rust::arguments::ReturnChanges;\n    /// use reql_rust::cmd::insert::InsertOption;\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::types::MutationResponse;\n    /// use reql_rust::{args, r, Result};\n    /// use serde_json::json;\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let insert_option = InsertOption::default().return_changes(ReturnChanges::Bool(true));\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: MutationResponse = r.table(\"posts\")\n    ///         .insert(args!(\n    ///             json!({\"title\": \"Lorem ipsum\", \"content\": \"Dolor sit amet\"}),\n    ///             insert_option\n    ///         ))\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response.inserted == 1);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [update](Self::update)\n    /// - [replace](Self::replace)\n    /// - [delete](Self::delete)\n    pub fn insert(self, args: impl insert::InsertArg) -\u003e Self {\n        insert::new(args).with_parent(self)\n    }\n\n    /// Update JSON documents in a table.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// table.replace(object) → response\n    /// table.replace(func) → response\n    /// table.replace(args!(object, options)) → response\n    /// table.replace(args!(func, options)) → response\n    /// ```\n    ///\n    /// Where:\n    /// - object: impl Serialize | [Command](crate::Command)\n    /// - func: func!(...)\n    /// - options: [ReplaceOption](crate::cmd::replace::ReplaceOption)\n    /// - response: [MutationResponse](crate::types::MutationResponse)\n    ///\n    /// # Description\n    ///\n    /// Accepts a JSON document, a ReQL expression, or a combination of the two.\n    ///\n    /// ## Examples\n    ///\n    /// Update the status of the post with `id` of `1` to `published`.\n    ///\n    /// ```\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::types::MutationResponse;\n    /// use reql_rust::{r, Result};\n    /// use serde_json::json;\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: MutationResponse = r.table(\"posts\")\n    ///         .get(1)\n    ///         .update(json!({\"status\": \"published\"}))\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response.replaced == 1);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Update the status of all posts to `published`.\n    ///\n    /// ```\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::types::MutationResponse;\n    /// use reql_rust::{r, Result};\n    /// use serde_json::json;\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: MutationResponse = r.table(\"posts\")\n    ///         .update(json!({\"status\": \"published\"}))\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response.replaced == 100);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Update the status of all the posts written by Moussa.\n    ///\n    /// ```\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::types::MutationResponse;\n    /// use reql_rust::{r, Result};\n    /// use serde_json::json;\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: MutationResponse = r.table(\"posts\")\n    ///         .filter(json!({\"author\": \"Moussa\"}))\n    ///         .update(json!({\"status\": \"published\"}))\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response.replaced == 5);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ```text\n    /// Note that `filter`, `get_all` and similar operations\n    /// do **not** execute in an atomic fashion with `update`.\n    /// Read [Consistency guarantees](https://rethinkdb.com/docs/consistency) for more details.\n    /// Also, see the example for conditional updates\n    /// below for a solution using `branch` in an `update` clause.\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Increment the field `view` of the post with `id` of `1`.\n    /// This query will throw an error if the field `views` doesn’t exist.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::types::MutationResponse;\n    /// use reql_rust::{r, Result};\n    /// use serde_json::json;\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: MutationResponse = r.table(\"posts\")\n    ///         .get(1)\n    ///         .update(func!(|post| post.g(\"views\") + r.expr(1)))\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response.replaced == 1);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Increment the field view of the post with id of 1.\n    /// If the field views does not exist, it will be set to 0.\n    ///\n    /// ```\n    /// use std::ops::Add;\n    ///\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::types::MutationResponse;\n    /// use reql_rust::{r, Result};\n    /// use serde_json::json;\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: MutationResponse = r.table(\"posts\")\n    ///         .get(1)\n    ///         .update(func!(|post| post.g(\"views\").add(r.expr(1)).default(0)))\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response.replaced == 1);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Perform a conditional update.\n    ///\n    /// If the post has more than 100 views,\n    /// set the `type` of a post to `hot`,\n    /// else set it to `normal`.\n    ///\n    /// ```\n    /// use std::ops::Add;\n    ///\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::types::MutationResponse;\n    /// use reql_rust::{args, r, Result};\n    /// use serde_json::json;\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: MutationResponse = r.table(\"posts\")\n    ///         .get(1)\n    ///         .update(func!(|post| r.branch(\n    ///             post.g(\"views\").gt(100),\n    ///             args!(\n    ///                 r.expr(json!({\"type\": \"hot\"})),\n    ///                 r.expr(json!({\"type\": \"normal\"}))\n    ///             )\n    ///         )))\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response.replaced == 1);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Update the field `num_comments` with the result of a sub-query.\n    /// Because this update is not atomic, you must pass the `non_atomic` flag.\n    ///\n    /// ```\n    /// use std::collections::HashMap;\n    ///\n    /// use reql_rust::cmd::update::UpdateOption;\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::types::MutationResponse;\n    /// use reql_rust::{args, r, Result};\n    /// use serde_json::json;\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let update_option = UpdateOption::default().non_atomic(true);\n    ///     let conn = r.connection().connect().await?;\n    ///     let mut comments_filtered = HashMap::new();\n    ///     comments_filtered.insert(\n    ///         \"num_comments\",\n    ///         r.table(\"comments\")\n    ///             .filter(json!({\"id_post\": 1}))\n    ///             .count(())\n    ///     );\n    ///     let response: MutationResponse = r.table(\"posts\")\n    ///         .get(1)\n    ///         .update(args!(r.hash_map(comments_filtered), update_option))\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response.replaced == 1);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// If you forget to specify the `non_atomic` flag,\n    /// you will get a `ReqlRuntimeError`:\n    ///\n    /// ```text\n    /// ReqlRuntimeError: Could not prove function deterministic.\n    /// Maybe you want to use the non_atomic flag?\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Update the field `num_comments` with a random value between 0 and 100.\n    /// This update cannot be proven deterministic because of `r.js` (and in fact is not),\n    /// so you must pass the `non_atomic` flag.\n    ///\n    /// ```\n    /// use std::collections::HashMap;\n    ///\n    /// use reql_rust::cmd::update::UpdateOption;\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::types::MutationResponse;\n    /// use reql_rust::{args, r, Result};\n    /// use serde_json::json;\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let update_option = UpdateOption::default().non_atomic(true);\n    ///     let conn = r.connection().connect().await?;\n    ///     let mut comments_filtered = HashMap::new();\n    ///     comments_filtered.insert(\n    ///         \"num_comments\",\n    ///         r.js(\"Math.floor(Math.random()*100)\")\n    ///     );\n    ///     let response: MutationResponse = r.table(\"posts\")\n    ///         .get(1)\n    ///         .update(args!(r.hash_map(comments_filtered), update_option))\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response.replaced == 1);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Update the status of the post with `id` of `1` using soft durability.\n    ///\n    /// ```\n    /// use reql_rust::arguments::Durability;\n    /// use reql_rust::cmd::update::UpdateOption;\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::types::MutationResponse;\n    /// use reql_rust::{args, r, Result};\n    /// use serde_json::json;\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let update_option = UpdateOption::default().durability(Durability::Soft);\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: MutationResponse = r.table(\"posts\")\n    ///         .get(1)\n    ///         .update(args!(json!({\"status\": \"published\"}), update_option))\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response.replaced == 1);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [insert](Self::insert)\n    /// - [replace](Self::replace)\n    /// - [delete](Self::delete)\n    pub fn update(self, args: impl update::UpdateArg) -\u003e Self {\n        update::new(args).with_parent(self)\n    }\n\n    /// Replace documents in a table.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// table.replace(object) → response\n    /// table.replace(func) → response\n    /// table.replace(args!(object, options)) → response\n    /// table.replace(args!(func, options)) → response\n    /// ```\n    ///\n    /// Where:\n    /// - object: impl Serialize | [Command](crate::Command)\n    /// - func: func!(...)\n    /// - options: [ReplaceOption](crate::cmd::replace::ReplaceOption)\n    /// - response: [MutationResponse](crate::types::MutationResponse)\n    ///\n    /// # Description\n    ///\n    /// Accepts a JSON document or a ReQL expression, and replaces\n    /// the original document with the new one.\n    /// The new document must have the same primary key as the original document.\n    ///\n    /// The `replace` command can be used to both insert and delete documents.\n    /// If the “replaced” document has a primary key that doesn’t exist in the table,\n    /// the document will be inserted; if an existing document is replaced with `None`,\n    /// the document will be deleted.\n    /// Since `update` and `replace` operations are performed atomically,\n    /// this allows atomic inserts and deletes as well.\n    ///\n    /// ## Examples\n    ///\n    /// Replace the document with the primary key `1`.\n    ///\n    /// ```\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::types::MutationResponse;\n    /// use reql_rust::{r, Result};\n    /// use serde_json::json;\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: MutationResponse = r.table(\"posts\")\n    ///         .get(1)\n    ///         .replace(json!({\n    ///             \"id\": 1,\n    ///             \"title\": \"Lorem ipsum\",\n    ///             \"content\": \"Aleas jacta est\",\n    ///             \"status\": \"draft\"\n    ///         }))\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response.replaced == 1);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Remove the field `status` from all posts.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::types::MutationResponse;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: MutationResponse = r.table(\"posts\")\n    ///         .replace(func!(|post| post.without(\"status\")))\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response.replaced == 5);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Remove all the fields that are not `id`, `title` or `content`.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::types::MutationResponse;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: MutationResponse = r.table(\"posts\")\n    ///         .replace(func!(|post| post.pluck([\"id\", \"title\", \"content\"])))\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response.replaced == 5);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Replace the document with the primary key `1` using soft durability.\n    ///\n    /// ```\n    /// use reql_rust::arguments::Durability;\n    /// use reql_rust::cmd::replace::ReplaceOption;\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::types::MutationResponse;\n    /// use reql_rust::{args, r, Result};\n    /// use serde_json::json;\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let replace_option = ReplaceOption::default().durability(Durability::Soft);\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: MutationResponse = r.table(\"posts\")\n    ///         .get(1)\n    ///         .replace(args!(json!({\n    ///             \"id\": 1,\n    ///             \"title\": \"Lorem ipsum\",\n    ///             \"content\": \"Aleas jacta est\",\n    ///             \"status\": \"draft\"\n    ///         }), replace_option))\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response.replaced == 1);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Replace the document with the primary key `1` and return the\n    /// values of the document before and after the replace operation.\n    ///\n    /// ```\n    /// use reql_rust::arguments::ReturnChanges;\n    /// use reql_rust::cmd::replace::ReplaceOption;\n    /// use reql_rust::{args, r, Result};\n    /// use serde_json::json;\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let replace_option = ReplaceOption::default().return_changes(ReturnChanges::Bool(true));\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"posts\")\n    ///         .get(1)\n    ///         .replace(args!(json!({\n    ///             \"id\": 1,\n    ///             \"title\": \"Lorem ipsum\",\n    ///             \"content\": \"Aleas jacta est\",\n    ///             \"status\": \"draft\"\n    ///         }), replace_option))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [insert](Self::insert)\n    /// - [update](Self::update)\n    /// - [delete](Self::delete)\n    pub fn replace(self, args: impl replace::ReplaceArg) -\u003e Self {\n        replace::new(args).with_parent(self)\n    }\n\n    /// Delete one or more documents from a table.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// table.delete(()) → response\n    /// table.delete(options) → response\n    /// ```\n    ///\n    /// Where:\n    /// - options: [DeleteOption](crate::cmd::delete::DeleteOption)\n    /// - response: [MutationResponse](crate::types::MutationResponse)\n    ///\n    /// ## Examples\n    ///\n    /// Delete a single document from the table `comments`.\n    ///\n    /// ```\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::types::MutationResponse;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: MutationResponse = r.table(\"comments\")\n    ///         .get(\"7eab9e63-73f1-4f33-8ce4-95cbea626f59\")\n    ///         .delete(())\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response.deleted == 1);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Delete all documents from the table comments.\n    ///\n    /// ```\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::types::MutationResponse;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: MutationResponse = r.table(\"comments\")\n    ///         .delete(())\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response.deleted == 100);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Delete all comments where the field `id_post` is `3`.\n    ///\n    /// ```\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::types::MutationResponse;\n    /// use reql_rust::{r, Result};\n    /// use serde_json::json;\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: MutationResponse = r.table(\"comments\")\n    ///         .filter(json!({\"id_post\": 3}))\n    ///         .delete(())\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response.deleted == 5);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Delete a single document from the table `comments` and return its value.\n    ///\n    /// ```\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::arguments::ReturnChanges;\n    /// use reql_rust::cmd::delete::DeleteOption;\n    /// use reql_rust::types::MutationResponse;\n    /// use reql_rust::{r, Result};\n    /// use serde_json::json;\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let expected_data = json!({\n    ///         \"id\": \"7eab9e63-73f1-4f33-8ce4-95cbea626f59\",\n    ///         \"author\": \"Moussa\",\n    ///         \"comment\": \"Great post\",\n    ///         \"id_post\": 3\n    ///     });\n    ///     let delete_option = DeleteOption::default().return_changes(ReturnChanges::Bool(true));\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: MutationResponse = r.table(\"comments\")\n    ///         .get(\"7eab9e63-73f1-4f33-8ce4-95cbea626f59\")\n    ///         .delete(delete_option)\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     let old_val = response\n    ///         .clone()\n    ///         .changes\n    ///         .unwrap()\n    ///         .first()\n    ///         .unwrap()\n    ///         .to_owned()\n    ///         .old_val;\n    ///\n    ///     assert!(response.deleted == 1);\n    ///     assert_eq!(old_val, Some(expected_data));\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Delete all documents from the table `comments` without\n    /// waiting for the operation to be flushed to disk.\n    ///\n    /// ```\n    /// use reql_rust::arguments::Durability;\n    /// use reql_rust::cmd::delete::DeleteOption;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let delete_option = DeleteOption::default().durability(Durability::Soft);\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"comments\")\n    ///         .delete(delete_option)\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [insert](Self::insert)\n    /// - [update](Self::update)\n    /// - [replace](Self::replace)\n    pub fn delete(self, args: impl delete::DeleteArg) -\u003e Self {\n        delete::new(args).with_parent(self)\n    }\n\n    /// `sync` ensures that writes on a given\n    /// table are written to permanent storage.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// table.sync() → response\n    /// ```\n    ///\n    /// Where:\n    /// - response: [SyncResponse](crate::types::SyncResponse)\n    ///\n    /// # Description\n    ///\n    /// Queries that specify soft durability (`durability=Durability::Soft`)\n    /// do not give such guarantees, so `sync` can be used to ensure the state of these queries.\n    /// A call to `sync` does not return until all previous writes to the table are persisted.\n    ///\n    /// ## Examples\n    ///\n    /// After having updated multiple heroes with soft durability,\n    /// we now want to wait until these changes are persisted.\n    ///\n    /// ```\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::types::SyncResponse;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: SyncResponse = r.table(\"simbad\")\n    ///         .sync()\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response.synced == 1);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [noreply_wait](crate::connection::Session::noreply_wait)\n    pub fn sync(self) -\u003e Self {\n        sync::new().with_parent(self)\n    }\n\n    /// Get a document by primary key.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// table.get(keys) → singleRowSelection\n    /// ```\n    ///\n    /// Where:\n    /// - keys: impl Serialize | [Command](crate::Command)\n    ///\n    /// # Description\n    ///\n    /// If no document exists with that primary key, `get` will return `None`.\n    ///\n    /// ## Examples\n    ///\n    /// Find a document by UUID.\n    ///\n    /// ```\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"posts\")\n    ///         .get(\"a9849eef-7176-4411-935b-79a6e3c56a74\")\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Find a document and merge another document with it.\n    ///\n    /// ```\n    /// use reql_rust::{r, Result};\n    /// use serde_json::json;\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"heroes\")\n    ///         .get(3)\n    ///         .merge(json!({\n    ///             \"powers\": [\"invisibility\", \"speed\"]\n    ///         }))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [get_all](Self::get_all)\n    /// - [between](Self::between)\n    /// - [filter](Self::filter)\n    pub fn get(self, args: impl get::GetArg) -\u003e Self {\n        get::new(args).with_parent(self)\n    }\n\n    /// Get all documents where the given value\n    /// matches the value of the requested index.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// table.get_all(keys) → selection\n    /// table.get_all(args!(keys, options)) → selection\n    /// ```\n    ///\n    /// Where:\n    /// - keys: impl IntoIterator | [Command](crate::Command)\n    /// - options: [GetAllOption](crate::cmd::get_all::GetAllOption)\n    ///\n    /// ## Examples\n    ///\n    /// Secondary index keys are not guaranteed to be unique so we cannot\n    /// query via [get](Self::get) when using a secondary index.\n    ///\n    /// ```\n    /// use reql_rust::cmd::get_all::GetAllOption;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let get_all_option = GetAllOption::default().index(\"code_name\");\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"marvel\")\n    ///         .get_all(args!([\"man_of_steel\"], get_all_option))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Without an index argument, we default to the primary index.\n    /// While `get` will either return the document or `None` when no document\n    /// with such a primary key value exists, this will return either a one or zero length stream.\n    ///\n    /// ```\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"dc\")\n    ///         .get_all([\"superman\"])\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// You can get multiple documents in a single call to get_all.\n    ///\n    /// ```\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"dc\")\n    ///         .get_all([\"superman\", \"ant man\"])\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Note\n    ///\n    /// ```text\n    /// `get_all` does not perform any de-duplication.\n    /// If you pass the same key more than once, the same document will be returned multiple times.\n    /// ```\n    ///\n    /// # Related commands\n    /// - [get](Self::get)\n    /// - [between](Self::between)\n    /// - [filter](Self::filter)\n    pub fn get_all(self, values: impl get_all::GetAllArg) -\u003e Self {\n        get_all::new(values).with_parent(self)\n    }\n\n    /// Get all documents between two keys.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// table.between(args!(lower_key, upper_key)) → table_slice\n    /// table.between(args!(lower_key, upper_key, options)) → table_slice\n    /// ```\n    ///\n    /// Where:\n    /// - lower_key, upper_key: [Command](crate::Command)\n    /// - options: [BetweenOption](crate::cmd::between::BetweenOption)\n    ///\n    /// # Description\n    ///\n    /// You may also use the special constants `r::min_val()` and `r::max_val()` for boundaries,\n    /// which represent “less than any index key” and “more than any index key” respectively.\n    /// For instance, if you use `r::min_val()` as the lower key, then `between` will return\n    /// all documents whose primary keys (or indexes) are less than the specified upper key.\n    ///\n    /// If you use arrays as indexes (compound indexes),\n    /// they will be sorted using\n    /// [lexicographical order](https://en.wikipedia.org/wiki/Lexicographical_order).\n    /// Take the following range as an example:\n    ///\n    /// ```text\n    /// [[1, \"c\"] ... [5, \"e\"]]\n    /// ```\n    ///\n    /// This range includes all compound keys:\n    /// - whose first item is 1 and second item is equal or greater than “c”;\n    /// - whose first item is between 1 and 5,\n    /// **regardless of the value of the second item**;\n    /// - whose first item is 5 and second item is less than or equal to “e”.\n    ///\n    /// ## Examples\n    ///\n    /// Find all users with primary key \u003e= 10 and \u003c 20 (a normal half-open interval).\n    ///\n    /// ```\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"users\")\n    ///         .between(args!(r.expr(10), r.expr(20)))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Find all users with primary key \u003e= 10 and \u003c= 20 (an interval closed on both sides).\n    ///\n    /// ```\n    /// use reql_rust::arguments::Status;\n    /// use reql_rust::cmd::between::BetweenOption;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let between_option = BetweenOption::default().right_bound(Status::Closed);\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"users\")\n    ///         .between(args!(r.expr(10), r.expr(20), between_option))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Find all users with primary key \u003c 20.\n    ///\n    /// ```\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"users\")\n    ///         .between(args!(r::min_val(), r.expr(20)))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Find all users with primary key \u003e 10.\n    ///\n    /// ```\n    /// use reql_rust::arguments::Status;\n    /// use reql_rust::cmd::between::BetweenOption;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let between_option = BetweenOption::default().right_bound(Status::Open);\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"users\")\n    ///         .between(args!(r.expr(10), r::max_val(), between_option))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Between can be used on secondary indexes too.\n    /// Just pass an optional index argument giving the secondary index to query.\n    ///\n    /// ```\n    /// use reql_rust::cmd::between::BetweenOption;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let between_option = BetweenOption::default().index(\"code_name\");\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"dc\")\n    ///         .between(args!(r.expr(\"dark_knight\"), r.expr(\"man_of_steel\"), between_option))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Get all users whose full name is between “John Smith” and “Wade Welles.”\n    ///\n    /// ```\n    /// use reql_rust::cmd::between::BetweenOption;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let between_option = BetweenOption::default().index(\"full_name\");\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"dc\")\n    ///         .between(args!(r.expr([\"Smith\", \"John\"]), r.expr([\"Welles\", \"Wade\"]), between_option))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [get](Self::get)\n    /// - [get_all](Self::get_all)\n    /// - [filter](Self::filter)\n    pub fn between(self, args: impl between::BetweenArg) -\u003e Self {\n        between::new(args).with_parent(self)\n    }\n\n    /// Return all the elements in a sequence for which the given predicate is true.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// selection.filter(func) → selection\n    /// selection.filter(predicate) → selection\n    /// selection.filter(args!(func, options)) → selection\n    /// selection.filter(args!(predicate, options)) → selection\n    /// ```\n    ///\n    /// Where:\n    /// - predicate: [Command](crate::Command) | impl Serialize\n    /// - func: func!(...)\n    /// - options: [FilterOption](crate::cmd::filter::FilterOption)\n    ///\n    /// # Description\n    ///\n    /// Return all the elements in a sequence for which the given predicate is true.\n    /// The return value of `filter` will be the same as the input (sequence, stream, or array).\n    /// Documents can be filtered in a variety of ways—ranges, nested values, boolean conditions,\n    /// and the results of anonymous functions.\n    ///\n    /// By default, `filter` will silently skip documents with missing fields:\n    /// if the predicate tries to access a field that doesn’t exist\n    /// (for instance, the predicate `{\"age\": 30}` applied to a document with no `age` field),\n    /// that document will not be returned in the result set, and no error will be generated.\n    /// This behavior can be changed with the default optional argument\n    /// [FilterOption](crate::cmd::filter::FilterOption).\n    ///\n    /// ## Note\n    ///\n    /// `filter` does not use secondary indexes.\n    /// For retrieving documents via secondary indexes, consider\n    /// [get_all](Self::get_all), [between](Self::between) and [eq_join](Self::eq_join).\n    ///\n    /// # Basic predicates\n    ///\n    /// ## Examples\n    ///\n    /// Get all users who are 30 years old.\n    ///\n    /// ```\n    /// use reql_rust::{args, r, Result};\n    /// use serde_json::json;\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"users\")\n    ///         .filter(json!({\"age\": 30}))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// The predicate `{\"age\": 30}` selects documents in the `users` table\n    /// with an `age` field whose value is 30. Documents with an `age` field\n    /// set to any other value or with no `age` field present are skipped.\n    ///\n    /// While the `{\"field\": value}` style of predicate is useful for exact matches,\n    /// a more general way to write a predicate is to use an anonymous function that\n    /// returns `true` or `false`.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"users\")\n    ///         .filter(func!(|user| user.g(\"age\").eq(30)))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// In this case, the function returns `true` if the field `age` is equal to 30.\n    ///\n    /// Predicates to filter are evaluated on the server, and must use ReQL expressions.\n    /// You cannot use standard Java comparison operators such as `==`, `\u003c` / `\u003e` and `||` / `\u0026\u0026`.\n    ///\n    /// ## Examples\n    ///\n    /// Get all users who are more than 18 years old.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"users\")\n    ///         .filter(func!(|user| user.g(\"age\").gt(18)))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Get all users who are less than 18 years old and more than 13 years old.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"users\")\n    ///         .filter(func!(|user| user.clone().g(\"age\").lt(18).and(\n    ///             user.g(\"age\").gt(13)\n    ///         )))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Get all users who are more than 18 years old or have their parental consent.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"users\")\n    ///         .filter(func!(|user| user\n    ///             .clone()\n    ///             .g(\"age\")\n    ///             .ge(18)\n    ///             .or(user.g(\"hasParentalConsent\"))\n    ///         ))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Get all users who are more than 18 years old or have their parental consent.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"users\")\n    ///         .filter(func!(|user| user\n    ///             .clone()\n    ///             .g(\"age\")\n    ///             .ge(18)\n    ///             .or(user.g(\"hasParentalConsent\"))\n    ///         ))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # More complex predicates\n    ///\n    /// ## Examples\n    ///\n    /// Retrieve all users who subscribed between January\n    /// 1st, 2012 (included) and January 1st, 2013 (excluded).\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{args, r, Result};\n    /// use time::macros::{date, offset};\n    /// use time::UtcOffset;\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let timezone = UtcOffset::UTC;\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"users\")\n    ///         .filter(func!(|user| user.g(\"subscription_date\").during(args!(\n    ///             r.time(args!(date!(2012 - 1 - 1), timezone)),\n    ///             r.time(args!(date!(2015 - 1 - 1), timezone))\n    ///         ))))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Retrieve all users who have a gmail account (whose field email ends with @gmail.com).\n    ///\n    /// ```\n    /// use regex::Regex;\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let regexpr = Regex::new(\"@gmail.com$\")?;\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"users\")\n    ///         .filter(func!(|user| user.g(\"email\").match_(regexpr)))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Filter based on the presence of a value in an array.\n    ///\n    /// Given this schema for the `users` table.\n    ///\n    /// ```text\n    /// {\n    ///     \"name\": String,\n    ///     \"places_visited\": Vec\u003cString\u003e,\n    /// }\n    /// ```\n    ///\n    /// Retrieve all users whose field `places_visited` contains `Cameroon`.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"users\")\n    ///         .filter(func!(|user| user.g(\"places_visited\").contains(\"Cameroon\")))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Filter based on nested fields.\n    ///\n    /// Given this schema for the `users` table.\n    ///\n    /// ```text\n    /// {\n    ///     \"id\": String,\n    ///     \"name\": {\n    ///         \"first\": String,\n    ///         \"middle\": String,\n    ///         \"last\": String,\n    ///     },\n    /// }\n    /// ```\n    ///\n    /// Retrieve all users named “Moussa Ibrahim\n    /// (first name “Moussa”, last name “Ibrahim”),\n    /// with any middle name.\n    ///\n    /// ```\n    /// use reql_rust::{args, r, Result};\n    /// use serde_json::json;\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"users\")\n    ///         .filter(json!({\n    ///             \"name\": {\n    ///                 \"first\": \"Moussa\",\n    ///                 \"last\": \"Ibrahim\",\n    ///             }\n    ///         }))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// If you want an exact match for a field that is an object,\n    /// you will have to use anonymous functions.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"users\")\n    ///         .filter(func!(|user| user\n    ///             .clone()\n    ///             .g(\"name\")\n    ///             .g(\"first\")\n    ///             .eq(\"Moussa\")\n    ///             .and(user.g(\"name\").g(\"last\").eq(\"Ibrahim\"))\n    ///         ))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{args, r, Result};\n    /// use serde_json::json;\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"users\")\n    ///         .filter(func!(|user| user\n    ///             .g(\"name\")\n    ///             .eq(r.expr(json!({\n    ///                 \"first\": \"Moussa\",\n    ///                 \"last\": \"Ibrahim\",\n    ///             })))\n    ///         ))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [get](Self::get)\n    /// - [get_all](Self::get_all)\n    /// - [between](Self::between)\n    pub fn filter(self, args: impl filter::FilterArg) -\u003e Self {\n        filter::new(args).with_parent(self)\n    }\n\n    /// Returns an inner join of two sequences.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// sequence.inner_join(other_sequence, func) → response\n    /// ```\n    ///\n    /// Where:\n    /// - other_sequence: [Command](crate::Command)\n    /// - func: func!(...)\n    /// - response: [Vec\u003cJoinResponse\u003cLeft, Right\u003e\u003e](crate::types::JoinResponse)\n    ///\n    /// # Description\n    ///\n    /// The returned sequence represents an intersection of the left-hand sequence\n    /// and the right-hand sequence: each row of the left-hand sequence will be\n    /// compared with each row of the right-hand sequence to find all pairs of rows\n    /// which satisfy the predicate. In most cases, you will want to follow the join\n    /// with [zip](Self::zip) to combine the left and right results.\n    ///\n    /// ```text\n    /// Note that `inner_join` is slower and much less efficient than using `concat_map`\n    /// with `get_all`. You should avoid using `inner_join` in commands when possible.\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Return a list of all matchups between Marvel and DC heroes\n    /// in which the DC hero could beat the Marvel hero in a fight.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"marvel\")\n    ///         .inner_join(\n    ///             r.table(\"dc\"),\n    ///             func!(|marvel, dc| marvel.g(\"strength\").lt(dc.g(\"strength\")))\n    ///         )\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// (Compare this to an [outer_join](Self::outer_join) with\n    /// the same inputs and predicate, which would return a list\n    /// of **all** Marvel heroes along with any DC heroes with a higher strength.)\n    ///\n    /// # Related commands\n    /// - [eq_join](Self::eq_join)\n    /// - [outer_join](Self::outer_join)\n    /// - [zip](Self::zip)\n    pub fn inner_join(self, other_sequence: Command, func: Func) -\u003e Self {\n        inner_join::new(other_sequence, func).with_parent(self)\n    }\n\n    /// Returns a left outer join of two sequences.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// sequence.outer_join(other_sequence, func) → response\n    /// ```\n    ///\n    /// Where:\n    /// - other_sequence: [Command](crate::Command)\n    /// - func: func!(...)\n    /// - response: [Vec\u003cJoinResponse\u003cLeft, Right\u003e\u003e](crate::types::JoinResponse)\n    ///\n    /// # Description\n    ///\n    /// The returned sequence represents a union of the left-hand sequence and the\n    /// right-hand sequence: all documents in the left-hand sequence will be returned,\n    /// each matched with a document in the right-hand sequence if one satisfies the\n    /// predicate condition. In most cases, you will want to follow the join with\n    /// [zip](Self::zip) to combine the left and right results.\n    ///\n    /// ```text\n    /// Note that `outer_join` is slower and much less efficient than using `concat_map`\n    /// with `get_all`. You should avoid using `outer_join` in commands when possible.\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Return a list of all Marvel heroes, paired with\n    /// any DC heroes who could beat them in a fight.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"marvel\")\n    ///         .outer_join(\n    ///             r.table(\"dc\"),\n    ///             func!(|marvel, dc| marvel.g(\"strength\").lt(dc.g(\"strength\")))\n    ///         )\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// (Compare this to an [inner_join](Self::inner_join) with\n    /// the same inputs and predicate, which would return a list\n    /// only of the matchups in which the DC hero has the higher strength.)\n    ///\n    /// # Related commands\n    /// - [eq_join](Self::eq_join)\n    /// - [inner_join](Self::inner_join)\n    /// - [zip](Self::zip)\n    pub fn outer_join(self, other_sequence: Command, func: Func) -\u003e Self {\n        outer_join::new(other_sequence, func).with_parent(self)\n    }\n\n    /// Join tables using a field or function on the left-hand sequence\n    /// matching primary keys or secondary indexes on the right-hand table.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// sequence.eq_join(args!(left_field, right_table)) → response\n    /// sequence.eq_join(args!(func, right_table)) → response\n    /// sequence.eq_join(args!(left_field, right_table, options)) → response\n    /// sequence.eq_join(args!(func, right_table, options)) → response\n    /// ```\n    ///\n    /// Where:\n    /// - left_field, right_table: [Command](crate::Command)\n    /// - func: func!(...)\n    /// - options: [EqJoinOption](crate::cmd::eq_join::EqJoinOption)\n    /// - response: [Vec\u003cJoinResponse\u003cLeft, Right\u003e\u003e](crate::types::JoinResponse)\n    ///\n    /// # Description\n    ///\n    /// `eq_join` is more efficient than other ReQL join types, and operates much faster.\n    /// Documents in the result set consist of pairs of left-hand and right-hand documents,\n    /// matched when the field on the left-hand side exists and is non-null and an entry\n    /// with that field’s value exists in the specified index on the right-hand side.\n    ///\n    /// The result set of `eq_join` is a stream or array of\n    /// [JoinResponse\u003cLeftDocument, RightDocument\u003e](crate::types::JoinResponse).\n    /// Each object in the returned set will be an object of the form\n    /// `{ left: \u003cLeftDocument\u003e, right: \u003cRightDocument\u003e }`, where the values of `left` and\n    /// `right` will be the joined documents.\n    /// Use the [zip](Self::zip) command to merge the `left` and `right` fields together.\n    ///\n    /// The results from `eq_join` are, by default, not ordered.\n    ///\n    /// Suppose the players table contains these documents:\n    ///\n    /// ```text\n    /// [\n    ///     { \"id\": 1, \"player\": \"Moussa\", \"game_id\": 1 },\n    ///     { \"id\": 2, \"player\": \"Fatima\", \"game_id\": 3 },\n    ///     { \"id\": 3, \"player\": \"Abessolo\", \"game_id\": 2 },\n    ///     { \"id\": 4, \"player\": \"Kamga\", \"game_id\": 2 },\n    ///     { \"id\": 5, \"player\": \"Malika\", \"game_id\": 1 },\n    ///     { \"id\": 6, \"player\": \"Ibrahim\", \"game_id\": 3 }\n    /// ]\n    /// ```\n    ///\n    /// The games table contains these documents:\n    ///\n    /// [\n    ///     { \"id\": 1, \"field\": \"Aurion\" },\n    ///     { \"id\": 2, \"field\": \"Adventures of Nyangi\" },\n    ///     { \"id\": 3, \"field\": \"Gazkar\" }\n    /// ]\n    ///\n    /// ## Examples\n    ///\n    /// Match players with the games they’ve played against one another.\n    ///\n    /// Join these tables using `game_id` on the player table and `id` on the games table:\n    ///\n    /// ```\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"players\")\n    ///         .eq_join(args!(\"game_id\", r.table(\"games\")))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// For more information, see\n    /// [Table joins in RethinkDB](https://rethinkdb.com/docs/table-joins/).\n    ///\n    /// ## Examples\n    ///\n    /// Use a secondary index on the right table rather than the primary key.\n    /// If players have a secondary index on their cities, we can get a list\n    /// of arenas with players in the same area.\n    ///\n    /// ```\n    /// use reql_rust::cmd::eq_join::EqJoinOption;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"players\")\n    ///         .eq_join(args!(\n    ///             \"city_id\",\n    ///             r.table(\"arenas\"),\n    ///             EqJoinOption::default().index(\"city_id\")\n    ///         ))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Use a function instead of a field to join on a more complicated expression.\n    /// Suppose the players have lists of favorite games ranked in order in a field\n    /// such as \"favorites\": [3, 2, 1]. Get a list of players and their top favorite:\n    ///\n    /// ```\n    /// use reql_rust::cmd::eq_join::EqJoinOption;\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{args, r, Result};\n    /// use serde_json::json;\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"players\")\n    ///         .eq_join(args!(\n    ///             func!(|player| player.g(\"favorites\").nth(0)),\n    ///             r.table(\"games\")\n    ///         ))\n    ///         .without(json!([\n    ///             { \"left\": [\"favorites\", \"game_id\", \"id\"] },\n    ///             { \"right\": \"id\" }\n    ///         ]))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [inner_join](Self::inner_join)\n    /// - [outer_join](Self::outer_join)\n    /// - [without](Self::without)\n    /// - [zip](Self::zip)\n    pub fn eq_join(self, args: impl eq_join::EqJoinArg) -\u003e Self {\n        eq_join::new(args).with_parent(self)\n    }\n\n    /// Used to ‘zip’ up the result of a join by merging the ‘right’\n    /// fields into ‘left’ fields of each member of the sequence.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// stream.zip() → stream\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// ‘zips up’ the sequence by merging the left and right fields produced by a join.\n    ///\n    /// ```\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"posts\")\n    ///         .eq_join(args!(\"user_id\", r.table(\"users\")))\n    ///         .zip()\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [eq_join](Self::eq_join)\n    /// - [inner_join](Self::inner_join)\n    /// - [outer_join](Self::outer_join)\n    pub fn zip(self) -\u003e Self {\n        zip::new().with_parent(self)\n    }\n\n    /// Transform each element of one or more sequences\n    /// by applying a mapping function to them.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// sequence.map(func) → stream\n    /// sequence.map(sequence, func) → stream\n    /// sequence.map(sequences, func) → stream\n    /// r.map(sequence, func) → stream\n    /// r.map(sequence, sequence, func) → stream\n    /// r.map(sequence, sequences, func) → stream\n    /// ```\n    ///\n    /// Where:\n    /// - func: func!(...)\n    /// - sequence: [Command](crate::Command)\n    /// - sequences: [...] | \u0026[...] | vec![...]\n    ///\n    /// # Description\n    ///\n    /// If `map` is run with two or more sequences, it will iterate\n    /// for as many items as there are in the shortest sequence.\n    ///\n    /// Note that `map` can only be applied to sequences, not single values.\n    /// If you wish to apply a function to a single value/selection (including an array),\n    /// use the [do_](Self::do_) command.\n    ///\n    /// ## Examples\n    ///\n    /// Return the first five squares.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: Vec\u003cu8\u003e = r.expr([1, 2, 3, 4, 5])\n    ///         .map(func!(|val| val.clone() * val))\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert_eq!(response, [1, 4, 9, 16, 25]);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Sum the elements of three sequences.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let sequence1 = r.expr([100, 200, 300, 400]);\n    ///     let sequence2 = r.expr([10, 20, 30, 40]);\n    ///     let sequence3 = r.expr([1, 2, 3, 4]);\n    ///\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: Vec\u003cu32\u003e = r.map(sequence1, args!(\n    ///             [sequence2, sequence3],\n    ///             func!(|val1, val2, val3| val1 + val2 + val3)\n    ///         ))\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert_eq!(response, [111, 222, 333, 444]);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Rename a field when retrieving documents\n    /// using `map` and [merge](Self::merge).\n    ///\n    /// This example renames the field `id` to `user_id`\n    /// when retrieving documents from the table `users`.\n    ///\n    /// ```\n    /// use std::collections::HashMap;\n    ///\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"users\")\n    ///         .map(func!(|doc| {\n    ///             let mut user = HashMap::new();\n    ///             user.insert(\"user_id\", doc.clone().g(\"id\"));\n    ///             \n    ///             doc.merge(r.hash_map(user)).without(\"id\")\n    ///         }))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Assign every superhero an archenemy.\n    ///\n    /// ```\n    /// use std::collections::HashMap;\n    ///\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"heroes\")\n    ///         .map(args!(r.table(\"villains\"), func!(|hero, villain| {\n    ///             let mut villain_obj = HashMap::new();\n    ///             villain_obj.insert(\"villain\", villain);\n    ///\n    ///             hero.merge(r.hash_map(villain_obj))\n    ///         })))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [concat_map](Self::concat_map)\n    /// - [reduce](Self::reduce)\n    /// - [do_](Self::do_)\n    pub fn map(self, args: impl map::MapArg) -\u003e Self {\n        map::new(args).with_parent(self)\n    }\n\n    /// Plucks one or more attributes from a sequence of objects, filtering\n    /// out any objects in the sequence that do not have the specified fields.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// sequence.with_fields(selector) → stream\n    /// sequence.with_fields(selectors) → stream\n    /// ```\n    ///\n    /// Where:\n    /// - selector: \u0026str | String | Cow\u003c'static, String\u003e\n    /// - selectors: [...] | \u0026[...] | vec![...]\n    ///\n    /// # Description\n    ///\n    /// Functionally, this is identical to [has_fields](Self::has_fields)\n    /// followed by [pluck](Self::pluck) on a sequence.\n    ///\n    /// ## Examples\n    ///\n    /// Get a list of users and their posts, excluding any users who have not made any posts.\n    ///\n    /// Existing table structure:\n    ///\n    /// ```text\n    /// [\n    ///     { \"id\": 1, \"user\": \"bob\", \"email\": \"bob@foo.com\", \"posts\": [ 1, 4, 5 ] },\n    ///     { \"id\": 2, \"user\": \"george\", \"email\": \"george@foo.com\" },\n    ///     { \"id\": 3, \"user\": \"jane\", \"email\": \"jane@foo.com\", \"posts\": [ 2, 3, 6 ] }\n    /// ]\n    /// ```\n    ///\n    /// Command and output:\n    ///\n    /// ```\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"users\")\n    ///         .with_fields([\"id\", \"user\", \"posts\"])\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///\n    ///     // [\n    ///     //      { \"id\": 1, \"user\": \"bob\", \"posts\": [ 1, 4, 5 ] },\n    ///     //      { \"id\": 3, \"user\": \"jane\", \"posts\": [ 2, 3, 6 ] }\n    ///     // ]\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [has_fields](Self::has_fields)\n    /// - [pluck](Self::pluck)\n    /// - [without](Self::without)\n    pub fn with_fields(self, fields: impl Serialize) -\u003e Self {\n        with_fields::new(fields).with_parent(self)\n    }\n\n    // TODO write Doc\n    pub fn concat_map(self, func: Func) -\u003e Command {\n        concat_map::new(func).with_parent(self)\n    }\n\n    // TODO write Doc\n    pub fn order_by(self, args: impl order_by::OrderByArg) -\u003e Self {\n        order_by::new(args).with_parent(self)\n    }\n\n    /// Skip a number of elements from the head of the sequence.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// sequence.skip(n) → stream\n    /// ```\n    ///\n    /// Where:\n    /// - n: usize\n    ///\n    /// ## Examples\n    ///\n    /// Only so many can fit in our Pantheon of heroes.\n    ///\n    /// ```\n    /// use reql_rust::cmd::order_by::OrderByOption;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"players\")\n    ///         .order_by(OrderByOption::default().index(\"age\"))\n    ///         .skip(10)\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [order_by](Self::order_by)\n    /// - [limit](Self::limit)\n    /// - [slice](Self::slice)\n    /// - [nth](Self::nth)\n    pub fn skip(self, n: usize) -\u003e Self {\n        skip::new(n).with_parent(self)\n    }\n\n    /// End the sequence after the given numbers of elements.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// sequence.limit(n) → stream\n    /// ```\n    ///\n    /// Where:\n    /// - n: usize\n    ///\n    /// ## Examples\n    ///\n    /// Only so many can fit in our Pantheon of heroes.\n    ///\n    /// ```\n    /// use reql_rust::cmd::order_by::OrderByOption;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"players\")\n    ///         .order_by(OrderByOption::default().index(\"age\"))\n    ///         .limit(10)\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [order_by](Self::order_by)\n    /// - [skip](Self::skip)\n    /// - [slice](Self::slice)\n    /// - [nth](Self::nth)\n    pub fn limit(self, n: usize) -\u003e Self {\n        limit::new(n).with_parent(self)\n    }\n\n    /// Return the elements of a sequence within the specified range.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// selection.slice(start_offset) → selection\n    /// selection.slice(args!(start_offset, options)) → selection\n    /// selection.slice(args!(start_offset, end_offset)) → selection\n    /// selection.slice(args!(start_offset, end_offset, options)) → selection\n    /// ```\n    ///\n    /// Where:\n    /// - start_offset, end_offset: isize\n    /// - options: [SliceOption](crate::cmd::slice::SliceOption)\n    ///\n    /// # Description\n    ///\n    /// // TODO Complete this description\n    ///\n    /// ## Examples\n    ///\n    /// Return the fourth, fifth and sixth youngest players.\n    /// (The youngest player is at index 0, so those are elements 3-5.)\n    ///\n    /// ```\n    /// use reql_rust::cmd::order_by::OrderByOption;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"players\")\n    ///         .order_by(OrderByOption::default().index(\"age\"))\n    ///         .slice(args!(3, 6))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Return all but the top three playerss who have a red flag.\n    ///\n    /// ```\n    /// use reql_rust::{args, r, Result};\n    /// use serde_json::json;\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"players\")\n    ///         .filter(json!({\"flag\": \"red\"}))\n    ///         .slice(3)\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Return the holders of tickets `X` through `Y`,\n    /// assuming tickets are numbered sequentially.\n    /// We want to include ticket `Y`.\n    ///\n    /// ```\n    /// use reql_rust::arguments::Status;\n    /// use reql_rust::cmd::order_by::OrderByOption;\n    /// use reql_rust::cmd::slice::SliceOption;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let x = 3;\n    ///     let y = 6;\n    ///     let order_by_options = OrderByOption::default().index(\"ticket\");\n    ///     let slice_options = SliceOption::default().right_bound(Status::Closed);\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"users\")\n    ///         .order_by(order_by_options)\n    ///         .slice(args!(x, y, slice_options))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Return the elements of an array from the second through\n    /// two from the end (that is, not including the last two).\n    ///\n    /// ```\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: Vec\u003cu8\u003e = r.expr([0, 1, 2, 3, 4, 5])\n    ///         .slice(args!(2, -2))\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert_eq!(response, vec![2, 3]);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Return the thirds through fifth characters of a string.\n    ///\n    /// ```\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: String = r.expr(\"I love africa.\")\n    ///         .slice(args!(-7, -1))\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert_eq!(response, \"africa\");\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [order_by](Self::order_by)\n    /// - [skip](Self::skip)\n    /// - [limit](Self::limit)\n    /// - [nth](Self::nth)\n    pub fn slice(self, args: impl slice::SliceArg) -\u003e Self {\n        slice::new(args).with_parent(self)\n    }\n\n    /// Get the **nth** element of a sequence, counting from zero.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// sequence.nth(index) → object\n    /// ```\n    ///\n    /// Where:\n    /// - index: isize\n    ///\n    /// # Description\n    ///\n    /// If the argument is negative, count from the last element.\n    ///\n    /// ## Examples\n    ///\n    /// Select the second element in the array.\n    ///\n    /// ```\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: u8 = r.expr([1, 2, 3])\n    ///         .nth(1)\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == 2);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Select the bronze medalist from the competitors.\n    ///\n    /// ```\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"players\")\n    ///         .order_by(r.desc(\"score\"))\n    ///         .nth(3)\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Select the last place competitors.\n    ///\n    /// ```\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"players\")\n    ///         .order_by(r.desc(\"score\"))\n    ///         .nth(-1)\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [order_by](Self::order_by)\n    /// - [skip](Self::skip)\n    /// - [limit](Self::limit)\n    /// - [bracket](Self::bracket)\n    /// - [slice](Self::slice)\n    pub fn nth(self, index: isize) -\u003e Self {\n        nth::new(index).with_parent(self)\n    }\n\n    /// Get the indexes of an element in a sequence.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// sequence.offsets_of(datum) → array\n    /// sequence.offsets_of(func!(...)) → array\n    /// ```\n    ///\n    /// Where:\n    /// - datum: impl Serialize\n    ///\n    /// # Description\n    ///\n    /// If the argument is a predicate, get\n    /// the indexes of all elements matching it.\n    ///\n    /// ## Examples\n    ///\n    /// Find the position of the letter ‘c’.\n    ///\n    /// ```\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: Vec\u003cusize\u003e = r.expr(['a','b','c'])\n    ///         .offsets_of('c')\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert_eq!(response.first(), Some(\u00262));\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Find the popularity ranking of invisible heroes.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"marvel\")\n    ///         .union(r.table(\"dc\"))\n    ///         .order_by(r.expr(\"popularity\"))\n    ///         .offsets_of(func!(|hero| hero.g(\"superpowers\").contains(\"invisibility\")))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    pub fn offsets_of(self, args: impl offsets_of::OffsetsOfArg) -\u003e Self {\n        offsets_of::new(args).with_parent(self)\n    }\n\n    /// Test if a sequence is empty.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// sequence.is_empty() → bool\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Are there any documents in the simbad table?\n    ///\n    /// ```\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: bool = r.table(\"simbad\")\n    ///         .is_empty()\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [offsets_of](Self::offsets_of)\n    pub fn is_empty(self) -\u003e Self {\n        is_empty::new().with_parent(self)\n    }\n\n    /// Merge two or more sequences.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// stream.union(sequence) → stream\n    /// stream.union(vec![sequence]) → stream\n    /// stream.union(args!(sequence, options)) → stream\n    /// stream.union(args!(vec![sequence], options)) → stream\n    /// ```\n    ///\n    /// Where:\n    /// - sequence: [Command](crate::Command)\n    /// - options: [UnionOption](crate::cmd::union::UnionOption)\n    ///\n    /// ## Examples\n    ///\n    /// Construct a stream of all characters.\n    ///\n    /// ```\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"simbad\")\n    ///         .union(r.table(\"kirikou\"))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    pub fn union(self, args: impl union::UnionArg) -\u003e Self {\n        union::new(args).with_parent(self)\n    }\n\n    /// Select a given number of elements from\n    /// a sequence with uniform random distribution.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// sequence.sample(number) → selection\n    /// stream.sample(number) → array\n    /// array.sample(number) → array\n    /// ```\n    ///\n    /// Where:\n    /// - number: usize\n    /// - sequence, stream, array: [Command](crate::Command)\n    ///\n    /// # Description\n    ///\n    /// Select a given number of elements from a\n    /// sequence with uniform random distribution.\n    /// Selection is done without replacement.\n    ///\n    /// If the sequence has less than the requested\n    /// number of elements (i.e., calling `sample(10)`\n    /// on a sequence with only five elements), `sample`\n    /// will return the entire sequence in a random order.\n    ///\n    /// ## Examples\n    ///\n    /// Select 3 random heroes.\n    ///\n    /// ```\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"simbad\")\n    ///         .sample(3)\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Select and stratify 3 random heroes by belovedness.\n    ///\n    /// ```\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"simbad\")\n    ///         .group(\"belovedness\")\n    ///         .sample(3)\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    pub fn sample(self, number: usize) -\u003e Self {\n        sample::new(number).with_parent(self)\n    }\n\n    /// Takes a stream and partitions it into multiple\n    /// groups based on the fields or functions provided.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// sequence.group(field) → grouped_stream\n    /// sequence.group(func) → grouped_stream\n    /// sequence.group(args!(field, options)) → grouped_stream\n    /// sequence.group(args!(func, options)) → grouped_stream\n    /// r.group(sequence, field) → grouped_stream\n    /// r.group(sequence, func) → grouped_stream\n    /// r.group(sequence, args!(field, options)) → grouped_stream\n    /// r.group(sequence, args!(func, options)) → grouped_stream\n    /// ```\n    ///\n    /// Where:\n    /// - field: \u0026str | [\u0026str; N]\n    /// - func: func!(...) | [func!(...); N]\n    /// - grouped_stream: [GroupedStream](crate::types::GroupedStream)\n    /// - sequence: [Command](crate::Command)\n    ///\n    /// # Description\n    ///\n    /// With the `multi` flag single documents can be assigned to multiple groups,\n    /// similar to the behavior of\n    /// [multi-indexes](https://rethinkdb.com/docs/secondary-indexes/javascript).\n    /// When `multi` is `true` and the grouping value is an array, documents\n    /// will be placed in each group that corresponds to the elements of the array.\n    /// If the array is empty the row will be ignored.\n    ///\n    /// Suppose that the table games has the following data:\n    ///\n    /// ```text\n    /// [\n    ///     {id: 2, player: \"Moussa\", points: 15, class: \"ranked\"},\n    ///     {id: 5, player: \"Fatou\", points: 7, class: \"free\"},\n    ///     {id: 11, player: \"Moussa\", points: 10, class: \"free\"},\n    ///     {id: 12, player: \"Fatou\", points: 2, class: \"free\"}\n    /// ]\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Group games by player.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::types::{GroupedItem, GroupedStream};\n    /// use reql_rust::{args, r, Result};\n    /// use serde::{Serialize, Deserialize};\n    ///\n    /// #[derive(Serialize, Deserialize, PartialEq, Eq)]\n    /// struct Player {\n    ///     id: u8,\n    ///     player: String,\n    ///     points: u8,\n    ///     class: String,\n    /// }\n    ///\n    /// impl Player {\n    ///     fn new(id: u8, player: \u0026str, points: u8, class: \u0026str) -\u003e Self {\n    ///         Self {\n    ///             id,\n    ///             points,\n    ///             player: player.to_owned(),\n    ///             class: class.to_owned(),\n    ///         }\n    ///     }\n    /// }\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let expected_data = vec![\n    ///         GroupedItem {\n    ///             group: String::from(\"Fatou\"),\n    ///             values: vec![\n    ///                 Player::new(5, \"Fatou\", 7, \"free\"),\n    ///                 Player::new(12, \"Fatou\", 2, \"free\"),\n    ///             ]\n    ///         },\n    ///         GroupedItem {\n    ///             group: String::from(\"Moussa\"),\n    ///             values: vec![\n    ///                 Player::new(2, \"Moussa\", 15, \"ranked\"),\n    ///                 Player::new(11, \"Moussa\", 10, \"free\"),\n    ///             ]\n    ///         },\n    ///     ];\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: GroupedStream\u003cString, Player\u003e = r.table(\"games\")\n    ///         .group(\"player\")\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response.collect() == expected_data);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [ungroup](Self::ungroup)\n    /// - [map](Self::map)\n    /// - [reduce](Self::reduce)\n    /// - [count](Self::count)\n    /// - [sum](Self::sum)\n    /// - [avg](Self::avg)\n    /// - [min](Self::min)\n    /// - [max](Self::max)\n    pub fn group(self, args: impl group::GroupArg) -\u003e Self {\n        group::new(args).with_parent(self)\n    }\n\n    /// Takes a grouped stream or grouped data and turns it\n    /// into an array of objects representing the groups.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// grouped_stream.ungroup() → array\n    /// grouped_data.ungroup() → array\n    /// ```\n    ///\n    /// Where:\n    /// - grouped_stream, grouped_data: [Command](crate::Command)\n    ///\n    /// # Description\n    ///\n    /// Any commands chained after `ungroup` will operate on this array,\n    /// rather than operating on each group individually. This is useful\n    /// if you want to e.g. order the groups by the value of their reduction.\n    ///\n    /// The format of the array returned by `ungroup` is the same as\n    /// the default native format of grouped data in the javascript driver and data explorer.\n    ///\n    /// Suppose that the table games has the following data:\n    ///\n    /// ```text\n    /// [\n    ///     {id: 2, player: \"Moussa\", points: 15, type: \"ranked\"},\n    ///     {id: 5, player: \"Fatou\", points: 7, type: \"free\"},\n    ///     {id: 11, player: \"Ibrahim\", points: 10, type: \"free\"},\n    ///     {id: 12, player: \"Abess\", points: 2, type: \"free\"}\n    /// ]\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// What is the maximum number of points scored by each player, with the highest scorers first?\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{args, r, Result};\n    /// use serde_json::json;\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let expected_data = json!([\n    ///         {\n    ///             \"group\": \"Bob\",\n    ///             \"reduction\": 15\n    ///         },\n    ///         {\n    ///             \"group\": \"Alice\",\n    ///             \"reduction\": 7\n    ///         }\n    ///     ]);\n    ///     let response = r.table(\"games\")\n    ///         .group(\"player\")\n    ///         .max(args!(\"points\"))\n    ///         .g(\"points\")\n    ///         .ungroup()\n    ///         .order_by(r.desc(\"reduction\"))\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap();\n    ///\n    ///     assert!(response == expected_data);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// A shorter way to execute this query is to use [count](Self::count).\n    ///\n    /// ## Examples\n    ///\n    /// Suppose that each `post` has a field `comments` that is an array of comments.\n    /// Return the maximum number comments per post.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"posts\")\n    ///         .map(func!(|post| post.g(\"comments\").count(())))\n    ///         .reduce(func!(|left, right| r.branch(\n    ///             left.clone().gt(right.clone()),\n    ///             args!(left, right)\n    ///         )))\n    ///         .default(0)\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// A shorter way to execute this query is to use [max](Self::max).\n    ///\n    /// # Related commands\n    /// - [group](Self::group)\n    pub fn ungroup(self) -\u003e Self {\n        ungroup::new().with_parent(self)\n    }\n\n    /// Produce a single value from a sequence through\n    /// repeated application of a reduction function.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// sequence.fold(base, func) → value\n    /// ```\n    ///\n    /// Where:\n    /// - base, value: impl Serialize\n    /// - func: func!(...)\n    /// - sequence: [Command](crate::Command)\n    ///\n    /// # Description\n    ///\n    /// The reduction function can be called on:\n    ///\n    /// - two elements of the sequence\n    /// - one element of the sequence and one result of a previous reduction\n    /// - two results of previous reductions\n    ///\n    /// The reduction function can be called on the results of\n    /// two previous reductions because the `reduce` command is\n    /// distributed and parallelized across shards and CPU cores.\n    /// A common mistaken when using the `reduce` command is to\n    /// suppose that the reduction is executed from left to right.\n    /// [Read the map-reduce in RethinkDB](https://rethinkdb.com/docs/map-reduce/)\n    /// article to see an example.\n    ///\n    /// If the sequence is empty, the server will produce a\n    /// `ReqlRuntimeError` that can be caught with default.\n    /// If the sequence has only one element, the first element will be returned.\n    ///\n    /// ## Examples\n    ///\n    /// Return the number of documents in the table posts.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"posts\")\n    ///         .map(func!(|| r.expr(1)))\n    ///         .reduce(func!(|left, right| left + right))\n    ///         .default(0)\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// A shorter way to execute this query is to use [count](Self::count).\n    ///\n    /// ## Examples\n    ///\n    /// Suppose that each `post` has a field `comments` that is an array of comments.\n    /// Return the maximum number comments per post.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"posts\")\n    ///         .map(func!(|post| post.g(\"comments\").count(())))\n    ///         .reduce(func!(|left, right| r.branch(\n    ///             left.clone().gt(right.clone()),\n    ///             args!(left, right)\n    ///         )))\n    ///         .default(0)\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// A shorter way to execute this query is to use [max](Self::max).\n    ///\n    /// # Related commands\n    /// - [group](Self::group)\n    /// - [map](Self::map)\n    /// - [concat_map](Self::concat_map)\n    /// - [sum](Self::sum)\n    /// - [avg](Self::avg)\n    /// - [min](Self::min)\n    /// - [max](Self::max)\n    pub fn reduce(self, func: Func) -\u003e Self {\n        reduce::new(func).with_parent(self)\n    }\n\n    /// Apply a function to a sequence in order,\n    /// maintaining state via an accumulator.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// sequence.fold(base, func) → value\n    /// ```\n    ///\n    /// Where:\n    /// - base, value: impl Serialize\n    /// - func: func!(...)\n    /// - sequence: [Command](crate::Command)\n    ///\n    /// # Description\n    ///\n    /// The `fold` command returns either a single value or a new sequence.\n    ///\n    /// In its first form, `fold` operates like [reduce](Self::reduce), returning a value\n    /// by applying a combining function to each element in a sequence.\n    /// The combining function takes two parameters: the previous reduction\n    /// result (the accumulator) and the current element. However, `fold` has\n    /// the following differences from `reduce`:\n    /// - it is guaranteed to proceed through the sequence from first element to last.\n    /// - it passes an initial base value to the function with the first element in\n    /// place of the previous reduction result.\n    ///\n    /// ```text\n    /// combining_function(accumulator | base, element) → new_accumulator\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Concatenate words from a list.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"words\")\n    ///         .order_by(r.expr(\"id\"))\n    ///         .fold(\n    ///             \"\",\n    ///             func!(|acc, word| acc.clone()\n    ///                 + r.branch(acc.eq(\"\"), args!(r.expr(\"\"), r.expr(\", \")))\n    ///                 + word),\n    ///         )\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// (This example could be implemented with `reduce`,\n    /// but `fold` will preserve the order when `words` is\n    /// a RethinkDB table or other stream, which is\n    /// not guaranteed with `reduce`.)\n    ///\n    /// # Related commands\n    /// - [reduce](Self::reduce)\n    /// - [concat_map](Self::concat_map)\n    pub fn fold\u003cT\u003e(self, base: T, func: Func) -\u003e Self\n    where\n        T: Serialize,\n    {\n        fold::new(base, func).with_parent(self)\n    }\n\n    /// Count the number of elements in sequence or key/value pairs in an object,\n    /// or returns the size of a string or binary object.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// binary.count(()) → number\n    /// string.count(()) → number\n    /// object.count(()) → number\n    /// sequence.count(()) → number\n    /// sequence.count(args!(value)) → number\n    /// sequence.count(func) → number\n    /// r.count(query_cmd) → number\n    /// r.count(query_cmd, args!(value)) → number\n    /// r.count(query_cmd, func) → number\n    /// ```\n    ///\n    /// Where:\n    /// - value: impl Serialize\n    /// - func: func!(...)\n    /// - sequence, binary, string, object, query_cmd: [Command](crate::Command)\n    ///\n    /// # Description\n    ///\n    /// When `count` is called on a sequence with a predicate value or function,\n    /// it returns the number of elements in the sequence equal to that value or\n    /// where the function returns `true`. On a [binary](crate::r::binary) object, `count`\n    /// returns the size of the object in bytes; on strings, `count` returns the string’s length.\n    /// This is determined by counting the number of Unicode codepoints in the string,\n    /// counting combining codepoints separately.\n    ///\n    /// ## Examples\n    ///\n    /// Count the number of users.\n    ///\n    /// ```\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"users\")\n    ///         .count(())\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Count the number of 18 year old users.\n    ///\n    /// ```\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"users\")\n    ///         .g(\"age\")\n    ///         .count(args!(18))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Count the number of users over 18.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"users\")\n    ///         .g(\"age\")\n    ///         .count(func!(|age| age.gt(18)))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Return the length of a Unicode string.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: usize = r.expr(\"こんにちは\")\n    ///         .count(())\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == 5);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Return the length of an array.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: usize = r.expr(['0','1','2'])\n    ///         .count(())\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == 3);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [map](Self::map)\n    /// - [reduce](Self::reduce)\n    /// - [sum](Self::sum)\n    /// - [avg](Self::avg)\n    /// - [min](Self::min)\n    /// - [max](Self::max)\n    /// - [group](Self::group)\n    pub fn count(self, args: impl count::CountArg) -\u003e Self {\n        count::new(args).with_parent(self)\n    }\n\n    /// Sum all the elements of sequence.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// sequence.sum(()) → number\n    /// sequence.sum(field) → number\n    /// sequence.sum(func) → number\n    /// r.sum(sequence) → number\n    /// r.sum(sequence, field) → number\n    /// r.sum(sequence, func) → number\n    /// ```\n    ///\n    /// Where:\n    /// - field: \u0026str, String, Cow\u003c'static, str\u003e\n    /// - func: func!(...)\n    /// - sequence: [Command](crate::Command)\n    ///\n    /// # Description\n    ///\n    /// If called with a field name, sums all the values of that field in\n    /// the sequence, skipping elements of the sequence that lack that field.\n    /// If called with a function, calls that function on every element of the\n    /// sequence and sums the results, skipping elements of the sequence\n    /// where that function returns `None` or non-existence error.\n    ///\n    /// Returns `0` when called on an empty sequence.\n    ///\n    /// ## Examples\n    ///\n    /// What's 3 + 5 + 7?\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: u8 = r.expr([3, 5, 7])\n    ///         .sum(())\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == 15);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// How many points have been scored across all games?\n    ///\n    /// ```\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"games\")\n    ///         .sum(\"points\")\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// How many points have been scored across all games, counting bonus points?\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"games\")\n    ///         .sum(func!(|game| game.clone().g(\"points\") + game.g(\"bonus_points\")))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [map](Self::map)\n    /// - [reduce](Self::reduce)\n    /// - [count](Self::count)\n    /// - [avg](Self::avg)\n    /// - [min](Self::min)\n    /// - [max](Self::max)\n    /// - [group](Self::group)\n    pub fn sum(self, args: impl sum::SumArg) -\u003e Self {\n        sum::new(args).with_parent(self)\n    }\n\n    /// Averages all the elements of sequence.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// sequence.avg(()) → Option\u003cf64\u003e\n    /// sequence.avg(field) → Option\u003cf64\u003e\n    /// sequence.avg(func) → Option\u003cf64\u003e\n    /// r.avg(sequence) → Option\u003cf64\u003e\n    /// r.avg(sequence, field) → Option\u003cf64\u003e\n    /// r.avg(sequence, func) → Option\u003cf64\u003e\n    /// ```\n    ///\n    /// Where:\n    /// - field: \u0026str, String, Cow\u003c'static, str\u003e\n    /// - func: func!(...)\n    /// - sequence: [Command](crate::Command)\n    ///\n    /// # Description\n    ///\n    /// If called with a field name, averages all the values of that field in\n    /// the sequence, skipping elements of the sequence that lack that field.\n    /// If called with a function, calls that function on every element of the\n    /// sequence and averages the results, skipping elements of the sequence\n    /// where that function returns `None` or non-existence error.\n    ///\n    /// Produces a non-existence error when called on an empty sequence.\n    /// You can handle this case with `default`.\n    ///\n    /// ## Examples\n    ///\n    /// What's the average of 3, 5 and 7?\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: Option\u003cf64\u003e = r.expr([3, 5, 7])\n    ///         .avg(())\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == Some(5.));\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// What's the average number of points scored in a games?\n    ///\n    /// ```\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"games\")\n    ///         .avg(\"points\")\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// What's the average number of points scored in a games, counting bonus points?\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"games\")\n    ///         .avg(func!(|game| game.clone().g(\"points\") + game.g(\"bonus_points\")))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [map](Self::map)\n    /// - [reduce](Self::reduce)\n    /// - [count](Self::count)\n    /// - [sum](Self::sum)\n    /// - [min](Self::min)\n    /// - [max](Self::max)\n    /// - [group](Self::group)\n    pub fn avg(self, args: impl avg::AvgArg) -\u003e Self {\n        avg::new(args).with_parent(self)\n    }\n\n    /// Finds the minimum element of a sequence.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// sequence.min(()) → element\n    /// sequence.min(args!(field)) → element\n    /// sequence.min(func) → element\n    /// sequence.min(options) → element\n    /// r.min(sequence) → element\n    /// r.min(sequence, args!(field)) → element\n    /// r.min(sequence, func) → element\n    /// r.min(sequence, options) → element\n    /// ```\n    ///\n    /// Where:\n    /// - field: \u0026str, String, Cow\u003c'static, str\u003e\n    /// - func: func!(...)\n    /// - options: [MinOption](crate::cmd::min::MinOption)\n    /// - sequence: [Command](crate::Command)\n    ///\n    /// # Description\n    ///\n    /// The `min` command can be called with:\n    /// - a `field name`, to return the element of the sequence\n    /// with the largest value in that field;\n    /// - a `function`, to apply the function to every element within the sequence\n    /// and return the element which returns the largest value from the function,\n    /// ignoring any elements where the function produces a non-existence error;\n    /// - an `index` (the primary key or a secondary index), to return the element\n    /// of the sequence with the largest value in that index;\n    ///\n    /// For more information on RethinkDB’s sorting order, read the section in\n    /// [ReQL data types](https://rethinkdb.com/docs/data-types/#sorting-order).\n    ///\n    /// Calling `min` on an empty sequence will throw a non-existence error;\n    /// this can be handled using the [default](Self::default) command.\n    ///\n    /// ## Examples\n    ///\n    /// Return the minimum value in the list [3, 5, 7].\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: u8 = r.expr([3, 5, 7])\n    ///         .min(())\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == 3);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Return the user who has scored the fewest points.\n    ///\n    /// ```\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"users\")\n    ///         .min(args!(\"points\"))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// The same as above, but using a secondary index on the `points` field.\n    ///\n    /// ```\n    /// use reql_rust::cmd::min::MinOption;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"users\")\n    ///         .min(MinOption::default().index(\"points\"))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Return the user who has scored the fewest points,\n    /// adding in bonus points from a separate field using a function.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"users\")\n    ///         .min(func!(|user| user.clone().g(\"points\") + user.g(\"bonus_points\")))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Return the highest number of points any user has ever scored.\n    /// This returns the value of that `points` field, not a document.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: u8 = r.table(\"users\")\n    ///         .min(args!(\"points\"))\n    ///         .g(\"points\")\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == 2);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [map](Self::map)\n    /// - [reduce](Self::reduce)\n    /// - [count](Self::count)\n    /// - [sum](Self::sum)\n    /// - [avg](Self::avg)\n    /// - [max](Self::max)\n    /// - [group](Self::group)\n    pub fn min(self, args: impl min::MinArg) -\u003e Self {\n        min::new(args).with_parent(self)\n    }\n\n    /// Finds the maximum element of a sequence.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// sequence.max(()) → element\n    /// sequence.max(args!(field)) → element\n    /// sequence.max(func) → element\n    /// sequence.max(options) → element\n    /// r.max(sequence) → element\n    /// r.max(sequence, args!(field)) → element\n    /// r.max(sequence, func) → element\n    /// r.max(sequence, options) → element\n    /// ```\n    ///\n    /// Where:\n    /// - field: \u0026str, String, Cow\u003c'static, str\u003e\n    /// - func: func!(...)\n    /// - options: [MaxOption](crate::cmd::max::MaxOption)\n    /// - sequence: [Command](crate::Command)\n    ///\n    /// # Description\n    ///\n    /// The `max` command can be called with:\n    /// - a `field name`, to return the element of the sequence\n    /// with the largest value in that field;\n    /// - a `function`, to apply the function to every element within the sequence\n    /// and return the element which returns the largest value from the function,\n    /// ignoring any elements where the function produces a non-existence error;\n    /// - an `index` (the primary key or a secondary index), to return the element\n    /// of the sequence with the largest value in that index;\n    ///\n    /// For more information on RethinkDB’s sorting order, read the section in\n    /// [ReQL data types](https://rethinkdb.com/docs/data-types/#sorting-order).\n    ///\n    /// Calling `max` on an empty sequence will throw a non-existence error;\n    /// this can be handled using the [default](Self::default) command.\n    ///\n    /// ## Examples\n    ///\n    /// Return the maximum value in the list [3, 5, 7].\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: u8 = r.expr([3, 5, 7])\n    ///         .max(())\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == 7);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Return the user who has scored the most points.\n    ///\n    /// ```\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"users\")\n    ///         .max(args!(\"points\"))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// The same as above, but using a secondary index on the `points` field.\n    ///\n    /// ```\n    /// use reql_rust::cmd::max::MaxOption;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"users\")\n    ///         .max(MaxOption::default().index(\"points\"))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Return the user who has scored the most points,\n    /// adding in bonus points from a separate field using a function.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"users\")\n    ///         .max(func!(|user| user.clone().g(\"points\") + user.g(\"bonus_points\")))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Return the highest number of points any user has ever scored.\n    /// This returns the value of that `points` field, not a document.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: u8 = r.table(\"users\")\n    ///         .max(args!(\"points\"))\n    ///         .g(\"points\")\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == 15);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [map](Self::map)\n    /// - [reduce](Self::reduce)\n    /// - [count](Self::count)\n    /// - [sum](Self::sum)\n    /// - [avg](Self::avg)\n    /// - [min](Self::min)\n    /// - [group](Self::group)\n    pub fn max(self, args: impl max::MaxArg) -\u003e Self {\n        max::new(args).with_parent(self)\n    }\n\n    /// Removes duplicate elements from a sequence.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// sequence.distinct(()) → array\n    /// table.distinct(options) → stream\n    /// r.distinct(sequence) → array\n    /// r.distinct(table, options) → stream\n    /// ```\n    ///\n    /// Where:\n    /// - options: [DistinctOption](crate::cmd::distinct::DistinctOption)\n    /// - sequence: [Command](crate::Command)\n    ///\n    /// # Description\n    ///\n    /// The `distinct` command can be called on any sequence or table with an index.\n    ///\n    /// ```text\n    /// While `distinct` can be called on a table without an index,\n    /// the only effect will be to convert the table into a stream;\n    /// the content of the stream will not be affected.\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Which unique villains have been vanquished by Marvel heroes?\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"marvel\")\n    ///         .concat_map(func!(|hero| hero.g(\"villain_list\")))\n    ///         .distinct(())\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Topics in a table of messages have a secondary index on them,\n    /// and more than one message can have the same topic.\n    /// What are the unique topics in the table?\n    ///\n    /// ```\n    /// use reql_rust::cmd::distinct::DistinctOption;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"messages\")\n    ///         .distinct(DistinctOption::default().index(\"topics\"))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// The above structure is functionally identical to:\n    ///\n    /// ```\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"messages\")\n    ///         .g(\"topics\")\n    ///         .distinct(())\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// However, the first form (passing the index as an argument to `distinct`) is faster,\n    /// and won’t run into array limit issues since it’s returning a stream.\n    ///\n    /// # Related commands\n    /// - [map](Self::map)\n    /// - [concat_map](Self::concat_map)\n    /// - [group](Self::group)\n    pub fn distinct(self, args: impl distinct::DistinctArg) -\u003e Self {\n        distinct::new(args).with_parent(self)\n    }\n\n    /// When called with values, returns `true`\n    /// if a sequence contains all the specified values.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// query.contains(value) → bool\n    /// r.contains(sequence, value) → bool\n    /// ```\n    ///\n    /// Where:\n    /// - value: impl Serialize | [Command](crate::Command)\n    /// - sequence: [Command](crate::Command)\n    ///\n    /// # Description\n    ///\n    /// When called with predicate functions, returns `true`\n    /// if for each predicate there exists at least one element\n    /// of the stream where that predicate returns `true`.\n    ///\n    /// Values and predicates may be mixed freely in the argument list.\n    ///\n    /// ## Examples\n    ///\n    /// Has Iron Man ever fought Superman?\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: bool = r.table(\"marvel\")\n    ///         .get(\"ironman\")\n    ///         .g(\"opponents\")\n    ///         .contains(\"superman\")\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Has Iron Man ever defeated Superman in battle?\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: bool = r.table(\"marvel\")\n    ///         .get(\"ironman\")\n    ///         .g(\"battles\")\n    ///         .contains(func!(|battle| battle.clone().g(\"winner\").eq(\"ironman\").and(\n    ///             battle.g(\"loser\").eq(\"superman\")\n    ///         )))\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Return all heroes who have fought both Loki and the Hulk.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: bool = r.table(\"marvel\")\n    ///         .filter(func!(|hero| hero.g(\"opponents\").contains([\"loki\", \"hulk\"])))\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Use contains with a predicate function to simulate an or.\n    /// Return the Marvel superheroes who live in Detroit, Chicago or Hoboken.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: bool = r.table(\"marvel\")\n    ///         .filter(func!(|hero| r.expr([\"Detroit\", \"Chicago\", \"Hoboken\"]).contains(hero.g(\"city\"))))\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [map](Self::map)\n    /// - [concat_map](Self::concat_map)\n    /// - [group](Self::group)\n    pub fn contains(self, args: impl contains::ContainsArg) -\u003e Self {\n        contains::new(args).with_parent(self)\n    }\n\n    /// Plucks out one or more attributes from either\n    /// an object or a sequence of objects (projection).\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// query.pluck(selectors) → any\n    /// ```\n    ///\n    /// Where:\n    /// - selectors: impl Serialize | [Command](crate::Command) |\n    /// args!(Vec\u003cCommand\u003e) | args!([Command; N]) | args!(\u0026[Command])\n    ///\n    /// ## Examples\n    ///\n    /// We just need information about IronMan’s\n    /// reactor and not the rest of the document.\n    ///\n    /// ```\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"marvel\")\n    ///         .get(\"IronMan\")\n    ///         .pluck([\"reactorState\", \"reactorPower\"])\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// For the hero beauty contest we only care about certain qualities.\n    ///\n    /// ```\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"marvel\")\n    ///         .pluck([\"beauty\", \"muscleTone\", \"charm\"])\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Pluck can also be used on nested objects.\n    ///\n    /// ```\n    /// use reql_rust::{r, Result};\n    /// use serde_json::json;\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"marvel\")\n    ///         .pluck(json!({\n    ///             \"abilities\": {\"damage\": true, \"mana_cost\": true},\n    ///             \"weapons\": true\n    ///         }))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// The nested syntax can quickly become overly\n    /// verbose so there’s a shorthand for it.\n    ///\n    /// ```\n    /// use reql_rust::{args, r, Result};\n    /// use serde_json::json;\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"marvel\")\n    ///         .pluck(args!([\n    ///             r.expr(json!({\"abilities\": [\"damage\", \"mana_cost\"]})),\n    ///             r.expr(\"weapons\")\n    ///         ]))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// For more information read the\n    /// [nested field documentation](https://rethinkdb.com/docs/nested-fields/python/).\n    ///\n    /// # Related commands\n    /// - [without](Self::without)\n    /// - [map](Self::map)\n    pub fn pluck(self, args: impl pluck::PluckArg) -\u003e Self {\n        pluck::new(args).with_parent(self)\n    }\n\n    /// The opposite of pluck; takes an object or a sequence of objects,\n    /// and returns them with the specified paths removed.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// query.without(selectors) → any\n    /// ```\n    ///\n    /// Where:\n    /// - selectors: impl Serialize | [Command](crate::Command) |\n    /// args!(Vec\u003cCommand\u003e) | args!([Command; N]) | args!(\u0026[Command])\n    ///\n    /// ## Examples\n    ///\n    /// Since we don’t need it for this computation we’ll save bandwidth\n    /// and leave out the list of IronMan’s romantic conquests.\n    ///\n    /// ```\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"marvel\")\n    ///         .get(\"IronMan\")\n    ///         .without(\"personalVictoriesList\")\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Without their prized weapons, our enemies will quickly be vanquished.\n    ///\n    /// ```\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"enemies\")\n    ///         .without(\"weapons\")\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Nested objects can be used to remove the damage\n    /// subfield from the weapons and abilities fields.\n    ///\n    /// ```\n    /// use reql_rust::{r, Result};\n    /// use serde_json::json;\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"marvel\")\n    ///         .without(json!({\n    ///             \"weapons\": { \"damage\": true },\n    ///             \"abilities\": { \"damage\": true }\n    ///         }))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// The nested syntax can quickly become overly verbose so there’s a shorthand for it.\n    ///\n    /// ```\n    /// use reql_rust::{r, Result};\n    /// use serde_json::json;\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"marvel\")\n    ///         .without(json!({\n    ///             \"weapons\": \"damage\",\n    ///             \"abilities\": \"damage\"\n    ///         }))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [pluck](Self::pluck)\n    /// - [map](Self::map)\n    pub fn without(self, args: impl without::WithoutArg) -\u003e Self {\n        without::new(args).with_parent(self)\n    }\n\n    /// Merge two or more objects together to construct\n    /// a new object with properties from all.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// query.merge(params) → any\n    /// ```\n    ///\n    /// Where:\n    /// - params: impl Serialize | func!(...) |\n    /// [Command](crate::Command) | Vec\u003cCommand\u003e, Vec\u003cFunc\u003e |\n    /// [Command; N] | [Func; N] | \u0026[Command] | \u0026[Func]\n    ///\n    /// # Description\n    ///\n    /// When there is a conflict between field names, preference is\n    /// given to fields in the rightmost object in the argument list\n    /// `merge` also accepts a subquery function that returns an object,\n    /// which will be used similarly to a [map](Self::map) function.\n    ///\n    /// ## Examples\n    ///\n    /// Equip Thor for battle.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"marvel\")\n    ///         .get(\"thor\")\n    ///         .merge(args!([\n    ///             r.table(\"equipment\").get(\"hammer\"),\n    ///             r.table(\"equipment\").get(\"pimento_sandwich\"),\n    ///         ]))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Equip every hero for battle, using a subquery\n    /// function to retrieve their weapons.\n    ///\n    /// ```\n    /// use std::collections::HashMap;\n    ///\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"marvel\")\n    ///         .get(\"thor\")\n    ///         .merge(func!(|hero| {\n    ///             let mut weapons = HashMap::new();\n    ///             weapons.insert(\"weapons\", r.table(\"weapons\").get(hero.g(\"weapon_id\")));\n    ///             r.hash_map(weapons)\n    ///         }))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Use `merge` to join each blog post with its comments.\n    ///\n    /// Note that the sequence being merged—in this example,\n    /// the comments—must be coerced from a selection to an array.\n    /// Without `coerce_to` the operation will throw an error\n    /// (“Expected type DATUM but found SELECTION”).\n    ///\n    /// ```\n    /// use std::collections::HashMap;\n    ///\n    /// use reql_rust::cmd::get_all::GetAllOption;\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"posts\")\n    ///         .merge(func!(|post| {\n    ///             let mut comments = HashMap::new();\n    ///             comments.insert(\"comments\", r.table(\"comments\")\n    ///                 .get_all(args!(\n    ///                     post.g(\"id\"),\n    ///                     GetAllOption::default().index(\"title\")\n    ///                 ))\n    ///                 .coerce_to(\"array\")\n    ///             );\n    ///             r.hash_map(comments)\n    ///         }))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Merge can be used recursively to modify object within objects.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    /// use serde_json::json;\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.expr(json!({\n    ///             \"weapons\": {\n    ///                 \"spectacular graviton beam\": {\n    ///                     \"dmg\": 10,\n    ///                     \"cooldown\": 20\n    ///                 }\n    ///             }\n    ///         }))\n    ///         .merge(json!({\n    ///             \"weapons\": {\n    ///                 \"spectacular graviton beam\": {\n    ///                     \"dmg\": 10\n    ///                 }\n    ///             }\n    ///         }))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [pluck](Self::pluck)\n    /// - [without](Self::without)\n    /// - [map](Self::map)\n    pub fn merge(self, args: impl merge::MergeArg) -\u003e Self {\n        merge::new(args).with_parent(self)\n    }\n\n    /// Append a value to an array.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// query.append(value) → array\n    /// ```\n    ///\n    /// Where:\n    /// - value: impl Serialize | [Command](crate::Command)\n    ///\n    /// ## Examples\n    ///\n    /// Retrieve Simon's colours list with the addition of yellow\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     // [\"green\", \"pink\", \"red\", \"blue\", \"purple\"]\n    ///     let response: [String; 6] = r.table(\"simbad\")\n    ///         .get(1)\n    ///         .g(\"colour\")\n    ///         .append(\"yellow\")\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == [\"green\", \"pink\", \"red\", \"blue\", \"purple\", \"yellow\"]);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [prepend](Self::prepend)\n    /// - [merge](Self::merge)\n    /// - [insert_at](Self::insert_at)\n    /// - [delete_at](Self::delete_at)\n    /// - [change_at](Self::change_at)\n    pub fn append(self, args: impl append::AppendArg) -\u003e Self {\n        append::new(args).with_parent(self)\n    }\n\n    /// Prepend a value to an array.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// query.prepend(value) → array\n    /// ```\n    ///\n    /// Where:\n    /// - value: impl Serialize | [Command](crate::Command)\n    ///\n    /// ## Examples\n    ///\n    /// Retrieve Simon's colours list with the addition of yellow\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     // [\"green\", \"pink\", \"red\", \"blue\", \"purple\"]\n    ///     let response: [String; 6] = r.table(\"simbad\")\n    ///         .get(1)\n    ///         .g(\"colour\")\n    ///         .prepend(\"yellow\")\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == [\"yellow\", \"green\", \"pink\", \"red\", \"blue\", \"purple\"]);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [append](Self::append)\n    /// - [merge](Self::merge)\n    /// - [insert_at](Self::insert_at)\n    /// - [delete_at](Self::delete_at)\n    /// - [change_at](Self::change_at)\n    pub fn prepend(self, args: impl prepend::PrependArg) -\u003e Self {\n        prepend::new(args).with_parent(self)\n    }\n\n    /// Remove the elements of one array from another array\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// query.difference(attr) → array\n    /// ```\n    ///\n    /// Where:\n    /// - attr: vec![...] | [...] | \u0026[...]\n    ///\n    /// ## Examples\n    ///\n    /// Retrieve Simon's colour list without pink and purple\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     // [\"green\", \"pink\", \"red\", \"blue\", \"purple\"]\n    ///     let response: [String; 3] = r.table(\"simbad\")\n    ///         .get(1)\n    ///         .g(\"colour\")\n    ///         .difference([\"pink\", \"purple\", \"yellow\"])\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == [\"green\", \"red\", \"blue\"]);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [union](Self::union)\n    /// - [set_insert](Self::set_insert)\n    /// - [set_union](Self::set_union)\n    /// - [set_intersection](Self::set_intersection)\n    /// - [set_difference](Self::set_difference)\n    pub fn difference(self, args: impl difference::DifferenceArg) -\u003e Self {\n        difference::new(args).with_parent(self)\n    }\n\n    /// Add a value to an array and return it as a set\n    /// (an array with distinct values).\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// query.set_insert(value) → array\n    /// ```\n    ///\n    /// Where:\n    /// - value: impl Serialize\n    ///\n    /// ## Examples\n    ///\n    /// Retrieve Simon's colours list with the addition of yellow\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     // [\"green\", \"pink\", \"red\", \"blue\", \"purple\"]\n    ///     let response: [String; 6] = r.table(\"simbad\")\n    ///         .get(1)\n    ///         .g(\"colour\")\n    ///         .set_insert(\"yellow\")\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == [\"green\", \"pink\", \"red\", \"blue\", \"purple\", \"yellow\"]);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [union](Self::union)\n    /// - [difference](Self::difference)\n    /// - [set_union](Self::set_union)\n    /// - [set_intersection](Self::set_intersection)\n    /// - [set_difference](Self::set_difference)\n    pub fn set_insert(self, value: impl Serialize) -\u003e Self {\n        set_insert::new(value).with_parent(self)\n    }\n\n    /// Add a several values to an array and return\n    /// it as a set (an array with distinct values).\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// query.set_union(attr) → array\n    /// ```\n    ///\n    /// Where:\n    /// - attr: vec![...] | [...] | \u0026[...]\n    ///\n    /// ## Examples\n    ///\n    /// Retrieve Simon's colours list with the addition of yellow\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     // [\"green\", \"pink\", \"red\", \"blue\", \"purple\"]\n    ///     let response: [String; 6] = r.table(\"simbad\")\n    ///         .get(1)\n    ///         .g(\"colour\")\n    ///         .set_union([\"purple\", \"pink\", \"yellow\"])\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == [\"green\", \"pink\", \"red\", \"blue\", \"purple\", \"yellow\"]);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [union](Self::union)\n    /// - [difference](Self::difference)\n    /// - [set_insert](Self::set_insert)\n    /// - [set_intersection](Self::set_intersection)\n    /// - [set_difference](Self::set_difference)\n    pub fn set_union(self, args: impl set_union::SetUnionArg) -\u003e Self {\n        set_union::new(args).with_parent(self)\n    }\n\n    /// Intersect two arrays returning values that occur in\n    /// both of them as a set (an array with distinct values).\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// query.set_intersection(attr) → array\n    /// ```\n    ///\n    /// Where:\n    /// - attr: vec![...] | [...] | \u0026[...]\n    ///\n    /// ## Examples\n    ///\n    /// Check which colour Simon likes from a fixed list.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     // [\"green\", \"pink\", \"red\", \"blue\", \"purple\"]\n    ///     let response: [String; 2] = r.table(\"simbad\")\n    ///         .get(1)\n    ///         .g(\"colour\")\n    ///         .set_intersection([\"purple\", \"pink\", \"yellow\"])\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == [\"purple\", \"pink\"]);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [union](Self::union)\n    /// - [difference](Self::difference)\n    /// - [set_insert](Self::set_insert)\n    /// - [set_union](Self::set_union)\n    /// - [set_difference](Self::set_difference)\n    pub fn set_intersection(self, args: impl set_intersection::SetIntersectionArg) -\u003e Self {\n        set_intersection::new(args).with_parent(self)\n    }\n\n    /// Remove the elements of one array from another and\n    /// return them as set (an array with distinct values)\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// query.set_difference(attr) → array\n    /// ```\n    ///\n    /// Where:\n    /// - attr: vec![...] | [...] | \u0026[...]\n    ///\n    /// ## Examples\n    ///\n    /// Check which colour Simon likes,\n    /// excluding a fixed list.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     // [\"green\", \"pink\", \"red\", \"blue\", \"purple\"]\n    ///     let response: [String; 3] = r.table(\"simbad\")\n    ///         .get(1)\n    ///         .g(\"colour\")\n    ///         .set_difference([\"purple\", \"pink\"])\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == [\"green\", \"red\", \"blue\"]);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [union](Self::union)\n    /// - [difference](Self::difference)\n    /// - [set_insert](Self::set_insert)\n    /// - [set_union](Self::set_union)\n    /// - [set_intersection](Self::set_intersection)\n    pub fn set_difference(self, args: impl set_difference::SetDifferenceArg) -\u003e Self {\n        set_difference::new(args).with_parent(self)\n    }\n\n    /// Get a single field from an object.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// query.get_field(attr) → value\n    /// ```\n    ///\n    /// Where:\n    /// - attr: String, \u0026str\n    ///\n    /// # Description\n    ///\n    /// If called on a sequence, gets that field from every object\n    /// in the sequence, skipping objects that lack it.\n    ///\n    /// ``` text\n    /// Under most circumstances, you’ll want to use [get_field](Self::get_field)\n    /// (or its shorthand g) or [nth](Self::nth) rather than `bracket`.\n    /// The `bracket` term may be useful in situations where you are unsure of the\n    /// data type returned by the term you are calling `bracket` on.\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// How old is Moussa\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: u8 = r.table(\"simbad\")\n    ///         .get(1)\n    ///         .bracket(\"age\")\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == 15);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// The `bracket` command also accepts integer arguments\n    /// as array offsets, like the [nth](Self::nth) command.\n    ///\n    /// ## Examples\n    ///\n    /// How old is Moussa\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: u8 = r.expr([10, 20, 30, 40, 50])\n    ///         .bracket(3)\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == 40);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [get_field](Self::get_field)\n    /// - [nth](Self::nth)\n    pub fn bracket(self, attr: impl Serialize) -\u003e Self {\n        bracket::new(attr).with_parent(self)\n    }\n\n    /// Get a single field from an object.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// query.get_field(attr) → value\n    /// ```\n    ///\n    /// Where:\n    /// - attr: String, \u0026str\n    ///\n    /// # Description\n    ///\n    /// If called on a sequence, gets that field from every object\n    /// in the sequence, skipping objects that lack it.\n    ///\n    /// You may use either `get_field` or its shorthand, `g`.\n    ///\n    /// ## Examples\n    ///\n    /// How old is Moussa\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: u8 = r.table(\"simbad\")\n    ///         .get(1)\n    ///         .get_field(\"age\")\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == 15);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [bracket](Self::bracket)\n    /// - [nth](Self::nth)\n    pub fn get_field(self, attr: impl Into\u003cString\u003e) -\u003e Self {\n        get_field::new(attr).with_parent(self)\n    }\n\n    /// Get a single field from an object.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// query.g(attr) → value\n    /// ```\n    ///\n    /// Where:\n    /// - attr: String, \u0026str\n    ///\n    /// # Description\n    ///\n    /// If called on a sequence, gets that field from every object\n    /// in the sequence, skipping objects that lack it.\n    ///\n    /// You may use either `get_field` or its shorthand, `g`.\n    ///\n    /// ## Examples\n    ///\n    /// How old is Moussa\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: u8 = r.table(\"simbad\")\n    ///         .get(1)\n    ///         .g(\"age\")\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == 15);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [bracket](Self::bracket)\n    /// - [nth](Self::nth)\n    pub fn g(self, attr: impl Into\u003cString\u003e) -\u003e Self {\n        get_field::new(attr).with_parent(self)\n    }\n\n    /// Test if an object has one or more fields.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// query.has_fields(selector) → response\n    /// ```\n    ///\n    /// Where:\n    /// - selector: impl Serialize\n    /// - response: array | bool\n    ///\n    /// # Description\n    ///\n    /// An object has a field if it has that key and the key has a non-null value.\n    /// For instance, the object `{'a': 1,'b': 2,'c': null}` has the fields `a` and `b`.\n    ///\n    /// When applied to a single object, `has_fields` returns `true` if the object has\n    /// the fields and `false` if it does not. When applied to a sequence, it will return\n    /// a new sequence (an array or stream) containing the elements that have the specified fields.\n    ///\n    /// ## Examples\n    ///\n    /// Return the players who have won games.\n    ///\n    /// ```\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"players\")\n    ///         .has_fields(\"games_won\")\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Return the players who have not won games.\n    /// To do this, use `has_fields` with [not](crate::r::not),\n    /// wrapped with [filter](Self::filter).\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"players\")\n    ///         .filter(func!(|player| !player.has_fields(\"games_won\")))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Test if a specific player has won any games.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: bool = r.table(\"players\")\n    ///         .get(1)\n    ///         .has_fields(\"games_won\")\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Nested Fields\n    ///\n    /// `has_fields` lets you test for nested fields in objects.\n    /// If the value of a field is itself a set of key/value pairs,\n    /// you can test for the presence of specific keys.\n    ///\n    /// ## Examples\n    ///\n    /// In the `players` table, the `games_won` field contains one\n    /// or more fields for kinds of games won:\n    ///\n    /// ```text\n    /// {\n    ///     'games_won': {\n    ///         'playoffs': 2,\n    ///         'championships': 1\n    ///     }\n    /// }\n    /// ```\n    ///\n    /// Return players who have the “championships” field.\n    ///\n    /// ```\n    /// use reql_rust::{r, Result};\n    /// use serde_json::json;\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"players\")\n    ///         .has_fields(json!({\"games_won\": {\"championships\": true}}))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// Note that `true` in the example above is testing for the existence of `championships`\n    /// as a field, not testing to see if the value of the `championships` field is set to `true`.\n    /// There’s a more convenient shorthand form available.\n    /// (See [pluck](Self::pluck) for more details on this.)\n    ///\n    /// ```\n    /// use reql_rust::{r, Result};\n    /// use serde_json::json;\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"players\")\n    ///         .has_fields(json!({\"games_won\": \"championships\"}))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [get_field](Self::get_field)\n    /// - [with_fields](Self::with_fields)\n    pub fn has_fields(self, selector: impl Serialize) -\u003e Self {\n        has_fields::new(selector).with_parent(self)\n    }\n\n    /// Insert a value in to an array at a given index. Returns the modified array.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// array.insert_at(offset, value) → array\n    /// ```\n    ///\n    /// Where:\n    /// - offset: isize\n    /// - value: impl Serialize\n    ///\n    /// ## Examples\n    ///\n    /// Alima decide to join Simbad.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: [String; 4] = r.expr([\"Moussa\", \"Ali\", \"Fati\"])\n    ///         .insert_at(1, \"Alima\")\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == [\"Moussa\", \"Alima\", \"Ali\", \"Fati\"]);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [splice_at](Self::splice_at)\n    /// - [change_at](Self::change_at)\n    /// - [delete_at](Self::delete_at)\n    pub fn insert_at(self, offset: isize, value: impl Serialize) -\u003e Self {\n        insert_at::new(offset, value).with_parent(self)\n    }\n\n    /// Insert several values into an array at the given index.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// array.splice_at(args!(offset, list)) → array\n    /// ```\n    ///\n    /// Where:\n    /// - offset: isize | [Command](crate::Command)\n    /// - value: vec![...] | [...] | \u0026[...] | [Command](crate::Command)\n    ///\n    /// ## Examples\n    ///\n    /// Fati and Alima decide to join Simbad.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: [String; 4] = r.expr([\"Moussa\", \"Ali\"])\n    ///         .splice_at(args!(1, [\"Fati\", \"Alima\"]))\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == [\"Moussa\", \"Fati\", \"Alima\", \"Ali\"]);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [insert_at](Self::insert_at)\n    /// - [delete_at](Self::delete_at)\n    /// - [change_at](Self::change_at)\n    pub fn splice_at(self, args: impl splice_at::SpliceAtArg) -\u003e Self {\n        splice_at::new(args).with_parent(self)\n    }\n\n    /// Remove one or more elements from an array at a given index.\n    /// (Note: `delete_at` operates on arrays, not documents;\n    /// to delete documents, see the [delete](Self::delete) command.)\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// array.delete_at(offset) → array\n    /// array.delete_at(args!(offset, end_offset)) → array\n    /// ```\n    ///\n    /// # Description\n    ///\n    /// If only `offset` is specified, `delete_at` removes the element at that index.\n    /// If both `offset` and `end_offset` are specified, `delete_at` removes the range\n    /// of elements between `offset` and `end_offset`, inclusive of `offset` but not\n    /// inclusive of `end_offset`.\n    ///\n    /// If `end_offset` is specified, it must not be less than `offset`.\n    /// Both `offset` and `end_offset` must be within the array’s bounds\n    /// (i.e., if the array has 10 elements, an `offset` or `end_offset`\n    /// of 10 or higher is invalid).\n    ///\n    /// By using a negative `offset` you can delete from the end of the array.\n    /// `-1` is the last element in the array, `-2` is the second-to-last element, and so on.\n    /// You may specify a negative `end_offset`, although just as with a positive value,\n    /// this will not be inclusive. The range `(2,-1)` specifies the third element through\n    /// the next-to-last element.\n    ///\n    /// ## Examples\n    ///\n    /// Delete the second element of an array.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: [char; 5] = r.expr(['a', 'b', 'c', 'd', 'e', 'f'])\n    ///         .delete_at(1)\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == ['a', 'c', 'd', 'e', 'f']);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Delete the second and third elements of an array.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: [char; 4] = r.expr(['a', 'b', 'c', 'd', 'e', 'f'])\n    ///         .delete_at(args!(1, 3))\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == ['a', 'd', 'e', 'f']);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Delete the next-to-last element of an array.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: [char; 5] = r.expr(['a', 'b', 'c', 'd', 'e', 'f'])\n    ///         .delete_at(-2)\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == ['a', 'b', 'c', 'd', 'f']);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Delete a comment on a post.\n    ///\n    /// Given a post document such as:\n    ///\n    /// ```text\n    ///\n    /// ```\n    /// {\n    ///     \"id\": 1,\n    ///     \"title\": \"Post title\",\n    ///     \"author\": \"Ali\",\n    ///     \"comments\": [\n    ///         { \"author\": \"Agatha\", \"text\": \"Comment 1\" },\n    ///         { \"author\": \"Fatima\", \"text\": \"Comment 2\" }\n    ///     ]\n    /// }\n    ///\n    /// The second comment can be deleted by using `update` and `delete_at` together.\n    ///\n    /// ```\n    /// use std::collections::HashMap;\n    ///\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: [char; 5] = r.table(\"posts\")\n    ///         .get(1)\n    ///         .update(func!(|post| {\n    ///             let mut comments = HashMap::new();\n    ///             comments.insert(\"comments\", post.g(\"comments\").delete_at(1));\n    ///             r.hash_map(comments)\n    ///         }))\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == ['a', 'b', 'c', 'd', 'f']);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [insert_at](Self::insert_at)\n    /// - [splice_at](Self::splice_at)\n    /// - [change_at](Self::change_at)\n    pub fn delete_at(self, args: impl delete_at::DeleteAtArg) -\u003e Self {\n        delete_at::new(args).with_parent(self)\n    }\n\n    /// Change a value in an array at a given index.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// array.change_at(offset, value) → array\n    /// ```\n    ///\n    /// Where:\n    /// - offset: isize\n    /// - value: impl Serialize\n    ///\n    /// ## Examples\n    ///\n    /// Replace Ali by Alima in array.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: [String; 3] = r.expr([\"Moussa\", \"Ali\", \"Fati\"])\n    ///         .change_at(1, \"Alima\")\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == [\"Moussa\", \"Alima\", \"Fati\"]);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [insert_at](Self::insert_at)\n    /// - [splice_at](Self::splice_at)\n    /// - [delete_at](Self::delete_at)\n    pub fn change_at(self, offset: isize, value: impl Serialize) -\u003e Self {\n        change_at::new(offset, value).with_parent(self)\n    }\n\n    /// Return an array containing all of an object’s keys.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// string.keys() → array\n    /// ```\n    ///\n    /// # Description\n    ///\n    /// Note that the keys will be sorted as described in\n    /// [ReQL data types](https://rethinkdb.com/docs/data-types/#sorting-order)\n    /// (for strings, lexicographically).\n    ///\n    /// ## Examples\n    ///\n    /// Get all the keys from a table row.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     // row: { \"id\": \"1\", \"mail\": \"fred@example.com\", \"name\": \"fred\" }\n    ///     let response: [String; 3] = r.table(\"users\")\n    ///         .get(1)\n    ///         .keys()\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == [\"id\", \"mail\", \"name\"]);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [values](Self::values)\n    pub fn keys(self) -\u003e Self {\n        keys::new().with_parent(self)\n    }\n\n    /// Return an array containing all of an object’s values.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// string.values() → array\n    /// ```\n    ///\n    /// # Description\n    ///\n    /// `values()` guarantees the values will\n    /// come out in the same order as [keys](Self::keys).\n    ///\n    /// ## Examples\n    ///\n    /// Get all of the values from a table row.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     // row: { \"id\": \"1\", \"mail\": \"fred@example.com\", \"name\": \"fred\" }\n    ///     let response: [String; 3] = r.table(\"users\")\n    ///         .get(1)\n    ///         .values()\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == [\"1\", \"fred@example.com\", \"fred\"]);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [keys](Self::keys)\n    pub fn values(self) -\u003e Self {\n        values::new().with_parent(self)\n    }\n\n    /// Match a string against a regular expression.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// string.match(regexp) → response\n    /// ```\n    ///\n    /// Where:\n    /// - regexp: [Regex](regex::Regex)\n    /// - response: Option\u003c[MatchResponse](crate::types::MatchResponse)\u003e\n    ///\n    /// ## Examples\n    ///\n    /// ```\n    /// use regex::Regex;\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::types::MatchResponse;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let regexp = Regex::new(\".*@(.*)\")?;\n    ///     let response: String = r.expr(\"name@domain.com\")\n    ///         .match_(regexp.clone())\n    ///         .g(\"groups\")\n    ///         .nth(0)\n    ///         .g(\"str\")\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///     let response2: Option\u003cMatchResponse\u003e = r.expr(\"name[at]domain.com\")\n    ///         .match_(regexp)\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == \"domain.com\");\n    ///     assert!(response2 == None);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [upcase](Self::upcase)\n    /// - [downcase](Self::downcase)\n    /// - [split](Self::split)\n    pub fn match_(self, regexp: Regex) -\u003e Self {\n        match_::new(regexp).with_parent(self)\n    }\n\n    /// Split a string into substrings.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// string.split(()) → string\n    /// string.split(\u0026str) → string\n    /// string.split(args!(\u0026str, usize)) → string\n    /// ```\n    ///\n    /// # Description\n    ///\n    /// With no arguments, will split on whitespace;\n    /// when called with a string as the first argument,\n    /// will split using that string as a separator.\n    /// A maximum number of splits can also be specified.\n    ///\n    /// ## Examples\n    ///\n    /// Split on whitespace.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let data = [\n    ///         String::from(\"foo\"),\n    ///         String::from(\"bar\"),\n    ///         String::from(\"bax\"),\n    ///     ];\n    ///     let response: [String; 3] = r.expr(\"foo  bar bax\")\n    ///         .split(())\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == data);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Split the entries in a CSV file.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let data = [\n    ///         String::from(\"12\"),\n    ///         String::from(\"37\"),\n    ///         String::new(),\n    ///         String::from(\"22\"),\n    ///         String::new(),\n    ///     ];\n    ///     let response: [String; 5] = r.expr(\"12,37,,22,\")\n    ///         .split(\",\")\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == data);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Split a string into characters.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let data = [\n    ///         String::from(\"t\"),\n    ///         String::from(\"o\"),\n    ///         String::from(\"t\"),\n    ///         String::from(\"o\"),\n    ///     ];\n    ///     let response: [String; 4] = r.expr(\"toto\")\n    ///         .split(\"\")\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == data);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Split the entries in a CSV file, but only at most 3 times.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let data = [\n    ///         String::from(\"12\"),\n    ///         String::from(\"37\"),\n    ///         String::new(),\n    ///         String::from(\"22,\"),\n    ///     ];\n    ///     let response: [String; 4] = r.expr(\"12,37,,22,\")\n    ///         .split(args!(\",\", 3))\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == data);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Split on whitespace at most once (i.e. get the first word).\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let data = [\n    ///         String::from(\"foo\"),\n    ///         String::from(\"bar bax\"),\n    ///     ];\n    ///     let response: [String; 2] = r.expr(\"foo  bar bax\")\n    ///         .split(args!(\" \", 1))\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == data);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [upcase](Self::upcase)\n    /// - [downcase](Self::downcase)\n    /// - [match](Self::match_)\n    pub fn split(self, args: impl split::SplitArg) -\u003e Self {\n        split::new(args).with_parent(self)\n    }\n\n    /// Uppercases a string.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// string.upcase() → string\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: String = r.expr(\"Sentence about LaTeX.\")\n    ///         .upcase()\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == \"SENTENCE ABOUT LATEX.\");\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Note\n    ///\n    /// `upcase` and `downcase` only affect ASCII characters.\n    ///\n    /// # Related commands\n    /// - [downcase](Self::downcase)\n    /// - [match](Self::match_)\n    /// - [split](Self::split)\n    pub fn upcase(self) -\u003e Self {\n        upcase::new().with_parent(self)\n    }\n\n    /// Lowercase a string.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// string.downcase() → string\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: String = r.expr(\"Sentence about LaTeX.\")\n    ///         .downcase()\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == \"sentence about latex.\");\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Note\n    ///\n    /// `upcase` and `downcase` only affect ASCII characters.\n    ///\n    /// # Related commands\n    /// - [upcase](Self::upcase)\n    /// - [match](Self::match_)\n    /// - [split](Self::split)\n    pub fn downcase(self) -\u003e Self {\n        downcase::new().with_parent(self)\n    }\n\n    /// Compute the logical “and” of one or more values.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// cmd_value.and(value) → bool\n    /// cmd_value.and(args!(values)) → bool\n    /// r.and(args!(values)) → bool\n    /// ```\n    ///\n    /// Where:\n    /// - value: [Command](crate::Command) | bool\n    /// - values: [Command](crate::Command) | vec![...] | [...] | \u0026[...]\n    ///\n    /// # Description\n    ///\n    /// The `and` command can be used as an infix operator after its\n    /// first argument (`r.expr(true).and(false)`) or given all of\n    /// its arguments as parameters (`r.and(args!([true, false]))`).\n    ///\n    /// Calling `or` with zero arguments will return `false`.\n    ///\n    /// ## Examples\n    ///\n    /// Return whether either true or false evaluate to true.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: bool = r.expr(true)\n    ///         .or(false)\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == false);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Return whether any of true, true or true evaluate to true.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: bool = r.or(args!([true, true, true]))\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == true);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [eq](Self::eq)\n    /// - [ne](Self::ne)\n    /// - [or](Self::or)\n    pub fn and(self, args: impl and::AndArg) -\u003e Self {\n        and::new(args).with_parent(self)\n    }\n\n    /// Compute the logical “or” of one or more values.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// cmd_value.or(value) → bool\n    /// cmd_value.or(args!(values)) → bool\n    /// r.or(args!(values)) → bool\n    /// ```\n    ///\n    /// Where:\n    /// - value: [Command](crate::Command) | bool\n    /// - values: [Command](crate::Command) | vec![...] | [...] | \u0026[...]\n    ///\n    /// # Description\n    ///\n    /// The `or` command can be used as an infix operator after\n    /// its first argument (`r.expr(true).or(false)`) or given all\n    /// of its arguments as parameters (`r.or(args!([true, false]))`).\n    ///\n    /// Calling `or` with zero arguments will return `false`.\n    ///\n    /// ## Examples\n    ///\n    /// Return whether either true or false evaluate to true.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: bool = r.expr(true)\n    ///         .or(false)\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == true);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Return whether any of false, false or false evaluate to false.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: bool = r.or(args!([false, false, false]))\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == false);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Note\n    ///\n    /// When using `or` inside a `filter` predicate to test the values of\n    /// fields that may not exist on the documents being tested,\n    /// you should use the `default` command with those fields so\n    /// they explicitly return `false`.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"table\")\n    ///         .filter(func!(|post| post.clone()\n    ///             .g(\"category\").default(\"foo\").eq(\"article\")\n    ///             .or(post.g(\"genre\").default(\"foo\").eq(\"mystery\"))\n    ///         ))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [eq](Self::eq)\n    /// - [ne](Self::ne)\n    /// - [and](Self::and)\n    pub fn or(self, args: impl or::OrArg) -\u003e Self {\n        or::new(args).with_parent(self)\n    }\n\n    /// Test if two or more values are equal.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// cmd_value.eq(value) → bool\n    /// cmd_value.eq(args!(values)) → bool\n    /// r.eq(args!(values)) → bool\n    /// ```\n    ///\n    /// Where:\n    /// - value: [Command](crate::Command) | impl Serialize\n    /// - values: [Command](crate::Command) | vec![...] | [...] | \u0026[...]\n    ///\n    /// ## Examples\n    ///\n    /// See if a user’s `role` field is set to `administrator`.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: bool = r.table(\"users\")\n    ///         .get(1)\n    ///         .g(\"role\")\n    ///         .eq(\"administrator\")\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == true);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// See if three variables contain equal values.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: bool = r.eq(args!([20, 10, 15]))\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == true);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [ne](Self::ne)\n    /// - [and](Self::and)\n    /// - [or](Self::or)\n    pub fn eq(self, args: impl eq::EqArg) -\u003e Self {\n        eq::new(args).with_parent(self)\n    }\n\n    /// Test if two or more values are not equal.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// cmd_value.ne(value) → bool\n    /// cmd_value.ne(args!(values)) → bool\n    /// r.ne(args!(values)) → bool\n    /// ```\n    ///\n    /// Where:\n    /// - value: [Command](crate::Command) | impl Serialize\n    /// - values: [Command](crate::Command) | vec![...] | [...] | \u0026[...]\n    ///\n    /// ## Examples\n    ///\n    /// See if a user’s `role` field is not set to `administrator`.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: bool = r.table(\"users\")\n    ///         .get(1)\n    ///         .g(\"role\")\n    ///         .ne(\"administrator\")\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == true);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// See if three variables do not contain equal values.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: bool = r.ne(args!([20, 10, 15]))\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == true);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [eq](Self::eq)\n    /// - [and](Self::and)\n    /// - [or](Self::or)\n    pub fn ne(self, args: impl ne::NeArg) -\u003e Self {\n        ne::new(args).with_parent(self)\n    }\n\n    /// Compare values, testing if the left-hand value is greater than the right-hand.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// cmd_value.gt(value) → bool\n    /// cmd_value.gt(args!(values)) → bool\n    /// r.gt(args!(values)) → bool\n    /// ```\n    ///\n    /// Where:\n    /// - value: [Command](crate::Command) | impl Serialize\n    /// - values: [Command](crate::Command) | vec![...] | [...] | \u0026[...]\n    ///\n    /// ## Examples\n    ///\n    /// Test if a player has scored more than 10 points.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: bool = r.table(\"players\")\n    ///         .get(1)\n    ///         .g(\"score\")\n    ///         .gt(10)\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == true);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Test if variables are ordered from lowest to highest,\n    /// with no values being equal to one another.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: bool = r.gt(args!([20, 10, 15]))\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == true);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [eq](Self::eq)\n    /// - [ne](Self::ne)\n    /// - [ge](Self::ge)\n    /// - [lt](Self::lt)\n    /// - [le](Self::le)\n    pub fn gt(self, args: impl gt::GtArg) -\u003e Self {\n        gt::new(args).with_parent(self)\n    }\n\n    /// Compare values, testing if the left-hand value is greater than the right-hand.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// cmd_value.ge(value) → bool\n    /// cmd_value.ge(args!(values)) → bool\n    /// r.ge(args!(values)) → bool\n    /// ```\n    ///\n    /// Where:\n    /// - value: [Command](crate::Command) | impl Serialize\n    /// - values: [Command](crate::Command) | vec![...] | [...] | \u0026[...]\n    ///\n    /// ## Examples\n    ///\n    /// Test if a player has scored more than 10 points.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: bool = r.table(\"players\")\n    ///         .get(1)\n    ///         .g(\"score\")\n    ///         .ge(10)\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == true);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Test if variables are ordered from lowest to highest,\n    /// with no values being equal to one another.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: bool = r.ge(args!([20, 10, 15]))\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == true);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [eq](Self::eq)\n    /// - [ne](Self::ne)\n    /// - [gt](Self::gt)\n    /// - [lt](Self::lt)\n    /// - [le](Self::le)\n    pub fn ge(self, args: impl ge::GeArg) -\u003e Self {\n        ge::new(args).with_parent(self)\n    }\n\n    /// Compare values, testing if the left-hand value is less than the right-hand.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// cmd_value.lt(value) → bool\n    /// cmd_value.lt(args!(values)) → bool\n    /// r.lt(args!(values)) → bool\n    /// ```\n    ///\n    /// Where:\n    /// - value: [Command](crate::Command) | impl Serialize\n    /// - values: [Command](crate::Command) | vec![...] | [...] | \u0026[...]\n    ///\n    /// ## Examples\n    ///\n    /// Test if a player has scored less than 10 points.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: bool = r.table(\"players\")\n    ///         .get(1)\n    ///         .g(\"score\")\n    ///         .lt(10)\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == true);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Test if variables are ordered from highest to lowest,\n    /// with no values being equal to one another.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: bool = r.lt(args!([20, 10, 15]))\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == true);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [eq](Self::eq)\n    /// - [ne](Self::ne)\n    /// - [gt](Self::gt)\n    /// - [ge](Self::ge)\n    /// - [le](Self::le)\n    pub fn lt(self, args: impl lt::LtArg) -\u003e Self {\n        lt::new(args).with_parent(self)\n    }\n\n    /// Compare values, testing if the left-hand value is\n    /// less than or equal to the right-hand.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// cmd_value.ne(value) → bool\n    /// cmd_value.ne(args!(values)) → bool\n    /// r.ne(args!(values)) → bool\n    /// ```\n    ///\n    /// Where:\n    /// - value: [Command](crate::Command) | impl Serialize\n    /// - values: [Command](crate::Command) | vec![...] | [...] | \u0026[...]\n    ///\n    /// ## Examples\n    ///\n    /// Test if a player has scored 10 points or less.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: bool = r.table(\"players\")\n    ///         .get(1)\n    ///         .g(\"score\")\n    ///         .le(10)\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == true);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Test if variables are ordered from highest to lowest.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: bool = r.le(args!([20, 10, 15]))\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == true);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [eq](Self::eq)\n    /// - [ne](Self::ne)\n    /// - [gt](Self::gt)\n    /// - [ge](Self::ge)\n    /// - [lt](Self::lt)\n    pub fn le(self, args: impl le::LeArg) -\u003e Self {\n        le::new(args).with_parent(self)\n    }\n\n    /// Rounds the given value to the nearest whole integer.\n    ///\n    /// # Command syntax\n    /// ```text\n    /// r.round(param_number) → number\n    /// cmd_number.round() → number\n    /// ```\n    ///\n    /// Where:\n    /// - param_number: f64 | [Command](crate::Command)\n    /// - cmd_number: [Command](crate::Command)\n    ///\n    /// # Description\n    ///\n    /// For example, values of 1.0 up to but not including 1.5\n    /// will return 1.0, similar to [floor](Self::floor); values\n    /// of 1.5 up to 2.0 will return 2.0, similar to [ceil](Self::ceil).\n    ///\n    /// ## Examples\n    ///\n    /// Round 12.345 to the nearest integer.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: i32 = r.round(12.345)\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == 12);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// The `round` command can also be chained after an expression.\n    ///\n    /// ## Examples\n    ///\n    /// Round -12.345 to the nearest integer.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: i32 = r.expr(-12.345)\n    ///         .round()\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == -12);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [ceil](Self::ceil)\n    /// - [round](Self::round)\n    pub fn round(self) -\u003e Self {\n        round::new(()).with_parent(self)\n    }\n\n    /// Rounds the given value up, returning the smallest integer value\n    /// greater than or equal to the given value (the value’s ceiling).\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// r.ceil(param_number) → number\n    /// cmd_number.ceil() → number\n    /// ```\n    ///\n    /// Where:\n    /// - param_number: f64 | [Command](crate::Command)\n    /// - cmd_number: [Command](crate::Command)\n    ///\n    /// ## Examples\n    ///\n    /// Return the ceiling of 12.345.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: i32 = r.ceil(12.345)\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == 13);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// The `ceil` command can also be chained after an expression.\n    ///\n    /// ## Examples\n    ///\n    /// Return the ceiling of -12.345.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: i32 = r.expr(-12.345)\n    ///         .ceil()\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == -13);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [floor](Self::floor)\n    /// - [round](Self::round)\n    pub fn ceil(self) -\u003e Self {\n        ceil::new(()).with_parent(self)\n    }\n\n    /// Rounds the given value down, returning the largest integer\n    /// value less than or equal to the given value (the value’s floor).\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// r.floor(param_number) → number\n    /// cmd_number.floor() → number\n    /// ```\n    ///\n    /// Where:\n    /// - param_number: f64 | [Command](crate::Command)\n    /// - cmd_number: [Command](crate::Command)\n    ///\n    /// ## Examples\n    ///\n    /// Return the floor of 12.345.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: i32 = r.floor(12.345)\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == 13);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// The `floor` command can also be chained after an expression.\n    ///\n    /// ## Examples\n    ///\n    /// Return the floor of -12.345.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: i32 = r.expr(-12.345)\n    ///         .floor()\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == -13);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [ceil](Self::ceil)\n    /// - [round](Self::round)\n    pub fn floor(self) -\u003e Self {\n        floor::new(()).with_parent(self)\n    }\n\n    /// Compute the arithmetic \"and\" of one or more values.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// cmd_number \u0026 cmd_number\n    /// number.bitand(cmd_number) → number\n    /// number.bit_and(param_number) → number\n    /// r.bit_and(cmd_number, param_number) → number\n    /// ```\n    ///\n    /// Where:\n    /// - param_number: i32 | [Command](crate::Command)\n    /// - cmd_number: [Command](crate::Command)\n    ///\n    /// # Description\n    ///\n    /// A bitwise AND is a binary operation that takes two equal-length binary\n    /// representations and performs the logical AND operation on each pair of\n    /// the corresponding bits, which is equivalent to multiplying them.\n    /// Thus, if both bits in the compared position are 1,\n    /// the bit in the resulting binary representation is 1 (1 × 1 = 1);\n    /// otherwise, the result is 0 (1 × 0 = 0 and 0 × 0 = 0).\n    ///\n    /// ## Examples\n    ///\n    /// Compute the arithmetic \"and\" of 5 and 3\n    ///\n    /// ```\n    /// use std::ops::BitAnd;\n    ///\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: i32 = r.expr(5)\n    ///         .bit_and(3)\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     let response2: i32 = r.bit_and(r.expr(5), 3)\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     let response3: i32 = (r.expr(5) \u0026 r.expr(3))\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     let response4: i32 = r.expr(5)\n    ///         .bitand(r.expr(3))\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(\n    ///         response == 1 \u0026\u0026\n    ///         response == response2 \u0026\u0026\n    ///         response == response3 \u0026\u0026\n    ///         response == response4\n    ///     );\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [bit_or](Self::bit_or)\n    /// - [bit_not](Self::bit_not)\n    /// - [bit_xor](Self::bit_xor)\n    /// - [bit_sal](Self::bit_sal)\n    /// - [bit_sar](Self::bit_sar)\n    pub fn bit_and(self, args: impl bit_and::BitAndArg) -\u003e Self {\n        self.bitand(args)\n    }\n\n    /// Compute the arithmetic \"or\" of one or more values.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// cmd_number | cmd_number\n    /// number.bitor(cmd_number) → number\n    /// number.bit_or(param_number) → number\n    /// r.bit_or(cmd_number, param_number) → number\n    /// ```\n    ///\n    /// Where:\n    /// - param_number: i32 | [Command](crate::Command)\n    /// - cmd_number: [Command](crate::Command)\n    ///\n    /// # Description\n    ///\n    /// A bitwise OR is a binary operation that takes two bit patterns\n    /// of equal length and performs the logical inclusive OR operation\n    /// on each pair of corresponding bits. The result in each position\n    /// is 0 if both bits are 0, while otherwise the result is 1.\n    ///\n    /// ## Examples\n    ///\n    /// Compute the arithmetic \"or\" of 6 and 4\n    ///\n    /// ```\n    /// use std::ops::BitOr;\n    ///\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: i32 = r.expr(5)\n    ///         .bit_or(3)\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     let response2: i32 = r.bit_or(r.expr(5), 3)\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     let response3: i32 = (r.expr(5) ^ r.expr(3))\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     let response4: i32 = r.expr(5)\n    ///         .bitor(r.expr(3))\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(\n    ///         response == 7 \u0026\u0026\n    ///         response == response2 \u0026\u0026\n    ///         response == response3 \u0026\u0026\n    ///         response == response4\n    ///     );\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [bit_and](Self::bit_and)\n    /// - [bit_not](Self::bit_not)\n    /// - [bit_xor](Self::bit_xor)\n    /// - [bit_sal](Self::bit_sal)\n    /// - [bit_sar](Self::bit_sar)\n    pub fn bit_or(self, args: impl bit_or::BitOrArg) -\u003e Self {\n        self.bitor(args)\n    }\n\n    /// Compute the arithmetic \"and\" of one or more values.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// cmd_number ^ cmd_number\n    /// number.bitxor(cmd_number) → number\n    /// number.bit_xor(param_number) → number\n    /// r.bit_xor(cmd_number, param_number) → number\n    /// ```\n    ///\n    /// Where:\n    /// - param_number: i32 | [Command](crate::Command)\n    /// - cmd_number: [Command](crate::Command)\n    ///\n    /// # Description\n    ///\n    /// A bitwise XOR is a binary operation that takes two bit patterns\n    /// of equal length and performs the logical exclusive OR operation\n    /// on each pair of corresponding bits. The result in each position\n    /// is 1 if only the first bit is 1 or only the second bit is 1,\n    /// but will be 0 if both are 0 or both are 1.\n    /// In this we perform the comparison of two bits, being 1 if the\n    /// two bits are different, and 0 if they are the same.\n    ///\n    /// ## Examples\n    ///\n    /// Compute the arithmetic \"and\" of 6 and 4\n    ///\n    /// ```\n    /// use std::ops::BitXor;\n    ///\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: i32 = r.expr(6)\n    ///         .bit_xor(4)\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     let response2: i32 = r.bit_xor(r.expr(6), 4)\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     let response3: i32 = (r.expr(6) ^ r.expr(4))\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     let response4: i32 = r.expr(6)\n    ///         .bitxor(r.expr(4))\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(\n    ///         response == 2 \u0026\u0026\n    ///         response == response2 \u0026\u0026\n    ///         response == response3 \u0026\u0026\n    ///         response == response4\n    ///     );\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [bit_and](Self::bit_and)\n    /// - [bit_not](Self::bit_not)\n    /// - [bit_or](Self::bit_or)\n    /// - [bit_sal](Self::bit_sal)\n    /// - [bit_sar](Self::bit_sar)\n    pub fn bit_xor(self, args: impl bit_xor::BitXorArg) -\u003e Self {\n        self.bitxor(args)\n    }\n\n    /// Compute the arithmetic inverse (not) of an expression.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// number.bit_not() → number\n    /// r.bit_not(cmd_number) → number\n    /// ```\n    ///\n    /// Where:\n    /// - cmd_number: [Command](crate::Command)\n    ///\n    /// # Description\n    ///\n    /// A bitwise NOT, or complement, is a unary operation that performs logical\n    /// negation on each bit, forming the ones’ complement of the given binary value.\n    /// Bits that are 0 become 1, and those that are 1 become 0.\n    ///\n    /// ## Examples\n    ///\n    /// Negate the arithmetice expression\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: i32 = r.expr(7)\n    ///         .bit_not()\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     let response2: i32 = r.bit_not(r.expr(7))\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == -8 \u0026\u0026 response == response2);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [bit_and](Self::bit_and)\n    /// - [bit_or](Self::bit_or)\n    /// - [bit_sal](Self::bit_sal)\n    /// - [bit_sar](Self::bit_sar)\n    /// - [bit_xor](Self::bit_xor)\n    pub fn bit_not(self) -\u003e Self {\n        bit_not::new().with_parent(self)\n    }\n\n    /// Compute the left arithmetic shift (left logical shift) of one or more values.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// number.bit_sal(param_number) → number\n    /// r.bit_sal(cmd_number, param_number) → number\n    /// ```\n    ///\n    /// Where:\n    /// - param_number: i32 | [Command](crate::Command)\n    /// - cmd_number: [Command](crate::Command)\n    ///\n    /// # Description\n    ///\n    /// In an arithmetic shift (also referred to as signed shift),\n    /// like a logical shift, the bits that slide off the end disappear\n    /// (except for the last, which goes into the carry flag).\n    /// But in an arithmetic shift, the spaces are filled in such a way\n    /// to preserve the sign of the number being slid. For this reason,\n    /// arithmetic shifts are better suited for signed numbers in two’s\n    /// complement format.\n    ///\n    /// ## Note\n    ///\n    /// SHL and SAL are the same, and differentiation only happens because\n    /// SAR and SHR (right shifting) has differences in their implementation.\n    ///\n    /// ## Examples\n    ///\n    /// Compute the left arithmetic shift of 5 and 4\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: u8 = r.expr(5)\n    ///         .bit_sar(4)\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     let response2: u8 = r.bit_sar(r.expr(5), r.expr(4))\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == 80 \u0026\u0026 response == response2);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [bit_and](Self::bit_and)\n    /// - [bit_not](Self::bit_not)\n    /// - [bit_or](Self::bit_or)\n    /// - [bit_sar](Self::bit_sar)\n    /// - [bit_xor](Self::bit_xor)\n    pub fn bit_sal(self, args: impl bit_sal::BitSalArg) -\u003e Self {\n        bit_sal::new(args).with_parent(self)\n    }\n\n    /// Compute the right arithmetic shift of one or more values.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// number.bit_sar(param_number) → number\n    /// r.bit_sar(cmd_number, param_number) → number\n    /// ```\n    ///\n    /// Where:\n    /// - param_number: i32 | [Command](crate::Command)\n    /// - cmd_number: [Command](crate::Command)\n    ///\n    /// # Description\n    ///\n    /// In an arithmetic shift (also referred to as signed shift),\n    /// like a logical shift, the bits that slide off the end disappear\n    /// (except for the last, which goes into the carry flag).\n    /// But in an arithmetic shift, the spaces are filled in such\n    /// a way to preserve the sign of the number being slid.\n    /// For this reason, arithmetic shifts are better suited for\n    /// signed numbers in two’s complement format.\n    ///\n    /// ## Examples\n    ///\n    /// Compute the right arithmetic shift of 32 and 3\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: u8 = r.expr(32)\n    ///         .bit_sar(3)\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     let response2: u8 = r.bit_sar(r.expr(32), r.expr(3))\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == 4 \u0026\u0026 response == response2);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [bit_and](Self::bit_and)\n    /// - [bit_not](Self::bit_not)\n    /// - [bit_or](Self::bit_or)\n    /// - [bit_sal](Self::bit_sal)\n    /// - [bit_xor](Self::bit_xor)\n    pub fn bit_sar(self, args: impl bit_sar::BitSarArg) -\u003e Self {\n        bit_sar::new(args).with_parent(self)\n    }\n\n    /// Return a new time object with a different timezone.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// time.in_timezone(timezone) → time\n    /// ```\n    ///\n    /// Where:\n    /// - timezone: [UtcOffset](UtcOffset)\n    /// - time: [Time](crate::types::Time)\n    ///\n    /// # Description\n    ///\n    /// While the time stays the same, the results returned by methods such\n    /// as hours() will change since they take the timezone into account.\n    /// The timezone argument has to be of the ISO 8601 format.\n    ///\n    /// ## Examples\n    ///\n    /// Hour of the day in San Francisco (UTC/GMT -8, without daylight saving time).\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::types::Time;\n    /// use reql_rust::{r, Result};\n    /// use time::macros::offset;\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let date_time = r.now().in_timezone(offset!(-08:00));\n    ///     let time1: Time = date_time.clone().value();\n    ///     let time2: Time = date_time.cmd()\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(time1.is_valid());\n    ///     assert!(time2.is_valid());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [timezone](Self::timezone)\n    /// - [now](crate::r::now)\n    /// - [time](crate::r::time)\n    pub fn in_timezone(self, timezone: UtcOffset) -\u003e Self {\n        in_timezone::new(timezone).with_parent(self)\n    }\n\n    /// Return the timezone of the time object.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// time.timezone() → String\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Return all the users in the “-07:00” timezone.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"users\")\n    ///         .filter(func!(|user| user.g(\"subscription_date\").timezone().lt(\"-07:00\")))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [now](crate::r::now)\n    /// - [time](crate::r::time)\n    /// - [in_timezone](Self::in_timezone)\n    pub fn timezone(self) -\u003e Self {\n        timezone::new().with_parent(self)\n    }\n\n    /// Return whether a time is between two other times.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// time.during(args!(start_time, end_time)) -\u003e bool\n    /// time.during(args!(start_time, end_time, options)) -\u003e bool\n    /// ```\n    ///\n    /// Where:\n    /// - start_time, end_time: [DateTime](crate::types::DateTime), [Command](crate::Command)\n    /// - options: [DuringOption](crate::cmd::during::DuringOption)\n    ///\n    /// ## Examples\n    ///\n    /// Retrieve all the posts that were posted between December 1st,\n    /// 2013 (inclusive) and December 10th, 2013 (exclusive).\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{args, r, Result};\n    /// use time::macros::{date, offset};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let start_date = r.time(args!(date!(2013 - 12 - 01), offset!(UTC)));\n    ///     let end_date = r.time(args!(date!(2013 - 12 - 10), offset!(UTC)));\n    ///     let response = r.table(\"posts\")\n    ///         .filter(func!(|post| post.g(\"date\").during(args!(start_date, end_date))))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Retrieve all the posts that were posted between December 1st,\n    /// 2013 (exclusive) and December 10th, 2013 (inclusive).\n    ///\n    /// ```\n    /// use reql_rust::arguments::Status;\n    /// use reql_rust::cmd::during::DuringOption;\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{args, r, Result};\n    /// use time::macros::{date, offset};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let start_date = r.time(args!(date!(2013 - 12 - 01), offset!(UTC)));\n    ///     let end_date = r.time(args!(date!(2013 - 12 - 10), offset!(UTC)));\n    ///     let during_options = DuringOption::default()\n    ///         .left_bound(Status::Open)\n    ///         .right_bound(Status::Closed);\n    ///     let response = r.table(\"posts\")\n    ///         .filter(func!(|post| post.g(\"date\").during(args!(\n    ///             start_date,\n    ///             end_date,\n    ///             during_options\n    ///         ))))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [now](crate::r::now)\n    /// - [time](crate::r::time)\n    /// - [in_timezone](Self::in_timezone)\n    pub fn during(self, args: impl during::DuringArg) -\u003e Self {\n        during::new(args).with_parent(self)\n    }\n\n    /// Return a new time struct only based on the day,\n    /// month and year (ie. the same day at 00:00).\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// time.date() → time\n    /// ```\n    ///\n    /// Where:\n    /// - time: [Time](crate::types::Time)\n    ///\n    /// ## Examples\n    ///\n    /// Retrieve all the users whose birthday is today.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"users\")\n    ///         .filter(func!(|user| user.g(\"birthdate\").date().eq(r.now().cmd().date())))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// Note that the [now](crate::r::now) command always returns UTC time, so the\n    /// comparison may fail if `user.g(\"birthdate\")` isn’t also in UTC.\n    /// You can use the [in_timezone](Self::in_timezone) command to adjust for this:\n    ///\n    /// ```\n    /// use time::macros::offset;\n    ///\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"users\")\n    ///         .filter(func!(|user| user.g(\"birthdate\").date().eq(\n    ///             r.now().cmd().in_timezone(offset!(-08:00)).date()\n    ///         )))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [now](crate::r::now)\n    /// - [time](crate::r::time)\n    /// - [in_timezone](Self::in_timezone)\n    pub fn date(self) -\u003e Self {\n        date::new().with_parent(self)\n    }\n\n    /// Return the number of seconds elapsed since the\n    /// beginning of the day stored in the time object.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// time.time_of_day() → f64\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Retrieve posts that were submitted before noon.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"posts\")\n    ///         .filter(func!(|post| post.g(\"date\").time_of_day().le(12*60*60)))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [now](crate::r::now)\n    /// - [time](crate::r::time)\n    /// - [in_timezone](Self::in_timezone)\n    pub fn time_of_day(self) -\u003e Self {\n        time_of_day::new().with_parent(self)\n    }\n\n    /// Return the year of a time object.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// time.year() → i32\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Retrieve all the users born in 1986.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"users\")\n    ///         .filter(func!(|user| user.g(\"birthdate\").year().eq(r.expr(1986))))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [now](crate::r::now)\n    /// - [time](crate::r::time)\n    pub fn year(self) -\u003e Self {\n        year::new().with_parent(self)\n    }\n\n    /// Return the month of a time object as a number between 1 and 12.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// time.month() → u8\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Retrieve all the users who were born in November.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"users\")\n    ///         .filter(func!(|user| user.g(\"birthdate\").month().eq(r.expr(11))))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [now](crate::r::now)\n    /// - [time](crate::r::time)\n    pub fn month(self) -\u003e Self {\n        month::new().with_parent(self)\n    }\n\n    /// Return the day of a time object as a number between 1 and 31.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// time.day() → u8\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Return the users born on the 24th of any month.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"users\")\n    ///         .filter(func!(|user| user.g(\"birthdate\").day().eq(r.expr(24))))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [now](crate::r::now)\n    /// - [time](crate::r::time)\n    pub fn day(self) -\u003e Self {\n        day::new().with_parent(self)\n    }\n\n    /// Return the day of week of a time object as a number\n    /// between 1 and 7 (following ISO 8601 standard).\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// time.day_of_week() → u8\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Return today’s day of week.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let day_of_week = r.now().day_of_week();\n    ///     let day_of_week1 = day_of_week.clone().value();\n    ///     let day_of_week2: u8 = day_of_week.cmd()\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(day_of_week1 == day_of_week2);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Retrieve all the users who were born on a Tuesday.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"users\")\n    ///         .filter(func!(|user| user.g(\"birthdate\").day_of_week().eq(r.expr(2))))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [now](crate::r::now)\n    /// - [time](crate::r::time)\n    pub fn day_of_week(self) -\u003e Self {\n        day_of_week::new().with_parent(self)\n    }\n\n    /// Return the day of the year of a time object as a number\n    /// between 1 and 366 (following ISO 8601 standard).\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// time.day_of_year() → u16\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Retrieve all the users who were born the first day of a year.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"users\")\n    ///         .filter(func!(|user| user.g(\"birthdate\").day_of_year().eq(r.expr(1))))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [now](crate::r::now)\n    /// - [time](crate::r::time)\n    pub fn day_of_year(self) -\u003e Self {\n        day_of_year::new().with_parent(self)\n    }\n\n    /// Return the hour in a time object as a number between 0 and 23.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// time.hours() → u8\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Return all the posts submitted after midnight and before 4am.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"posts\")\n    ///         .filter(func!(|post| post.g(\"date\").hours().lt(4)))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [now](crate::r::now)\n    /// - [time](crate::r::time)\n    /// - [in_timezone](Self::in_timezone)\n    pub fn hours(self) -\u003e Self {\n        hours::new().with_parent(self)\n    }\n\n    /// Return the minute in a time object as a number between 0 and 59.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// time.minutes() → u8\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Return all the posts submitted during the first 10 minutes of every hour.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"posts\")\n    ///         .filter(func!(|post| post.g(\"date\").minutes().lt(10)))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [now](crate::r::now)\n    /// - [time](crate::r::time)\n    /// - [in_timezone](Self::in_timezone)\n    pub fn minutes(self) -\u003e Self {\n        minutes::new().with_parent(self)\n    }\n\n    /// Return the seconds in a time object as a number between 0 and 59.999.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// time.seconds() → f64\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Return the post submitted during the first 30 seconds of every minute.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"posts\")\n    ///         .filter(func!(|post| post.g(\"date\").seconds().lt(30)))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [now](crate::r::now)\n    /// - [time](crate::r::time)\n    /// - [in_timezone](Self::in_timezone)\n    pub fn seconds(self) -\u003e Self {\n        seconds::new().with_parent(self)\n    }\n\n    /// Convert a time object to a string in ISO 8601 format.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// time.to_iso8601() → String\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Return the current ISO 8601 time.\n    ///\n    /// ```\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let iso8601 = r.now().to_iso8601();\n    ///     let iso8601_1 = iso8601.clone().value();\n    ///     let iso8601_2: String = iso8601.cmd()\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(!iso8601_1.is_empty());\n    ///     assert!(!iso8601_2.is_empty());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [now](crate::r::now)\n    /// - [time](crate::r::time)\n    pub fn to_iso8601(self) -\u003e Self {\n        to_iso8601::new().with_parent(self)\n    }\n\n    /// Convert a time object to its epoch time.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// time.to_epoch_time() → f64\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Return the current time in seconds since\n    /// the Unix Epoch with millisecond-precision.\n    ///\n    /// ```\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let time = r.now().to_epoch_time();\n    ///     let time1: f64 = time.clone().value();\n    ///     let time2: f64 = time.cmd()\n    ///         .run(\u0026conn)\n    ///         .await?.unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(time1.is_normal());\n    ///     assert!(time2.is_normal());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [now](crate::r::now)\n    /// - [time](crate::r::time)\n    /// - [to_iso8601](Self::to_iso8601)\n    pub fn to_epoch_time(self) -\u003e Self {\n        to_epoch_time::new().with_parent(self)\n    }\n\n    // FIXME Command no work\n    pub fn do_(self, args: impl do_::DoArg) -\u003e Self {\n        do_::new(args).with_parent(self)\n    }\n\n    /// Perform a branching conditional equivalent to `if-then-else`.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// r.branch(test, args!(true_action, false_action)) → any\n    /// r.branch(test, args!(true_action, [(test2, test2_action), N], false_action)) → any\n    /// query.branch(args!(true_action, false_action)) -\u003e any\n    /// query.branch(args!(true_action, [(test2, test2_action), N], false_action)) → any\n    /// ```\n    ///\n    /// Where:\n    /// - test, true_action, false_action, test2, test2_action: r.expr(...)\n    ///\n    /// # Description\n    ///\n    /// The `branch` command takes 2n+1 arguments: pairs of conditional expressions\n    /// and commands to be executed if the conditionals return any value but `false`\n    /// or `None` i.e., “truthy” values), with a final “else” command to be evaluated\n    /// if all of the conditionals are `false` or `None`.\n    ///\n    /// You may call `branch` infix style on the first test.\n    /// (See the second example for an illustration.)\n    ///\n    /// ```text\n    /// r.branch(test1, args!(val1, [(test2, val2)], elseval))\n    /// ```\n    ///\n    /// is the equivalent of the Rust statement\n    ///\n    /// ```text\n    /// if (test1) {\n    ///     val1\n    /// } else if (test2) {\n    ///     val2\n    /// } else {\n    ///     elseval\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Test the value of x.\n    ///\n    /// ```\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let x = 10;\n    ///     let conn = r.connection().connect().await?;\n    ///\n    ///     let response: String = r.branch(\n    ///             r.expr(x \u003e 5),\n    ///             args!(r.expr(\"big\"), r.expr(\"small\"))\n    ///         ).run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response.eq(\"big\"));\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// As above, infix-style.\n    ///\n    /// ```\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let x = 10;\n    ///     let conn = r.connection().connect().await?;\n    ///\n    ///     let response: String = r.expr(x \u003e 5)\n    ///         .branch(args!(r.expr(\"big\"), r.expr(\"small\")))\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response.eq(\"big\"));\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Categorize heroes by victory counts.\n    ///\n    /// ```\n    /// use std::ops::Add;\n    ///\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///\n    ///     let response = r.table(\"pricings\")\n    ///         .map(func!(|offer| r.branch(\n    ///             offer.clone().g(\"price\").gt(100),\n    ///             args!(\n    ///                 offer.clone().g(\"offer\").add(\"premium\"),\n    ///                 [(\n    ///                     offer.clone().g(\"price\").gt(10),\n    ///                     offer.clone().g(\"offer\").add(\"standard\")\n    ///                 )],\n    ///                 offer.g(\"offer\").add(\"freemium\")\n    ///         ))))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [do_](Self::do_)\n    pub fn branch(self, args: impl branch::BranchArg) -\u003e Self {\n        branch::new(args).with_parent(self)\n    }\n\n    /// Loop over a sequence, evaluating the given write query for each element.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// sequence.for_each(write_function) → response\n    /// ```\n    ///\n    /// Where:\n    /// - write_function: func!(...)\n    /// - response: [MutationResponse](crate::types::MutationResponse)\n    ///\n    /// ## Examples\n    ///\n    /// Get information about a table such as primary key, or cache size.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::types::MutationResponse;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///\n    ///     let response: MutationResponse = r.table(\"models\")\n    ///         .for_each(func!(|model| r.table(\"cars\")\n    ///             .get(model.get(\"car_model\"))\n    ///             .delete(())\n    ///         ))\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response.deleted == 5);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [map](Self::map)\n    pub fn for_each(self, write_function: Func) -\u003e Self {\n        for_each::new(write_function).with_parent(self)\n    }\n\n    /// Provide a default value in case of non-existence errors.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// value.default(default_value) → any\n    /// sequence.default(default_value) → any\n    /// ```\n    ///\n    /// # Description\n    ///\n    /// The `default` command evaluates its first argument (the value it’s chained to).\n    /// If that argument returns `None` or a non-existence error is thrown in evaluation,\n    /// then `default` returns its second argument. The second argument is usually a default value,\n    /// but it can be a function that returns a value.\n    ///\n    /// ## Examples\n    ///\n    /// Suppose we want to retrieve the titles and authors of the table posts.\n    /// In the case where the author field is missing or null,\n    /// we want to retrieve the string Anonymous.\n    ///\n    /// ```\n    /// use std::collections::HashMap;\n    ///\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    /// use serde::{Deserialize, Serialize};\n    ///\n    /// #[derive(Debug, Serialize, Deserialize)]\n    /// struct Post {\n    ///     title: String,\n    ///     author: String,\n    /// }\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///\n    ///     let response: Vec\u003cPost\u003e = r.table(\"posts\")\n    ///         .map(func!(|doc| {\n    ///             let mut post = HashMap::new();\n    ///             post.insert(\"title\", doc.clone().g(\"title\"));\n    ///             post.insert(\"author\", doc.clone().g(\"author\").default(\"Anonymous\"));\n    ///             r.hash_map(post)\n    ///         }))\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response.len() \u003e 0);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// The `default` command can also be used to filter documents.\n    /// Suppose we want to retrieve all our users who are not grown-ups or\n    /// whose age is unknown (i.e., the field `age` is missing or equals `None`).\n    /// We can do it with this query:\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///\n    ///     let response = r.table(\"users\")\n    ///         .filter(func!(|user| user.g(\"age\").lt(18).default(true)))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// One more way to write the previous query is\n    /// to set the age to be `-1` when the field is missing.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///\n    ///     let response = r.table(\"users\")\n    ///         .filter(func!(|user| user.g(\"age\").default(-1).lt(18)))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// Another way to do the same query is to use hasFields.\n    ///\n    /// ```\n    /// use std::ops::Not;\n    ///\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///\n    ///     let response = r.table(\"users\")\n    ///         .filter(func!(|user| user.clone().has_fields(\"age\").not().or(user.g(\"age\").lt(18))))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// Another way to do the same query is to use hasFields.\n    ///\n    /// ```\n    /// use reql_rust::cmd::filter::FilterOption;\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///\n    ///     let response = r.table(\"users\")\n    ///         .filter(args!(\n    ///             func!(|user| user.g(\"age\").lt(18).default(true)),\n    ///             FilterOption::default().default_(true)\n    ///         ))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    pub fn default(self, default_value: impl Serialize) -\u003e Self {\n        default::new(default_value).with_parent(self)\n    }\n\n    /// Convert a value of one type into another.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// sequence.coerce_to('array') → array\n    /// value.coerce_to('string') → string\n    /// string.coerce_to('number') → number\n    /// array.coerce_to('object') → object\n    /// sequence.coerce_to('object') → object\n    /// object.coerce_to('array') → array\n    /// binary.coerce_to('string') → string\n    /// string.coerce_to('binary') → binary\n    /// ```\n    ///\n    /// # Description\n    ///\n    /// - a sequence, selection or object can be coerced to an array\n    /// - a sequence, selection or an array of key-value pairs can be coerced to an object\n    /// - a string can be coerced to a number\n    /// - any datum (single value) can be coerced to a string\n    /// - a binary object can be coerced to a string and vice-versa\n    ///\n    /// ## Examples\n    ///\n    /// Coerce an array of pairs into an object.\n    ///\n    /// ```\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///\n    ///     let response = r.expr([[\"name\", \"Malika\"], [\"genre\", \"woman\"]])\n    ///         .coerce_to(\"object\")\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Coerce a number to a string.\n    ///\n    /// ```\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///\n    ///     let response: char = r.expr(1)\n    ///         .coerce_to(\"string\")\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == '1');\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [object](crate::r::object)\n    pub fn coerce_to(self, value: impl Serialize) -\u003e Self {\n        coerce_to::new(value).with_parent(self)\n    }\n\n    /// Gets the type of a ReQL query’s return value.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// any.type_of() → response\n    /// ```\n    ///\n    /// Where:\n    /// - response: [TypeOf](crate::types::TypeOf)\n    ///\n    /// # Description\n    ///\n    /// Read the article on [ReQL data types](https://rethinkdb.com/docs/data-types/)\n    /// for a more detailed discussion.\n    /// Note that some possible return values from `type_of` are internal values,\n    /// such as `TypeOf::MAXVAL`, and unlikely to be returned from queries in standard practice.\n    ///\n    /// ## Examples\n    ///\n    /// Get the type of a TypeOf.\n    ///\n    /// ```\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::types::TypeOf;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///\n    ///     let response: TypeOf = r.expr(\"foo\")\n    ///         .type_of()\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == TypeOf::String);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    pub fn type_of(self) -\u003e Self {\n        type_of::new().with_parent(self)\n    }\n\n    /// Get information about a ReQL value.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// any.info() → response\n    /// r.info(any) → response\n    /// ```\n    ///\n    /// Where:\n    /// - response: [InfoResponse](crate::types::InfoResponse)\n    ///\n    /// ## Examples\n    ///\n    /// Get information about a table such as primary key, or cache size.\n    ///\n    /// ```\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::types::{InfoResponse, TypeOf};\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///\n    ///     let response: InfoResponse = r.table(\"simbad\")\n    ///         .info()\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response.typ == TypeOf::Table);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    pub fn info(self) -\u003e Self {\n        info::new().with_parent(self)\n    }\n\n    /// Convert a ReQL value or object to a JSON string.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// value.to_json() → String\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Get a ReQL document as a JSON string.\n    ///\n    /// ```\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///\n    ///     let response: String = r.table(\"simbad\")\n    ///         .get(1)\n    ///         .to_json()\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(!response.is_empty());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    pub fn to_json(self) -\u003e Self {\n        to_json::new().with_parent(self)\n    }\n\n    /// Compute the distance between a point and another geometry object.\n    /// At least one of the geometry objects specified must be a point.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// geometry.distance(geometry) → f64\n    /// geometry.distance(args!(geometry, options)) → f64\n    /// r.distance(geometry.cmd(), geometry) → f64\n    /// r.distance(geometry.cmd(), args!(geometry, options)) → f64\n    /// ```\n    ///\n    /// Where:\n    /// - geometry: [r.point(...)](crate::r::point) |\n    /// [r.line(...)](crate::r::line) |\n    /// [r.polygon(...)](crate::r::polygon)\n    /// - options: [DistanceOption](crate::cmd::distance::DistanceOption)\n    ///\n    /// # Description\n    ///\n    /// If one of the objects is a polygon or a line, the point will be projected\n    /// into the line or polygon assuming a perfect sphere model before the distance\n    /// is computed (using the model specified with `geo_system`).\n    /// As a consequence, if the polygon or line is extremely large compared\n    /// to Earth’s radius and the distance is being computed with the default\n    ///  WGS84 model, the results of `distance` should be considered approximate\n    /// due to the deviation between the ellipsoid and spherical models.\n    ///\n    /// ## Examples\n    ///\n    /// Compute the distance between two points on the Earth in kilometers.\n    ///\n    /// ```\n    /// use reql_rust::arguments::Unit;\n    /// use reql_rust::cmd::distance::DistanceOption;\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let point1 = r.point(-122.423246, 37.779388);\n    ///     let point2 = r.point(-117.220406, 32.719464);\n    ///     let distance_option = DistanceOption::default().unit(Unit::Kilometer);\n    ///\n    ///     let response: f64 = point1.cmd()\n    ///         .distance(point2)\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == 734.125249602186);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [polygon](crate::r::polygon)\n    /// - [line](crate::r::line)\n    pub fn distance(self, args: impl distance::DistanceArg) -\u003e Self {\n        distance::new(args).with_parent(self)\n    }\n\n    /// Convert a ReQL geometry object to a [GeoJSON](https://geojson.org/) object.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// geometry.to_geojson() → response\n    /// ```\n    ///\n    /// Where:\n    /// - geometry: [r.point(...)](crate::r::point) |\n    /// [r.line(...)](crate::r::line) |\n    /// [r.polygon(...)](crate::r::polygon)\n    /// command\n    /// - response: [GeoJson\u003cT\u003e](crate::types::GeoJson)\n    ///\n    /// ## Examples\n    ///\n    /// Convert a ReQL geometry object to a GeoJSON object.\n    ///\n    /// ```\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::types::{GeoJson, GeoType};\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///\n    ///     let response: GeoJson\u003c[f64; 2]\u003e = r.table(\"simbad\")\n    ///         .get(\"sfo\")\n    ///         .g(\"location\")\n    ///         .to_geojson()\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response.typ == GeoType::Point);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [geojson](crate::r::geojson)\n    pub fn to_geojson(self) -\u003e Self {\n        to_geojson::new().with_parent(self)\n    }\n\n    /// Get all documents where the given geometry object intersects\n    /// the geometry object of the requested geospatial index.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// table.get_intersecting(geometry, options) → selection\u003cstream\u003e\n    /// ```\n    ///\n    /// Where:\n    /// - geometry: [r.point(...)](crate::r::point) |\n    /// [r.line(...)](crate::r::line) |\n    /// [r.polygon(...)](crate::r::polygon)\n    /// command\n    /// - sequence: command\n    /// - options: [GetIntersectingOption](crate::cmd::get_intersecting::GetIntersectingOption)\n    ///\n    /// # Description\n    ///\n    /// The `index` argument is mandatory. This command returns the same\n    ///  results as `|row| row.g(index).intersects(geometry)`.\n    /// The total number of results is limited to the array size limit\n    /// which defaults to 100,000, but can be changed with the `array_limit`\n    /// option to [run](Self::run).\n    ///\n    /// ## Examples\n    ///\n    /// Which of the locations in a list of parks intersect `circle`?\n    ///\n    /// ```\n    /// use reql_rust::arguments::Unit;\n    /// use reql_rust::cmd::circle::CircleOption;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let point = r.point(-117.220406, 32.719464);\n    ///     let circle_opts = CircleOption::default()\n    ///         .unit(Unit::InternationalMile);\n    ///     let circle = r.circle(args!(point, 10., circle_opts));\n    ///\n    ///     let response = r.table(\"simbad\")\n    ///         .get_intersecting(circle, \"area\")\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [get_nearest](Self::get_nearest)\n    pub fn get_intersecting(\n        self,\n        geometry: impl get_intersecting::GetIntersectingArg,\n        index: \u0026'static str,\n    ) -\u003e Self {\n        get_intersecting::new(geometry, index).with_parent(self)\n    }\n\n    /// Return a list of documents closest to a\n    /// specified point based on a geospatial index,\n    /// sorted in order of increasing distance.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// table.get_nearest(args!(geometry, \u0026str)) → array\n    /// table.get_nearest(args!(geometry, \u0026str, options)) → array\n    /// ```\n    ///\n    /// Where:\n    /// - geometry: [r.point(...)](crate::r::point) |\n    /// [r.line(...)](crate::r::line) |\n    /// [r.polygon(...)](crate::r::polygon) |\n    /// command\n    /// - sequence: command\n    /// - options: [GetNearestOption](crate::cmd::get_nearest::GetNearestOption)\n    ///\n    /// # Description\n    ///\n    /// The return value will be an array of two-item objects\n    /// with the keys `dist` and `doc`, set to the distance\n    /// between the specified point and the document\n    /// (in the units specified with `unit`, defaulting to meters)\n    /// and the document itself, respectively.\n    /// The array will be sorted by the values of `dist`.\n    ///\n    /// ## Examples\n    ///\n    /// Return a list of the closest 25 enemy hideouts to the secret base.\n    ///\n    /// ```\n    /// use reql_rust::cmd::get_nearest::GetNearestOption;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let secret_base = r.point(-122.422876, 37.777128);\n    ///     let opts = GetNearestOption::default().max_results(25);\n    ///\n    ///     let response = r.table(\"simbad\")\n    ///         .get_nearest(args!(secret_base, \"location\"))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [get_intersecting](Self::get_intersecting)\n    pub fn get_nearest(self, args: impl get_nearest::GetNearestArg) -\u003e Self {\n        get_nearest::new(args).with_parent(self)\n    }\n\n    /// Tests whether a geometry object is completely contained within another.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// geometry.includes(geometry) → bool\n    /// sequence.includes(geometry) → sequence\n    /// ```\n    ///\n    /// Where:\n    /// - geometry: [r.point(...)](crate::r::point) |\n    /// [r.line(...)](crate::r::line) |\n    /// [r.polygon(...)](crate::r::polygon) |\n    /// command\n    /// - sequence: command\n    ///\n    /// # Description\n    ///\n    /// When applied to a sequence of geometry objects,\n    /// `includes` acts as a [filter](Self::filter),\n    /// returning a sequence of objects from the sequence\n    /// that include the argument.\n    ///\n    /// ## Examples\n    ///\n    /// Is `point2` included within a 2000-meter circle around `point1`?\n    ///\n    /// ```\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let point1 = r.point(-117.220406, 32.719464);\n    ///     let point2 = r.point(-117.206201, 32.725186);\n    ///\n    ///     let response: bool = r.circle(args!(point1, 2000.))\n    ///         .includes(point2)\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Which of the locations in a list of parks include `circle`?\n    ///\n    /// ```\n    /// use reql_rust::arguments::Unit;\n    /// use reql_rust::cmd::circle::CircleOption;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let point = r.point(-117.220406, 32.719464);\n    ///     let circle_opts = CircleOption::default().unit(Unit::InternationalMile);\n    ///     let circle = r.circle(args!(point, 10., circle_opts));\n    ///\n    ///     let response = r.table(\"parks\")\n    ///         .g(\"area\")\n    ///         .includes(circle)\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Rewrite the previous example with `get_intersecting`.\n    ///\n    /// ```\n    /// use reql_rust::arguments::Unit;\n    /// use reql_rust::cmd::circle::CircleOption;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let point = r.point(-117.220406, 32.719464);\n    ///     let circle_opts = CircleOption::default()\n    ///         .unit(Unit::InternationalMile);\n    ///     let circle = r.circle(args!(point, 10., circle_opts));\n    ///\n    ///     let response = r.table(\"parks\")\n    ///         .get_intersecting(circle.clone(), \"area\")\n    ///         .g(\"area\")\n    ///         .includes(circle)\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [intersects](Self::intersects)\n    pub fn includes(self, args: impl includes::IncludesArg) -\u003e Self {\n        includes::new(args).with_parent(self)\n    }\n\n    /// Tests whether two geometry objects intersect with one another.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// geometry.intersects(geometry) → bool\n    /// r.intersects(geometry_command, geometry) → bool\n    /// sequence.intersects(geometry) → sequence_response\n    /// r.intersects(sequence, geometry) → sequence_response\n    /// ```\n    ///\n    /// Where:\n    /// - geometry: [r.point(...)](crate::r::point) |\n    /// [r.line(...)](crate::r::line) |\n    /// [r.polygon(...)](crate::r::polygon) |\n    /// command\n    /// - sequence, geometry_command: [Command](crate::Command)\n    ///\n    /// # Description\n    ///\n    /// When applied to a sequence of geometry objects, `intersects` acts as a\n    /// [filter](Self::filter), returning a sequence of objects from\n    /// the sequence that intersect with the argument.\n    ///\n    /// ## Examples\n    ///\n    /// Is `point2` within a 2000-meter circle around `point1`?\n    ///\n    /// ```\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let point1 = r.point(-117.220406, 32.719464);\n    ///     let point2 = r.point(-117.206201, 32.725186);\n    ///\n    ///     let response: bool = r.circle(args!(point1, 2000.))\n    ///         .intersects(point2)\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Which of the locations in a list of parks intersect `circle`?\n    ///\n    /// ```\n    /// use reql_rust::arguments::Unit;\n    /// use reql_rust::cmd::circle::CircleOption;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let point = r.point(-117.220406, 32.719464);\n    ///     let circle_opts = CircleOption::default().unit(Unit::InternationalMile);\n    ///     let circle = r.circle(args!(point, 10., circle_opts));\n    ///\n    ///     let response = r.table(\"parks\")\n    ///         .g(\"area\")\n    ///         .intersects(circle)\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [includes](Self::includes)\n    /// - [get_intersecting](Self::get_intersecting)\n    pub fn intersects(self, geometry: impl intersects::IntersectsArg) -\u003e Self {\n        intersects::new(geometry).with_parent(self)\n    }\n\n    /// Grant or deny access permissions for a user account,\n    /// globally or on a per-database or per-table basis.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// r.grant(username, permission) → response\n    /// table.grant(username, permission) → response\n    /// db.grant(username, permission) → response\n    /// ```\n    ///\n    /// Where:\n    /// - table: [r.table(...)](crate::r::table) |\n    /// [query.table(...)](Self::table)\n    /// - db: [r.db(...)](crate::r::db)\n    /// - response: [GrantResponse](crate::types::GrantResponse)\n    ///\n    /// # Description\n    ///\n    /// Permissions that are not defined on a local scope will\n    /// be inherited from the next largest scope.\n    /// For example, a write operation on a table will first\n    /// check if `write` permissions are explicitly set to `true` or `false`\n    /// for that table and account combination; if they are not,\n    /// the `write` permissions for the database will be used\n    /// if those are explicitly set; and if neither table nor database\n    /// permissions are set for that account, the global `write`\n    /// permissions for that account will be used.\n    ///\n    /// ## Note\n    ///\n    /// For all accounts other than the special, system-defined `admin` account,\n    /// permissions that are not explicitly set in any scope will effectively be `false`.\n    /// When you create a new user account by inserting a record into the\n    /// [system table](https://rethinkdb.com/docs/system-tables/#users),\n    /// that account will have **no** permissions until they are explicitly granted.\n    ///\n    /// For a full description of permissions, read\n    /// [Permissions and user accounts](https://rethinkdb.com/docs/permissions-and-accounts/).\n    ///\n    /// ## Examples\n    ///\n    /// Grant the `alima` user account read and write permissions on the `users` database.\n    ///\n    /// ```\n    /// use reql_rust::arguments::Permission;\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::types::GrantResponse;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let permission = Permission::default().read(true).write(true);\n    ///\n    ///     let response: GrantResponse = r.db(\"users\")\n    ///         .grant(\"alima\", permission)\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response.granted == 1);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Deny write permissions from the `alima` account for the `simbad` table.\n    ///\n    /// ```\n    /// use reql_rust::arguments::Permission;\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::types::GrantResponse;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let permission = Permission::default().write(false);\n    ///\n    ///     let response: GrantResponse = r.db(\"users\")\n    ///         .table(\"simbad\")\n    ///         .grant(\"alima\", permission)\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response.granted == 1);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Grant `alima` the ability to use HTTP connections.\n    ///\n    /// ```\n    /// use reql_rust::arguments::Permission;\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::types::GrantResponse;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let permission = Permission::default().connect(true);\n    ///\n    ///     let response: GrantResponse = r.grant(\"alima\", permission)\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response.granted == 1);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Grant a `monitor` account read-only access to all databases.\n    ///\n    /// ```\n    /// use reql_rust::arguments::Permission;\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::types::GrantResponse;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let permission = Permission::default().read(true);\n    ///\n    ///     let response: GrantResponse = r.grant(\"monitor\", permission)\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response.granted == 1);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    pub fn grant(self, username: \u0026str, permission: Permission) -\u003e Self {\n        grant::new(username, permission).with_parent(self)\n    }\n\n    /// Query (read and/or update) the configurations for individual tables or databases.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// table.config() → response\n    /// db.config() → response\n    /// ```\n    ///\n    /// Where:\n    /// - table: [r.table(...)](crate::r::table) |\n    /// [query.table(...)](Self::table)\n    /// - db: [r.db(...)](crate::r::db)\n    /// - response: [ConfigResponse](crate::types::ConfigResponse)\n    ///\n    /// # Description\n    ///\n    /// The config command is a shorthand way to access the `table_config` or `db_config`\n    /// [System tables](https://rethinkdb.com/docs/system-tables/#configuration-tables).\n    /// It will return the single row from the system that corresponds to the database\n    /// or table configuration, as if [get](Self::get) had been called on the system\n    /// table with the UUID of the database or table in question.\n    ///\n    /// ## Examples\n    ///\n    /// Rebalance a table.\n    ///\n    /// ```\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::types::ConfigResponse;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///\n    ///     let response: ConfigResponse = r.table(\"simbad\")\n    ///         .config()\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response.name == \"simbad\");\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    pub fn config(self) -\u003e Self {\n        config::new().with_parent(self)\n    }\n\n    /// Rebalances the shards of a table. When called on a database,\n    /// all the tables in that database will be rebalanced.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// table.rebalance() → response\n    /// db.rebalance() → response\n    /// ```\n    ///\n    /// Where:\n    /// - table: [r.table(...)](crate::r::table) |\n    /// [query.table(...)](Self::table)\n    /// - db: [r.db(...)](crate::r::db)\n    /// - response: [RebalanceResponse](crate::types::RebalanceResponse)\n    ///\n    /// # Description\n    ///\n    /// The `rebalance` command operates by measuring the distribution of\n    /// primary keys within a table and picking split points that will\n    /// give each shard approximately the same number of documents.\n    /// It won’t change the number of shards within a table,\n    /// or change any other configuration aspect for the table or the database.\n    ///\n    /// A table will lose availability temporarily after `rebalance` is called;\n    /// use the [wait](Self::wait) command to wait for the table to become available again,\n    /// or [status](Self::status) to check if the table is available for writing.\n    ///\n    /// RethinkDB automatically rebalances tables when the number of shards are increased,\n    /// and as long as your documents have evenly distributed primary keys—such as\n    /// the default UUIDs—it is rarely necessary to call `rebalance` manually.\n    /// Cases where `rebalance` may need to be called include:\n    /// - Tables with unevenly distributed primary keys, such as incrementing integers\n    /// - Changing a table’s primary key type\n    /// - Increasing the number of shards on an empty table,\n    /// then using non-UUID primary keys in that table\n    ///\n    /// The [web UI](https://rethinkdb.com/docs/administration-tools/)\n    /// (and the [info](Self::info) command)\n    /// can be used to tell you when a table’s shards need to be rebalanced.\n    ///\n    /// See the [status](Self::status) command for an explanation of\n    /// the objects returned in the `old_val` and `new_val` fields.\n    ///\n    /// ## Examples\n    ///\n    /// Rebalance a table.\n    ///\n    /// ```\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::types::RebalanceResponse;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///\n    ///     let response: RebalanceResponse = r.table(\"simbad\")\n    ///         .rebalance()\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response.rebalanced == 1);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    pub fn rebalance(self) -\u003e Self {\n        rebalance::new().with_parent(self)\n    }\n\n    /// Reconfigure a table’s sharding and replication.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// table.reconfigure(options) → response\n    /// db.reconfigure(options) → response\n    /// ```\n    ///\n    /// Where:\n    /// - table: [r.table(...)](crate::r::table) |\n    /// [query.table(...)](Self::table)\n    /// - db: [r.db(...)](crate::r::db)\n    /// - options: [ReconfigureOption](crate::cmd::reconfigure::ReconfigureOption)\n    /// - response: [ReconfigureResponse](crate::types::ReconfigureResponse)\n    ///\n    /// # Description\n    ///\n    /// A table will lose availability temporarily after `reconfigure` is called;\n    /// use the [wait](Self::wait) command to wait for the table to become available again,\n    /// or [status](Self::wait) to check if the table is available for writing.\n    ///\n    /// ## Note\n    ///\n    /// Whenever you call `reconfigure`, the write durability will be set to\n    /// `Durability::Hard` and the write\n    /// acknowledgments will be set to `ReadMode::Majority`;\n    /// these can be changed by using the `config` command on the table.\n    ///\n    ///\n    /// If `reconfigure` is called on a database,\n    /// all the tables in the database will have their configurations affected.\n    /// The return value will be an array of the objects described above, one per table.\n    ///\n    /// Read [Sharding and replication](https://rethinkdb.com/docs/sharding-and-replication/)\n    /// for a complete discussion of the subject, including advanced topics.\n    ///\n    /// ## Examples\n    ///\n    /// Reconfigure a table.\n    ///\n    /// ```\n    /// use reql_rust::arguments::Replicas;\n    /// use reql_rust::cmd::reconfigure::ReconfigureOption;\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::types::ReconfigureResponse;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let opts = ReconfigureOption::default()\n    ///         .shards(1)\n    ///         .replicas(Replicas::Int(1));\n    ///\n    ///     let response: ReconfigureResponse = r.table(\"simbad\")\n    ///         .reconfigure(opts)\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response.reconfigured == 1);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Reconfigure a table, specifying replicas by server tags.\n    ///\n    /// ```\n    /// use std::collections::HashMap;\n    ///\n    /// use reql_rust::arguments::Replicas;\n    /// use reql_rust::cmd::reconfigure::ReconfigureOption;\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::types::ReconfigureResponse;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let mut replicas = HashMap::new();\n    ///\n    ///     replicas.insert(\"malika\".static_string(), 1);\n    ///     replicas.insert(\"malika\".static_string(), 1);\n    ///\n    ///     let opts = ReconfigureOption::default()\n    ///         .shards(2)\n    ///         .replicas(Replicas::Map {\n    ///             replicas,\n    ///             primary_replica_tag: \"malika\".static_string()\n    ///         });\n    ///\n    ///     let response: ReconfigureResponse = r.table(\"simbad\")\n    ///         .reconfigure(opts)\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response.reconfigured == 1);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Perform an emergency repair on a table.\n    ///\n    /// ```\n    /// use reql_rust::arguments::EmergencyRepair;\n    /// use reql_rust::cmd::reconfigure::ReconfigureOption;\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::types::ReconfigureResponse;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let opts = ReconfigureOption::default()\n    ///         .emergency_repair(EmergencyRepair::UnsafeRollback);\n    ///\n    ///     let response: ReconfigureResponse = r.table(\"simbad\")\n    ///         .reconfigure(opts)\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response.reconfigured == 1);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    pub fn reconfigure(self, opts: reconfigure::ReconfigureOption) -\u003e Self {\n        reconfigure::new(opts).with_parent(self)\n    }\n\n    /// Return the status of a table.\n    ///\n    /// The return value is an object providing information about\n    /// the table’s shards, replicas and replica readiness states.\n    /// For a more complete discussion of the object fields,\n    /// read about the table_status table in\n    /// [System tables](https://rethinkdb.com/docs/system-tables/#status-tables).\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// table.status() → response\n    /// ```\n    ///\n    /// Where:\n    /// - table: [r.table(...)](crate::r::table) |\n    /// [query.table(...)](Self::table)\n    /// - response: [StatusResponse](crate::types::StatusResponse)\n    ///\n    /// ## Examples\n    ///\n    /// Get a table’s status.\n    ///\n    /// ```\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::types::StatusResponse;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///\n    ///     let response: StatusResponse = r.table(\"simbad\")\n    ///         .status()\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response.name.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    pub fn status(self) -\u003e Self {\n        status::new().with_parent(self)\n    }\n\n    /// Wait for a table or all the tables in a database to be ready.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// table.wait(()) → response\n    /// db.wait(()) → response\n    /// r.wait(table) → response\n    /// r.wait(database) → response\n    /// table.wait(options) → response\n    /// db.wait(options) → response\n    /// r.wait(args!(table, options)) → response\n    /// r.wait(args!(database, options)) → response\n    /// ```\n    ///\n    /// Where:\n    /// - table: [r.table(...)](crate::r::table) |\n    /// [query.table(...)](Self::table)\n    /// - db: [r.db(...)](crate::r::db)\n    /// - options: [WaitOption](crate::cmd::wait::WaitOption)\n    /// - response: [WaitResponse](crate::types::WaitResponse)\n    ///\n    /// # Description\n    ///\n    /// A table may be temporarily unavailable after creation,\n    /// rebalancing or reconfiguring.\n    /// The `wait` command blocks until the given\n    /// table (or database) is fully up to date.\n    ///\n    /// ## Examples\n    ///\n    /// Wait on a table to be ready.\n    ///\n    /// ```\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::types::WaitResponse;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///\n    ///     let response: WaitResponse = r.table(\"simbad\")\n    ///         .wait(())\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response.ready == 1);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Wait on a table with timeout to be ready for reads.\n    ///\n    /// ```\n    /// use reql_rust::arguments::WaitFor;\n    /// use reql_rust::cmd::wait::WaitOption;\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::types::WaitResponse;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let table_command = r.db(\"anim\").table(\"simbad\");\n    ///     let opts = WaitOption::default()\n    ///         .wait_for(WaitFor::ReadyForReads)\n    ///         .timeout(8000f64);\n    ///\n    ///     let response: WaitResponse =  r.wait(args!(table_command, opts))\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response.ready == 1);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    pub fn wait(self, args: impl wait::WaitArg) -\u003e Self {\n        wait::new(args).with_parent(self)\n    }\n\n    /// Run a query on a connection,\n    /// returning either a single JSON result or a cursor,\n    /// depending on the query.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// query.run(\u0026session) → value\n    /// query.run(connection) → value\n    /// query.run(args!(\u0026session, options)) → value\n    /// query.run(args!(connection, options)) → value\n    /// query.run(\u0026mut session) → value\n    /// query.run(args!(\u0026mut session, options)) → value\n    /// ```\n    ///\n    /// Where:\n    /// - session: [Session](crate::connection::Session)\n    /// - connection: [Connection](crate::connection::Connection)\n    /// - options: [RunOption](crate::cmd::run::RunOption)\n    /// - stream: [impl Stream\u003cItem = Result\u003cValue\u003e\u003e](futures::stream::Stream)\n    ///\n    /// ## Examples\n    ///\n    /// If you are OK with potentially out of date data\n    /// from all the tables involved in this query and\n    /// want potentially faster reads,\n    /// pass a flag allowing out of date data in an options object.\n    /// Settings for individual tables will supercede this global\n    /// setting for all tables in the query.\n    ///\n    /// ```\n    /// use reql_rust::arguments::ReadMode;\n    /// use reql_rust::cmd::run::RunOption;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let opts = RunOption::default().read_mode(ReadMode::Outdated);\n    ///\n    ///     r.table(\"simbad\").run(args!(\u0026conn, opts)).await?;\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// If you want to specify whether to wait for a write to be written\n    /// to disk (overriding the table’s default settings),\n    /// you can set `durability` to `Durability::Hard`\n    /// or `Durability::Soft` in the options.\n    ///\n    /// ```\n    /// use reql_rust::arguments::Durability;\n    /// use reql_rust::cmd::run::RunOption;\n    /// use reql_rust::{args, r, Result};\n    /// use serde_json::json;\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let opts = RunOption::default().durability(Durability::Hard);\n    ///     let data = json!({\n    ///         \"name\": \"Pumba\",\n    ///         \"live\": 5\n    ///     });\n    ///\n    ///     r.table(\"simbad\").insert(data).run(args!(\u0026conn, opts)).await?;\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// If you do not want a time object to be converted to a native date object,\n    /// you can pass a time_format flag to prevent it\n    /// (valid flags are `Format::Raw` and `Format::Native`).\n    /// This query returns an object with two fields (epoch_time and $reql_type$)\n    /// instead of a native date object.\n    ///\n    /// ```\n    /// use reql_rust::arguments::Format;\n    /// use reql_rust::cmd::run::RunOption;\n    /// use reql_rust::{args, r, Result};\n    /// use serde_json::json;\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let opts = RunOption::default().time_format(Format::Raw);\n    ///\n    ///     r.now().cmd().run(args!(\u0026conn, opts)).await?;\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Specify the database to use for the query.\n    ///\n    /// ```\n    /// use reql_rust::arguments::Format;\n    /// use reql_rust::cmd::run::RunOption;\n    /// use reql_rust::{args, r, Result};\n    /// use serde_json::json;\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let opts = RunOption::default().db(\"jikoni\");\n    ///\n    ///     r.table(\"simbad\").run(args!(\u0026conn, opts)).await?;\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Change the batching parameters for this query.\n    ///\n    /// ```\n    /// use reql_rust::arguments::Format;\n    /// use reql_rust::cmd::run::RunOption;\n    /// use reql_rust::{args, r, Result};\n    /// use serde_json::json;\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let opts = RunOption::default()\n    ///         .max_batch_rows(16)\n    ///         .max_batch_bytes(2048);\n    ///\n    ///     r.table(\"simbad\").run(args!(\u0026conn, opts)).await?;\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [connection](crate::r::connection)\n    pub async fn run(self, arg: impl run::RunArg) -\u003e Result\u003cOption\u003cValue\u003e\u003e {\n        self.make_query(arg).try_next().await\n    }\n\n    /// Prepare query for execution\n    ///\n    /// See [run](self::run) for more information.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// query.make_query(\u0026session) → stream\n    /// query.make_query(connection) → stream\n    /// query.make_query(args!(\u0026session, options)) → stream\n    /// query.make_query(args!(connection, options)) → stream\n    /// query.make_query(\u0026mut session) → stream\n    /// query.make_query(args!(\u0026mut session, options)) → stream\n    /// ```\n    ///\n    /// Where:\n    /// - session: [Session](crate::connection::Session)\n    /// - connection: [Connection](crate::connection::Connection)\n    /// - options: [RunOption](crate::cmd::run::RunOption)\n    ///\n    /// # Description\n    ///\n    /// This method has the same parameters as `run`.\n    /// The main difference between `make_query` and `run` is that\n    /// `make_query` can be used to execute multiple requests\n    ///\n    /// ## Examples\n    ///\n    /// You can use `query.make_query` to get the same result than `query.run`\n    ///\n    /// ```\n    /// use futures::TryStreamExt;\n    /// use reql_rust::r;\n    ///\n    /// async fn example() -\u003e reql_rust::Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///\n    ///     r.table(\"simbad\").make_query(\u0026conn).try_next().await?;\n    ///     // is same than\n    ///     r.table(\"simbad\").run(\u0026conn).await?;\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Run many queries\n    ///\n    /// ```\n    /// use futures::stream::{select_all, TryStreamExt};\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::r;\n    ///\n    /// async fn example() -\u003e reql_rust::Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let mut streams = Vec::new();\n    ///     let expected_messages: Vec\u003cString\u003e = (0..10_000)\n    ///         .into_iter()\n    ///         .map(|i| format!(\"message {}\", i))\n    ///         .collect();\n    ///\n    ///     for msg in expected_messages.iter() {\n    ///         streams.push(r.expr(msg).make_query(\u0026conn));\n    ///     }\n    ///\n    ///     let mut list = select_all(streams);\n    ///     let mut response = Vec::new();\n    ///\n    ///     while let Some(msg) = list.try_next().await? {\n    ///         let msg: String = msg.parse()?;\n    ///         response.push(msg);\n    ///     }\n    ///\n    ///     assert!(response == expected_messages);\n    ///\n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [run](self::run)\n    pub fn make_query(self, arg: impl run::RunArg) -\u003e impl Stream\u003cItem = Result\u003cValue\u003e\u003e {\n        Box::pin(run::new(self, arg))\n    }\n}\n\npub enum CmdOpts {\n    Single(Command),\n    Many(Vec\u003cCommand\u003e),\n}\n\nimpl CmdOpts {\n    pub(crate) fn add_to_cmd(self, command: Command) -\u003e Command {\n        match self {\n            Self::Single(arg) =\u003e command.with_arg(arg),\n            Self::Many(args) =\u003e args.into_iter().fold(command, |cmd, arg| cmd.with_arg(arg)),\n        }\n    }\n}\n\nimpl From\u003cCmdOpts\u003e for Option\u003cCommand\u003e {\n    fn from(command: CmdOpts) -\u003e Self {\n        if let CmdOpts::Single(arg) = command {\n            Some(arg)\n        } else {\n            None\n        }\n    }\n}\n\n// for debug purposes only\nfn bytes_to_string(bytes: \u0026[u8]) -\u003e String {\n    if let Ok(string) = str::from_utf8(bytes) {\n        return string.to_owned();\n    }\n    format!(\"{:?}\", bytes)\n}\n","traces":[{"line":194,"address":[4471248],"length":1,"stats":{"Line":4},"fn_name":"static_string"},{"line":195,"address":[4471269],"length":1,"stats":{"Line":4},"fn_name":null},{"line":200,"address":[4013680],"length":1,"stats":{"Line":1},"fn_name":"static_string"},{"line":201,"address":[4013692],"length":1,"stats":{"Line":1},"fn_name":null},{"line":206,"address":[1837680],"length":1,"stats":{"Line":0},"fn_name":"static_string"},{"line":207,"address":[1837703],"length":1,"stats":{"Line":0},"fn_name":null},{"line":208,"address":[1837726],"length":1,"stats":{"Line":0},"fn_name":null},{"line":209,"address":[1837767],"length":1,"stats":{"Line":0},"fn_name":null},{"line":215,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":216,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":219,"address":[2192426,2192453,2192224],"length":1,"stats":{"Line":1},"fn_name":"table_create\u003c(\u0026str, reql_rust::cmd::table_create::TableCreateOption)\u003e"},{"line":220,"address":[2192358,2192259],"length":1,"stats":{"Line":2},"fn_name":null},{"line":223,"address":[4047696,4047895,4047922],"length":1,"stats":{"Line":0},"fn_name":"table_drop"},{"line":224,"address":[4047827,4047760],"length":1,"stats":{"Line":0},"fn_name":null},{"line":227,"address":[4047936,4048093,4048120],"length":1,"stats":{"Line":0},"fn_name":"table_list"},{"line":228,"address":[4048025,4047958],"length":1,"stats":{"Line":0},"fn_name":null},{"line":231,"address":[2192903,2192464,2192654,2192681,2192930,2192704],"length":1,"stats":{"Line":4},"fn_name":"table\u003c(\u0026str, reql_rust::cmd::table::TableOption)\u003e"},{"line":232,"address":[2192768,2192486,2192584,2192835],"length":1,"stats":{"Line":8},"fn_name":null},{"line":235,"address":[2193374,2193401,2192944,2193170,2193184,2193143],"length":1,"stats":{"Line":2},"fn_name":"index_create\u003c\u0026str\u003e"},{"line":236,"address":[2193075,2193206,2193304,2193008],"length":1,"stats":{"Line":4},"fn_name":null},{"line":239,"address":[4048144,4048370,4048343],"length":1,"stats":{"Line":1},"fn_name":"index_drop"},{"line":240,"address":[4048208,4048275],"length":1,"stats":{"Line":2},"fn_name":null},{"line":243,"address":[4048384,4048568,4048541],"length":1,"stats":{"Line":1},"fn_name":"index_list"},{"line":244,"address":[4048473,4048406],"length":1,"stats":{"Line":2},"fn_name":null},{"line":247,"address":[2193614,2193664,2193424,2193893,2193866,2193641],"length":1,"stats":{"Line":2},"fn_name":"index_rename\u003c(\u0026str, \u0026str)\u003e"},{"line":248,"address":[2193686,2193544,2193796,2193446],"length":1,"stats":{"Line":4},"fn_name":null},{"line":251,"address":[2194569,2194112,2193904,2194063,2194311,2194338,2194542,2194090,2194352],"length":1,"stats":{"Line":3},"fn_name":"index_status\u003c()\u003e"},{"line":252,"address":[2193926,2194374,2194472,2193993,2194243,2194176],"length":1,"stats":{"Line":6},"fn_name":null},{"line":255,"address":[2194782,2194832,2195266,2194809,2195239,2195040,2194991,2194592,2195018],"length":1,"stats":{"Line":3},"fn_name":"index_wait\u003calloc::vec::Vec\u003c\u0026str, alloc::alloc::Global\u003e\u003e"},{"line":256,"address":[2194854,2194712,2194921,2194614,2195171,2195104],"length":1,"stats":{"Line":6},"fn_name":null},{"line":259,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":260,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":263,"address":[4048592,4048749,4048776],"length":1,"stats":{"Line":0},"fn_name":"get_write_hook"},{"line":264,"address":[4048681,4048614],"length":1,"stats":{"Line":0},"fn_name":null},{"line":267,"address":[2196130,2198455,2196354,2195458,2196818,2198428,2195952,2197266,2196381,2195682,2196400,2198178,2195709,2197293,2197730,2195728,2197042,2195906,2196617,2196590,2197529,2198224,2197502,2197954,2195504,2198205,2197552,2196640,2195485,2197981,2197088,2196157,2196845,2197069,2195280,2195933,2196864,2198000,2197776,2197312,2196176,2197757],"length":1,"stats":{"Line":14},"fn_name":"insert\u003creql_rust::arguments::Args\u003c(\u0026reql_rust::spec::Post, reql_rust::cmd::insert::InsertOption)\u003e\u003e"},{"line":268,"address":[2195995,2195547,2197595,2196974,2197131,2196907,2196520,2197432,2198110,2195771,2196286,2197819,2196062,2197662,2195614,2198259,2196219,2198358,2195302,2195838,2196422,2196750,2198043,2197334,2195388,2197886,2196683,2197198],"length":1,"stats":{"Line":28},"fn_name":null},{"line":271,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":272,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":275,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":276,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":279,"address":[2198666,2198639,2198480],"length":1,"stats":{"Line":1},"fn_name":"delete\u003c()\u003e"},{"line":280,"address":[2198502,2198569],"length":1,"stats":{"Line":2},"fn_name":null},{"line":283,"address":[4048800,4048957,4048984],"length":1,"stats":{"Line":1},"fn_name":"sync"},{"line":284,"address":[4048889,4048822],"length":1,"stats":{"Line":2},"fn_name":null},{"line":287,"address":[2199138,2199356,2199383,2199408,2199577,2199604,2198865,2199111,2199152,2198912,2198688,2198892],"length":1,"stats":{"Line":4},"fn_name":"get\u003ci32\u003e"},{"line":288,"address":[2198976,2199439,2199286,2198728,2199043,2198795,2199509,2199187],"length":1,"stats":{"Line":8},"fn_name":null},{"line":291,"address":[2199830,2199616,2199857],"length":1,"stats":{"Line":1},"fn_name":"get_all\u003c(alloc::vec::Vec\u003c\u0026str, alloc::alloc::Global\u003e, reql_rust::cmd::get_all::GetAllOption)\u003e"},{"line":292,"address":[2199760,2199638],"length":1,"stats":{"Line":2},"fn_name":null},{"line":295,"address":[2200357,2199872,2200103,2200330,2200076,2200128],"length":1,"stats":{"Line":2},"fn_name":"between\u003creql_rust::arguments::Args\u003c(reql_rust::proto::Command, reql_rust::proto::Command, reql_rust::cmd::between::BetweenOption)\u003e\u003e"},{"line":296,"address":[2200262,2199907,2200006,2200163],"length":1,"stats":{"Line":4},"fn_name":null},{"line":299,"address":[2200572,2200599,2200855,2200828,2200624,2200368],"length":1,"stats":{"Line":2},"fn_name":"filter\u003creql_rust::proto::Command\u003e"},{"line":300,"address":[2200758,2200659,2200403,2200502],"length":1,"stats":{"Line":4},"fn_name":null},{"line":303,"address":[4049008,4049260,4049287],"length":1,"stats":{"Line":0},"fn_name":"inner_join"},{"line":304,"address":[4049192,4049048],"length":1,"stats":{"Line":0},"fn_name":null},{"line":307,"address":[4049591,4049564,4049312],"length":1,"stats":{"Line":0},"fn_name":"outer_join"},{"line":308,"address":[4049352,4049496],"length":1,"stats":{"Line":0},"fn_name":null},{"line":311,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":312,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":315,"address":[4049616,4049773,4049800],"length":1,"stats":{"Line":0},"fn_name":"zip"},{"line":316,"address":[4049638,4049705],"length":1,"stats":{"Line":0},"fn_name":null},{"line":319,"address":[2201111,2201084,2200880],"length":1,"stats":{"Line":1},"fn_name":"map\u003creql_rust::cmd::func::Func\u003e"},{"line":320,"address":[2201014,2200915],"length":1,"stats":{"Line":2},"fn_name":null},{"line":323,"address":[4050028,4050055,4049824],"length":1,"stats":{"Line":1},"fn_name":"with_fields"},{"line":324,"address":[4049958,4049859],"length":1,"stats":{"Line":2},"fn_name":null},{"line":327,"address":[4050311,4050284,4050080],"length":1,"stats":{"Line":0},"fn_name":"concat_map"},{"line":328,"address":[4050115,4050214],"length":1,"stats":{"Line":0},"fn_name":null},{"line":331,"address":[2201632,2201607,2201326,2201136,2201353,2201376,2202117,2201863,2201836,2201888,2201580,2202090],"length":1,"stats":{"Line":4},"fn_name":"order_by\u003creql_rust::cmd::order_by::OrderByOption\u003e"},{"line":332,"address":[2201510,2201256,2201158,2202022,2201411,2201923,2201667,2201766],"length":1,"stats":{"Line":8},"fn_name":null},{"line":335,"address":[4050514,4050541,4050336],"length":1,"stats":{"Line":1},"fn_name":"skip"},{"line":336,"address":[4050446,4050379],"length":1,"stats":{"Line":2},"fn_name":null},{"line":339,"address":[4050738,4050765,4050560],"length":1,"stats":{"Line":1},"fn_name":"limit"},{"line":340,"address":[4050670,4050603],"length":1,"stats":{"Line":2},"fn_name":null},{"line":343,"address":[2202128,2202327,2202354],"length":1,"stats":{"Line":1},"fn_name":"slice\u003c(isize, isize)\u003e"},{"line":344,"address":[2202259,2202192],"length":1,"stats":{"Line":2},"fn_name":null},{"line":347,"address":[4050784,4050989,4050962],"length":1,"stats":{"Line":1},"fn_name":"nth"},{"line":348,"address":[4050827,4050894],"length":1,"stats":{"Line":2},"fn_name":null},{"line":351,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":352,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":355,"address":[4051192,4051165,4051008],"length":1,"stats":{"Line":1},"fn_name":"is_empty"},{"line":356,"address":[4051030,4051097],"length":1,"stats":{"Line":2},"fn_name":null},{"line":359,"address":[2202599,2202572,2202368],"length":1,"stats":{"Line":1},"fn_name":"union\u003creql_rust::proto::Command\u003e"},{"line":360,"address":[2202403,2202502],"length":1,"stats":{"Line":2},"fn_name":null},{"line":363,"address":[4051421,4051394,4051216],"length":1,"stats":{"Line":1},"fn_name":"sample"},{"line":364,"address":[4051259,4051326],"length":1,"stats":{"Line":2},"fn_name":null},{"line":367,"address":[2202850,2202823,2202624],"length":1,"stats":{"Line":1},"fn_name":"group\u003c\u0026str\u003e"},{"line":368,"address":[2202755,2202688],"length":1,"stats":{"Line":2},"fn_name":null},{"line":371,"address":[4051624,4051440,4051597],"length":1,"stats":{"Line":1},"fn_name":"ungroup"},{"line":372,"address":[4051529,4051462],"length":1,"stats":{"Line":2},"fn_name":null},{"line":375,"address":[4051648,4051879,4051852],"length":1,"stats":{"Line":0},"fn_name":"reduce"},{"line":376,"address":[4051782,4051683],"length":1,"stats":{"Line":0},"fn_name":null},{"line":379,"address":[4052156,4051904,4052183],"length":1,"stats":{"Line":0},"fn_name":"fold"},{"line":380,"address":[4051944,4052088],"length":1,"stats":{"Line":0},"fn_name":null},{"line":383,"address":[2202864,2203050,2203023],"length":1,"stats":{"Line":1},"fn_name":"count\u003c()\u003e"},{"line":384,"address":[2202953,2202886],"length":1,"stats":{"Line":2},"fn_name":null},{"line":387,"address":[2203298,2203271,2203072],"length":1,"stats":{"Line":1},"fn_name":"sum\u003c\u0026str\u003e"},{"line":388,"address":[2203136,2203203],"length":1,"stats":{"Line":2},"fn_name":null},{"line":391,"address":[2203538,2203312,2203511],"length":1,"stats":{"Line":1},"fn_name":"avg\u003c\u0026str\u003e"},{"line":392,"address":[2203376,2203443],"length":1,"stats":{"Line":2},"fn_name":null},{"line":395,"address":[2203778,2203751,2203552],"length":1,"stats":{"Line":1},"fn_name":"min\u003c\u0026str\u003e"},{"line":396,"address":[2203683,2203616],"length":1,"stats":{"Line":2},"fn_name":null},{"line":399,"address":[2204018,2203792,2203991],"length":1,"stats":{"Line":1},"fn_name":"max\u003c\u0026str\u003e"},{"line":400,"address":[2203856,2203923],"length":1,"stats":{"Line":2},"fn_name":null},{"line":403,"address":[2204032,2204222,2204249],"length":1,"stats":{"Line":1},"fn_name":"distinct\u003creql_rust::cmd::distinct::DistinctOption\u003e"},{"line":404,"address":[2204152,2204054],"length":1,"stats":{"Line":2},"fn_name":null},{"line":407,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":408,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":411,"address":[2204462,2204272,2204489],"length":1,"stats":{"Line":1},"fn_name":"pluck\u003c[\u0026str; 2]\u003e"},{"line":412,"address":[2204294,2204392],"length":1,"stats":{"Line":2},"fn_name":null},{"line":415,"address":[2204512,2204729,2204702],"length":1,"stats":{"Line":1},"fn_name":"without\u003c[\u0026str; 2]\u003e"},{"line":416,"address":[2204632,2204534],"length":1,"stats":{"Line":2},"fn_name":null},{"line":419,"address":[2204983,2204752,2204956],"length":1,"stats":{"Line":1},"fn_name":"merge\u003creql_rust::proto::Command\u003e"},{"line":420,"address":[2204787,2204886],"length":1,"stats":{"Line":2},"fn_name":null},{"line":423,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":424,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":427,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":428,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":431,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":432,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":435,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":436,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":439,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":440,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":443,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":444,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":447,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":448,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":451,"address":[2205008,2205207,2205234],"length":1,"stats":{"Line":1},"fn_name":"bracket\u003c\u0026str\u003e"},{"line":452,"address":[2205072,2205139],"length":1,"stats":{"Line":2},"fn_name":null},{"line":455,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":456,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":459,"address":[2205474,2205248,2205447],"length":1,"stats":{"Line":1},"fn_name":"g\u003c\u0026str\u003e"},{"line":460,"address":[2205312,2205379],"length":1,"stats":{"Line":2},"fn_name":null},{"line":463,"address":[2205714,2205687,2205488],"length":1,"stats":{"Line":1},"fn_name":"has_fields\u003c\u0026str\u003e"},{"line":464,"address":[2205619,2205552],"length":1,"stats":{"Line":2},"fn_name":null},{"line":467,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":468,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":471,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":472,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":475,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":476,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":479,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":480,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":483,"address":[4052392,4052365,4052208],"length":1,"stats":{"Line":1},"fn_name":"keys"},{"line":484,"address":[4052297,4052230],"length":1,"stats":{"Line":2},"fn_name":null},{"line":487,"address":[4052416,4052600,4052573],"length":1,"stats":{"Line":1},"fn_name":"values"},{"line":488,"address":[4052505,4052438],"length":1,"stats":{"Line":2},"fn_name":null},{"line":491,"address":[4052823,4052850,4052624],"length":1,"stats":{"Line":0},"fn_name":"match_"},{"line":492,"address":[4052755,4052688],"length":1,"stats":{"Line":0},"fn_name":null},{"line":495,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":496,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":499,"address":[4053021,4053048,4052864],"length":1,"stats":{"Line":0},"fn_name":"upcase"},{"line":500,"address":[4052886,4052953],"length":1,"stats":{"Line":0},"fn_name":null},{"line":503,"address":[4053256,4053229,4053072],"length":1,"stats":{"Line":0},"fn_name":"downcase"},{"line":504,"address":[4053094,4053161],"length":1,"stats":{"Line":0},"fn_name":null},{"line":507,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":508,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":511,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":512,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":515,"address":[2205932,2205959,2205728],"length":1,"stats":{"Line":1},"fn_name":"eq\u003creql_rust::proto::Command\u003e"},{"line":516,"address":[2205763,2205862],"length":1,"stats":{"Line":2},"fn_name":null},{"line":519,"address":[2206215,2206188,2205984],"length":1,"stats":{"Line":1},"fn_name":"ne\u003creql_rust::arguments::any_param::AnyParam\u003e"},{"line":520,"address":[2206019,2206118],"length":1,"stats":{"Line":2},"fn_name":null},{"line":523,"address":[2206240,2206417,2206444],"length":1,"stats":{"Line":1},"fn_name":"gt\u003ci32\u003e"},{"line":524,"address":[2206280,2206347],"length":1,"stats":{"Line":2},"fn_name":null},{"line":527,"address":[2206641,2206668,2206464],"length":1,"stats":{"Line":1},"fn_name":"ge\u003ci32\u003e"},{"line":528,"address":[2206504,2206571],"length":1,"stats":{"Line":2},"fn_name":null},{"line":531,"address":[2206892,2206688,2206865],"length":1,"stats":{"Line":1},"fn_name":"lt\u003ci32\u003e"},{"line":532,"address":[2206728,2206795],"length":1,"stats":{"Line":2},"fn_name":null},{"line":535,"address":[2207089,2207116,2206912],"length":1,"stats":{"Line":1},"fn_name":"le\u003ci32\u003e"},{"line":536,"address":[2207019,2206952],"length":1,"stats":{"Line":2},"fn_name":null},{"line":539,"address":[4053437,4053280,4053464],"length":1,"stats":{"Line":1},"fn_name":"not_"},{"line":540,"address":[4053369,4053302],"length":1,"stats":{"Line":2},"fn_name":null},{"line":543,"address":[4053645,4053488,4053672],"length":1,"stats":{"Line":0},"fn_name":"round"},{"line":544,"address":[4053577,4053510],"length":1,"stats":{"Line":0},"fn_name":null},{"line":547,"address":[4053696,4053853,4053880],"length":1,"stats":{"Line":0},"fn_name":"ceil"},{"line":548,"address":[4053785,4053718],"length":1,"stats":{"Line":0},"fn_name":null},{"line":551,"address":[4054061,4054088,4053904],"length":1,"stats":{"Line":0},"fn_name":"floor"},{"line":552,"address":[4053993,4053926],"length":1,"stats":{"Line":0},"fn_name":null},{"line":634,"address":[2207136,2207232],"length":1,"stats":{"Line":2},"fn_name":"bit_and\u003creql_rust::proto::Command\u003e"},{"line":635,"address":[2207259,2207157],"length":1,"stats":{"Line":2},"fn_name":null},{"line":715,"address":[2207408,2207312],"length":1,"stats":{"Line":2},"fn_name":"bit_or\u003creql_rust::proto::Command\u003e"},{"line":716,"address":[2207333,2207435],"length":1,"stats":{"Line":2},"fn_name":null},{"line":799,"address":[2207584,2207488],"length":1,"stats":{"Line":2},"fn_name":"bit_xor\u003creql_rust::proto::Command\u003e"},{"line":800,"address":[2207611,2207509],"length":1,"stats":{"Line":2},"fn_name":null},{"line":856,"address":[4054296,4054269,4054112],"length":1,"stats":{"Line":1},"fn_name":"bit_not"},{"line":857,"address":[4054134,4054201],"length":1,"stats":{"Line":2},"fn_name":null},{"line":923,"address":[2208119,2207664,2207888,2208092,2207841,2207868],"length":1,"stats":{"Line":2},"fn_name":"bit_sal\u003ci32\u003e"},{"line":924,"address":[2207771,2207704,2207923,2208022],"length":1,"stats":{"Line":4},"fn_name":null},{"line":985,"address":[2208348,2208368,2208144,2208599,2208321,2208572],"length":1,"stats":{"Line":2},"fn_name":"bit_sar\u003ci32\u003e"},{"line":986,"address":[2208251,2208184,2208403,2208502],"length":1,"stats":{"Line":4},"fn_name":null},{"line":1038,"address":[4054320,4054557,4054584],"length":1,"stats":{"Line":0},"fn_name":"in_timezone"},{"line":1039,"address":[4054377,4054489],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1075,"address":[4054608,4054765,4054792],"length":1,"stats":{"Line":0},"fn_name":"timezone"},{"line":1076,"address":[4054630,4054697],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1155,"address":[2208853,2208826,2208624],"length":1,"stats":{"Line":1},"fn_name":"during\u003creql_rust::arguments::Args\u003c(reql_rust::types::datetime::DateTime, reql_rust::types::datetime::DateTime)\u003e\u003e"},{"line":1156,"address":[2208659,2208758],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1221,"address":[4054973,4055000,4054816],"length":1,"stats":{"Line":0},"fn_name":"date"},{"line":1222,"address":[4054905,4054838],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1259,"address":[4055208,4055024,4055181],"length":1,"stats":{"Line":0},"fn_name":"time_of_day"},{"line":1260,"address":[4055046,4055113],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1295,"address":[4055389,4055232,4055416],"length":1,"stats":{"Line":0},"fn_name":"year"},{"line":1296,"address":[4055254,4055321],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1331,"address":[4055440,4055597,4055624],"length":1,"stats":{"Line":0},"fn_name":"month"},{"line":1332,"address":[4055529,4055462],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1367,"address":[4055648,4055805,4055832],"length":1,"stats":{"Line":0},"fn_name":"day"},{"line":1368,"address":[4055737,4055670],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1428,"address":[4055856,4056013,4056040],"length":1,"stats":{"Line":0},"fn_name":"day_of_week"},{"line":1429,"address":[4055878,4055945],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1465,"address":[4056064,4056221,4056248],"length":1,"stats":{"Line":0},"fn_name":"day_of_year"},{"line":1466,"address":[4056153,4056086],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1502,"address":[4056456,4056429,4056272],"length":1,"stats":{"Line":0},"fn_name":"hours"},{"line":1503,"address":[4056361,4056294],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1539,"address":[4056637,4056480,4056664],"length":1,"stats":{"Line":0},"fn_name":"minutes"},{"line":1540,"address":[4056569,4056502],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1576,"address":[4056845,4056872,4056688],"length":1,"stats":{"Line":0},"fn_name":"seconds"},{"line":1577,"address":[4056777,4056710],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1616,"address":[4057080,4056896,4057053],"length":1,"stats":{"Line":0},"fn_name":"to_iso8601"},{"line":1617,"address":[4056918,4056985],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1657,"address":[4057104,4057261,4057288],"length":1,"stats":{"Line":0},"fn_name":"to_epoch_time"},{"line":1658,"address":[4057193,4057126],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1662,"address":[2208864,2209068,2209095],"length":1,"stats":{"Line":0},"fn_name":"do_\u003creql_rust::cmd::func::Func\u003e"},{"line":1663,"address":[2208998,2208899],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1792,"address":[2209322,2209349,2209120],"length":1,"stats":{"Line":1},"fn_name":"branch\u003creql_rust::arguments::Args\u003c(reql_rust::proto::Command, reql_rust::proto::Command)\u003e\u003e"},{"line":1793,"address":[2209155,2209254],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1838,"address":[4057312,4057516,4057543],"length":1,"stats":{"Line":1},"fn_name":"for_each"},{"line":1839,"address":[4057446,4057347],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1987,"address":[2209559,2209586,2209360],"length":1,"stats":{"Line":1},"fn_name":"default\u003c\u0026str\u003e"},{"line":1988,"address":[2209491,2209424],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2061,"address":[2209600,2209799,2209826],"length":1,"stats":{"Line":1},"fn_name":"coerce_to\u003c\u0026str\u003e"},{"line":2062,"address":[2209664,2209731],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2107,"address":[4057725,4057752,4057568],"length":1,"stats":{"Line":1},"fn_name":"type_of"},{"line":2108,"address":[4057657,4057590],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2147,"address":[4057933,4057960,4057776],"length":1,"stats":{"Line":1},"fn_name":"info"},{"line":2148,"address":[4057865,4057798],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2183,"address":[4058168,4058141,4057984],"length":1,"stats":{"Line":1},"fn_name":"to_json"},{"line":2184,"address":[4058073,4058006],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2247,"address":[2210057,2209840,2210030],"length":1,"stats":{"Line":1},"fn_name":"distance\u003creql_rust::arguments::Args\u003c(reql_rust::cmd::point::Point, reql_rust::cmd::distance::DistanceOption)\u003e\u003e"},{"line":2248,"address":[2209960,2209862],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2295,"address":[4058192,4058376,4058349],"length":1,"stats":{"Line":1},"fn_name":"to_geojson"},{"line":2296,"address":[4058214,4058281],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2353,"address":[2210080,2210339,2210312],"length":1,"stats":{"Line":1},"fn_name":"get_intersecting\u003creql_rust::cmd::polygon::Polygon\u003e"},{"line":2358,"address":[2210242,2210144],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2415,"address":[2210352,2210581,2210554],"length":1,"stats":{"Line":1},"fn_name":"get_nearest\u003creql_rust::arguments::Args\u003c(reql_rust::cmd::point::Point, \u0026str)\u003e\u003e"},{"line":2416,"address":[2210484,2210374],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2526,"address":[2210782,2210592,2210809],"length":1,"stats":{"Line":1},"fn_name":"includes\u003creql_rust::cmd::point::Point\u003e"},{"line":2527,"address":[2210614,2210712],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2610,"address":[2210832,2211022,2211049],"length":1,"stats":{"Line":1},"fn_name":"intersects\u003creql_rust::cmd::point::Point\u003e"},{"line":2611,"address":[2210854,2210952],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2760,"address":[4058630,4058657,4058400],"length":1,"stats":{"Line":1},"fn_name":"grant"},{"line":2761,"address":[4058562,4058477],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2811,"address":[4058856,4058829,4058672],"length":1,"stats":{"Line":1},"fn_name":"config"},{"line":2812,"address":[4058761,4058694],"length":1,"stats":{"Line":2},"fn_name":null},{"line":2883,"address":[4058880,4059064,4059037],"length":1,"stats":{"Line":1},"fn_name":"rebalance"},{"line":2884,"address":[4058902,4058969],"length":1,"stats":{"Line":2},"fn_name":null},{"line":3022,"address":[4059088,4059353,4059326],"length":1,"stats":{"Line":1},"fn_name":"reconfigure"},{"line":3023,"address":[4059110,4059256],"length":1,"stats":{"Line":2},"fn_name":null},{"line":3069,"address":[4059533,4059560,4059376],"length":1,"stats":{"Line":1},"fn_name":"status"},{"line":3070,"address":[4059398,4059465],"length":1,"stats":{"Line":2},"fn_name":null},{"line":3156,"address":[2211072,2211258,2211231],"length":1,"stats":{"Line":1},"fn_name":"wait\u003c()\u003e"},{"line":3157,"address":[2211094,2211161],"length":1,"stats":{"Line":2},"fn_name":null},{"line":3300,"address":[2211280,2211309],"length":1,"stats":{"Line":8},"fn_name":"run\u003c\u0026reql_rust::connection::Session\u003e"},{"line":3301,"address":[2373392,2373701,2373456,2373818,2373633,2373982],"length":1,"stats":{"Line":15},"fn_name":null},{"line":3386,"address":[2211376],"length":1,"stats":{"Line":5},"fn_name":"make_query\u003c\u0026reql_rust::connection::Session\u003e"},{"line":3387,"address":[2211600,2211402],"length":1,"stats":{"Line":10},"fn_name":null},{"line":3397,"address":[4471692,4471719,4471296],"length":1,"stats":{"Line":3},"fn_name":"add_to_cmd"},{"line":3398,"address":[4471323],"length":1,"stats":{"Line":9},"fn_name":null},{"line":3399,"address":[4471690,4471361],"length":1,"stats":{"Line":16},"fn_name":null},{"line":3400,"address":[2374064,2374105],"length":1,"stats":{"Line":4},"fn_name":"{closure#0}"},{"line":3406,"address":[2703680],"length":1,"stats":{"Line":1},"fn_name":"from"},{"line":3407,"address":[2703802,2703702],"length":1,"stats":{"Line":2},"fn_name":null},{"line":3408,"address":[2703756],"length":1,"stats":{"Line":1},"fn_name":null},{"line":3410,"address":[2703809],"length":1,"stats":{"Line":0},"fn_name":null},{"line":3416,"address":[4471744],"length":1,"stats":{"Line":0},"fn_name":"bytes_to_string"},{"line":3417,"address":[4471771],"length":1,"stats":{"Line":0},"fn_name":null},{"line":3418,"address":[4471831],"length":1,"stats":{"Line":0},"fn_name":null},{"line":3420,"address":[4471841],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":163,"coverable":276},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","connection.rs"],"content":"use dashmap::DashMap;\nuse futures::channel::mpsc::{self, UnboundedReceiver, UnboundedSender};\nuse futures::lock::Mutex;\nuse futures::TryFutureExt;\nuse ql2::query::QueryType;\nuse ql2::response::ResponseType;\nuse serde_json::json;\nuse std::borrow::Cow;\nuse std::ops::Drop;\nuse std::sync::atomic::{AtomicBool, AtomicU64, Ordering};\nuse std::sync::Arc;\nuse tokio::time;\nuse tracing::trace;\n\nuse super::cmd::run::Response;\nuse super::cmd::StaticString;\nuse crate::cmd::TcpStreamConnection;\nuse crate::proto::{Payload, Query};\nuse crate::types::ServerInfoResponse;\nuse crate::{err, r, ReqlDriverError, Result};\n\ntype Sender = UnboundedSender\u003cResult\u003c(ResponseType, Response)\u003e\u003e;\ntype Receiver = UnboundedReceiver\u003cResult\u003c(ResponseType, Response)\u003e\u003e;\n\n#[derive(Debug)]\npub(crate) struct InnerSession {\n    pub(crate) db: Mutex\u003cCow\u003c'static, str\u003e\u003e,\n    pub(crate) stream: Mutex\u003cTcpStreamConnection\u003e,\n    pub(crate) channels: DashMap\u003cu64, Sender\u003e,\n    pub(crate) token: AtomicU64,\n    pub(crate) broken: AtomicBool,\n    pub(crate) change_feed: AtomicBool,\n}\n\nimpl InnerSession {\n    pub(crate) fn token(\u0026self) -\u003e u64 {\n        let token = self\n            .token\n            .fetch_update(Ordering::SeqCst, Ordering::SeqCst, |x| Some(x + 1))\n            .unwrap();\n        if token == u64::MAX {\n            self.mark_broken();\n        }\n        token\n    }\n\n    pub(crate) fn mark_broken(\u0026self) {\n        self.broken.store(true, Ordering::SeqCst);\n    }\n\n    pub(crate) fn broken(\u0026self) -\u003e Result\u003c()\u003e {\n        if self.broken.load(Ordering::SeqCst) {\n            return Err(err::ReqlDriverError::ConnectionBroken.into());\n        }\n        Ok(())\n    }\n\n    pub(crate) fn mark_change_feed(\u0026self) {\n        self.change_feed.store(true, Ordering::SeqCst);\n    }\n\n    pub(crate) fn unmark_change_feed(\u0026self) {\n        self.change_feed.store(false, Ordering::SeqCst);\n    }\n\n    pub(crate) fn is_change_feed(\u0026self) -\u003e bool {\n        self.change_feed.load(Ordering::SeqCst)\n    }\n\n    pub(crate) fn change_feed(\u0026self) -\u003e Result\u003c()\u003e {\n        if self.change_feed.load(Ordering::SeqCst) {\n            return Err(err::ReqlDriverError::ConnectionLocked.into());\n        }\n        Ok(())\n    }\n}\n\n/// The connection object returned by `r.connection()`\n#[derive(Debug, Clone)]\npub struct Session {\n    pub(crate) inner: Arc\u003cInnerSession\u003e,\n}\n\nimpl Session {\n    #[doc(hidden)]\n    pub fn connection(\u0026self) -\u003e Result\u003cConnection\u003e {\n        self.inner.broken()?;\n        self.inner.change_feed()?;\n        let token = self.inner.token();\n        let (tx, rx) = mpsc::unbounded();\n        self.inner.channels.insert(token, tx);\n        Ok(Connection::new(self.clone(), rx, token))\n    }\n\n    /// Close and reopen a connection.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// conn.reconnect(noreply_wait, timeout)\n    /// ```\n    ///\n    /// Where\n    /// - noreply_wait: bool\n    /// - timeout: Option\u003c[Duration](std::time::Duration)\u003e\n    ///\n    /// # Description\n    ///\n    /// Closing a connection normally waits until all outstanding requests have\n    /// finished and then frees any open resources associated with the connection.\n    /// By passing `false` to the `noreply_wait` optional argument,\n    /// the connection will be closed immediately,\n    /// possibly aborting any outstanding noreply writes.\n    ///\n    /// A noreply query is executed by passing the `noreply`\n    /// option to the [run](crate::Command::run) command,\n    /// indicating that `run()` should not wait for the query to complete before returning.\n    /// You may also explicitly wait for a noreply query to complete by using\n    /// the [noreply_wait](Self::noreply_wait) command.\n    ///\n    /// ## Examples\n    ///\n    /// Cancel outstanding requests/queries that are no longer needed.\n    ///\n    /// ```\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let mut conn = r.connection().connect().await?;\n    ///     conn.reconnect(true, None).await?;\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [connection](crate::r::connection)\n    /// - [use_](Self::use_)\n    /// - [close](Self::close)\n    pub async fn reconnect(\n        \u0026self,\n        noreply_wait: bool,\n        timeout: Option\u003cstd::time::Duration\u003e,\n    ) -\u003e Result\u003c()\u003e {\n        let future = self\n            .close(noreply_wait)\n            .and_then(|_| async { self.connection() });\n\n        if let Some(timeout) = timeout {\n            time::timeout(timeout, future).await.unwrap()?;\n        } else {\n            future.await?;\n        }\n\n        Ok(())\n    }\n\n    /// Change the default database on this connection.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// conn.use_(db_name)\n    /// ```\n    ///\n    /// Where\n    /// - db_name: \u0026'static str\n    ///\n    /// ## Examples\n    ///\n    /// Change the default database so that we don’t need\n    /// to specify the database when referencing a table.\n    ///\n    /// ```\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let mut conn = r.connection().connect().await?;\n    ///     conn.use_(\"simbad\").await?;\n    ///     \n    ///     r.table(\"simbad\").run(\u0026conn).await?;\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [connection](crate::r::connection)\n    /// - [close](Self::close)\n    /// - [reconnect](Self::reconnect)\n    pub async fn use_(\u0026mut self, db_name: \u0026'static str) -\u003e Result\u003c()\u003e {\n        *self.inner.db.lock().await = db_name.static_string();\n\n        Ok(())\n    }\n\n    /// `noreply_wait` ensures that previous queries with\n    /// the `noreply` flag have been processed by the server.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// result.close()\n    /// ```\n    ///\n    /// ## Note\n    ///\n    /// Note that this guarantee only applies to queries run on the given connection.\n    ///\n    /// ## Examples\n    ///\n    /// We have previously run queries with the `noreply` argument set to `true`.\n    /// Now wait until the server has processed them.\n    ///\n    /// ```\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     \n    ///     conn.noreply_wait().await?;\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [run](crate::Command::run)\n    /// - [sync](crate::Command::sync)\n    pub async fn noreply_wait(\u0026self) -\u003e Result\u003c()\u003e {\n        let mut conn = self.connection()?;\n        let payload = Payload(QueryType::NoreplyWait, None, Default::default());\n        trace!(\n            \"waiting for noreply operations to finish; token: {}\",\n            conn.token\n        );\n        let (typ, _) = conn.request(\u0026payload, false).await?;\n        trace!(\n            \"session.noreply_wait() run; token: {}, response type: {:?}\",\n            conn.token,\n            typ,\n        );\n        Ok(())\n    }\n\n    /// Return information about the server being used by a connection.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// result.server() -\u003e response\n    /// ```\n    ///\n    /// Where:\n    /// - server: [ServerInfoResponse](crate::types::ServerInfoResponse)\n    ///\n    /// ## Examples\n    ///\n    /// Return server information.\n    ///\n    /// ```\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::types::ServerInfoResponse;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: ServerInfoResponse = conn.server().await?;\n    ///\n    ///     assert_eq!(response.id.to_string(), \"404bef53-4b2c-433f-9184-bc3f7bda4a15\");\n    ///     assert_eq!(response.name, Some(\"amadeus\".to_string()));\n    ///     assert_eq!(response.proxy, false);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    pub async fn server(\u0026self) -\u003e Result\u003cServerInfoResponse\u003e {\n        let mut conn = self.connection()?;\n        let payload = Payload(QueryType::ServerInfo, None, Default::default());\n        trace!(\"retrieving server information; token: {}\", conn.token);\n        let (typ, resp) = conn.request(\u0026payload, false).await?;\n        trace!(\n            \"session.server() run; token: {}, response type: {:?}\",\n            conn.token,\n            typ,\n        );\n        let mut vec = serde_json::from_value::\u003cVec\u003cServerInfoResponse\u003e\u003e(resp.r)?;\n        let info = vec\n            .pop()\n            .ok_or_else(|| ReqlDriverError::Other(\"server info is empty\".into()))?;\n        Ok(info)\n    }\n\n    /// Close a cursor.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// result.close()\n    /// ```\n    ///\n    /// # Description\n    ///\n    /// Closing a result cancels the corresponding query and\n    /// frees the memory associated with the open request.\n    ///\n    /// ## Examples\n    ///\n    /// Close a result.\n    ///\n    /// ```\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     \n    ///     conn.close(false).await?;\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    pub async fn close(\u0026self, noreply_wait: bool) -\u003e Result\u003c()\u003e {\n        self.connection()?.close(noreply_wait).await\n    }\n\n    #[doc(hidden)]\n    pub fn is_broken(\u0026self) -\u003e bool {\n        self.inner.broken.load(Ordering::SeqCst)\n    }\n}\n\n#[derive(Debug, Clone)]\npub struct Connection {\n    pub(crate) session: Session,\n    pub(crate) rx: Arc\u003cMutex\u003cReceiver\u003e\u003e,\n    pub(crate) token: u64,\n    pub(crate) closed: Arc\u003cAtomicBool\u003e,\n}\n\nimpl Connection {\n    fn new(session: Session, rx: Receiver, token: u64) -\u003e Connection {\n        Connection {\n            session,\n            token,\n            rx: Arc::new(Mutex::new(rx)),\n            closed: Arc::new(AtomicBool::new(false)),\n        }\n    }\n\n    pub async fn close(\u0026mut self, noreply_wait: bool) -\u003e Result\u003c()\u003e {\n        if !self.session.inner.is_change_feed() {\n            trace!(\n                \"ignoring conn.close() called on a normal connection; token: {}\",\n                self.token\n            );\n            return Ok(());\n        }\n\n        self.set_closed(true);\n\n        let arg = if noreply_wait {\n            Some(r.expr(json!({ \"noreply\": false })))\n        } else {\n            None\n        };\n\n        let payload = Payload(QueryType::Stop, arg.as_ref().map(Query), Default::default());\n        trace!(\"closing a changefeed; token: {}\", self.token);\n        let (typ, _) = self.request(\u0026payload, false).await?;\n        self.session.inner.unmark_change_feed();\n        trace!(\n            \"conn.close() run; token: {}, response type: {:?}\",\n            self.token,\n            typ,\n        );\n        Ok(())\n    }\n\n    pub(crate) fn closed(\u0026self) -\u003e bool {\n        self.closed.load(Ordering::SeqCst)\n    }\n\n    pub(crate) fn set_closed(\u0026self, closed: bool) {\n        self.closed.store(closed, Ordering::SeqCst);\n    }\n}\n\nimpl Drop for Connection {\n    fn drop(\u0026mut self) {\n        self.session.inner.channels.remove(\u0026self.token);\n        if self.session.inner.is_change_feed() {\n            self.session.inner.unmark_change_feed();\n        }\n    }\n}\n","traces":[{"line":36,"address":[4673568],"length":1,"stats":{"Line":4},"fn_name":"token"},{"line":37,"address":[4673599,4673582],"length":1,"stats":{"Line":8},"fn_name":null},{"line":39,"address":[4482624,4482638],"length":1,"stats":{"Line":24},"fn_name":"{closure#0}"},{"line":41,"address":[4673661],"length":1,"stats":{"Line":10},"fn_name":null},{"line":42,"address":[4673681],"length":1,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[4673696],"length":1,"stats":{"Line":0},"fn_name":"mark_broken"},{"line":48,"address":[4673705],"length":1,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[4673744],"length":1,"stats":{"Line":4},"fn_name":"broken"},{"line":52,"address":[4673774],"length":1,"stats":{"Line":4},"fn_name":null},{"line":53,"address":[4673824],"length":1,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[4673815],"length":1,"stats":{"Line":4},"fn_name":null},{"line":58,"address":[4673888],"length":1,"stats":{"Line":0},"fn_name":"mark_change_feed"},{"line":59,"address":[4673897],"length":1,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[4673936],"length":1,"stats":{"Line":0},"fn_name":"unmark_change_feed"},{"line":63,"address":[4673945],"length":1,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[4673984],"length":1,"stats":{"Line":4},"fn_name":"is_change_feed"},{"line":67,"address":[4673993],"length":1,"stats":{"Line":4},"fn_name":null},{"line":70,"address":[4674048],"length":1,"stats":{"Line":4},"fn_name":"change_feed"},{"line":71,"address":[4674078],"length":1,"stats":{"Line":4},"fn_name":null},{"line":72,"address":[4674128],"length":1,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[4674119],"length":1,"stats":{"Line":4},"fn_name":null},{"line":86,"address":[4674980,4674192],"length":1,"stats":{"Line":4},"fn_name":"connection"},{"line":87,"address":[4674332,4674230],"length":1,"stats":{"Line":4},"fn_name":null},{"line":88,"address":[4674426,4674503,4674320],"length":1,"stats":{"Line":8},"fn_name":null},{"line":89,"address":[4674491,4674590],"length":1,"stats":{"Line":8},"fn_name":null},{"line":90,"address":[4674608],"length":1,"stats":{"Line":10},"fn_name":null},{"line":91,"address":[4674670,4674733],"length":1,"stats":{"Line":20},"fn_name":null},{"line":92,"address":[4674819],"length":1,"stats":{"Line":10},"fn_name":null},{"line":95,"address":[4675024],"length":1,"stats":{"Line":0},"fn_name":"reconnect"},{"line":113,"address":[4675152,4675179],"length":1,"stats":{"Line":0},"fn_name":"use_"},{"line":117,"address":[4675254,4675232],"length":1,"stats":{"Line":0},"fn_name":"noreply_wait"},{"line":133,"address":[4675296,4675318],"length":1,"stats":{"Line":0},"fn_name":"server"},{"line":150,"address":[4675360,4675396],"length":1,"stats":{"Line":0},"fn_name":"close"},{"line":155,"address":[4675440],"length":1,"stats":{"Line":0},"fn_name":"is_broken"},{"line":156,"address":[4675449],"length":1,"stats":{"Line":0},"fn_name":null},{"line":169,"address":[4675789,4675504],"length":1,"stats":{"Line":10},"fn_name":"new"},{"line":173,"address":[4675573,4675622],"length":1,"stats":{"Line":20},"fn_name":null},{"line":174,"address":[4675646,4675695],"length":1,"stats":{"Line":20},"fn_name":null},{"line":178,"address":[4675861,4675824],"length":1,"stats":{"Line":0},"fn_name":"close"},{"line":207,"address":[4675920],"length":1,"stats":{"Line":1},"fn_name":"closed"},{"line":208,"address":[4675929],"length":1,"stats":{"Line":1},"fn_name":null},{"line":211,"address":[4675984],"length":1,"stats":{"Line":0},"fn_name":"set_closed"},{"line":212,"address":[4676006],"length":1,"stats":{"Line":0},"fn_name":null},{"line":217,"address":[6912832],"length":1,"stats":{"Line":4},"fn_name":"drop"},{"line":218,"address":[6912846],"length":1,"stats":{"Line":4},"fn_name":null},{"line":219,"address":[6912902],"length":1,"stats":{"Line":4},"fn_name":null},{"line":220,"address":[6912946],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":27,"coverable":47},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","constants.rs"],"content":"pub(crate) const BUFFER_SIZE: usize = 1024;\npub(crate) const NULL_BYTE: u8 = b'\\0';\npub(crate) const PROTOCOL_VERSION: usize = 0;\npub(crate) const DEFAULT_AUTHENTICATION_METHOD: \u0026str = \"SCRAM-SHA-256\";\npub(crate) const DATA_SIZE: usize = 4;\npub(crate) const TOKEN_SIZE: usize = 8;\npub(crate) const HEADER_SIZE: usize = DATA_SIZE + TOKEN_SIZE;\npub(crate) const NANOS_PER_SEC: i128 = 1_000_000_000;\npub(crate) const NANOS_PER_MSEC: i128 = 1_000_000;\npub(crate) const TIMEZONE_FORMAT: \u0026str = \"[offset_hour sign:mandatory]:[offset_minute]\";\npub(crate) const MINUTE: f64 = 60.;\npub(crate) const HOUR: f64 = 60. * MINUTE;\n\npub const DEFAULT_RETHINKDB_HOSTNAME: \u0026str = \"localhost\";\npub const DEFAULT_RETHINKDB_DBNAME: \u0026str = \"test\";\npub const DEFAULT_RETHINKDB_PORT: u16 = 28015;\npub const DEFAULT_RETHINKDB_USER: \u0026str = \"admin\";\npub const DEFAULT_RETHINKDB_PASSWORD: \u0026str = \"\";\npub const MAX_LONGITUDE_VALUE: f64 = 180.;\npub const MAX_LATITUDE_VALUE: f64 = 90.;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","err.rs"],"content":"use std::sync::Arc;\nuse std::{error, fmt, io};\n\n/// The most generic error message in ReQL\n#[derive(Debug, Clone)]\npub enum ReqlError {\n    Compile(String),\n    Runtime(ReqlRuntimeError),\n    Driver(ReqlDriverError),\n}\n\nimpl error::Error for ReqlError {}\n\nimpl fmt::Display for ReqlError {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        match self {\n            Self::Compile(msg) =\u003e write!(f, \"compile error; {}\", msg),\n            Self::Runtime(msg) =\u003e write!(f, \"runtime error; {}\", msg),\n            Self::Driver(msg) =\u003e write!(f, \"client error; {}\", msg),\n        }\n    }\n}\n\n/// The parent class of all runtime errors\n///\n/// All errors on the server unrelated to compilation. Programs may use this to catch any runtime\n/// error, but the server will always return a more specific error class.\n#[derive(Debug, Clone)]\npub enum ReqlRuntimeError {\n    /// The query contains a logical impossibility, such as adding a number to a string.\n    QueryLogic(String),\n    NonExistence(String),\n    ResourceLimit(String),\n    User(String),\n    Internal(String),\n    Availability(ReqlAvailabilityError),\n    Permission(String),\n}\n\nimpl From\u003cReqlRuntimeError\u003e for ReqlError {\n    fn from(err: ReqlRuntimeError) -\u003e ReqlError {\n        ReqlError::Runtime(err)\n    }\n}\n\nimpl fmt::Display for ReqlRuntimeError {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        match self {\n            Self::QueryLogic(msg) =\u003e write!(f, \"query logic; {}\", msg),\n            Self::NonExistence(msg) =\u003e write!(f, \"non-existence error; {}\", msg),\n            Self::ResourceLimit(msg) =\u003e write!(f, \"resource limit error; {}\", msg),\n            Self::User(msg) =\u003e write!(f, \"user error; {}\", msg),\n            Self::Internal(msg) =\u003e write!(f, \"internal error; {}\", msg),\n            Self::Availability(msg) =\u003e write!(f, \"availability error; {}\", msg),\n            Self::Permission(msg) =\u003e write!(f, \"permission error; {}\", msg),\n        }\n    }\n}\n\n/// A server in the cluster is unavailable\n///\n/// The parent class of `OpFailedError` and `OpIndeterminateError`. Programs may use this\n/// to catch any availability error, but the server will always return one of this class’s\n/// children.\n#[derive(Debug, Clone)]\npub enum ReqlAvailabilityError {\n    OpFailed(String),\n    OpIndeterminate(String),\n}\n\nimpl From\u003cReqlAvailabilityError\u003e for ReqlError {\n    fn from(err: ReqlAvailabilityError) -\u003e ReqlError {\n        ReqlRuntimeError::Availability(err).into()\n    }\n}\n\nimpl fmt::Display for ReqlAvailabilityError {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        match self {\n            Self::OpFailed(msg) =\u003e write!(f, \"operation failed; {}\", msg),\n            Self::OpIndeterminate(msg) =\u003e write!(f, \"operation indeterminate; {}\", msg),\n        }\n    }\n}\n\n/// An error has occurred within the driver\n///\n/// This may be a driver bug, or it may be an unfulfillable command, such as an unserializable\n/// query.\n#[derive(Debug, Clone)]\n#[non_exhaustive]\npub enum ReqlDriverError {\n    Auth(String),\n    ConnectionBroken,\n    ConnectionLocked,\n    Io(io::ErrorKind, String),\n    Json(Arc\u003cserde_json::Error\u003e),\n    Other(String),\n    Time(String),\n    Tls(String),\n    Regex(String),\n}\n\nimpl From\u003cReqlDriverError\u003e for ReqlError {\n    fn from(err: ReqlDriverError) -\u003e ReqlError {\n        ReqlError::Driver(err)\n    }\n}\n\nimpl fmt::Display for ReqlDriverError {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        match self {\n            Self::Auth(msg) =\u003e write!(f, \"auth error; {}\", msg),\n            Self::ConnectionBroken =\u003e write!(f, \"connection broken\"),\n            Self::ConnectionLocked =\u003e write!(\n                f,\n                \"another query is running a changefeed on this connection\"\n            ),\n            Self::Io(_, error) =\u003e write!(f, \"{}\", error),\n            Self::Json(error) =\u003e write!(f, \"{}\", error),\n            Self::Other(msg) =\u003e write!(f, \"{}\", msg),\n            Self::Time(error) =\u003e write!(f, \"{}\", error),\n            Self::Tls(error) =\u003e write!(f, \"{}\", error),\n            Self::Regex(error) =\u003e write!(f, \"{}\", error),\n        }\n    }\n}\n\nimpl From\u003cio::Error\u003e for ReqlError {\n    fn from(err: io::Error) -\u003e ReqlError {\n        ReqlDriverError::Io(err.kind(), err.to_string()).into()\n    }\n}\n\nimpl From\u003cserde_json::Error\u003e for ReqlError {\n    fn from(err: serde_json::Error) -\u003e ReqlError {\n        ReqlDriverError::Json(Arc::new(err)).into()\n    }\n}\n\nimpl From\u003casync_native_tls::Error\u003e for ReqlError {\n    fn from(err: async_native_tls::Error) -\u003e Self {\n        ReqlDriverError::Tls(err.to_string()).into()\n    }\n}\n\nimpl From\u003ctime::error::ComponentRange\u003e for ReqlError {\n    fn from(err: time::error::ComponentRange) -\u003e Self {\n        ReqlDriverError::Time(err.to_string()).into()\n    }\n}\n\nimpl From\u003ctime::error::Parse\u003e for ReqlError {\n    fn from(err: time::error::Parse) -\u003e Self {\n        ReqlDriverError::Time(err.to_string()).into()\n    }\n}\n\nimpl From\u003ctime::error::InvalidFormatDescription\u003e for ReqlError {\n    fn from(err: time::error::InvalidFormatDescription) -\u003e Self {\n        ReqlDriverError::Time(err.to_string()).into()\n    }\n}\n\nimpl From\u003ctime::error::Format\u003e for ReqlError {\n    fn from(err: time::error::Format) -\u003e Self {\n        ReqlDriverError::Time(err.to_string()).into()\n    }\n}\n\nimpl From\u003cregex::Error\u003e for ReqlError {\n    fn from(err: regex::Error) -\u003e Self {\n        ReqlDriverError::Regex(err.to_string()).into()\n    }\n}\n","traces":[{"line":15,"address":[1684560],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":16,"address":[1684593],"length":1,"stats":{"Line":0},"fn_name":null},{"line":17,"address":[1684630,1684953],"length":1,"stats":{"Line":0},"fn_name":null},{"line":18,"address":[1684863,1684670],"length":1,"stats":{"Line":0},"fn_name":null},{"line":19,"address":[1684715],"length":1,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[1685040],"length":1,"stats":{"Line":1},"fn_name":"from"},{"line":42,"address":[1685053],"length":1,"stats":{"Line":1},"fn_name":null},{"line":47,"address":[1685120],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":48,"address":[1685153],"length":1,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[1686102,1685195],"length":1,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[1686006,1685241],"length":1,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[1685910,1685287],"length":1,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[1685333,1685814],"length":1,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[1685718,1685379],"length":1,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[1685425,1685625],"length":1,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[1685470],"length":1,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[1686192],"length":1,"stats":{"Line":0},"fn_name":"from"},{"line":73,"address":[1686204],"length":1,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[1686320],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":79,"address":[1686353],"length":1,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[1686561,1686372],"length":1,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[1686412],"length":1,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[1686640],"length":1,"stats":{"Line":0},"fn_name":"from"},{"line":105,"address":[1686647],"length":1,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[1686736],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":111,"address":[1686769],"length":1,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[1686805,1687722],"length":1,"stats":{"Line":0},"fn_name":null},{"line":113,"address":[1686846,1687684],"length":1,"stats":{"Line":0},"fn_name":null},{"line":114,"address":[1686888,1687651],"length":1,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[1687560,1686935],"length":1,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[1687464,1686981],"length":1,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[1687368,1687026],"length":1,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[1687275,1687072],"length":1,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[1687118],"length":1,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[1687953,1687808],"length":1,"stats":{"Line":0},"fn_name":"from"},{"line":129,"address":[1687884,1687831],"length":1,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[1688000],"length":1,"stats":{"Line":0},"fn_name":"from"},{"line":135,"address":[1688030],"length":1,"stats":{"Line":0},"fn_name":null},{"line":140,"address":[1688080,1688198],"length":1,"stats":{"Line":0},"fn_name":"from"},{"line":141,"address":[1688148,1688104],"length":1,"stats":{"Line":0},"fn_name":null},{"line":146,"address":[1688240],"length":1,"stats":{"Line":0},"fn_name":"from"},{"line":147,"address":[1688253],"length":1,"stats":{"Line":0},"fn_name":null},{"line":152,"address":[1688336],"length":1,"stats":{"Line":0},"fn_name":"from"},{"line":153,"address":[1688349],"length":1,"stats":{"Line":0},"fn_name":null},{"line":158,"address":[1688550,1688432],"length":1,"stats":{"Line":0},"fn_name":"from"},{"line":159,"address":[1688500,1688456],"length":1,"stats":{"Line":0},"fn_name":null},{"line":164,"address":[1688592,1688710],"length":1,"stats":{"Line":0},"fn_name":"from"},{"line":165,"address":[1688616,1688660],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":2,"coverable":48},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","lib.rs"],"content":"use std::collections::HashMap;\n\nuse prelude::Func;\nuse serde::Serialize;\n\nuse arguments::Permission;\npub use connection::*;\npub use err::*;\npub use proto::Command;\nuse types::{Binary, DateTime, GeoJson};\n\npub type Result\u003cT\u003e = std::result::Result\u003cT, ReqlError\u003e;\n\nmod constants;\nmod err;\nmod proto;\n#[cfg(test)]\nmod spec;\n\npub mod arguments;\npub mod cmd;\npub mod connection;\npub mod prelude;\npub mod types;\n\n#[macro_export]\nmacro_rules! args {\n    ( $($a:expr),* ) =\u003e {{ $crate::arguments::Args(($($a),*)) }};\n}\n\n#[allow(non_camel_case_types)]\npub struct r;\n\nimpl r {\n    /// Create a new connection to the database server.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// db.db_drop(db_name) → response\n    /// ```\n    ///\n    /// Where:\n    /// - db_name: \u0026str | String | Cow\u003c'static, str\u003e\n    /// - response: [DbResponse](crate::types::DbResponse)\n    ///\n    /// # Description\n    ///\n    /// If the connection cannot be established, a `ReqlDriverError` exception will be thrown.\n    ///\n    /// ## Examples\n    ///\n    /// Open a connection using the default host and port, specifying the default database.\n    ///\n    /// ```\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::types::DbResponse;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().dbname(\"jam\").connect().await?;\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Open a new connection to the database.\n    ///\n    /// ```\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::types::DbResponse;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection()\n    ///         .dbname(\"jam\")\n    ///         .host(\"localhost\")\n    ///         .port(28015)\n    ///         .connect()\n    ///         .await?;\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Open a new connection to the database,\n    /// specifying a user/password combination for authentication.\n    ///\n    /// ```\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::types::DbResponse;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection()\n    ///         .dbname(\"jam\")\n    ///         .host(\"localhost\")\n    ///         .port(28015)\n    ///         .user(\"jam_user\", \"jam_password\")\n    ///         .connect()\n    ///         .await?;\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [use_](crate::connection::Session::use_)\n    /// - [close](crate::connection::Session::close)\n    pub fn connection(self) -\u003e cmd::connect::ConnectionCommand {\n        cmd::connect::ConnectionCommand::default()\n    }\n\n    /// Create a database.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// db.db_drop(db_name) → response\n    /// ```\n    ///\n    /// Where:\n    /// - db_name: \u0026str | String | Cow\u003c'static, str\u003e\n    /// - response: [DbResponse](crate::types::DbResponse)\n    ///\n    /// # Description\n    ///\n    /// A RethinkDB database is a collection of tables, similar to relational databases.\n    ///\n    /// If a database with the same name already exists, the command throws `ReqlRuntimeError`.\n    ///\n    /// ## Note\n    ///\n    /// Only alphanumeric characters, hyphens and underscores are valid for the database name.\n    ///\n    /// ## Examples\n    ///\n    /// Create a database named ‘simbad’.\n    ///\n    /// ```\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::types::DbResponse;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: DbResponse = r.db_create(\"simbad\")\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert_eq!(response.dbs_created, Some(1));\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [db_drop](Self::db_drop)\n    /// - [db_list](Self::db_list)\n    /// - [table_create](Self::table_create)\n    pub fn db_create(self, db_name: impl Into\u003cString\u003e) -\u003e Command {\n        cmd::db_create::new(db_name)\n    }\n\n    /// Drop a database.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// db.db_drop(db_name) → response\n    /// ```\n    ///\n    /// Where:\n    /// - db_name: \u0026str | String | Cow\u003c'static, str\u003e\n    /// - response: [DbResponse](crate::types::DbResponse)\n    ///\n    /// # Description\n    ///\n    /// The database, all its tables, and corresponding data will be deleted.\n    ///\n    /// If the given database does not exist, the command throws `ReqlRuntimeError`.\n    ///\n    /// ## Examples\n    ///\n    /// Drop a database named ‘simbad’.\n    ///\n    /// ```\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::types::DbResponse;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: DbResponse = r.db_drop(\"simbad\")\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert_eq!(response.dbs_dropped, Some(1));\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [db_create](Self::db_create)\n    /// - [db_list](Self::db_list)\n    /// - [table_create](Self::table_create)\n    pub fn db_drop(self, db_name: impl Into\u003cString\u003e) -\u003e Command {\n        cmd::db_drop::new(db_name)\n    }\n\n    /// List all database names in the system.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// db.db_list() → response\n    /// ```\n    ///\n    /// Where:\n    /// - response: Vec\u003cString\u003e\n    ///\n    /// ## Examples\n    ///\n    /// List all databases.\n    ///\n    /// ```\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: Vec\u003cString\u003e = r.db_list().run(\u0026conn).await?.unwrap().parse()?;\n    ///\n    ///     assert!(response.len() \u003e 0);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [db_create](Self::db_create)\n    /// - [db_drop](Self::db_drop)\n    pub fn db_list(self) -\u003e Command {\n        cmd::db_list::new()\n    }\n\n    /// Reference a database.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// r.db(db_name) → db\n    /// ```\n    ///\n    /// Where:\n    /// - db_name: impl Into\u003cString\u003e\n    ///\n    /// # Description\n    ///\n    /// The `db` command is optional. If it is not present in a query,\n    /// the query will run against the database specified in the `db`\n    /// argument given to [run](crate::Command::run) if one was specified.\n    /// Otherwise, the query will run against the default database for the connection,\n    /// specified in the `db` argument to [connection](Self::connection).\n    ///\n    /// ## Examples\n    ///\n    /// Explicitly specify a database for a query.\n    ///\n    /// ```\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.db(\"heroes\").table(\"simbad\").run(\u0026conn).await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [table](crate::Command::table)\n    /// - [db_list](Self::db_list)\n    pub fn db(self, db_name: impl Into\u003cString\u003e) -\u003e Command {\n        cmd::db::new(db_name)\n    }\n\n    /// Create a table.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// db.table_create(table_name) → response\n    /// db.table_create(args!(table_name, options)) → response\n    /// ```\n    ///\n    /// Where:\n    /// - table_name: \u0026str | String | Cow\u003c'static, str\u003e\n    /// - options: [TableCreateOption](crate::cmd::table_create::TableCreateOption)\n    /// - response: [DbResponse](crate::types::DbResponse)\n    ///\n    /// # Description\n    ///\n    /// A RethinkDB table is a collection of JSON documents.\n    ///\n    /// If a table with the same name already exists,\n    /// the command throws `ReqlOpFailedError`.\n    ///\n    /// ```text\n    /// Note: Only alphanumeric characters and underscores are valid for the table name.\n    ///\n    /// Invoking table_create without specifying a database using db creates a table in\n    /// the database specified in connect, or test if no database was specified.\n    /// ```\n    ///\n    /// The [data type](https://rethinkdb.com/docs/data-types/) of a primary key is usually a string\n    /// (like a UUID) or a number, but it can also be a time, binary object, boolean or an array.\n    /// Data types can be mixed in the primary key field, but all values must be unique. Using an array\n    /// as a primary key causes the primary key to behave like a compound index; read the documentation on\n    /// [compound secondary indexes](https://rethinkdb.com/docs/secondary-indexes/python/#compound-indexes)\n    /// for more information, as it applies to primary keys as well.\n    /// (Note that the primary index still only covers a single field,\n    /// while compound secondary indexes can cover multiple fields in a single index.)\n    /// Primary keys cannot be objects.\n    ///\n    /// Tables will be available for writing when the command returns.\n    ///\n    /// ## Examples\n    ///\n    /// Create a table named ‘simbad’ with the default settings.\n    ///\n    /// ```\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::types::DbResponse;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: DbResponse = r.db(\"test\")\n    ///         .table_create(\"simbad\")\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response.tables_created \u003e Some(0));\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Create a table named ‘simbad’ using the field ‘name’ as primary key.\n    ///\n    /// ```\n    /// use reql_rust::cmd::table_create::TableCreateOption;\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::types::DbResponse;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let table_create_option = TableCreateOption::default().primary_key(\"name\");\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: DbResponse = r.db(\"test\")\n    ///         .table_create(args!(\"simbad\", table_create_option))\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response.tables_created \u003e Some(0));\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Create a table set up for two shards and three replicas per shard.\n    /// This requires three available servers.\n    ///\n    /// ```\n    /// use reql_rust::arguments::Replicas;\n    /// use reql_rust::cmd::table_create::TableCreateOption;\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::types::DbResponse;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let table_create_option = TableCreateOption::default()\n    ///         .shards(2)\n    ///         .replicas(Replicas::Int(3));\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: DbResponse = r.db(\"test\")\n    ///         .table_create(args!(\"simbad\", table_create_option))\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response.tables_created \u003e Some(0));\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// Read [Sharding and replication](https://rethinkdb.com/docs/sharding-and-replication/)\n    /// for a complete discussion of the subject, including advanced topics.\n    ///\n    /// # Related commands\n    /// - [table_drop](Self::table_drop)\n    /// - [table_list](Self::table_list)\n    pub fn table_create(self, args: impl cmd::table_create::TableCreateArg) -\u003e Command {\n        cmd::table_create::new(args)\n    }\n\n    /// Drop a table.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// db.table_drop(table_name) → response\n    /// ```\n    ///\n    /// Where:\n    /// - table_name: \u0026str | String | Cow\u003c'static, str\u003e\n    /// - response: [DbResponse](crate::types::DbResponse)\n    ///\n    /// # Description\n    ///\n    /// The table and all its data will be deleted.\n    ///\n    /// If the given table does not exist in the database,\n    /// the command throws `ReqlRuntimeError`.\n    ///\n    /// ## Examples\n    ///\n    /// Drop a table named ‘simbad’.\n    ///\n    /// ```\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::types::DbResponse;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: DbResponse = r.db(\"test\")\n    ///         .table_drop(\"simbad\")\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response.tables_dropped \u003e Some(0));\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [table_create](Self::table_create)\n    /// - [table_list](Self::table_list)\n    pub fn table_drop(self, table_name: \u0026str) -\u003e Command {\n        cmd::table_drop::new(table_name)\n    }\n\n    /// List all table names in a database.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// db.table_list() → response\n    /// ```\n    ///\n    /// Where:\n    /// - response: Vec\u003cString\u003e\n    ///\n    /// ## Examples\n    ///\n    /// List all tables of the ‘test’ database.\n    ///\n    /// ```\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: Vec\u003cString\u003e = r.db(\"test\")\n    ///         .table_list()\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response.len() \u003e 0);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [table_create](Self::table_create)\n    /// - [table_drop](Self::table_drop)\n    pub fn table_list(self) -\u003e Command {\n        cmd::table_list::new()\n    }\n\n    /// Return all documents in a table.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// db.table(name) → table\n    /// db.table(args!(name, options)) → table\n    /// r.table(name) → table\n    /// r.table(args!(name, options)) → table\n    /// ```\n    ///\n    /// Where:\n    /// - name: impl Into\u003cString\u003e | [Command](crate::Command)\n    /// - options: [TableOption](crate::cmd::table::TableOption)\n    ///\n    /// # Description\n    ///\n    /// Other commands may be chained after `table` to return a subset of documents\n    /// (such as [get](crate::Command::get) and [filter](crate::Command::filter))\n    /// or perform further processing.\n    ///\n    /// ## Examples\n    ///\n    /// Return all documents in the table ‘simbad’ of the default database.\n    ///\n    /// ```\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"simbad\").run(\u0026conn).await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Return all documents in the table ‘simbad’ of the database ‘heroes’.\n    ///\n    /// ```\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.db(\"heroes\").table(\"simbad\").run(\u0026conn).await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Allow potentially out-of-date data in exchange for faster reads.\n    ///\n    /// ```\n    /// use reql_rust::cmd::table::TableOption;\n    /// use reql_rust::arguments::ReadMode;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let table_option = TableOption::default().read_mode(ReadMode::Outdated);\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.db(\"heroes\").table(args!(\"simbad\", table_option)).run(\u0026conn).await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [filter](crate::Command::filter)\n    /// - [get](crate::Command::get)\n    pub fn table(self, args: impl cmd::table::TableArg) -\u003e Command {\n        cmd::table::new(args)\n    }\n\n    /// Transform each element of one or more sequences\n    /// by applying a mapping function to them.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// sequence.map(func) → stream\n    /// sequence.map(sequence, func) → stream\n    /// sequence.map(sequences, func) → stream\n    /// r.map(sequence, func) → stream\n    /// r.map(sequence, sequence, func) → stream\n    /// r.map(sequence, sequences, func) → stream\n    /// ```\n    ///\n    /// Where:\n    /// - func: func!(...)\n    /// - sequence: [Command](crate::Command)\n    /// - sequences: [...] | \u0026[...] | vec![...]\n    ///\n    /// # Description\n    ///\n    /// If `map` is run with two or more sequences, it will iterate\n    /// for as many items as there are in the shortest sequence.\n    ///\n    /// Note that `map` can only be applied to sequences, not single values.\n    /// If you wish to apply a function to a single value/selection (including an array),\n    /// use the [do_](Self::do_) command.\n    ///\n    /// ## Examples\n    ///\n    /// Return the first five squares.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: Vec\u003cu8\u003e = r.expr([1, 2, 3, 4, 5])\n    ///         .map(func!(|val| val.clone() * val))\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert_eq!(response, [1, 4, 9, 16, 25]);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Sum the elements of three sequences.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let sequence1 = r.expr([100, 200, 300, 400]);\n    ///     let sequence2 = r.expr([10, 20, 30, 40]);\n    ///     let sequence3 = r.expr([1, 2, 3, 4]);\n    ///\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: Vec\u003cu32\u003e = r.map(sequence1, args!(\n    ///             [sequence2, sequence3],\n    ///             func!(|val1, val2, val3| val1 + val2 + val3)\n    ///         ))\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert_eq!(response, [111, 222, 333, 444]);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Rename a field when retrieving documents\n    /// using `map` and [merge](crate::Command::merge).\n    ///\n    /// This example renames the field `id` to `user_id`\n    /// when retrieving documents from the table `users`.\n    ///\n    /// ```\n    /// use std::collections::HashMap;\n    ///\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"users\")\n    ///         .map(func!(|doc| {\n    ///             let mut user = HashMap::new();\n    ///             user.insert(\"user_id\", doc.clone().g(\"id\"));\n    ///             \n    ///             doc.merge(r.hash_map(user)).without(\"id\")\n    ///         }))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Assign every superhero an archenemy.\n    ///\n    /// ```\n    /// use std::collections::HashMap;\n    ///\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"heroes\")\n    ///         .map(args!(r.table(\"villains\"), func!(|hero, villain| {\n    ///             let mut villain_obj = HashMap::new();\n    ///             villain_obj.insert(\"villain\", villain);\n    ///\n    ///             hero.merge(r.hash_map(villain_obj))\n    ///         })))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [concat_map](crate::Command::concat_map)\n    /// - [reduce](Self::reduce)\n    /// - [do_](Self::do_)\n    pub fn map(self, sequence: Command, args: impl cmd::map::MapArg) -\u003e Command {\n        sequence.map(args)\n    }\n\n    // TODO write Doc\n    pub fn order_by(self, args: impl cmd::order_by::OrderByArg) -\u003e Command {\n        cmd::order_by::new(args)\n    }\n\n    /// Merge two or more sequences.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// stream.union(sequence) → stream\n    /// stream.union(vec![sequence]) → stream\n    /// stream.union(args!(sequence, options)) → stream\n    /// stream.union(args!(vec![sequence], options)) → stream\n    /// ```\n    ///\n    /// Where:\n    /// - sequence: [Command](crate::Command)\n    /// - options: [UnionOption](crate::cmd::union::UnionOption)\n    ///\n    /// ## Examples\n    ///\n    /// Construct a stream of all characters.\n    ///\n    /// ```\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"simbad\")\n    ///         .union(r.table(\"kirikou\"))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    pub fn union(self, stream: Command, args: impl cmd::union::UnionArg) -\u003e Command {\n        stream.union(args)\n    }\n\n    /// Takes a stream and partitions it into multiple\n    /// groups based on the fields or functions provided.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// sequence.group(field) → grouped_stream\n    /// sequence.group(func) → grouped_stream\n    /// sequence.group(args!(field, options)) → grouped_stream\n    /// sequence.group(args!(func, options)) → grouped_stream\n    /// r.group(sequence, field) → grouped_stream\n    /// r.group(sequence, func) → grouped_stream\n    /// r.group(sequence, args!(field, options)) → grouped_stream\n    /// r.group(sequence, args!(func, options)) → grouped_stream\n    /// ```\n    ///\n    /// Where:\n    /// - field: \u0026str | [\u0026str; N]\n    /// - func: func!(...) | [func!(...); N]\n    /// - grouped_stream: [GroupedStream](crate::types::GroupedStream)\n    /// - sequence: [Command](crate::Command)\n    ///\n    /// # Description\n    ///\n    /// With the `multi` flag single documents can be assigned to multiple groups,\n    /// similar to the behavior of\n    /// [multi-indexes](https://rethinkdb.com/docs/secondary-indexes/javascript).\n    /// When `multi` is `true` and the grouping value is an array, documents\n    /// will be placed in each group that corresponds to the elements of the array.\n    /// If the array is empty the row will be ignored.\n    ///\n    /// Suppose that the table games has the following data:\n    ///\n    /// ```text\n    /// [\n    ///     {id: 2, player: \"Moussa\", points: 15, class: \"ranked\"},\n    ///     {id: 5, player: \"Fatou\", points: 7, class: \"free\"},\n    ///     {id: 11, player: \"Moussa\", points: 10, class: \"free\"},\n    ///     {id: 12, player: \"Fatou\", points: 2, class: \"free\"}\n    /// ]\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Group games by player.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::types::{GroupedItem, GroupedStream};\n    /// use reql_rust::{args, r, Result};\n    /// use serde::{Serialize, Deserialize};\n    ///\n    /// #[derive(Serialize, Deserialize, PartialEq, Eq)]\n    /// struct Player {\n    ///     id: u8,\n    ///     player: String,\n    ///     points: u8,\n    ///     class: String,\n    /// }\n    ///\n    /// impl Player {\n    ///     fn new(id: u8, player: \u0026str, points: u8, class: \u0026str) -\u003e Self {\n    ///         Self {\n    ///             id,\n    ///             points,\n    ///             player: player.to_owned(),\n    ///             class: class.to_owned(),\n    ///         }\n    ///     }\n    /// }\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let expected_data = vec![\n    ///         GroupedItem {\n    ///             group: String::from(\"Fatou\"),\n    ///             values: vec![\n    ///                 Player::new(5, \"Fatou\", 7, \"free\"),\n    ///                 Player::new(12, \"Fatou\", 2, \"free\"),\n    ///             ]\n    ///         },\n    ///         GroupedItem {\n    ///             group: String::from(\"Moussa\"),\n    ///             values: vec![\n    ///                 Player::new(2, \"Moussa\", 15, \"ranked\"),\n    ///                 Player::new(11, \"Moussa\", 10, \"free\"),\n    ///             ]\n    ///         },\n    ///     ];\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: GroupedStream\u003cString, Player\u003e = r.table(\"games\")\n    ///         .group(\"player\")\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response.collect() == expected_data);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [ungroup](crate::Command::ungroup)\n    /// - [map](Self::map)\n    /// - [reduce](Self::reduce)\n    /// - [count](Self::count)\n    /// - [sum](Self::sum)\n    /// - [avg](Self::avg)\n    /// - [min](Self::min)\n    /// - [max](Self::max)\n    pub fn group(self, sequence: Command, args: impl cmd::group::GroupArg) -\u003e Command {\n        sequence.group(args)\n    }\n\n    /// Produce a single value from a sequence through\n    /// repeated application of a reduction function.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// sequence.fold(base, func) → value\n    /// ```\n    ///\n    /// Where:\n    /// - base, value: impl Serialize\n    /// - func: func!(...)\n    /// - sequence: [Command](crate::Command)\n    ///\n    /// # Description\n    ///\n    /// The reduction function can be called on:\n    ///\n    /// - two elements of the sequence\n    /// - one element of the sequence and one result of a previous reduction\n    /// - two results of previous reductions\n    ///\n    /// The reduction function can be called on the results of\n    /// two previous reductions because the `reduce` command is\n    /// distributed and parallelized across shards and CPU cores.\n    /// A common mistaken when using the `reduce` command is to\n    /// suppose that the reduction is executed from left to right.\n    /// [Read the map-reduce in RethinkDB](https://rethinkdb.com/docs/map-reduce/)\n    /// article to see an example.\n    ///\n    /// If the sequence is empty, the server will produce a\n    /// `ReqlRuntimeError` that can be caught with default.\n    /// If the sequence has only one element, the first element will be returned.\n    ///\n    /// ## Examples\n    ///\n    /// Return the number of documents in the table posts.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"posts\")\n    ///         .map(func!(|| r.expr(1)))\n    ///         .reduce(func!(|left, right| left + right))\n    ///         .default(0)\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// A shorter way to execute this query is to use [count](Self::count).\n    ///\n    /// ## Examples\n    ///\n    /// Suppose that each `post` has a field `comments` that is an array of comments.\n    /// Return the maximum number comments per post.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"posts\")\n    ///         .map(func!(|post| post.g(\"comments\").count(())))\n    ///         .reduce(func!(|left, right| r.branch(\n    ///             left.clone().gt(right.clone()),\n    ///             args!(left, right)\n    ///         )))\n    ///         .default(0)\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// A shorter way to execute this query is to use [max](Self::max).\n    ///\n    /// # Related commands\n    /// - [group](crate::Command::group)\n    /// - [map](Self::map)\n    /// - [concat_map](crate::Command::concat_map)\n    /// - [sum](Self::sum)\n    /// - [avg](Self::avg)\n    /// - [min](Self::min)\n    /// - [max](Self::max)\n    pub fn reduce(self, sequence: Command, func: Func) -\u003e Command {\n        sequence.reduce(func)\n    }\n\n    /// Count the number of elements in sequence or key/value pairs in an object,\n    /// or returns the size of a string or binary object.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// binary.count(()) → number\n    /// string.count(()) → number\n    /// object.count(()) → number\n    /// sequence.count(()) → number\n    /// sequence.count(args!(value)) → number\n    /// sequence.count(func) → number\n    /// r.count(query_cmd) → number\n    /// r.count(query_cmd, args!(value)) → number\n    /// r.count(query_cmd, func) → number\n    /// ```\n    ///\n    /// Where:\n    /// - value: impl Serialize\n    /// - func: func!(...)\n    /// - sequence, binary, string, object, query_cmd: [Command](crate::Command)\n    ///\n    /// # Description\n    ///\n    /// When `count` is called on a sequence with a predicate value or function,\n    /// it returns the number of elements in the sequence equal to that value or\n    /// where the function returns `true`. On a [binary](Self::binary) object, `count`\n    /// returns the size of the object in bytes; on strings, `count` returns the string’s length.\n    /// This is determined by counting the number of Unicode codepoints in the string,\n    /// counting combining codepoints separately.\n    ///\n    /// ## Examples\n    ///\n    /// Count the number of users.\n    ///\n    /// ```\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"users\")\n    ///         .count(())\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Count the number of 18 year old users.\n    ///\n    /// ```\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"users\")\n    ///         .g(\"age\")\n    ///         .count(args!(18))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Count the number of users over 18.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"users\")\n    ///         .g(\"age\")\n    ///         .count(func!(|age| age.gt(18)))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Return the length of a Unicode string.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: usize = r.expr(\"こんにちは\")\n    ///         .count(())\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == 5);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Return the length of an array.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: usize = r.expr(['0','1','2'])\n    ///         .count(())\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == 3);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [map](Self::map)\n    /// - [reduce](Self::reduce)\n    /// - [sum](Self::sum)\n    /// - [avg](Self::avg)\n    /// - [min](Self::min)\n    /// - [max](Self::max)\n    /// - [group](crate::Command::group)\n    pub fn count(self, query: Command, args: impl cmd::count::CountArg) -\u003e Command {\n        query.count(args)\n    }\n\n    /// Sum all the elements of sequence.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// sequence.sum(()) → number\n    /// sequence.sum(field) → number\n    /// sequence.sum(func) → number\n    /// r.sum(sequence) → number\n    /// r.sum(sequence, field) → number\n    /// r.sum(sequence, func) → number\n    /// ```\n    ///\n    /// Where:\n    /// - field: \u0026str, String, Cow\u003c'static, str\u003e\n    /// - func: func!(...)\n    /// - sequence: [Command](crate::Command)\n    ///\n    /// # Description\n    ///\n    /// If called with a field name, sums all the values of that field in\n    /// the sequence, skipping elements of the sequence that lack that field.\n    /// If called with a function, calls that function on every element of the\n    /// sequence and sums the results, skipping elements of the sequence\n    /// where that function returns `None` or non-existence error.\n    ///\n    /// Returns `0` when called on an empty sequence.\n    ///\n    /// ## Examples\n    ///\n    /// What's 3 + 5 + 7?\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: u8 = r.expr([3, 5, 7])\n    ///         .sum(())\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == 15);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// How many points have been scored across all games?\n    ///\n    /// ```\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"games\")\n    ///         .sum(\"points\")\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// How many points have been scored across all games, counting bonus points?\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"games\")\n    ///         .sum(func!(|game| game.clone().g(\"points\") + game.g(\"bonus_points\")))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [map](Self::map)\n    /// - [reduce](Self::reduce)\n    /// - [count](Self::count)\n    /// - [avg](Self::avg)\n    /// - [min](Self::min)\n    /// - [max](Self::max)\n    /// - [group](crate::Command::group)\n    pub fn sum(self, sequence: Command, args: impl cmd::sum::SumArg) -\u003e Command {\n        sequence.sum(args)\n    }\n\n    /// Averages all the elements of sequence.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// sequence.avg(()) → Option\u003cf64\u003e\n    /// sequence.avg(field) → Option\u003cf64\u003e\n    /// sequence.avg(func) → Option\u003cf64\u003e\n    /// r.avg(sequence) → Option\u003cf64\u003e\n    /// r.avg(sequence, field) → Option\u003cf64\u003e\n    /// r.avg(sequence, func) → Option\u003cf64\u003e\n    /// ```\n    ///\n    /// Where:\n    /// - field: \u0026str, String, Cow\u003c'static, str\u003e\n    /// - func: func!(...)\n    /// - sequence: [Command](crate::Command)\n    ///\n    /// # Description\n    ///\n    /// If called with a field name, averages all the values of that field in\n    /// the sequence, skipping elements of the sequence that lack that field.\n    /// If called with a function, calls that function on every element of the\n    /// sequence and averages the results, skipping elements of the sequence\n    /// where that function returns `None` or non-existence error.\n    ///\n    /// Produces a non-existence error when called on an empty sequence.\n    /// You can handle this case with `default`.\n    ///\n    /// ## Examples\n    ///\n    /// What's the average of 3, 5 and 7?\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: Option\u003cf64\u003e = r.expr([3, 5, 7])\n    ///         .avg(())\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == Some(5.));\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// What's the average number of points scored in a games?\n    ///\n    /// ```\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"games\")\n    ///         .avg(\"points\")\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// What's the average number of points scored in a games, counting bonus points?\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"games\")\n    ///         .avg(func!(|game| game.clone().g(\"points\") + game.g(\"bonus_points\")))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [map](Self::map)\n    /// - [reduce](Self::reduce)\n    /// - [count](Self::count)\n    /// - [sum](Self::sum)\n    /// - [min](Self::min)\n    /// - [max](Self::max)\n    /// - [group](crate::Command::group)\n    pub fn avg(self, sequence: Command, args: impl cmd::avg::AvgArg) -\u003e Command {\n        sequence.avg(args)\n    }\n\n    /// Finds the minimum element of a sequence.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// sequence.min(()) → element\n    /// sequence.min(args!(field)) → element\n    /// sequence.min(func) → element\n    /// sequence.min(options) → element\n    /// r.min(sequence) → element\n    /// r.min(sequence, args!(field)) → element\n    /// r.min(sequence, func) → element\n    /// r.min(sequence, options) → element\n    /// ```\n    ///\n    /// Where:\n    /// - field: \u0026str, String, Cow\u003c'static, str\u003e\n    /// - func: func!(...)\n    /// - options: [MinOption](crate::cmd::min::MinOption)\n    /// - sequence: [Command](crate::Command)\n    ///\n    /// # Description\n    ///\n    /// The `min` command can be called with:\n    /// - a `field name`, to return the element of the sequence\n    /// with the largest value in that field;\n    /// - a `function`, to apply the function to every element within the sequence\n    /// and return the element which returns the largest value from the function,\n    /// ignoring any elements where the function produces a non-existence error;\n    /// - an `index` (the primary key or a secondary index), to return the element\n    /// of the sequence with the largest value in that index;\n    ///\n    /// For more information on RethinkDB’s sorting order, read the section in\n    /// [ReQL data types](https://rethinkdb.com/docs/data-types/#sorting-order).\n    ///\n    /// Calling `min` on an empty sequence will throw a non-existence error;\n    /// this can be handled using the [default](crate::Command::default) command.\n    ///\n    /// ## Examples\n    ///\n    /// Return the minimum value in the list [3, 5, 7].\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: u8 = r.expr([3, 5, 7])\n    ///         .min(())\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == 3);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Return the user who has scored the fewest points.\n    ///\n    /// ```\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"users\")\n    ///         .min(args!(\"points\"))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// The same as above, but using a secondary index on the `points` field.\n    ///\n    /// ```\n    /// use reql_rust::cmd::min::MinOption;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"users\")\n    ///         .min(MinOption::default().index(\"points\"))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Return the user who has scored the fewest points,\n    /// adding in bonus points from a separate field using a function.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"users\")\n    ///         .min(func!(|user| user.clone().g(\"points\") + user.g(\"bonus_points\")))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Return the highest number of points any user has ever scored.\n    /// This returns the value of that `points` field, not a document.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: u8 = r.table(\"users\")\n    ///         .min(args!(\"points\"))\n    ///         .g(\"points\")\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == 2);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [map](Self::map)\n    /// - [reduce](Self::reduce)\n    /// - [count](Self::count)\n    /// - [sum](Self::sum)\n    /// - [avg](Self::avg)\n    /// - [max](Self::max)\n    /// - [group](crate::Command::group)\n    pub fn min(self, sequence: Command, args: impl cmd::min::MinArg) -\u003e Command {\n        sequence.min(args)\n    }\n\n    /// Finds the maximum element of a sequence.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// sequence.max(()) → element\n    /// sequence.max(args!(field)) → element\n    /// sequence.max(func) → element\n    /// sequence.max(options) → element\n    /// r.max(sequence) → element\n    /// r.max(sequence, args!(field)) → element\n    /// r.max(sequence, func) → element\n    /// r.max(sequence, options) → element\n    /// ```\n    ///\n    /// Where:\n    /// - field: \u0026str, String, Cow\u003c'static, str\u003e\n    /// - func: func!(...)\n    /// - options: [MaxOption](crate::cmd::max::MaxOption)\n    /// - sequence: [Command](crate::Command)\n    ///\n    /// # Description\n    ///\n    /// The `max` command can be called with:\n    /// - a `field name`, to return the element of the sequence\n    /// with the largest value in that field;\n    /// - a `function`, to apply the function to every element within the sequence\n    /// and return the element which returns the largest value from the function,\n    /// ignoring any elements where the function produces a non-existence error;\n    /// - an `index` (the primary key or a secondary index), to return the element\n    /// of the sequence with the largest value in that index;\n    ///\n    /// For more information on RethinkDB’s sorting order, read the section in\n    /// [ReQL data types](https://rethinkdb.com/docs/data-types/#sorting-order).\n    ///\n    /// Calling `max` on an empty sequence will throw a non-existence error;\n    /// this can be handled using the [default](crate::Command::default) command.\n    ///\n    /// ## Examples\n    ///\n    /// Return the maximum value in the list [3, 5, 7].\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: u8 = r.expr([3, 5, 7])\n    ///         .max(())\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == 7);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Return the user who has scored the most points.\n    ///\n    /// ```\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"users\")\n    ///         .max(args!(\"points\"))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// The same as above, but using a secondary index on the `points` field.\n    ///\n    /// ```\n    /// use reql_rust::cmd::max::MaxOption;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"users\")\n    ///         .max(MaxOption::default().index(\"points\"))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Return the user who has scored the most points,\n    /// adding in bonus points from a separate field using a function.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"users\")\n    ///         .max(func!(|user| user.clone().g(\"points\") + user.g(\"bonus_points\")))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Return the highest number of points any user has ever scored.\n    /// This returns the value of that `points` field, not a document.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: u8 = r.table(\"users\")\n    ///         .max(args!(\"points\"))\n    ///         .g(\"points\")\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == 15);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [map](Self::map)\n    /// - [reduce](Self::reduce)\n    /// - [count](Self::count)\n    /// - [sum](Self::sum)\n    /// - [avg](Self::avg)\n    /// - [min](Self::min)\n    /// - [group](crate::Command::group)\n    pub fn max(self, sequence: Command, args: impl cmd::max::MaxArg) -\u003e Command {\n        sequence.max(args)\n    }\n\n    /// Removes duplicate elements from a sequence.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// sequence.distinct(()) → array\n    /// table.distinct(options) → stream\n    /// r.distinct(sequence) → array\n    /// r.distinct(table, options) → stream\n    /// ```\n    ///\n    /// Where:\n    /// - options: [DistinctOption](crate::cmd::distinct::DistinctOption)\n    /// - sequence: [Command](crate::Command)\n    ///\n    /// # Description\n    ///\n    /// The `distinct` command can be called on any sequence or table with an index.\n    ///\n    /// ```text\n    /// While `distinct` can be called on a table without an index,\n    /// the only effect will be to convert the table into a stream;\n    /// the content of the stream will not be affected.\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Which unique villains have been vanquished by Marvel heroes?\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"marvel\")\n    ///         .concat_map(func!(|hero| hero.g(\"villain_list\")))\n    ///         .distinct(())\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Topics in a table of messages have a secondary index on them,\n    /// and more than one message can have the same topic.\n    /// What are the unique topics in the table?\n    ///\n    /// ```\n    /// use reql_rust::cmd::distinct::DistinctOption;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"messages\")\n    ///         .distinct(DistinctOption::default().index(\"topics\"))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// The above structure is functionally identical to:\n    ///\n    /// ```\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"messages\")\n    ///         .g(\"topics\")\n    ///         .distinct(())\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// However, the first form (passing the index as an argument to `distinct`) is faster,\n    /// and won’t run into array limit issues since it’s returning a stream.\n    ///\n    /// # Related commands\n    /// - [map](Self::map)\n    /// - [concat_map](crate::Command::concat_map)\n    /// - [group](crate::Command::group)\n    pub fn distinct(self, seq_or_table: Command, args: impl cmd::distinct::DistinctArg) -\u003e Command {\n        seq_or_table.distinct(args)\n    }\n\n    /// When called with values, returns `true`\n    /// if a sequence contains all the specified values.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// query.contains(value) → bool\n    /// r.contains(sequence, value) → bool\n    /// ```\n    ///\n    /// Where:\n    /// - value: impl Serialize | [Command](crate::Command)\n    /// - sequence: [Command](crate::Command)\n    ///\n    /// # Description\n    ///\n    /// When called with predicate functions, returns `true`\n    /// if for each predicate there exists at least one element\n    /// of the stream where that predicate returns `true`.\n    ///\n    /// Values and predicates may be mixed freely in the argument list.\n    ///\n    /// ## Examples\n    ///\n    /// Has Iron Man ever fought Superman?\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: bool = r.table(\"marvel\")\n    ///         .get(\"ironman\")\n    ///         .g(\"opponents\")\n    ///         .contains(\"superman\")\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Has Iron Man ever defeated Superman in battle?\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: bool = r.table(\"marvel\")\n    ///         .get(\"ironman\")\n    ///         .g(\"battles\")\n    ///         .contains(func!(|battle| battle.clone().g(\"winner\").eq(\"ironman\").and(\n    ///             battle.g(\"loser\").eq(\"superman\")\n    ///         )))\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Return all heroes who have fought both Loki and the Hulk.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: bool = r.table(\"marvel\")\n    ///         .filter(func!(|hero| hero.g(\"opponents\").contains([\"loki\", \"hulk\"])))\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Use contains with a predicate function to simulate an or.\n    /// Return the Marvel superheroes who live in Detroit, Chicago or Hoboken.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: bool = r.table(\"marvel\")\n    ///         .filter(func!(|hero| r.expr([\"Detroit\", \"Chicago\", \"Hoboken\"]).contains(hero.g(\"city\"))))\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [map](Self::map)\n    /// - [concat_map](crate::Command::concat_map)\n    /// - [group](crate::Command::group)\n    pub fn contains(self, sequence: Command, args: impl cmd::contains::ContainsArg) -\u003e Command {\n        sequence.contains(args)\n    }\n\n    /// TODO Write docs\n    pub fn literal(self, value: impl Serialize) -\u003e Command {\n        cmd::literal::new(value)\n    }\n\n    /// Creates an object from a list of key-value pairs,\n    /// where the keys must be strings.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// r.object(values) → object\n    /// ```\n    ///\n    /// Where:\n    /// - values: vec![...] | [...] | \u0026[...]\n    ///\n    /// ## Examples\n    ///\n    /// Create a simple object.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    /// use serde::{Deserialize, Serialize};\n    ///\n    /// #[derive(Debug, PartialEq, Eq, Serialize, Deserialize)]\n    /// struct Post {\n    ///     id: String,\n    ///     title: String,\n    /// }\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let post = Post {\n    ///         id: \"id1\".to_string(),\n    ///         title: \"title1\".to_string(),\n    ///     };\n    ///     let response: Post = r.object([\"id\", \"id1\", \"title\", \"title1\"])\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == post);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [coerce_to](crate::Command::coerce_to)\n    /// - [merge](crate::Command::merge)\n    /// - [keys](crate::Command::keys)\n    pub fn object\u003cS, T\u003e(self, values: T) -\u003e Command\n    where\n        S: Serialize,\n        T: IntoIterator\u003cItem = S\u003e,\n    {\n        cmd::object::new(values)\n    }\n\n    /// Compute the logical “and” of one or more values.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// cmd_value.and(value) → bool\n    /// cmd_value.and(args!(values)) → bool\n    /// r.and(args!(values)) → bool\n    /// ```\n    ///\n    /// Where:\n    /// - value: [Command](crate::Command) | bool\n    /// - values: [Command](crate::Command) | vec![...] | [...] | \u0026[...]\n    ///\n    /// # Description\n    ///\n    /// The `and` command can be used as an infix operator after its\n    /// first argument (`r.expr(true).and(false)`) or given all of\n    /// its arguments as parameters (`r.and(args!([true, false]))`).\n    ///\n    /// Calling `or` with zero arguments will return `false`.\n    ///\n    /// ## Examples\n    ///\n    /// Return whether either true or false evaluate to true.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: bool = r.expr(true)\n    ///         .or(false)\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == false);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Return whether any of true, true or true evaluate to true.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: bool = r.or(args!([true, true, true]))\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == true);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [eq](Self::eq)\n    /// - [ne](Self::ne)\n    /// - [or](Self::or)\n    pub fn and(self, args: impl cmd::and::AndArg) -\u003e Command {\n        cmd::and::new(args)\n    }\n\n    /// Compute the logical “or” of one or more values.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// cmd_value.or(value) → bool\n    /// cmd_value.or(args!(values)) → bool\n    /// r.or(args!(values)) → bool\n    /// ```\n    ///\n    /// Where:\n    /// - value: [Command](crate::Command) | bool\n    /// - values: [Command](crate::Command) | vec![...] | [...] | \u0026[...]\n    ///\n    /// # Description\n    ///\n    /// The `or` command can be used as an infix operator after\n    /// its first argument (`r.expr(true).or(false)`) or given all\n    /// of its arguments as parameters (`r.or(args!([true, false]))`).\n    ///\n    /// Calling `or` with zero arguments will return `false`.\n    ///\n    /// ## Examples\n    ///\n    /// Return whether either true or false evaluate to true.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: bool = r.expr(true)\n    ///         .or(false)\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == true);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Return whether any of false, false or false evaluate to false.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: bool = r.or(args!([false, false, false]))\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == false);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Note\n    ///\n    /// When using `or` inside a `filter` predicate to test the values of\n    /// fields that may not exist on the documents being tested,\n    /// you should use the `default` command with those fields so\n    /// they explicitly return `false`.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"table\")\n    ///         .filter(func!(|post| post.clone()\n    ///             .g(\"category\").default(\"foo\").eq(\"article\")\n    ///             .or(post.g(\"genre\").default(\"foo\").eq(\"mystery\"))\n    ///         ))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [eq](Self::eq)\n    /// - [ne](Self::ne)\n    /// - [and](Self::and)\n    pub fn or(self, args: impl cmd::or::OrArg) -\u003e Command {\n        cmd::or::new(args)\n    }\n\n    /// Test if two or more values are equal.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// cmd_value.eq(value) → bool\n    /// cmd_value.eq(args!(values)) → bool\n    /// r.eq(args!(values)) → bool\n    /// ```\n    ///\n    /// Where:\n    /// - value: [Command](crate::Command) | impl Serialize\n    /// - values: [Command](crate::Command) | vec![...] | [...] | \u0026[...]\n    ///\n    /// ## Examples\n    ///\n    /// See if a user’s `role` field is set to `administrator`.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: bool = r.table(\"users\")\n    ///         .get(1)\n    ///         .g(\"role\")\n    ///         .eq(\"administrator\")\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == true);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// See if three variables contain equal values.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: bool = r.eq(args!([20, 10, 15]))\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == true);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [ne](Self::ne)\n    /// - [and](Self::and)\n    /// - [or](Self::or)\n    pub fn eq(self, args: impl cmd::eq::EqArg) -\u003e Command {\n        cmd::eq::new(args)\n    }\n\n    /// Test if two or more values are not equal.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// cmd_value.ne(value) → bool\n    /// cmd_value.ne(args!(values)) → bool\n    /// r.ne(args!(values)) → bool\n    /// ```\n    ///\n    /// Where:\n    /// - value: [Command](crate::Command) | impl Serialize\n    /// - values: [Command](crate::Command) | vec![...] | [...] | \u0026[...]\n    ///\n    /// ## Examples\n    ///\n    /// See if a user’s `role` field is not set to `administrator`.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: bool = r.table(\"users\")\n    ///         .get(1)\n    ///         .g(\"role\")\n    ///         .ne(\"administrator\")\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == true);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// See if three variables do not contain equal values.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: bool = r.ne(args!([20, 10, 15]))\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == true);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [eq](Self::eq)\n    /// - [and](Self::and)\n    /// - [or](Self::or)\n    pub fn ne(self, args: impl cmd::ne::NeArg) -\u003e Command {\n        cmd::ne::new(args)\n    }\n\n    /// Compare values, testing if the left-hand value is greater than the right-hand.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// cmd_value.gt(value) → bool\n    /// cmd_value.gt(args!(values)) → bool\n    /// r.gt(args!(values)) → bool\n    /// ```\n    ///\n    /// Where:\n    /// - value: [Command](crate::Command) | impl Serialize\n    /// - values: [Command](crate::Command) | vec![...] | [...] | \u0026[...]\n    ///\n    /// ## Examples\n    ///\n    /// Test if a player has scored more than 10 points.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: bool = r.table(\"players\")\n    ///         .get(1)\n    ///         .g(\"score\")\n    ///         .gt(10)\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == true);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Test if variables are ordered from lowest to highest,\n    /// with no values being equal to one another.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: bool = r.gt(args!([20, 10, 15]))\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == true);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [eq](Self::eq)\n    /// - [ne](Self::ne)\n    /// - [ge](Self::ge)\n    /// - [lt](Self::lt)\n    /// - [le](Self::le)\n    pub fn gt(self, args: impl cmd::gt::GtArg) -\u003e Command {\n        cmd::gt::new(args)\n    }\n\n    /// Compare values, testing if the left-hand value is greater than the right-hand.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// cmd_value.ge(value) → bool\n    /// cmd_value.ge(args!(values)) → bool\n    /// r.ge(args!(values)) → bool\n    /// ```\n    ///\n    /// Where:\n    /// - value: [Command](crate::Command) | impl Serialize\n    /// - values: [Command](crate::Command) | vec![...] | [...] | \u0026[...]\n    ///\n    /// ## Examples\n    ///\n    /// Test if a player has scored more than 10 points.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: bool = r.table(\"players\")\n    ///         .get(1)\n    ///         .g(\"score\")\n    ///         .ge(10)\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == true);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Test if variables are ordered from lowest to highest,\n    /// with no values being equal to one another.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: bool = r.ge(args!([20, 10, 15]))\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == true);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [eq](Self::eq)\n    /// - [ne](Self::ne)\n    /// - [gt](Self::gt)\n    /// - [lt](Self::lt)\n    /// - [le](Self::le)\n    pub fn ge(self, args: impl cmd::ge::GeArg) -\u003e Command {\n        cmd::ge::new(args)\n    }\n\n    /// Compare values, testing if the left-hand value is less than the right-hand.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// cmd_value.lt(value) → bool\n    /// cmd_value.lt(args!(values)) → bool\n    /// r.lt(args!(values)) → bool\n    /// ```\n    ///\n    /// Where:\n    /// - value: [Command](crate::Command) | impl Serialize\n    /// - values: [Command](crate::Command) | vec![...] | [...] | \u0026[...]\n    ///\n    /// ## Examples\n    ///\n    /// Test if a player has scored less than 10 points.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: bool = r.table(\"players\")\n    ///         .get(1)\n    ///         .g(\"score\")\n    ///         .lt(10)\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == true);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Test if variables are ordered from highest to lowest,\n    /// with no values being equal to one another.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: bool = r.lt(args!([20, 10, 15]))\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == true);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [eq](Self::eq)\n    /// - [ne](Self::ne)\n    /// - [gt](Self::gt)\n    /// - [ge](Self::ge)\n    /// - [le](Self::le)\n    pub fn lt(self, args: impl cmd::lt::LtArg) -\u003e Command {\n        cmd::lt::new(args)\n    }\n\n    /// Compare values, testing if the left-hand value is\n    /// less than or equal to the right-hand.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// cmd_value.le(value) → bool\n    /// cmd_value.le(args!(values)) → bool\n    /// r.le(args!(values)) → bool\n    /// ```\n    ///\n    /// Where:\n    /// - value: [Command](crate::Command) | impl Serialize\n    /// - values: [Command](crate::Command) | vec![...] | [...] | \u0026[...]\n    ///\n    /// ## Examples\n    ///\n    /// Test if a player has scored 10 points or less.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: bool = r.table(\"players\")\n    ///         .get(1)\n    ///         .g(\"score\")\n    ///         .le(10)\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == true);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Test if variables are ordered from highest to lowest.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: bool = r.le(args!([20, 10, 15]))\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == true);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [eq](Self::eq)\n    /// - [ne](Self::ne)\n    /// - [gt](Self::gt)\n    /// - [ge](Self::ge)\n    /// - [lt](Self::lt)\n    pub fn le(self, args: impl cmd::le::LeArg) -\u003e Command {\n        cmd::le::new(args)\n    }\n\n    /// Compute the logical inverse (not) of an expression.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// !cmd_bool\n    /// cmd_bool.not() → bool\n    /// r.not(cmd_bool) → bool\n    /// ```\n    ///\n    /// Where:\n    /// - cmd_bool: [Command](crate::Command)\n    ///\n    /// # Description\n    ///\n    /// `not` can be called either via method chaining, immediately after\n    /// an expression that evaluates as a boolean value, or by passing\n    /// the expression as a parameter to `not`. All values that are not\n    /// `false` or `None` will be converted to `true`.\n    ///\n    /// ## Examples\n    ///\n    /// Not true is false.\n    ///\n    /// ```\n    /// use std::ops::Not;\n    ///\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: bool = r.expr(true)\n    ///         .not()\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     let response2: bool = r.not(r.expr(true))\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     let response3: bool = (!r.expr(true))\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(\n    ///         response == false \u0026\u0026\n    ///         response == response2 \u0026\u0026\n    ///         response == response3\n    ///     );\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [eq](Self::eq)\n    /// - [ne](Self::ne)\n    pub fn not(self, cmd_bool: Command) -\u003e Command {\n        !cmd_bool\n    }\n\n    /// Generate a random number between given (or implied) bounds.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// r.random(()) → number\n    /// r.round(param_number) → number\n    /// r.round(args!(param_number, param_number)) → number\n    /// r.round(args!(param_number, param_number, options)) → number\n    /// ```\n    ///\n    /// Where:\n    /// - param_number: f64 | [Command](crate::Command)\n    /// - cmd_number: [Command](crate::Command)\n    /// - options: [RandomOption](crate::cmd::random::RandomOption)\n    ///\n    /// # Description\n    ///\n    /// `random` takes zero, one or two arguments.\n    ///\n    /// - With *zero* arguments, the result will be a floating-point\n    /// number in the range `[0,1)` (from 0 up to but not including 1).\n    /// - With *one* argument x, the result will be in the range `[0,x)`, and will\n    /// be integer unless `RandomOption::default().float(true)` is given as an option.\n    /// Specifying a floating point number without the float option will raise an error.\n    /// - With *two* arguments x and y, the result will be in the range\n    /// `[x,y)`, and will be integer unless `RandomOption::default().float(true)` is given\n    /// as an option. If x and y are equal an error will occur, unless the floating-point\n    /// option has been specified, in which case x will be returned.\n    /// Specifying a floating point number without the float option will raise an error.\n    ///\n    /// ## Note\n    ///\n    /// The last argument given will always be the ‘open’ side of the range, but when\n    /// generating a floating-point number, the ‘open’ side may be less than the ‘closed’ side.\n    ///\n    /// ## Examples\n    ///\n    /// Generate a random number in the range `[0,1)`\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: u8 = r.random(())\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == 3);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Generate a random integer in the range `[0,100)`\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: u8 = r.random(100.)\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == 3);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Generate a random number in the range `(-2.24,1.59]`\n    ///\n    /// ```\n    /// use reql_rust::cmd::random::RandomOption;\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: f64 = r.random(args!(\n    ///             1.59, -2.24,\n    ///             RandomOption::default().float(true)\n    ///         ))\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == 0.);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [sample](crate::Command::sample)\n    pub fn random(self, args: impl cmd::random::RandomArg) -\u003e Command {\n        cmd::random::new(args)\n    }\n\n    /// Rounds the given value to the nearest whole integer.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// r.round(param_number) → number\n    /// cmd_number.round() → number\n    /// ```\n    ///\n    /// Where:\n    /// - param_number: f64 | [Command](crate::Command)\n    /// - cmd_number: [Command](crate::Command)\n    ///\n    /// # Description\n    ///\n    /// For example, values of 1.0 up to but not including 1.5\n    /// will return 1.0, similar to [floor](Self::floor); values\n    /// of 1.5 up to 2.0 will return 2.0, similar to [ceil](Self::ceil).\n    ///\n    /// ## Examples\n    ///\n    /// Round 12.345 to the nearest integer.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: i32 = r.round(12.345)\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == 12);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// The `round` command can also be chained after an expression.\n    ///\n    /// ## Examples\n    ///\n    /// Round -12.345 to the nearest integer.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: i32 = r.expr(-12.345)\n    ///         .round()\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == -12);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [ceil](Self::ceil)\n    /// - [round](Self::round)\n    pub fn round(self, args: impl cmd::round::RoundArg) -\u003e Command {\n        cmd::round::new(args)\n    }\n\n    /// Rounds the given value up, returning the smallest integer value\n    /// greater than or equal to the given value (the value’s ceiling).\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// r.ceil(param_number) → number\n    /// cmd_number.ceil() → number\n    /// ```\n    ///\n    /// Where:\n    /// - param_number: f64 | [Command](crate::Command)\n    /// - cmd_number: [Command](crate::Command)\n    ///\n    /// ## Examples\n    ///\n    /// Return the ceiling of 12.345.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: i32 = r.ceil(12.345)\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == 13);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// The `ceil` command can also be chained after an expression.\n    ///\n    /// ## Examples\n    ///\n    /// Return the ceiling of -12.345.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: i32 = r.expr(-12.345)\n    ///         .ceil()\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == -13);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [floor](Self::floor)\n    /// - [round](Self::round)\n    pub fn ceil(self, args: impl cmd::ceil::CeilArg) -\u003e Command {\n        cmd::ceil::new(args)\n    }\n\n    /// Rounds the given value down, returning the largest integer\n    /// value less than or equal to the given value (the value’s floor).\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// r.floor(param_number) → number\n    /// cmd_number.floor() → number\n    /// ```\n    ///\n    /// Where:\n    /// - param_number: f64 | [Command](crate::Command)\n    /// - cmd_number: [Command](crate::Command)\n    ///\n    /// ## Examples\n    ///\n    /// Return the floor of 12.345.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: i32 = r.floor(12.345)\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == 13);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// The `floor` command can also be chained after an expression.\n    ///\n    /// ## Examples\n    ///\n    /// Return the floor of -12.345.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: i32 = r.expr(-12.345)\n    ///         .floor()\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == -13);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [ceil](Self::ceil)\n    /// - [round](Self::round)\n    pub fn floor(self, args: impl cmd::floor::FloorArg) -\u003e Command {\n        cmd::floor::new(args)\n    }\n\n    /// Compute the arithmetic \"and\" of one or more values.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// cmd_number \u0026 cmd_number\n    /// number.bitand(cmd_number) → number\n    /// number.bit_and(param_number) → number\n    /// r.bit_and(cmd_number, param_number) → number\n    /// ```\n    ///\n    /// Where:\n    /// - param_number: i32 | [Command](crate::Command)\n    /// - cmd_number: [Command](crate::Command)\n    ///\n    /// # Description\n    ///\n    /// A bitwise AND is a binary operation that takes two equal-length binary\n    /// representations and performs the logical AND operation on each pair of\n    /// the corresponding bits, which is equivalent to multiplying them.\n    /// Thus, if both bits in the compared position are 1,\n    /// the bit in the resulting binary representation is 1 (1 × 1 = 1);\n    /// otherwise, the result is 0 (1 × 0 = 0 and 0 × 0 = 0).\n    ///\n    /// ## Examples\n    ///\n    /// Compute the arithmetic \"and\" of 5 and 3\n    ///\n    /// ```\n    /// use std::ops::BitAnd;\n    ///\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: i32 = r.expr(5)\n    ///         .bit_and(3)\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     let response2: i32 = r.bit_and(r.expr(5), 3)\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     let response3: i32 = (r.expr(5) \u0026 r.expr(3))\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     let response4: i32 = r.expr(5)\n    ///         .bitand(r.expr(3))\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(\n    ///         response == 1 \u0026\u0026\n    ///         response == response2 \u0026\u0026\n    ///         response == response3 \u0026\u0026\n    ///         response == response4\n    ///     );\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [bit_or](Self::bit_or)\n    /// - [bit_not](Self::bit_not)\n    /// - [bit_xor](Self::bit_xor)\n    /// - [bit_sal](Self::bit_sal)\n    /// - [bit_sar](Self::bit_sar)\n    pub fn bit_and(self, cmd_number: Command, args: impl cmd::bit_and::BitAndArg) -\u003e Command {\n        cmd_number.bit_and(args)\n    }\n\n    /// Compute the arithmetic \"or\" of one or more values.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// cmd_number | cmd_number\n    /// number.bitor(cmd_number) → number\n    /// number.bit_or(param_number) → number\n    /// r.bit_or(cmd_number, param_number) → number\n    /// ```\n    ///\n    /// Where:\n    /// - param_number: i32 | [Command](crate::Command)\n    /// - cmd_number: [Command](crate::Command)\n    ///\n    /// # Description\n    ///\n    /// A bitwise OR is a binary operation that takes two bit patterns\n    /// of equal length and performs the logical inclusive OR operation\n    /// on each pair of corresponding bits. The result in each position\n    /// is 0 if both bits are 0, while otherwise the result is 1.\n    ///\n    /// ## Examples\n    ///\n    /// Compute the arithmetic \"or\" of 6 and 4\n    ///\n    /// ```\n    /// use std::ops::BitOr;\n    ///\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: i32 = r.expr(5)\n    ///         .bit_or(3)\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     let response2: i32 = r.bit_xor(r.expr(5), 3)\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     let response3: i32 = (r.expr(5) ^ r.expr(3))\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     let response4: i32 = r.expr(5)\n    ///         .bitor(r.expr(3))\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(\n    ///         response == 7 \u0026\u0026\n    ///         response == response2 \u0026\u0026\n    ///         response == response3 \u0026\u0026\n    ///         response == response4\n    ///     );\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [bit_and](Self::bit_and)\n    /// - [bit_not](Self::bit_not)\n    /// - [bit_xor](Self::bit_xor)\n    /// - [bit_sal](Self::bit_sal)\n    /// - [bit_sar](Self::bit_sar)\n    pub fn bit_or(self, cmd_number: Command, args: impl cmd::bit_or::BitOrArg) -\u003e Command {\n        cmd_number.bit_or(args)\n    }\n\n    /// Compute the arithmetic \"and\" of one or more values.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// cmd_number ^ cmd_number\n    /// number.bitxor(cmd_number) → number\n    /// number.bit_xor(param_number) → number\n    /// r.bit_xor(cmd_number, param_number) → number\n    /// ```\n    ///\n    /// Where:\n    /// - param_number: i32 | [Command](crate::Command)\n    /// - cmd_number: [Command](crate::Command)\n    ///\n    /// # Description\n    ///\n    /// A bitwise XOR is a binary operation that takes two bit patterns\n    /// of equal length and performs the logical exclusive OR operation\n    /// on each pair of corresponding bits. The result in each position\n    /// is 1 if only the first bit is 1 or only the second bit is 1,\n    /// but will be 0 if both are 0 or both are 1.\n    /// In this we perform the comparison of two bits, being 1 if the\n    /// two bits are different, and 0 if they are the same.\n    ///\n    /// ## Examples\n    ///\n    /// Compute the arithmetic \"and\" of 6 and 4\n    ///\n    /// ```\n    /// use std::ops::BitXor;\n    ///\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: i32 = r.expr(6)\n    ///         .bit_xor(4)\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     let response2: i32 = r.bit_xor(r.expr(6), 4)\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     let response3: i32 = (r.expr(6) ^ r.expr(4))\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     let response4: i32 = r.expr(6)\n    ///         .bitxor(r.expr(4))\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(\n    ///         response == 2 \u0026\u0026\n    ///         response == response2 \u0026\u0026\n    ///         response == response3 \u0026\u0026\n    ///         response == response4\n    ///     );\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [bit_and](Self::bit_and)\n    /// - [bit_not](Self::bit_not)\n    /// - [bit_or](Self::bit_or)\n    /// - [bit_sal](Self::bit_sal)\n    /// - [bit_sar](Self::bit_sar)\n    pub fn bit_xor(self, cmd_number: Command, args: impl cmd::bit_xor::BitXorArg) -\u003e Command {\n        cmd_number.bit_xor(args)\n    }\n\n    /// Compute the arithmetic inverse (not) of an expression.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// number.bit_not() → number\n    /// r.bit_not(cmd_number) → number\n    /// ```\n    ///\n    /// Where:\n    /// - cmd_number: [Command](crate::Command)\n    ///\n    /// # Description\n    ///\n    /// A bitwise NOT, or complement, is a unary operation that performs logical\n    /// negation on each bit, forming the ones’ complement of the given binary value.\n    /// Bits that are 0 become 1, and those that are 1 become 0.\n    ///\n    /// ## Examples\n    ///\n    /// Negate the arithmetice expression\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: i32 = r.expr(7)\n    ///         .bit_not()\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     let response2: i32 = r.bit_not(r.expr(7))\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == -8 \u0026\u0026 response == response2);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [bit_and](Self::bit_and)\n    /// - [bit_or](Self::bit_or)\n    /// - [bit_sal](Self::bit_sal)\n    /// - [bit_sar](Self::bit_sar)\n    /// - [bit_xor](Self::bit_xor)\n    pub fn bit_not(self, cmd_number: Command) -\u003e Command {\n        cmd_number.bit_not()\n    }\n\n    /// Compute the left arithmetic shift (left logical shift) of one or more values.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// number.bit_sal(param_number) → number\n    /// r.bit_sal(cmd_number, param_number) → number\n    /// ```\n    ///\n    /// Where:\n    /// - param_number: i32 | [Command](crate::Command)\n    /// - cmd_number: [Command](crate::Command)\n    ///\n    /// # Description\n    ///\n    /// In an arithmetic shift (also referred to as signed shift),\n    /// like a logical shift, the bits that slide off the end disappear\n    /// (except for the last, which goes into the carry flag).\n    /// But in an arithmetic shift, the spaces are filled in such a way\n    /// to preserve the sign of the number being slid. For this reason,\n    /// arithmetic shifts are better suited for signed numbers in two’s\n    /// complement format.\n    ///\n    /// ## Note\n    ///\n    /// SHL and SAL are the same, and differentiation only happens because\n    /// SAR and SHR (right shifting) has differences in their implementation.\n    ///\n    /// ## Examples\n    ///\n    /// Compute the left arithmetic shift of 5 and 4\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: u8 = r.expr(5)\n    ///         .bit_sar(4)\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     let response2: u8 = r.bit_sar(r.expr(5), r.expr(4))\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == 80 \u0026\u0026 response == response2);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [bit_and](Self::bit_and)\n    /// - [bit_not](Self::bit_not)\n    /// - [bit_or](Self::bit_or)\n    /// - [bit_sar](Self::bit_sar)\n    /// - [bit_xor](Self::bit_xor)\n    pub fn bit_sal(self, cmd_number: Command, args: impl cmd::bit_sal::BitSalArg) -\u003e Command {\n        cmd_number.bit_sal(args)\n    }\n\n    /// Compute the right arithmetic shift of one or more values.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// number.bit_sar(param_number) → number\n    /// r.bit_sar(cmd_number, param_number) → number\n    /// ```\n    ///\n    /// Where:\n    /// - param_number: i32 | [Command](crate::Command)\n    /// - cmd_number: [Command](crate::Command)\n    ///\n    /// # Description\n    ///\n    /// In an arithmetic shift (also referred to as signed shift),\n    /// like a logical shift, the bits that slide off the end disappear\n    /// (except for the last, which goes into the carry flag).\n    /// But in an arithmetic shift, the spaces are filled in such\n    /// a way to preserve the sign of the number being slid.\n    /// For this reason, arithmetic shifts are better suited for\n    /// signed numbers in two’s complement format.\n    ///\n    /// ## Examples\n    ///\n    /// Compute the right arithmetic shift of 32 and 3\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response: u8 = r.expr(32)\n    ///         .bit_sar(3)\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     let response2: u8 = r.bit_sar(r.expr(32), r.expr(3))\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == 4 \u0026\u0026 response == response2);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [bit_and](Self::bit_and)\n    /// - [bit_not](Self::bit_not)\n    /// - [bit_or](Self::bit_or)\n    /// - [bit_sal](Self::bit_sal)\n    /// - [bit_xor](Self::bit_xor)\n    pub fn bit_sar(self, cmd_number: Command, args: impl cmd::bit_sar::BitSarArg) -\u003e Command {\n        cmd_number.bit_sar(args)\n    }\n\n    /// Return a time object representing the current time in UTC.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// r.now() → time\n    /// ```\n    ///\n    /// Where:\n    /// - time: [Time](crate::types::Time)\n    ///\n    /// # Description\n    ///\n    /// The command now() is computed once when the server receives the query,\n    /// so multiple instances of r.now() will always return the same time inside a query.\n    ///\n    /// ## Examples\n    ///\n    /// Create a time\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::types::Time;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///\n    ///     let time1: Time = r.now().value();\n    ///     let time2: Time = r.now()\n    ///         .cmd()\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(time1.is_valid());\n    ///     assert!(time2.is_valid());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [time](Self::time)\n    /// - [epoch_time](Self::epoch_time)\n    /// - [iso8601](Self::iso8601)\n    pub fn now(self) -\u003e DateTime {\n        DateTime::now()\n    }\n\n    /// Create a time object for a specific time.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// r.time(args!(date, timezone)) → time\n    /// r.time(args!(date, time_, timezone)) → time\n    /// ```\n    ///\n    /// Where:\n    /// - date: [time::Date](time::Date)\n    /// - time_: [time::Time](time::Time)\n    /// - timezone: [time::UtcOffset](time::UtcOffset)\n    /// - time: [Time](crate::types::Time)\n    ///\n    /// ## Examples\n    ///\n    /// Create a time\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::types::Time;\n    /// use reql_rust::{args, r, Result};\n    /// use time::macros::{date, offset, time};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let date = date!(1986 - 11 - 3);\n    ///     let time = time!(09:30:40);\n    ///     let timezone = offset!(+01:00);\n    ///\n    ///     let date_time = r.time(args!(date, time, timezone));\n    ///     let time1 = date_time.clone().value();\n    ///     let time2: Time = date_time.cmd()\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(time2 == time1);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [now](Self::now)\n    /// - [time](Self::time)\n    /// - [iso8601](Self::iso8601)\n    pub fn time(self, args: impl cmd::time::TimeArg) -\u003e DateTime {\n        DateTime::time(args)\n    }\n\n    /// Create a time object based on seconds since epoch.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// r.epoch_time(i64) → time\n    /// ```\n    ///\n    /// Where:\n    /// - time: [Time](crate::types::Time)\n    ///\n    /// ## Examples\n    ///\n    /// Create a time\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::types::Time;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let date_time = r.epoch_time(531360000)?;\n    ///     let time1 = date_time.clone().value();\n    ///     let time2: Time = date_time.cmd()\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(time2 == time1);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [now](Self::now)\n    /// - [time](Self::time)\n    /// - [iso8601](Self::iso8601)\n    pub fn epoch_time(self, timestamp: i64) -\u003e Result\u003cDateTime\u003e {\n        DateTime::epoch_time(timestamp)\n    }\n\n    /// Create a time object based on an ISO 8601\n    /// date-time string (e.g. ‘2013-01-01T01:01:01+00:00’).\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// r.iso8601(string) → time\n    /// r.iso8601(args!(string, default_timezone)) → time\n    /// ```\n    ///\n    /// Where:\n    /// - time: [Time](crate::types::Time)\n    /// - default_timezone: UtcOffset\n    ///\n    /// # Description\n    ///\n    /// RethinkDB supports all valid ISO 8601 formats except for week dates.\n    /// Read more about the ISO 8601 format at\n    /// [Wikipedia](http://en.wikipedia.org/wiki/ISO_8601).\n    ///\n    /// If you pass an ISO 8601 string without a time zone,\n    /// you must specify the time zone with the default_timezone argument.\n    ///\n    /// ## Examples\n    ///\n    /// Create a time\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::types::Time;\n    /// use reql_rust::{args, r, Result};\n    /// use time::macros::offset;\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let date_time = r.iso8601(args!(\"1986-11-03T08:30:00\", offset!(+01:00)))?;\n    ///     let time1 = date_time.clone().value();\n    ///     let time2: Time = date_time.cmd()\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(time2 == time1);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [now](Self::now)\n    /// - [time](Self::time)\n    /// - [epoch_time](Self::epoch_time)\n    pub fn iso8601(self, args: impl cmd::iso8601::Iso8601) -\u003e Result\u003cDateTime\u003e {\n        DateTime::iso8601(args)\n    }\n\n    /// Convert `HashMap` to `Command`\n    pub fn hash_map\u003cT\u003e(self, value: HashMap\u003cT, Command\u003e) -\u003e Command\n    where\n        T: Into\u003cString\u003e,\n    {\n        cmd::hash_map::new(value)\n    }\n\n    /// `r.args` is a special term that’s used to splice\n    /// an array of arguments into another term.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// r.args(array) → special\n    /// ```\n    /// Where:\n    /// - array: [Type; usize], Vec\u003cType\u003e, \u0026\\[Type]\n    ///\n    /// # Description\n    ///\n    /// This is useful when you want to call a variadic term such as\n    /// [get_all](crate::Command::get_all)\n    /// with a set of arguments produced at runtime.\n    ///\n    /// Note that `args` evaluates all its arguments before passing them\n    /// into the parent term, even if the parent term otherwise allows lazy evaluation.\n    ///\n    /// ## Examples\n    ///\n    /// Unpack array\n    ///\n    /// ```\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let data = vec![1, 2, 3];\n    ///\n    ///     let response: Vec\u003cu8\u003e = r.args(\u0026data)\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == data);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    pub fn args\u003cT, S\u003e(self, values: T) -\u003e Command\n    where\n        S: Serialize,\n        T: AsRef\u003c[S]\u003e + Serialize,\n    {\n        cmd::args::new(values)\n    }\n\n    /// Encapsulate binary data within a query.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// r.binary(data) → binary\n    /// ```\n    ///\n    /// Where:\n    /// - data: \u0026[u8]\n    /// - binary: [Binary](crate::types::Binary)\n    ///\n    /// # Description\n    ///\n    /// Binary struct returned to the client in Rust.\n    /// This can be changed with the `binary_format` option\n    /// provided to [run](crate::Command::run) to return “raw” objects.\n    ///\n    /// Only a limited subset of ReQL commands may be chained after `binary`:\n    /// - [coerce_to](crate::Command::coerce_to) can coerce binary objects to string types\n    /// - [count](Self::count) will return the number of bytes in the object\n    /// - [slice](crate::Command::slice) will treat bytes like array indexes\n    /// (i.e., slice(args!(10,20)) will return bytes 10–19)\n    /// - [type_of](crate::Command::type_of) returns `TypeOf::PtypeBinary`\n    /// - [info](Self::info) will return information on a binary struct.\n    ///\n    /// ## Examples\n    ///\n    /// Save an avatar image to a existing user record.\n    ///\n    /// ```\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let avatar_img = std::fs::read(\"default_avatar.png\")?;\n    ///     let conn = r.connection().connect().await?;\n    ///\n    ///     let response = r.table(\"images\")\n    ///         .insert(r.binary(\u0026avatar_img))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Get the size of an existing avatar image.\n    ///\n    /// ```\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///\n    ///     let response: usize = r.table(\"images\")\n    ///         .get(100)\n    ///         .g(\"avatar\")\n    ///         .count(())\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == 14156);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// Read more details about RethinkDB’s binary object support:\n    /// [Storing binary objects](\"https://rethinkdb.com/docs/storing-binary/python/\").\n    pub fn binary(self, data: \u0026[u8]) -\u003e Binary {\n        cmd::binary::new(data)\n    }\n\n    // FIXME Command no work\n    pub fn do_(self, args: impl cmd::do_::DoArg) -\u003e Command {\n        cmd::do_::new(args)\n    }\n\n    /// Perform a branching conditional equivalent to `if-then-else`.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// r.branch(test, args!(true_action, false_action)) → any\n    /// r.branch(test, args!(true_action, [(test2, test2_action), N], false_action)) → any\n    /// query.branch(args!(true_action, false_action)) -\u003e any\n    /// query.branch(args!(true_action, [(test2, test2_action), N], false_action)) → any\n    /// ```\n    ///\n    /// Where:\n    /// - test, true_action, false_action, test2, test2_action: r.expr(...)\n    ///\n    /// # Description\n    ///\n    /// The `branch` command takes 2n+1 arguments: pairs of conditional expressions\n    /// and commands to be executed if the conditionals return any value but `false`\n    /// or `None` i.e., “truthy” values), with a final “else” command to be evaluated\n    /// if all of the conditionals are `false` or `None`.\n    ///\n    /// You may call `branch` infix style on the first test.\n    /// (See the second example for an illustration.)\n    ///\n    /// ```text\n    /// r.branch(test1, args!(val1, [(test2, val2)], elseval))\n    /// ```\n    ///\n    /// is the equivalent of the Rust statement\n    ///\n    /// ```text\n    /// if (test1) {\n    ///     val1\n    /// } else if (test2) {\n    ///     val2\n    /// } else {\n    ///     elseval\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Test the value of x.\n    ///\n    /// ```\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let x = 10;\n    ///     let conn = r.connection().connect().await?;\n    ///\n    ///     let response: String = r.branch(\n    ///             r.expr(x \u003e 5),\n    ///             args!(r.expr(\"big\"), r.expr(\"small\"))\n    ///         ).run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response.eq(\"big\"));\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// As above, infix-style.\n    ///\n    /// ```\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let x = 10;\n    ///     let conn = r.connection().connect().await?;\n    ///\n    ///     let response: String = r.expr(x \u003e 5)\n    ///         .branch(args!(r.expr(\"big\"), r.expr(\"small\")))\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response.eq(\"big\"));\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Categorize heroes by victory counts.\n    ///\n    /// ```\n    /// use std::ops::Add;\n    ///\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///\n    ///     let response = r.table(\"pricings\")\n    ///         .map(func!(|offer| r.branch(\n    ///             offer.clone().g(\"price\").gt(100),\n    ///             args!(\n    ///                 offer.clone().g(\"offer\").add(\"premium\"),\n    ///                 [(\n    ///                     offer.clone().g(\"price\").gt(10),\n    ///                     offer.clone().g(\"offer\").add(\"standard\")\n    ///                 )],\n    ///                 offer.g(\"offer\").add(\"freemium\")\n    ///         ))))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [do_](Self::do_)\n    pub fn branch(self, test: Command, args: impl cmd::branch::BranchArg) -\u003e Command {\n        test.branch(args)\n    }\n\n    /// Generate a stream of sequential integers in a specified range.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// r.range(()) → stream\n    /// r.range(end_value) → stream\n    /// r.range(args!(start_value, end_value)) → stream\n    /// ```\n    ///\n    /// Where\n    /// - start_value, end_value: isize\n    ///\n    /// # Description\n    ///\n    /// `range` takes 0, 1 or 2 arguments:\n    /// - With no arguments, `range` returns an “infinite” stream\n    /// from 0 up to and including the maximum integer value;\n    /// - With one argument, `range` returns a stream from\n    /// 0 up to but not including the end value;\n    /// - With two arguments, `range` returns a stream from\n    /// the start value up to but not including the end value.\n    ///\n    /// Note that the left bound (including the implied left\n    /// bound of 0 in the 0- and 1-argument form)\n    /// is always closed and the right bound is always open:\n    /// the start value will always be included in the returned range\n    /// and the end value will **not** be included in the returned range.\n    ///\n    /// Any specified arguments must be integers, or a `ReqlRuntimeError` will be thrown.\n    /// If the start value is equal or to higher than the end value,\n    /// no error will be thrown but a zero-element stream will be returned.\n    ///\n    /// ## Examples\n    ///\n    /// Return a four-element range of `[0, 1, 2, 3]`.\n    ///\n    /// ```\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///\n    ///     let response: [u8; 4] = r.range(4)\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == [0, 1, 2, 3]);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// You can also use the [limit](crate::Command::limit)\n    /// command with the no-argument\n    /// variant to achieve the same result in this case:\n    ///\n    /// ```\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///\n    ///     let response: [u8; 4] = r.range(())\n    ///         .limit(4)\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == [0, 1, 2, 3]);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Return a range from -5 through 5.\n    ///\n    /// ```\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///\n    ///     let response: [i8; 11] = r.range(args!(-5, 6))\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == [-5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5]);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    pub fn range(self, args: impl cmd::range::RangeArg) -\u003e Command {\n        cmd::range::new(args)\n    }\n\n    /// Throw a runtime error.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// r.expr(value) → value\n    /// ```\n    ///\n    /// # Description\n    ///\n    /// If called with no arguments inside the second\n    /// argument to default, re-throw the current error.\n    ///\n    /// ## Examples\n    ///\n    /// Get Error\n    ///\n    /// ```\n    /// use reql_rust::{r, ReqlError, ReqlRuntimeError, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let msg = \"Error\";\n    ///\n    ///     let err = r.error(msg).run(\u0026conn).await.err().unwrap();\n    ///\n    ///     if let ReqlError::Runtime(err) = err {\n    ///         if let ReqlRuntimeError::User(err) = err {\n    ///             assert!(err == msg);\n    ///     \n    ///             return Ok(());\n    ///         }\n    ///     }\n    ///\n    ///     assert!(false);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    pub fn error(self, message: impl Into\u003cString\u003e) -\u003e Command {\n        cmd::error::new(message)\n    }\n\n    /// Construct a ReQL JSON object from a native object.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// r.expr(value) → value\n    /// ```\n    ///\n    /// # Description\n    ///\n    /// If the native object is of the `Binary` type,\n    /// then expr will return a binary object.\n    /// See [binary](Self::binary) for more information.\n    ///\n    /// ## Examples\n    ///\n    /// Objects wrapped with `expr` can then be manipulated by ReQL API functions.\n    ///\n    /// ```\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let data = [1, 2, 3];\n    ///\n    ///     let response: [u8; 3] = r.expr(data)\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == data);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    pub fn expr(self, value: impl Serialize) -\u003e Command {\n        cmd::expr::new(value)\n    }\n\n    /// Create a javascript expression.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// r.uuid(()) → String\n    /// r.uuid(\u0026str) → String\n    /// ```\n    ///\n    /// # Description\n    ///\n    /// ```text\n    /// Whenever possible, you should use native ReQL\n    /// commands rather than r.js for better performance.\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Concatenate two strings using JavaScript.\n    ///\n    /// ```\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///\n    ///     let response: String = r.js(\"'str1' + 'str2'\")\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response.eq(\"str1str2\"));\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// You may also specify a timeout in seconds (defaults to 5).\n    ///\n    /// ```\n    /// use reql_rust::cmd::js::JsOption;\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::{args, r, Result};\n    /// use serde_json::json;\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///\n    ///     let response = r.js(args!(\n    ///             \"while(true) {}\",\n    ///             JsOption::default().timeout(1.3)\n    ///             ))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    pub fn js(self, args: impl cmd::js::JsArg) -\u003e Command {\n        cmd::js::new(args)\n    }\n\n    /// Get information about a ReQL value.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// any.info() → response\n    /// r.info(any) → response\n    /// ```\n    ///\n    /// Where:\n    /// - response: [InfoResponse](crate::types::InfoResponse)\n    ///\n    /// ## Examples\n    ///\n    /// Get information about a table such as primary key, or cache size.\n    ///\n    /// ```\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::types::{InfoResponse, TypeOf};\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///\n    ///     let response: InfoResponse = r.table(\"simbad\")\n    ///         .info()\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response.typ == TypeOf::Table);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    pub fn info(self, any: Command) -\u003e Command {\n        any.info()\n    }\n\n    /// Parse a JSON string on the server.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// r.json(json_string) → value\n    /// ```\n    ///\n    /// Where:\n    /// - json_string: impl Into\u003cString\u003e\n    ///\n    /// ## Examples\n    ///\n    /// Send an array to the server.\n    ///\n    /// ```\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///\n    ///     let response: [u8; 3] = r.json(\"[1,2,3]\")\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == [1, 2, 3]);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    pub fn json(self, value: impl Into\u003cString\u003e) -\u003e Command {\n        cmd::json::new(value)\n    }\n\n    /// Retrieve data from the specified URL over HTTP.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// r.http(string) → value\n    /// r.http(args!(string, options)) → value\n    /// ```\n    ///\n    /// Where:\n    /// - string: impl Into\u003cString\u003e\n    /// - options: impl Serialize\n    ///\n    /// # Description\n    ///\n    /// The return type depends on the `result_format` option,\n    /// which checks the `Content-Type` of the response by default.\n    ///\n    /// See [External API access](https://rethinkdb.com/docs/external-api-access/)\n    /// for more informations\n    ///\n    /// ## Examples\n    ///\n    /// Perform an HTTP GET and store the result in a table.\n    ///\n    /// ```\n    /// use reql_rust::types::MutationResponse;\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///\n    ///     let response: MutationResponse = r.table(\"simbad\")\n    ///         .insert(r.http(\"http://httpbin.org/get\"))\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response.inserted == 1);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Perform request with parameters.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{args, r, Result};\n    /// use serde_json::json;\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///\n    ///     let response = r.http(args!(\"http://httpbin.org/get\", json!({\n    ///             \"params\": {\n    ///                 \"user\": 1\n    ///             }\n    ///         })))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Perform a `POST` request with accompanying data.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{args, r, Result};\n    /// use serde_json::json;\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///\n    ///     let response = r.http(args!(\"http://httpbin.org/get\", json!({\n    ///             \"method\": \"method\",\n    ///             \"data\": {\n    ///                 \"player\": \"Moussa\",\n    ///                 \"game\": \"AURION\"\n    ///             }\n    ///         })))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Perform a GitHub search and collect up to 3 pages of results.\n    ///\n    /// ```\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{args, r, Result};\n    /// use serde_json::json;\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///\n    ///     let response = r.http(args!(\"https://api.github.com/search/code?q=addClass+user:mozilla\", json!({\n    ///             \"page\": \"link-next\",\n    ///             \"page_limit\": 3\n    ///         })))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    pub fn http\u003cT\u003e(self, args: impl cmd::http::HttpArg\u003cT\u003e) -\u003e Command\n    where\n        T: Serialize,\n    {\n        cmd::http::new(args)\n    }\n\n    /// Return a UUID (universally unique identifier),\n    /// a string that can be used as a unique ID.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// r.uuid(()) → String\n    /// r.uuid(\u0026str) → String\n    /// ```\n    ///\n    /// # Description\n    ///\n    /// If a string is passed to uuid as an argument,\n    /// the UUID will be deterministic,\n    /// derived from the string’s SHA-1 hash.\n    ///\n    /// RethinkDB’s UUIDs are standards-compliant.\n    /// Without the optional argument,\n    /// a version 4 random UUID will be generated;\n    /// with that argument, a version 5 UUID will be generated,\n    /// using a fixed namespace UUID of `91461c99-f89d-49d2-af96-d8e2e14e9b58`.\n    /// For more information, read\n    /// [Wikipedia’s UUID article](https://en.wikipedia.org/wiki/Universally_unique_identifier).\n    ///\n    /// ## Examples\n    ///\n    /// Generate a UUID.\n    ///\n    /// ```\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::{args, r, Result};\n    /// use serde_json::json;\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///\n    ///     let response: String = r.uuid(())\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response.eq(\"27961a0e-f4e8-4eb3-bf95-c5203e1d87b9\"));\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Generate a UUID based on a String.\n    ///\n    /// ```\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::{args, r, Result};\n    /// use serde_json::json;\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///\n    ///     let response: String = r.uuid(\"malik@example.com\")\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response.eq(\"3461d115-2c05-5af4-9906-9f6882c58a15\"));\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    pub fn uuid(self, args: impl cmd::uuid::UuidArg) -\u003e Command {\n        cmd::uuid::new(args)\n    }\n\n    /// Construct a circular line or polygon.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// r.circle(args!(point, radius)) → polygon\n    /// r.circle(args!(point, radius, options)) → polygon\n    /// ```\n    ///\n    /// Where:\n    /// - radius: f64,\n    /// - point: [Point](crate::cmd::point::Point)\n    /// - polygon: [Polygon](crate::cmd::polygon::Polygon)\n    ///\n    /// # Description\n    ///\n    /// A circle in RethinkDB is a polygon or line **approximating**\n    /// a circle of a given radius around a given center,\n    /// consisting of a specified number of vertices (default 32).\n    ///\n    /// The center may be specified either by two floating point numbers, the longitude\n    /// (−180 to 180) and latitude (−90 to 90) of the point on a perfect sphere\n    /// (See [Geospatial support](https://rethinkdb.com/docs/geo-support/python/)\n    /// for more information on ReQL’s coordinate system), or by a point object.\n    /// The radius is a floating point number whose units are meters by default,\n    /// although that may be changed with the `unit` argument.\n    ///\n    /// ## Examples\n    ///\n    /// Define a point.\n    ///\n    /// ```\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::types::Polygon;\n    /// use reql_rust::{args, r, Result};\n    /// use serde_json::json;\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let circle: Polygon = r.circle(args!(r.point(-122.423246, 37.779388), 50.5))\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     let response = r.table(\"geo\")\n    ///         .insert(json!({\n    ///             \"id\": 300,\n    ///             \"name\": \"Douala\",\n    ///             \"location\": circle\n    ///         }))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [line](Self::line)\n    /// - [polygon](Self::polygon)\n    /// - [point](Self::point)\n    /// - [distance](crate::Command::distance)\n    pub fn circle(self, args: impl cmd::circle::CircleArg) -\u003e Command {\n        cmd::circle::new(args)\n    }\n\n    /// Compute the distance between a point and another geometry object.\n    /// At least one of the geometry objects specified must be a point.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// geometry.distance(geometry) → f64\n    /// geometry.distance(args!(geometry, options)) → f64\n    /// r.distance(geometry.cmd(), geometry) → f64\n    /// r.distance(geometry.cmd(), args!(geometry, options)) → f64\n    /// ```\n    ///\n    /// Where:\n    /// - geometry: [r.point(...)](crate::r::point) |\n    /// [r.line(...)](crate::r::line) |\n    /// [r.polygon(...)](crate::r::polygon)\n    /// command\n    /// - options: [DistanceOption](crate::cmd::distance::DistanceOption)\n    ///\n    /// # Description\n    ///\n    /// If one of the objects is a polygon or a line, the point will be projected\n    /// into the line or polygon assuming a perfect sphere model before the distance\n    /// is computed (using the model specified with `geo_system`).\n    /// As a consequence, if the polygon or line is extremely large compared\n    /// to Earth’s radius and the distance is being computed with the default\n    ///  WGS84 model, the results of `distance` should be considered approximate\n    /// due to the deviation between the ellipsoid and spherical models.\n    ///\n    /// ## Examples\n    ///\n    /// Compute the distance between two points on the Earth in kilometers.\n    ///\n    /// ```\n    /// use reql_rust::arguments::Unit;\n    /// use reql_rust::cmd::distance::DistanceOption;\n    /// use reql_rust::prelude::*;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let point1 = r.point(-122.423246, 37.779388);\n    ///     let point2 = r.point(-117.220406, 32.719464);\n    ///     let distance_option = DistanceOption::default().unit(Unit::Kilometer);\n    ///\n    ///     let response: f64 = r.distance(point1.cmd(), point2)\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response == 734.125249602186);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [polygon](crate::r::polygon)\n    /// - [line](crate::r::line)\n    pub fn distance(self, geometry: Command, args: impl cmd::distance::DistanceArg) -\u003e Command {\n        geometry.distance(args)\n    }\n\n    /// Convert a [GeoJSON](https://geojson.org/) object to a ReQL geometry object.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// r.geojson(geojson) → geometry\n    /// ```\n    ///\n    /// Where:\n    /// - geojson: [GeoJson](crate::types::GeoJson),\n    /// - geometry: [ReqlGeoJson](crate::types::ReqlGeoJson)\n    ///\n    /// # Description\n    ///\n    /// RethinkDB only allows conversion of GeoJSON objects\n    /// which have ReQL equivalents: Point, LineString, and Polygon.\n    ///  MultiPoint, MultiLineString, and MultiPolygon are not supported.\n    /// (You could, however, store multiple points, lines and polygons\n    /// in an array and use a geospatial multi index with them.)\n    ///\n    /// Only longitude/latitude coordinates are supported.\n    /// GeoJSON objects that use Cartesian coordinates,\n    /// specify an altitude, or specify their own coordinate\n    /// reference system will be rejected.\n    ///\n    /// ## Examples\n    ///\n    /// Convert a GeoJSON object to a ReQL geometry object.\n    ///\n    /// ```\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::types::{GeoJson, GeoType};\n    /// use reql_rust::{args, r, Result};\n    /// use serde_json::json;\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let geo_json = GeoJson {\n    ///         typ: GeoType::Point,\n    ///         coordinates: [-122.423246, 37.779388],\n    ///     };\n    ///\n    ///     let response = r.table(\"geo\")\n    ///         .insert(json!({\n    ///             \"id\": 1,\n    ///             \"name\": \"Yaoundé\",\n    ///             \"location\": r.geojson(geo_json)\n    ///         }))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [to_geojson](crate::Command::to_geojson)\n    pub fn geojson\u003cT: Serialize\u003e(self, geojson: GeoJson\u003cT\u003e) -\u003e cmd::geojson::ReqlGeoJson\u003cT\u003e {\n        cmd::geojson::ReqlGeoJson::new(geojson)\n    }\n\n    /// Construct a geometry object of type Polygon.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// r.line(points) → line\n    /// ```\n    ///\n    /// Where:\n    /// - points: \u0026[[Point](crate::types::Point)]\n    /// - line: [Polygon](crate::types::Line)\n    ///\n    /// # Description\n    ///\n    /// The line can be specified in one of two ways:\n    /// - Two or more two-item arrays, specifying latitude\n    /// and longitude numbers of the line’s vertices;\n    /// - Two or more [Point](crate::types::Point)\n    /// objects specifying the line’s vertices.\n    ///\n    /// Longitude (−180 to 180) and latitude (−90 to 90)\n    /// of vertices are plotted on a perfect sphere.\n    /// See [Geospatial support](https://rethinkdb.com/docs/geo-support/python/)\n    /// for more information on ReQL’s coordinate system.\n    ///\n    /// ## Examples\n    ///\n    /// Define a line.\n    ///\n    /// ```\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::{args, r, Result};\n    /// use serde_json::json;\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///\n    ///     let response = r.table(\"geo\")\n    ///         .insert(json!({\n    ///             \"id\": 101,\n    ///             \"route\": r.line(\u0026[\n    ///                 r.point(-122.423246, 37.779388),\n    ///                 r.point(-121.886420, 37.329898),\n    ///             ])\n    ///         }))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [point](Self::point)\n    /// - [polygon](Self::polygon)\n    /// - [circle](Self::circle)\n    pub fn line(self, points: \u0026[cmd::point::Point]) -\u003e cmd::line::Line {\n        cmd::line::Line::new(points)\n    }\n\n    /// Construct a geometry object of type Point.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// r.point(longitude, latitude) → point\n    /// ```\n    ///\n    /// Where:\n    /// - latitude: f64,\n    /// - longitude: f64,\n    /// - points: \u0026[[Point](crate::cmd::point::Point)]\n    ///\n    /// # Description\n    ///\n    /// The point is specified by two floating point numbers, the longitude\n    /// (−180 to 180) and latitude (−90 to 90) of the point on a perfect sphere.\n    /// See [Geospatial support](https://rethinkdb.com/docs/geo-support/python/)\n    /// for more information on ReQL’s coordinate system.\n    ///\n    /// ## Examples\n    ///\n    /// Define a point.\n    ///\n    /// ```\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::{args, r, Result};\n    /// use serde_json::json;\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///\n    ///     let response = r.table(\"geo\")\n    ///         .insert(json!({\n    ///             \"id\": 1,\n    ///             \"name\": \"Yaoundé\",\n    ///             \"location\": r.point(-122.423246, 37.779388)\n    ///         }))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [line](Self::line)\n    /// - [polygon](Self::polygon)\n    /// - [circle](Self::circle)\n    pub fn point(self, longitude: f64, latitude: f64) -\u003e cmd::point::Point {\n        cmd::point::Point::new(longitude, latitude)\n    }\n\n    /// Construct a geometry object of type Polygon.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// r.polygon(points) → polygon\n    /// ```\n    ///\n    /// Where:\n    /// - points: \u0026[[Point](crate::cmd::point::Point)]\n    /// - polygon: [Polygon](crate::cmd::polygon::Polygon)\n    ///\n    /// # Description\n    ///\n    /// The Polygon can be specified in one of two ways:\n    /// - Three or more two-item arrays, specifying latitude\n    /// and longitude numbers of the polygon’s vertices;\n    /// - Three or more [Point](crate::cmd::point::Point)\n    /// objects specifying the polygon’s vertices.\n    ///\n    /// Longitude (−180 to 180) and latitude (−90 to 90)\n    /// of vertices are plotted on a perfect sphere.\n    /// See [Geospatial support](https://rethinkdb.com/docs/geo-support/python/)\n    /// for more information on ReQL’s coordinate system.\n    ///\n    /// If the last point does not specify the same coordinates as\n    /// the first point, `polygon` will close the polygon by connecting them.\n    /// You cannot directly construct a polygon with holes in it using `polygon`,\n    /// but you can use [polygon_sub](crate::types::Polygon::polygon_sub)\n    /// to use a second polygon within the interior of the first to define a hole.\n    ///\n    /// ## Examples\n    ///\n    /// Define a polygon.\n    ///\n    /// ```\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::{args, r, Result};\n    /// use serde_json::json;\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///\n    ///     let response = r.table(\"geo\")\n    ///         .insert(json!({\n    ///             \"id\": 101,\n    ///             \"rectangle\": r.polygon(\u0026[\n    ///                 r.point(-122.423246, 37.779388),\n    ///                 r.point(-122.423246, 37.329898),\n    ///                 r.point(-121.886420, 37.329898),\n    ///                 r.point(-121.886420, 37.779388),\n    ///             ])\n    ///         }))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [point](Self::point)\n    /// - [line](Self::line)\n    /// - [circle](Self::circle)\n    pub fn polygon(self, points: \u0026[cmd::point::Point]) -\u003e cmd::polygon::Polygon {\n        cmd::polygon::Polygon::new(points)\n    }\n\n    /// Tests whether two geometry objects intersect with one another.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// geometry.intersects(geometry) → bool\n    /// r.intersects(geometry_command, geometry) → bool\n    /// sequence.intersects(geometry) → sequence_response\n    /// r.intersects(sequence, geometry) → sequence_response\n    /// ```\n    ///\n    /// Where:\n    /// - geometry: [r.point(...)](crate::r::point) |\n    /// [r.line(...)](crate::r::line) |\n    /// [r.polygon(...)](crate::r::polygon) |\n    /// command\n    /// - sequence, geometry_command: [Command](crate::Command)\n    ///\n    /// # Description\n    ///\n    /// When applied to a sequence of geometry objects, `intersects` acts as a\n    /// [filter](crate::Command::filter), returning a sequence of objects from\n    /// the sequence that intersect with the argument.\n    ///\n    /// ## Examples\n    ///\n    /// Is `point2` within a 2000-meter circle around `point1`?\n    ///\n    /// ```\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let point1 = r.point(-117.220406, 32.719464);\n    ///     let point2 = r.point(-117.206201, 32.725186);\n    ///     let circle_cmd = r.circle(args!(point1, 2000.));\n    ///\n    ///     let response: bool = r.intersects(circle_cmd, point2)\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Which of the locations in a list of parks intersect `circle`?\n    ///\n    /// ```\n    /// use reql_rust::arguments::Unit;\n    /// use reql_rust::cmd::circle::CircleOption;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let point = r.point(-117.220406, 32.719464);\n    ///     let circle_opts = CircleOption::default().unit(Unit::InternationalMile);\n    ///     let circle = r.circle(args!(point, 10., circle_opts));\n    ///\n    ///     let response = r.intersects(r.table(\"parks\").g(\"area\"), circle)\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Related commands\n    /// - [includes](crate::Command::includes)\n    /// - [get_intersecting](crate::Command::get_intersecting)\n    pub fn intersects(\n        self,\n        geometry: Command,\n        args: impl cmd::intersects::IntersectsArg,\n    ) -\u003e Command {\n        geometry.intersects(args)\n    }\n\n    /// Grant or deny access permissions for a user account,\n    /// globally or on a per-database or per-table basis.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// r.grant(username, permission) → response\n    /// table.grant(username, permission) → response\n    /// db.grant(username, permission) → response\n    /// ```\n    ///\n    /// Where:\n    /// - table: [r.table(...)](crate::r::table) |\n    /// [query.table(...)](Self::table)\n    /// - db: [r.db(...)](crate::r::db)\n    /// - response: [GrantResponse](crate::types::GrantResponse)\n    ///\n    /// # Description\n    ///\n    /// Permissions that are not defined on a local scope will\n    /// be inherited from the next largest scope.\n    /// For example, a write operation on a table will first\n    /// check if `write` permissions are explicitly set to `true` or `false`\n    /// for that table and account combination; if they are not,\n    /// the `write` permissions for the database will be used\n    /// if those are explicitly set; and if neither table nor database\n    /// permissions are set for that account, the global `write`\n    /// permissions for that account will be used.\n    ///\n    /// ## Note\n    ///\n    /// For all accounts other than the special, system-defined `admin` account,\n    /// permissions that are not explicitly set in any scope will effectively be `false`.\n    /// When you create a new user account by inserting a record into the\n    /// [system table](https://rethinkdb.com/docs/system-tables/#users),\n    /// that account will have **no** permissions until they are explicitly granted.\n    ///\n    /// For a full description of permissions, read\n    /// [Permissions and user accounts](https://rethinkdb.com/docs/permissions-and-accounts/).\n    ///\n    /// ## Examples\n    ///\n    /// Grant the `alima` user account read and write permissions on the `users` database.\n    ///\n    /// ```\n    /// use reql_rust::arguments::Permission;\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::types::GrantResponse;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let permission = Permission::default().read(true).write(true);\n    ///\n    ///     let response: GrantResponse = r.db(\"users\")\n    ///         .grant(\"alima\", permission)\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response.granted == 1);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Deny write permissions from the `alima` account for the `simbad` table.\n    ///\n    /// ```\n    /// use reql_rust::arguments::Permission;\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::types::GrantResponse;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let permission = Permission::default().write(false);\n    ///\n    ///     let response: GrantResponse = r.db(\"users\")\n    ///         .table(\"simbad\")\n    ///         .grant(\"alima\", permission)\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response.granted == 1);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Grant `alima` the ability to use HTTP connections.\n    ///\n    /// ```\n    /// use reql_rust::arguments::Permission;\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::types::GrantResponse;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let permission = Permission::default().connect(true);\n    ///\n    ///     let response: GrantResponse = r.grant(\"alima\", permission)\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response.granted == 1);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Grant a `monitor` account read-only access to all databases.\n    ///\n    /// ```\n    /// use reql_rust::arguments::Permission;\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::types::GrantResponse;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let permission = Permission::default().read(true);\n    ///\n    ///     let response: GrantResponse = r.grant(\"monitor\", permission)\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response.granted == 1);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    pub fn grant(self, username: \u0026str, permission: Permission) -\u003e Command {\n        cmd::grant::new(username, permission)\n    }\n\n    /// Wait for a table or all the tables in a database to be ready.\n    ///\n    /// # Command syntax\n    ///\n    /// ```text\n    /// table.wait(()) → response\n    /// db.wait(()) → response\n    /// r.wait(table) → response\n    /// r.wait(database) → response\n    /// table.wait(options) → response\n    /// db.wait(options) → response\n    /// r.wait(args!(table, options)) → response\n    /// r.wait(args!(database, options)) → response\n    /// ```\n    ///\n    /// Where:\n    /// - table: [r.table(...)](crate::r::table) |\n    /// [query.table(...)](Self::table)\n    /// - db: [r.db(...)](crate::r::db)\n    /// - options: [WaitOption](crate::cmd::wait::WaitOption)\n    /// - response: [WaitResponse](crate::types::WaitResponse)\n    ///\n    /// # Description\n    ///\n    /// A table may be temporarily unavailable after creation,\n    /// rebalancing or reconfiguring.\n    /// The `wait` command blocks until the given\n    /// table (or database) is fully up to date.\n    ///\n    /// ## Examples\n    ///\n    /// Wait on a table to be ready.\n    ///\n    /// ```\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::types::WaitResponse;\n    /// use reql_rust::{r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///\n    ///     let response: WaitResponse = r.table(\"simbad\")\n    ///         .wait(())\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response.ready == 1);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// ## Examples\n    ///\n    /// Wait on a table with timeout to be ready for reads.\n    ///\n    /// ```\n    /// use reql_rust::arguments::WaitFor;\n    /// use reql_rust::cmd::wait::WaitOption;\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::types::WaitResponse;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let table_command = r.db(\"anim\").table(\"simbad\");\n    ///     let opts = WaitOption::default()\n    ///         .wait_for(WaitFor::ReadyForReads)\n    ///         .timeout(8000f64);\n    ///\n    ///     let response: WaitResponse =  r.wait(args!(table_command, opts))\n    ///         .run(\u0026conn)\n    ///         .await?\n    ///         .unwrap()\n    ///         .parse()?;\n    ///\n    ///     assert!(response.ready == 1);\n    ///     \n    ///     Ok(())\n    /// }\n    /// ```\n    pub fn wait(self, args: impl cmd::wait::WaitArg) -\u003e Command {\n        cmd::wait::new(args)\n    }\n\n    /// To specify the descending ordering.\n    ///\n    /// # Command syntax\n    /// ```text\n    /// r.asc(field)\n    /// r.asc(func)\n    /// ```\n    ///\n    /// Where:\n    /// - field: String, \u0026str\n    /// - func: func!(...)\n    ///\n    /// ## Example\n    ///\n    /// ```\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"simbad\")\n    ///         .order_by(args!(r.expr(\"id\"), r.asc(\"character\")))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///\n    ///     Ok(())\n    /// }\n    /// ```\n    pub fn asc(self, args: impl cmd::asc::AscArg) -\u003e Command {\n        cmd::asc::new(args)\n    }\n\n    /// To specify the descending ordering.\n    ///\n    /// # Command syntax\n    /// ```text\n    /// r.desc(field)\n    /// r.desc(func)\n    /// ```\n    ///\n    /// Where:\n    /// - field: String, \u0026str\n    /// - func: func!(...)\n    ///\n    /// ## Example\n    ///\n    /// ```\n    /// use reql_rust::prelude::Converter;\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"simbad\")\n    ///         .order_by(args!(r.expr(\"id\"), r.desc(\"character\")))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///\n    ///     Ok(())\n    /// }\n    /// ```\n    pub fn desc(self, args: impl cmd::desc::DescArg) -\u003e Command {\n        cmd::desc::new(args)\n    }\n\n    /// max_val are used with some commands such as `between`\n    /// to specify absolute upper bounds.\n    ///\n    /// # Command syntax\n    /// ```text\n    /// r::min_val()\n    /// ```\n    ///\n    /// ## Example\n    ///\n    /// ```\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"simbad\")\n    ///         .between(args!(r::min_val(), r.expr(20)))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///\n    ///     Ok(())\n    /// }\n    /// ```\n    pub fn min_val() -\u003e Command {\n        Command::new(ql2::term::TermType::Minval)\n    }\n\n    /// max_val are used with some commands such as `between`\n    /// to specify absolute upper bounds.\n    ///\n    /// # Command syntax\n    /// ```text\n    /// r::max_val()\n    /// ```\n    ///\n    /// ## Example\n    ///\n    /// ```\n    /// use reql_rust::{args, r, Result};\n    ///\n    /// async fn example() -\u003e Result\u003c()\u003e {\n    ///     let conn = r.connection().connect().await?;\n    ///     let response = r.table(\"simbad\")\n    ///         .between(args!(r.expr(10), r::max_val()))\n    ///         .run(\u0026conn)\n    ///         .await?;\n    ///\n    ///     assert!(response.is_some());\n    ///\n    ///     Ok(())\n    /// }\n    /// ```\n    pub fn max_val() -\u003e Command {\n        Command::new(ql2::term::TermType::Maxval)\n    }\n}\n\n// Helper for making writing examples less verbose\n#[doc(hidden)]\npub fn example\u003c'a, Q, F, S\u003e(_query: Q)\nwhere\n    Q: FnOnce(r, \u0026'a mut Session) -\u003e async_stream::AsyncStream\u003c(), F\u003e,\n    F: futures::Future\u003cOutput = S\u003e,\n    S: futures::Stream\u003cItem = Result\u003cserde_json::Value\u003e\u003e,\n{\n}\n","traces":[{"line":36,"address":[4751456],"length":1,"stats":{"Line":4},"fn_name":"connection"},{"line":37,"address":[4751468],"length":1,"stats":{"Line":4},"fn_name":null},{"line":40,"address":[4751488],"length":1,"stats":{"Line":1},"fn_name":"db_create"},{"line":41,"address":[4751510],"length":1,"stats":{"Line":1},"fn_name":null},{"line":44,"address":[4751536],"length":1,"stats":{"Line":1},"fn_name":"db_drop"},{"line":45,"address":[4751558],"length":1,"stats":{"Line":1},"fn_name":null},{"line":48,"address":[4751584],"length":1,"stats":{"Line":1},"fn_name":"db_list"},{"line":49,"address":[4751596],"length":1,"stats":{"Line":1},"fn_name":null},{"line":52,"address":[4751616],"length":1,"stats":{"Line":3},"fn_name":"db"},{"line":53,"address":[4751638],"length":1,"stats":{"Line":3},"fn_name":null},{"line":56,"address":[4106832],"length":1,"stats":{"Line":6},"fn_name":"table_create\u003c\u0026str\u003e"},{"line":57,"address":[4106854],"length":1,"stats":{"Line":6},"fn_name":null},{"line":60,"address":[4751664],"length":1,"stats":{"Line":1},"fn_name":"table_drop"},{"line":61,"address":[4751686],"length":1,"stats":{"Line":1},"fn_name":null},{"line":64,"address":[4751712],"length":1,"stats":{"Line":1},"fn_name":"table_list"},{"line":65,"address":[4751724],"length":1,"stats":{"Line":1},"fn_name":null},{"line":68,"address":[4106880],"length":1,"stats":{"Line":6},"fn_name":"table\u003c\u0026str\u003e"},{"line":69,"address":[4106902],"length":1,"stats":{"Line":6},"fn_name":null},{"line":120,"address":[4106928],"length":1,"stats":{"Line":1},"fn_name":"object\u003c\u0026str\u003e"},{"line":121,"address":[4106939],"length":1,"stats":{"Line":1},"fn_name":null},{"line":124,"address":[4106992],"length":1,"stats":{"Line":1},"fn_name":"and\u003calloc::vec::Vec\u003cbool, alloc::alloc::Global\u003e\u003e"},{"line":125,"address":[4107003],"length":1,"stats":{"Line":1},"fn_name":null},{"line":128,"address":[4107056],"length":1,"stats":{"Line":1},"fn_name":"or\u003calloc::vec::Vec\u003cbool, alloc::alloc::Global\u003e\u003e"},{"line":129,"address":[4107067],"length":1,"stats":{"Line":1},"fn_name":null},{"line":132,"address":[4107120],"length":1,"stats":{"Line":1},"fn_name":"eq\u003calloc::vec::Vec\u003ci32, alloc::alloc::Global\u003e\u003e"},{"line":133,"address":[4107131],"length":1,"stats":{"Line":1},"fn_name":null},{"line":136,"address":[4107184],"length":1,"stats":{"Line":1},"fn_name":"ne\u003calloc::vec::Vec\u003ci32, alloc::alloc::Global\u003e\u003e"},{"line":137,"address":[4107195],"length":1,"stats":{"Line":1},"fn_name":null},{"line":140,"address":[4107248],"length":1,"stats":{"Line":1},"fn_name":"gt\u003creql_rust::arguments::Args\u003calloc::vec::Vec\u003ci32, alloc::alloc::Global\u003e\u003e\u003e"},{"line":141,"address":[4107259],"length":1,"stats":{"Line":1},"fn_name":null},{"line":144,"address":[4107312],"length":1,"stats":{"Line":1},"fn_name":"ge\u003creql_rust::arguments::Args\u003calloc::vec::Vec\u003ci32, alloc::alloc::Global\u003e\u003e\u003e"},{"line":145,"address":[4107323],"length":1,"stats":{"Line":1},"fn_name":null},{"line":148,"address":[4107376],"length":1,"stats":{"Line":1},"fn_name":"lt\u003creql_rust::arguments::Args\u003calloc::vec::Vec\u003ci32, alloc::alloc::Global\u003e\u003e\u003e"},{"line":149,"address":[4107387],"length":1,"stats":{"Line":1},"fn_name":null},{"line":152,"address":[4107440],"length":1,"stats":{"Line":1},"fn_name":"le\u003creql_rust::arguments::Args\u003calloc::vec::Vec\u003ci32, alloc::alloc::Global\u003e\u003e\u003e"},{"line":153,"address":[4107451],"length":1,"stats":{"Line":1},"fn_name":null},{"line":156,"address":[4751744],"length":1,"stats":{"Line":1},"fn_name":"not"},{"line":157,"address":[4751768],"length":1,"stats":{"Line":1},"fn_name":null},{"line":160,"address":[4107568,4107504,4107536],"length":1,"stats":{"Line":3},"fn_name":"random\u003c()\u003e"},{"line":161,"address":[4107552,4107515,4107579],"length":1,"stats":{"Line":3},"fn_name":null},{"line":164,"address":[4751792],"length":1,"stats":{"Line":1},"fn_name":"round"},{"line":165,"address":[4751809],"length":1,"stats":{"Line":1},"fn_name":null},{"line":168,"address":[4751824],"length":1,"stats":{"Line":1},"fn_name":"ceil"},{"line":169,"address":[4751841],"length":1,"stats":{"Line":1},"fn_name":null},{"line":172,"address":[4751856],"length":1,"stats":{"Line":1},"fn_name":"floor"},{"line":173,"address":[4751873],"length":1,"stats":{"Line":1},"fn_name":null},{"line":255,"address":[4107632],"length":1,"stats":{"Line":1},"fn_name":"bit_and\u003creql_rust::proto::Command\u003e"},{"line":256,"address":[4107654],"length":1,"stats":{"Line":1},"fn_name":null},{"line":336,"address":[4107728],"length":1,"stats":{"Line":1},"fn_name":"bit_or\u003creql_rust::proto::Command\u003e"},{"line":337,"address":[4107750],"length":1,"stats":{"Line":1},"fn_name":null},{"line":420,"address":[4107824],"length":1,"stats":{"Line":1},"fn_name":"bit_xor\u003creql_rust::proto::Command\u003e"},{"line":421,"address":[4107846],"length":1,"stats":{"Line":1},"fn_name":null},{"line":477,"address":[4751888],"length":1,"stats":{"Line":1},"fn_name":"bit_not"},{"line":478,"address":[4751905],"length":1,"stats":{"Line":1},"fn_name":null},{"line":544,"address":[4107920],"length":1,"stats":{"Line":1},"fn_name":"bit_sal\u003creql_rust::proto::Command\u003e"},{"line":545,"address":[4107942],"length":1,"stats":{"Line":1},"fn_name":null},{"line":606,"address":[4108016],"length":1,"stats":{"Line":1},"fn_name":"bit_sar\u003creql_rust::proto::Command\u003e"},{"line":607,"address":[4108038],"length":1,"stats":{"Line":1},"fn_name":null},{"line":657,"address":[4751952],"length":1,"stats":{"Line":1},"fn_name":"now"},{"line":658,"address":[4751964],"length":1,"stats":{"Line":1},"fn_name":null},{"line":710,"address":[4108112,4108176],"length":1,"stats":{"Line":2},"fn_name":"time\u003creql_rust::arguments::Args\u003c(time::date::Date, time::time::Time, time::utc_offset::UtcOffset)\u003e\u003e"},{"line":711,"address":[4108124,4108202],"length":1,"stats":{"Line":2},"fn_name":null},{"line":754,"address":[4751984],"length":1,"stats":{"Line":1},"fn_name":"epoch_time"},{"line":755,"address":[4752000],"length":1,"stats":{"Line":1},"fn_name":null},{"line":811,"address":[4108304,4108240],"length":1,"stats":{"Line":2},"fn_name":"iso8601\u003creql_rust::arguments::Args\u003c(\u0026str, time::utc_offset::UtcOffset)\u003e\u003e"},{"line":812,"address":[4108251,4108326],"length":1,"stats":{"Line":2},"fn_name":null},{"line":816,"address":[4108352],"length":1,"stats":{"Line":1},"fn_name":"hash_map\u003c\u0026str\u003e"},{"line":820,"address":[4108365],"length":1,"stats":{"Line":1},"fn_name":null},{"line":866,"address":[4108416],"length":1,"stats":{"Line":1},"fn_name":"args\u003c\u0026alloc::vec::Vec\u003cu8, alloc::alloc::Global\u003e, u8\u003e"},{"line":871,"address":[4108432],"length":1,"stats":{"Line":1},"fn_name":null},{"line":950,"address":[4752016],"length":1,"stats":{"Line":1},"fn_name":"binary"},{"line":951,"address":[4752038],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1085,"address":[4108448],"length":1,"stats":{"Line":1},"fn_name":"branch\u003creql_rust::arguments::Args\u003c(reql_rust::proto::Command, reql_rust::proto::Command)\u003e\u003e"},{"line":1086,"address":[4108469],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1191,"address":[4108592,4108624,4108544],"length":1,"stats":{"Line":3},"fn_name":"range\u003creql_rust::arguments::Args\u003c(isize, isize)\u003e\u003e"},{"line":1192,"address":[4108608,4108635,4108566],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1234,"address":[4108656],"length":1,"stats":{"Line":1},"fn_name":"error\u003c\u0026str\u003e"},{"line":1235,"address":[4108678],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1275,"address":[4108752,4108704,4108832,4108912,4108800],"length":1,"stats":{"Line":6},"fn_name":"expr\u003c\u0026str\u003e"},{"line":1276,"address":[4108726,4108924,4108816,4108776,4108844],"length":1,"stats":{"Line":6},"fn_name":null},{"line":1343,"address":[4108960],"length":1,"stats":{"Line":1},"fn_name":"js\u003c\u0026str\u003e"},{"line":1344,"address":[4108982],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1383,"address":[4752064],"length":1,"stats":{"Line":0},"fn_name":"info"},{"line":1384,"address":[4752081],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1420,"address":[4109008],"length":1,"stats":{"Line":1},"fn_name":"json\u003c\u0026str\u003e"},{"line":1421,"address":[4109030],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1548,"address":[4109120,4109056],"length":1,"stats":{"Line":2},"fn_name":"http\u003cserde_json::value::Value, reql_rust::arguments::Args\u003c(\u0026str, serde_json::value::Value)\u003e\u003e"},{"line":1552,"address":[4109069,4109142],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1626,"address":[4109168],"length":1,"stats":{"Line":1},"fn_name":"uuid\u003c()\u003e"},{"line":1627,"address":[4109179],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1695,"address":[4109200],"length":1,"stats":{"Line":1},"fn_name":"circle\u003creql_rust::arguments::Args\u003c(reql_rust::cmd::point::Point, f64)\u003e\u003e"},{"line":1696,"address":[4109212],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1759,"address":[4109280],"length":1,"stats":{"Line":1},"fn_name":"distance\u003creql_rust::arguments::Args\u003c(reql_rust::cmd::point::Point, reql_rust::cmd::distance::DistanceOption)\u003e\u003e"},{"line":1760,"address":[4109301],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1822,"address":[4109408],"length":1,"stats":{"Line":1},"fn_name":"geojson\u003c[f64; 2]\u003e"},{"line":1823,"address":[4109419],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1884,"address":[4752128],"length":1,"stats":{"Line":1},"fn_name":"line"},{"line":1885,"address":[4752150],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1939,"address":[4752176],"length":1,"stats":{"Line":1},"fn_name":"point"},{"line":1940,"address":[4752200],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2009,"address":[4752224],"length":1,"stats":{"Line":1},"fn_name":"polygon"},{"line":2010,"address":[4752246],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2245,"address":[4752272],"length":1,"stats":{"Line":0},"fn_name":"grant"},{"line":2246,"address":[4752306],"length":1,"stats":{"Line":0},"fn_name":null},{"line":2366,"address":[4109472],"length":1,"stats":{"Line":1},"fn_name":"asc\u003c\u0026str\u003e"},{"line":2367,"address":[4109494],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2400,"address":[4109520],"length":1,"stats":{"Line":1},"fn_name":"desc\u003c\u0026str\u003e"},{"line":2401,"address":[4109542],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2429,"address":[4752336],"length":1,"stats":{"Line":1},"fn_name":"min_val"},{"line":2430,"address":[4752348],"length":1,"stats":{"Line":1},"fn_name":null},{"line":2458,"address":[4752384],"length":1,"stats":{"Line":1},"fn_name":"max_val"},{"line":2459,"address":[4752396],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":108,"coverable":112},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","prelude.rs"],"content":"use std::sync::atomic::{AtomicU64, Ordering};\n\npub use futures::stream::select_all;\npub use futures::TryStreamExt;\n#[doc(hidden)]\npub use reql_macros::func;\npub use reql_macros::Geometry;\nuse serde::de::DeserializeOwned;\nuse serde::Serialize;\n\npub use crate::cmd::func::Func;\npub use crate::cmd::StaticString;\npub use crate::proto::Command;\npub use crate::Result;\n\n#[doc(hidden)]\npub static VAR_COUNTER: AtomicU64 = AtomicU64::new(1);\n\n#[doc(hidden)]\npub fn var_counter() -\u003e u64 {\n    VAR_COUNTER.fetch_add(1, Ordering::SeqCst)\n}\n\npub trait Converter {\n    fn parse\u003cT: Unpin + Serialize + DeserializeOwned\u003e(self) -\u003e Result\u003cT\u003e;\n}\n\nimpl Converter for serde_json::Value {\n    fn parse\u003cT: Unpin + Serialize + DeserializeOwned\u003e(self) -\u003e Result\u003cT\u003e {\n        Ok(serde_json::from_value(self)?)\n    }\n}\n\npub trait Geometry: Into\u003cCommand\u003e {\n    fn cmd(self) -\u003e Command {\n        self.into()\n    }\n}\n","traces":[{"line":20,"address":[2124864],"length":1,"stats":{"Line":1},"fn_name":"var_counter"},{"line":21,"address":[4534004],"length":1,"stats":{"Line":1},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":53},"fn_name":null},{"line":30,"address":[2160592,2152176,2157016,2162846,2154808,2158618,2158240,2151744,2158426,2151040,2152112,2156206,2153674,2160414,2153216,2155280,2154968,2161342,2159806,2162304,2161840,2151241,2162046,2155216,2158928,2158493,2160345,2156528,2160078,2158992,2151694,2155024,2150240,2156592,2154702,2150768,2161520,2157344,2150974,2157530,2151998,2157867,2155728,2158672,2160144,2159422,2153488,2152432,2155934,2159246,2154000,2161584,2159539,2152368,2157758,2154320,2161776,2151518,2159600,2161070,2150496,2162368,2155533,2159178,2158078,2159872,2154862,2154384,2160528,2153152,2157598,2152688,2155472,2160864,2157918,2155678,2154640,2159361,2156000,2154064,2161406,2152894,2157072,2153422,2151582,2160798,2157273,2162640,2153744,2151930,2156272,2151312,2152624,2161136,2156910,2152960,2158184,2162112,2150432,2162574,2157707,2158024,2156848,2150697],"length":1,"stats":{"Line":53},"fn_name":null},{"line":35,"address":[2766752],"length":1,"stats":{"Line":2},"fn_name":"cmd\u003creql_rust::cmd::polygon::Polygon\u003e"},{"line":36,"address":[1647292],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":6,"coverable":6},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","proto.rs"],"content":"use std::collections::{HashMap, VecDeque};\nuse std::{fmt, str};\n\nuse ql2::query::QueryType;\nuse ql2::term::TermType;\nuse serde::ser::{self, Serialize, Serializer};\nuse serde_json::value::{Number, Value};\n\nuse crate::cmd::run::{Db, RunOption};\n// use crate::prelude::ReqlOps;\nuse crate::{err, r};\n\n#[derive(Debug, Clone, Eq, PartialEq)]\npub(crate) enum Datum {\n    Null,\n    Bool(bool),\n    Number(Number),\n    String(String),\n    Array(Vec\u003cDatum\u003e),\n    Object(HashMap\u003cString, Datum\u003e),\n}\n\nimpl Default for Datum {\n    fn default() -\u003e Self {\n        Self::Null\n    }\n}\n\nimpl Serialize for Datum {\n    fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    where\n        S: Serializer,\n    {\n        match self {\n            Self::Null =\u003e serializer.serialize_none(),\n            Self::Bool(boolean) =\u003e boolean.serialize(serializer),\n            Self::Number(num) =\u003e num.serialize(serializer),\n            Self::String(string) =\u003e string.serialize(serializer),\n            Self::Array(arr) =\u003e (TermType::MakeArray as i32, arr).serialize(serializer),\n            Self::Object(map) =\u003e map.serialize(serializer),\n        }\n    }\n}\n\nimpl From\u003cValue\u003e for Datum {\n    fn from(value: Value) -\u003e Self {\n        match value {\n            Value::Null =\u003e Self::Null,\n            Value::Bool(boolean) =\u003e Self::Bool(boolean),\n            Value::Number(num) =\u003e Self::Number(num),\n            Value::String(string) =\u003e Self::String(string),\n            Value::Array(arr) =\u003e Self::Array(arr.into_iter().map(Into::into).collect()),\n            Value::Object(map) =\u003e Self::Object(\n                map.into_iter()\n                    .map(|(key, value)| (key, value.into()))\n                    .collect(),\n            ),\n        }\n    }\n}\n\n/// The query that will be sent to RethinkDB\n#[derive(Debug, Clone)]\npub struct Command {\n    typ: TermType,\n    datum: Option\u003csuper::Result\u003cDatum\u003e\u003e,\n    #[doc(hidden)]\n    pub args: VecDeque\u003csuper::Result\u003cCommand\u003e\u003e,\n    opts: Option\u003csuper::Result\u003cDatum\u003e\u003e,\n    change_feed: bool,\n}\n\nimpl Command {\n    #[doc(hidden)]\n    pub fn new(typ: TermType) -\u003e Self {\n        Self {\n            typ,\n            datum: None,\n            args: VecDeque::new(),\n            opts: None,\n            change_feed: false,\n        }\n    }\n\n    #[doc(hidden)]\n    pub fn var(id: u64) -\u003e Self {\n        let index = Self::from_json(id);\n        Self::new(TermType::Var).with_arg(index)\n    }\n\n    pub(crate) fn with_parent(mut self, parent: Command) -\u003e Self {\n        self.change_feed = self.change_feed || parent.change_feed;\n        self.args.push_front(Ok(parent));\n        self\n    }\n\n    #[doc(hidden)]\n    pub fn with_arg(mut self, arg: impl Into\u003cCommand\u003e) -\u003e Self {\n        let arg = arg.into();\n        self.args.push_back(Ok(arg));\n        self\n    }\n\n    pub(crate) fn with_opts\u003cT\u003e(mut self, opts: T) -\u003e Self\n    where\n        T: Serialize,\n    {\n        let opts = serde_json::to_value(\u0026opts)\n            .map(Into::into)\n            .map_err(Into::into);\n        self.opts = Some(opts);\n        self\n    }\n\n    #[doc(hidden)]\n    pub fn from_json\u003cT\u003e(arg: T) -\u003e Self\n    where\n        T: Serialize,\n    {\n        serde_json::to_value(arg)\n            .map_err(super::ReqlError::from)\n            .into()\n    }\n\n    pub(crate) fn mark_change_feed(mut self) -\u003e Self {\n        self.change_feed = true;\n        self\n    }\n\n    pub(crate) fn change_feed(\u0026self) -\u003e bool {\n        self.change_feed\n    }\n}\n\nimpl From\u003cDatum\u003e for Command {\n    fn from(datum: Datum) -\u003e Self {\n        Ok(datum).into()\n    }\n}\n\nimpl From\u003csuper::Result\u003cDatum\u003e\u003e for Command {\n    fn from(result: super::Result\u003cDatum\u003e) -\u003e Self {\n        let mut query = Self::new(TermType::Datum);\n        query.datum = Some(result);\n        query\n    }\n}\n\n#[doc(hidden)]\nimpl From\u003cValue\u003e for Command {\n    fn from(value: Value) -\u003e Self {\n        Datum::from(value).into()\n    }\n}\n\n#[doc(hidden)]\nimpl From\u003csuper::Result\u003cValue\u003e\u003e for Command {\n    fn from(result: super::Result\u003cValue\u003e) -\u003e Self {\n        match result {\n            Ok(value) =\u003e Datum::from(value).into(),\n            Err(error) =\u003e (Err(error) as super::Result\u003cDatum\u003e).into(),\n        }\n    }\n}\n\n#[derive(Debug, Clone)]\npub(crate) struct Query\u003c'a\u003e(pub(crate) \u0026'a Command);\n\nimpl Serialize for Query\u003c'_\u003e {\n    fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    where\n        S: Serializer,\n    {\n        let Query(cmd) = self;\n        match cmd.typ {\n            TermType::Datum =\u003e match \u0026cmd.datum {\n                Some(Ok(datum)) =\u003e datum.serialize(serializer),\n                Some(Err(error)) =\u003e Err(ser::Error::custom(error)),\n                _ =\u003e (None as Option\u003cDatum\u003e).serialize(serializer),\n            },\n            _ =\u003e {\n                let typ = cmd.typ as i32;\n                match \u0026cmd.opts {\n                    Some(Ok(map)) =\u003e (\n                        typ,\n                        to_query_result(\u0026cmd.args).map_err(ser::Error::custom)?,\n                        map,\n                    )\n                        .serialize(serializer),\n                    None =\u003e (typ, to_query_result(\u0026cmd.args).map_err(ser::Error::custom)?)\n                        .serialize(serializer),\n                    Some(Err(error)) =\u003e Err(ser::Error::custom(error)),\n                }\n            }\n        }\n    }\n}\n\nfn to_query_result(args: \u0026VecDeque\u003csuper::Result\u003cCommand\u003e\u003e) -\u003e super::Result\u003cVec\u003cQuery\u003c'_\u003e\u003e\u003e {\n    let mut vec = Vec::with_capacity(args.len());\n    for result in args {\n        let arg = result.as_ref().map_err(|error| error.clone())?;\n        vec.push(Query(arg));\n    }\n    Ok(vec)\n}\n\n#[derive(Debug, Clone)]\npub(crate) struct Payload\u003c'a\u003e(\n    pub(crate) QueryType,\n    pub(crate) Option\u003cQuery\u003c'a\u003e\u003e,\n    pub(crate) RunOption,\n);\n\nimpl Serialize for Payload\u003c'_\u003e {\n    fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    where\n        S: Serializer,\n    {\n        let Payload(typ, qry, opts) = self;\n        let typ = *typ as i32;\n        match qry {\n            Some(query) =\u003e (typ, query, opts).serialize(serializer),\n            None =\u003e (typ,).serialize(serializer),\n        }\n    }\n}\n\nimpl Payload\u003c'_\u003e {\n    pub(crate) fn to_bytes(\u0026self) -\u003e Result\u003cVec\u003cu8\u003e, err::ReqlError\u003e {\n        Ok(serde_json::to_vec(self)?)\n    }\n}\n\n// for debugging purposes only\nimpl fmt::Display for Payload\u003c'_\u003e {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        // print the serialised string if we can\n        if let Ok(payload) = self.to_bytes() {\n            if let Ok(payload) = str::from_utf8(\u0026payload) {\n                return write!(f, \"{}\", payload);\n            }\n        }\n        // otherwise just print the debug form\n        write!(f, \"{:?}\", self)\n    }\n}\n\nimpl Serialize for Db {\n    fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    where\n        S: Serializer,\n    {\n        let Self(name) = self;\n        let cmd = r.db(name.as_ref());\n        Query(\u0026cmd).serialize(serializer)\n    }\n}\n","traces":[{"line":24,"address":[4033920],"length":1,"stats":{"Line":0},"fn_name":"default"},{"line":25,"address":[4033923],"length":1,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[2167984,2168413],"length":1,"stats":{"Line":10},"fn_name":"serialize\u003c\u0026mut serde_json::ser::Serializer\u003c\u0026mut alloc::vec::Vec\u003cu8, alloc::alloc::Global\u003e, serde_json::ser::CompactFormatter\u003e\u003e"},{"line":34,"address":[2168011],"length":1,"stats":{"Line":10},"fn_name":null},{"line":35,"address":[2168057,2168406],"length":1,"stats":{"Line":2},"fn_name":null},{"line":36,"address":[2168087,2168394],"length":1,"stats":{"Line":2},"fn_name":null},{"line":37,"address":[2168129,2168382],"length":1,"stats":{"Line":2},"fn_name":null},{"line":38,"address":[2168370,2168171],"length":1,"stats":{"Line":16},"fn_name":null},{"line":39,"address":[2168213,2168358],"length":1,"stats":{"Line":2},"fn_name":null},{"line":40,"address":[2168270,2168335],"length":1,"stats":{"Line":16},"fn_name":null},{"line":46,"address":[4033936],"length":1,"stats":{"Line":10},"fn_name":"from"},{"line":47,"address":[4033958],"length":1,"stats":{"Line":10},"fn_name":null},{"line":48,"address":[4033994],"length":1,"stats":{"Line":1},"fn_name":null},{"line":49,"address":[4034012],"length":1,"stats":{"Line":1},"fn_name":null},{"line":50,"address":[4034053],"length":1,"stats":{"Line":1},"fn_name":null},{"line":51,"address":[4034116],"length":1,"stats":{"Line":8},"fn_name":null},{"line":52,"address":[4034481,4034193],"length":1,"stats":{"Line":2},"fn_name":null},{"line":54,"address":[4034339],"length":1,"stats":{"Line":8},"fn_name":null},{"line":55,"address":[2168456,2168432],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":75,"address":[4034760,4034544],"length":1,"stats":{"Line":11},"fn_name":"new"},{"line":79,"address":[4034586],"length":1,"stats":{"Line":11},"fn_name":null},{"line":86,"address":[4034800,4035002,4035029],"length":1,"stats":{"Line":1},"fn_name":"var"},{"line":87,"address":[4034825],"length":1,"stats":{"Line":1},"fn_name":null},{"line":88,"address":[4034918,4034851],"length":1,"stats":{"Line":2},"fn_name":null},{"line":91,"address":[4035040,4035281],"length":1,"stats":{"Line":3},"fn_name":"with_parent"},{"line":92,"address":[4035067],"length":1,"stats":{"Line":3},"fn_name":null},{"line":93,"address":[4035120],"length":1,"stats":{"Line":3},"fn_name":null},{"line":94,"address":[4035258],"length":1,"stats":{"Line":3},"fn_name":null},{"line":98,"address":[2168950,2168688],"length":1,"stats":{"Line":3},"fn_name":"with_arg\u003creql_rust::proto::Command\u003e"},{"line":99,"address":[2168748],"length":1,"stats":{"Line":3},"fn_name":null},{"line":100,"address":[2168809],"length":1,"stats":{"Line":9},"fn_name":null},{"line":101,"address":[2168927],"length":1,"stats":{"Line":9},"fn_name":null},{"line":104,"address":[2174106,2181410,2176332,2182576,2181954,2178576,2171952,2179758,2181993,2168976,2182537,2184264,2180366,2172453,2179040,2179648,2170736,2183040,2177488,2181488,2183758,2170592,2169436,2174750,2179792,2180862,2183792,2170702,2179184,2169984,2175872,2169475,2177419,2176960,2171310,2178032,2169520,2173570,2178537,2177954,2177993,2175289,2176876,2183150,2182498,2174144,2183648,2175829,2171808,2171200,2180944,2175250,2172960,2181449,2170094,2177457,2172496,2170128,2180256,2174640,2176416,2182032,2180901,2183184,2174176,2173648,2173609,2171918,2174784,2179150,2172414,2178498,2176371,2175328,2171344,2173104,2173070,2176915,2175790,2180400,2184374],"length":1,"stats":{"Line":38},"fn_name":"with_opts\u003creql_rust::cmd::random::RandomOption\u003e"},{"line":108,"address":[2174211,2175900,2176536,2179924,2178611,2174308,2179827,2171379,2175363,2177614,2181614,2169652,2173138,2177084,2175992,2180435,2169096,2183316,2182611,2170260,2181070,2179316,2182066,2176444,2174910,2181522,2177522,2175450,2173771,2172074,2170868,2172531,2173230,2178708,2170163,2170771,2176992,2180522,2171987,2172628,2182158,2182708,2173679,2183219,2180978,2171476,2169555,2169004,2174818,2178066,2179219,2178158,2183827,2183928],"length":1,"stats":{"Line":76},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[2181099,2182187,2178187,2169125,2183957,2171505,2177643,2173799,2180551,2183345,2170289,2182737,2173259,2172657,2178737,2176565,2181643,2176021,2177112,2170897,2179953,2175479,2172103,2174939,2169681,2174337,2179345],"length":1,"stats":{"Line":38},"fn_name":null},{"line":112,"address":[2181877,2176799,2171158,2180785,2170550,2172918,2182998,2175713,2178421,2175173,2184218,2173493,2169942,2169359,2174030,2179606,2171766,2181333,2182421,2180214,2174598,2177343,2178998,2176255,2177877,2172337,2183606],"length":1,"stats":{"Line":38},"fn_name":null},{"line":116,"address":[2185056,2184896,2186240,2185616,2186608,2186336,2187264,2187536,2184496,2185232,2186080,2185456,2186976,2185152,2186896,2184976,2185536,2187056,2186816,2186160,2184720,2186496,2185808,2185728,2187184,2184416,2185888,2184816,2185328,2187344,2186416,2186736,2187424,2185968,2184608],"length":1,"stats":{"Line":39},"fn_name":"from_json\u003cu8\u003e"},{"line":120,"address":[2185746,2185826,2184750,2186754,2184512,2185906,2187073,2186625,2186914,2187201,2186354,2185554,2184436,2186434,2187554,2185984,2185632,2187362,2185073,2185170,2184994,2186841,2186512,2187283,2187440,2184834,2185474,2186994,2186257,2185345,2184637,2186098,2185262,2186178,2184914],"length":1,"stats":{"Line":39},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":125,"address":[4035312],"length":1,"stats":{"Line":0},"fn_name":"mark_change_feed"},{"line":126,"address":[4035320],"length":1,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[4035327],"length":1,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[4035344],"length":1,"stats":{"Line":10},"fn_name":"change_feed"},{"line":131,"address":[4035349],"length":1,"stats":{"Line":10},"fn_name":null},{"line":136,"address":[4035376],"length":1,"stats":{"Line":10},"fn_name":"from"},{"line":137,"address":[4035392],"length":1,"stats":{"Line":11},"fn_name":null},{"line":142,"address":[4035788,4035472],"length":1,"stats":{"Line":11},"fn_name":"from"},{"line":143,"address":[4035496],"length":1,"stats":{"Line":11},"fn_name":null},{"line":144,"address":[4035760,4035581],"length":1,"stats":{"Line":22},"fn_name":null},{"line":151,"address":[4035840],"length":1,"stats":{"Line":0},"fn_name":"from"},{"line":152,"address":[4035853],"length":1,"stats":{"Line":0},"fn_name":null},{"line":158,"address":[4035936],"length":1,"stats":{"Line":3},"fn_name":"from"},{"line":159,"address":[4035958],"length":1,"stats":{"Line":9},"fn_name":null},{"line":160,"address":[4036210,4035977],"length":1,"stats":{"Line":19},"fn_name":null},{"line":161,"address":[4036084],"length":1,"stats":{"Line":0},"fn_name":null},{"line":170,"address":[2188917,2188362,2187616],"length":1,"stats":{"Line":10},"fn_name":"serialize\u003c\u0026mut serde_json::ser::Serializer\u003c\u0026mut alloc::vec::Vec\u003cu8, alloc::alloc::Global\u003e, serde_json::ser::CompactFormatter\u003e\u003e"},{"line":174,"address":[2187644],"length":1,"stats":{"Line":10},"fn_name":null},{"line":175,"address":[2187676],"length":1,"stats":{"Line":10},"fn_name":null},{"line":176,"address":[2188755,2187693],"length":1,"stats":{"Line":14},"fn_name":null},{"line":177,"address":[2188907,2188826],"length":1,"stats":{"Line":19},"fn_name":null},{"line":178,"address":[2188863],"length":1,"stats":{"Line":0},"fn_name":null},{"line":179,"address":[2188772],"length":1,"stats":{"Line":0},"fn_name":null},{"line":181,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":182,"address":[2187746],"length":1,"stats":{"Line":10},"fn_name":null},{"line":183,"address":[2187838,2187766],"length":1,"stats":{"Line":18},"fn_name":null},{"line":184,"address":[2188207,2187860,2188144,2188342],"length":1,"stats":{"Line":32},"fn_name":null},{"line":185,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":186,"address":[2187877,2188290,2188014,2188219],"length":1,"stats":{"Line":16},"fn_name":null},{"line":187,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":189,"address":[2188373,2188258,2188191,2188308,2188355],"length":1,"stats":{"Line":24},"fn_name":null},{"line":190,"address":[2188660,2188725,2187808,2188574,2188394],"length":1,"stats":{"Line":15},"fn_name":null},{"line":191,"address":[2188628,2188558,2188691,2188738],"length":1,"stats":{"Line":8},"fn_name":null},{"line":192,"address":[2187904,2187974],"length":1,"stats":{"Line":0},"fn_name":null},{"line":199,"address":[4036870,4036224],"length":1,"stats":{"Line":4},"fn_name":"to_query_result"},{"line":200,"address":[4036262],"length":1,"stats":{"Line":4},"fn_name":null},{"line":201,"address":[4036341,4036537,4036297],"length":1,"stats":{"Line":30},"fn_name":null},{"line":202,"address":[2188944,2188960],"length":1,"stats":{"Line":10},"fn_name":"{closure#0}"},{"line":203,"address":[4036865,4036661],"length":1,"stats":{"Line":20},"fn_name":null},{"line":205,"address":[4036450],"length":1,"stats":{"Line":10},"fn_name":null},{"line":216,"address":[2188976],"length":1,"stats":{"Line":10},"fn_name":"serialize\u003c\u0026mut serde_json::ser::Serializer\u003c\u0026mut alloc::vec::Vec\u003cu8, alloc::alloc::Global\u003e, serde_json::ser::CompactFormatter\u003e\u003e"},{"line":220,"address":[2188998],"length":1,"stats":{"Line":10},"fn_name":null},{"line":221,"address":[2189042],"length":1,"stats":{"Line":10},"fn_name":null},{"line":222,"address":[2189056],"length":1,"stats":{"Line":10},"fn_name":null},{"line":223,"address":[2189125],"length":1,"stats":{"Line":10},"fn_name":null},{"line":224,"address":[2189085],"length":1,"stats":{"Line":0},"fn_name":null},{"line":230,"address":[4036896],"length":1,"stats":{"Line":10},"fn_name":"to_bytes"},{"line":231,"address":[4037074,4036921],"length":1,"stats":{"Line":10},"fn_name":null},{"line":237,"address":[4037769,4037790,4037120],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":239,"address":[4037145],"length":1,"stats":{"Line":0},"fn_name":null},{"line":240,"address":[4037218,4037318],"length":1,"stats":{"Line":0},"fn_name":null},{"line":241,"address":[4037380,4037657],"length":1,"stats":{"Line":0},"fn_name":null},{"line":245,"address":[4037552,4037503],"length":1,"stats":{"Line":0},"fn_name":null},{"line":250,"address":[2999028,2999052,2998800],"length":1,"stats":{"Line":0},"fn_name":"serialize\u003c\u0026mut serde_json::ser::Serializer\u003c\u0026mut alloc::vec::Vec\u003cu8, alloc::alloc::Global\u003e, serde_json::ser::CompactFormatter\u003e\u003e"},{"line":254,"address":[2998828],"length":1,"stats":{"Line":0},"fn_name":null},{"line":255,"address":[2998929,2998852],"length":1,"stats":{"Line":0},"fn_name":null},{"line":256,"address":[2998946],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":71,"coverable":98},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","spec.rs"],"content":"use serde::{Deserialize, Serialize};\nuse serde_json::json;\nuse uuid::Uuid;\n\nuse crate::arguments::Durability;\nuse crate::cmd::insert::InsertOption;\nuse crate::{args, r, Command, Result, Session};\n\npub async fn set_up(with_data: bool) -\u003e Result\u003c(Session, Command, String)\u003e {\n    let table_name = Uuid::new_v4().to_string();\n    let user_rethinkdb = json!({\n        \"id\": \"malik\",\n        \"password\": \"malik\"\n    });\n    let conn = r.connection().connect().await?;\n    let table = r.table(table_name.as_str());\n\n    r.table_create(table_name.as_str()).run(\u0026conn).await?;\n    r.db(\"rethinkdb\")\n        .table(\"users\")\n        .insert(user_rethinkdb)\n        .run(\u0026conn)\n        .await?;\n\n    if with_data {\n        let data = Post::get_many_data();\n        let insert_option = InsertOption::default().durability(Durability::Soft);\n\n        table.clone().index_create(\"title\").run(\u0026conn).await?;\n        table.clone().index_wait(()).run(\u0026conn).await?;\n        table\n            .clone()\n            .insert(args!(data, insert_option))\n            .run(\u0026conn)\n            .await?;\n    }\n\n    Ok((conn, table, table_name))\n}\n\npub async fn tear_down(conn: Session, table_name: \u0026str) -\u003e Result\u003c()\u003e {\n    r.table_drop(table_name).run(\u0026conn).await?;\n    r.db(\"rethinkdb\")\n        .table(\"users\")\n        .get(\"malik\")\n        .delete(())\n        .run(\u0026conn)\n        .await?;\n    Ok(())\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]\npub struct Post {\n    pub id: u8,\n    pub title: String,\n    pub content: Option\u003cString\u003e,\n    pub view: u8,\n}\n\nimpl Post {\n    pub fn new(id: u8, title: \u0026str, content: Option\u003c\u0026str\u003e, view: u8) -\u003e Self {\n        Self {\n            id,\n            view,\n            title: title.to_string(),\n            content: content.map(String::from),\n        }\n    }\n\n    pub fn get_many_data() -\u003e Vec\u003cSelf\u003e {\n        vec![\n            Self::new(1, \"title1\", Some(\"content1\"), 10),\n            Self::new(2, \"title2\", Some(\"content2\"), 2),\n            Self::new(3, \"title3\", None, 0),\n            Self::new(4, \"title4\", Some(\"content4\"), 2),\n            Self::new(5, \"title4\", None, 0),\n        ]\n    }\n\n    pub fn get_one_data() -\u003e Self {\n        Self::new(1, \"title1\", Some(\"content1\"), 0)\n    }\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]\npub struct Comment {\n    pub id: u8,\n    pub text: String,\n    pub post_id: u8,\n}\n\nimpl Comment {\n    pub fn new(id: u8, content: \u0026str, post_id: u8) -\u003e Self {\n        Self {\n            id,\n            post_id,\n            text: content.to_string(),\n        }\n    }\n\n    pub fn get_many_data() -\u003e Vec\u003cSelf\u003e {\n        vec![\n            Self::new(1, \"comment1\", 1),\n            Self::new(2, \"comment2\", 2),\n            Self::new(3, \"comment3\", 3),\n            Self::new(4, \"comment4\", 2),\n            Self::new(5, \"comment4\", 1),\n        ]\n    }\n\n    pub async fn own_set_up() -\u003e Result\u003c(Session, Command, Command, String, String)\u003e {\n        let comment_tablename = Uuid::new_v4().to_string();\n        let (conn, post_table, post_tablename) = set_up(true).await?;\n        let comment_table = r.table(\u0026comment_tablename);\n\n        r.table_create(comment_tablename.as_str())\n            .run(\u0026conn)\n            .await?;\n        comment_table\n            .clone()\n            .insert(Self::get_many_data())\n            .run(\u0026conn)\n            .await?;\n\n        Ok((\n            conn,\n            comment_table,\n            post_table,\n            comment_tablename,\n            post_tablename,\n        ))\n    }\n\n    pub async fn own_tear_down(\n        conn: Session,\n        comment_tablename: String,\n        post_tablename: String,\n    ) -\u003e Result\u003c()\u003e {\n        r.table_drop(\u0026comment_tablename).run(\u0026conn).await?;\n        tear_down(conn, \u0026post_tablename).await\n    }\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]\npub struct CommentWithPost {\n    pub id: u8,\n    pub text: String,\n    pub post_id: u8,\n    pub title: String,\n    pub content: Option\u003cString\u003e,\n    pub view: u8,\n}\n","traces":[{"line":9,"address":[4514587,4521156,4514021,4514150,4513952,4515074],"length":1,"stats":{"Line":5},"fn_name":"{async_fn#0}"},{"line":10,"address":[4514128,4514715],"length":1,"stats":{"Line":2},"fn_name":null},{"line":11,"address":[4514785,4515055,4515176,4514730,4515361,4515110,4514848],"length":1,"stats":{"Line":21},"fn_name":null},{"line":15,"address":[6843568],"length":1,"stats":{"Line":17},"fn_name":null},{"line":16,"address":[4515986,4516249],"length":1,"stats":{"Line":12},"fn_name":null},{"line":18,"address":[6843434,6843377],"length":1,"stats":{"Line":19},"fn_name":null},{"line":19,"address":[4517125,4517052,4517258,4517223,4517381,4517656,4517455,4517864],"length":1,"stats":{"Line":7},"fn_name":null},{"line":21,"address":[4517168],"length":1,"stats":{"Line":1},"fn_name":null},{"line":22,"address":[6843300],"length":1,"stats":{"Line":6},"fn_name":null},{"line":23,"address":[6843354,6843314],"length":1,"stats":{"Line":1},"fn_name":null},{"line":25,"address":[4517934,4520875],"length":1,"stats":{"Line":2},"fn_name":null},{"line":26,"address":[4517956],"length":1,"stats":{"Line":1},"fn_name":null},{"line":27,"address":[4518020,4518095],"length":1,"stats":{"Line":2},"fn_name":null},{"line":29,"address":[4514243,4514400,4518240,4518194],"length":1,"stats":{"Line":4},"fn_name":null},{"line":30,"address":[4514264,4519005,4514349,4519067],"length":1,"stats":{"Line":4},"fn_name":null},{"line":31,"address":[4520423,4520631,4519781,4519987,4520145,4520022,4520222],"length":1,"stats":{"Line":6},"fn_name":null},{"line":33,"address":[4519835],"length":1,"stats":{"Line":1},"fn_name":null},{"line":34,"address":[4520178,4514282,4520350,4520002,4520045],"length":1,"stats":{"Line":5},"fn_name":null},{"line":35,"address":[4520661,4520513],"length":1,"stats":{"Line":1},"fn_name":null},{"line":38,"address":[4520936],"length":1,"stats":{"Line":1},"fn_name":null},{"line":41,"address":[4523145,4523042,4522240,4521211,4522194,4521730,4521310,4521168,4521443],"length":1,"stats":{"Line":5},"fn_name":"{async_fn#0}"},{"line":42,"address":[4521741,4521405,4521334,4521300,4521535],"length":1,"stats":{"Line":4},"fn_name":null},{"line":43,"address":[4522507,4522578,4522767,4522278,4522975,4522396,4522208],"length":1,"stats":{"Line":6},"fn_name":null},{"line":47,"address":[4522376,4522419,4521349,4522537,4522706],"length":1,"stats":{"Line":5},"fn_name":null},{"line":48,"address":[4522857,4523005],"length":1,"stats":{"Line":1},"fn_name":null},{"line":49,"address":[4523133],"length":1,"stats":{"Line":1},"fn_name":null},{"line":61,"address":[7016479,7016224],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":65,"address":[7016323],"length":1,"stats":{"Line":4},"fn_name":null},{"line":66,"address":[4523168,4523190],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":70,"address":[7017269,7016512],"length":1,"stats":{"Line":4},"fn_name":"get_many_data"},{"line":71,"address":[7016529,7016751,7016978,7016857,7017087,7016633],"length":1,"stats":{"Line":1},"fn_name":null},{"line":72,"address":[7016559],"length":1,"stats":{"Line":4},"fn_name":null},{"line":73,"address":[7016665],"length":1,"stats":{"Line":4},"fn_name":null},{"line":74,"address":[7016783],"length":1,"stats":{"Line":1},"fn_name":null},{"line":75,"address":[7016886],"length":1,"stats":{"Line":4},"fn_name":null},{"line":76,"address":[7017010],"length":1,"stats":{"Line":1},"fn_name":null},{"line":80,"address":[7017312],"length":1,"stats":{"Line":1},"fn_name":"get_one_data"},{"line":81,"address":[7017324],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":38,"coverable":38},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","types","binary.rs"],"content":"use serde::{Deserialize, Serialize};\n\nuse super::ReqlType;\n\n#[derive(Debug, Serialize, Deserialize, Clone)]\npub struct Binary {\n    #[serde(rename = \"$reql_type$\")]\n    reql_type: ReqlType,\n    pub data: String,\n}\n\nimpl Binary {\n    pub fn new(bytes: \u0026[u8]) -\u003e Self {\n        Self {\n            reql_type: ReqlType::Binary,\n            data: base64::encode(bytes),\n        }\n    }\n}\n","traces":[{"line":13,"address":[2212336],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":16,"address":[2212365],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":2,"coverable":2},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","types","datetime.rs"],"content":"use std::fmt::Debug;\nuse std::hash::Hash;\nuse std::ops::Deref;\n\nuse serde::{de, Deserialize, Deserializer, Serialize, Serializer};\nuse time::format_description::well_known::Iso8601;\nuse time::macros::time;\nuse time::{format_description, OffsetDateTime, UtcOffset};\n\nuse crate::arguments::Args;\nuse crate::constants::{HOUR, MINUTE, NANOS_PER_MSEC, NANOS_PER_SEC, TIMEZONE_FORMAT};\nuse crate::{cmd, Command};\n\nuse super::response_with_cmd::ResponseWithCmd;\nuse super::Time;\n\n#[derive(Clone)]\npub struct DateTime(pub OffsetDateTime, pub Option\u003cCommand\u003e);\n\nimpl DateTime {\n    pub(crate) fn now() -\u003e Self {\n        let offset_datetime = OffsetDateTime::now_utc();\n\n        Self::default().create_datetime_command(Some(offset_datetime), Some(cmd::now::new()))\n    }\n\n    pub(crate) fn time(args: impl cmd::time::TimeArg) -\u003e Self {\n        let (offset_datetime, timezone_formated, with_time) = args.into_time_opts();\n\n        Self::default().create_datetime_command(\n            Some(offset_datetime),\n            Some(cmd::time::new(\n                offset_datetime,\n                timezone_formated,\n                with_time,\n            )),\n        )\n    }\n\n    pub(crate) fn epoch_time(timestamp: i64) -\u003e crate::Result\u003cSelf\u003e {\n        let offset_datetime = OffsetDateTime::from_unix_timestamp(timestamp)?;\n\n        Ok(Self::default().create_datetime_command(\n            Some(offset_datetime),\n            Some(cmd::epoch_time::epoch_time(timestamp)),\n        ))\n    }\n\n    pub(crate) fn iso8601(args: impl cmd::iso8601::Iso8601) -\u003e crate::Result\u003cSelf\u003e {\n        let datetime = args.into_iso8601_opts()?;\n        let command = cmd::iso8601::new(\u0026datetime);\n        let datetime = OffsetDateTime::parse(\u0026datetime, \u0026Iso8601::DEFAULT)?;\n\n        Ok(Self::default().create_datetime_command(Some(datetime), Some(command)))\n    }\n\n    pub fn in_timezone(self, timezone: UtcOffset) -\u003e Self {\n        let datetime = self.0.replace_offset(timezone);\n\n        self.clone().create_datetime_command(\n            Some(datetime),\n            Some(cmd::in_timezone::new(timezone).with_parent(self.cmd())),\n        )\n    }\n\n    pub fn timezone(self) -\u003e ResponseWithCmd\u003cUtcOffset\u003e {\n        ResponseWithCmd(\n            self.0.offset(),\n            cmd::timezone::new().with_parent(self.cmd()),\n        )\n    }\n\n    pub fn during(\n        self,\n        start_time: DateTime,\n        end_time: DateTime,\n        during_option: Option\u003ccmd::during::DuringOption\u003e,\n    ) -\u003e ResponseWithCmd\u003cbool\u003e {\n        let is_verified = self.le(\u0026end_time) \u0026\u0026 self.gt(\u0026start_time);\n\n        ResponseWithCmd(\n            is_verified,\n            cmd::during::new(Args((start_time, end_time, during_option))).with_parent(self.cmd()),\n        )\n    }\n\n    pub fn date(self) -\u003e Self {\n        let datetime = self.0.replace_time(time!(00:00));\n\n        self.clone().create_datetime_command(\n            Some(datetime),\n            Some(cmd::date::new().with_parent(self.cmd())),\n        )\n    }\n\n    pub fn time_of_day(self) -\u003e ResponseWithCmd\u003cf64\u003e {\n        let time_ = self.0.time();\n        let milliseconds = get_milliseconds(\u0026time_);\n        let hours: f64 = time_.hour().into();\n        let minutes: f64 = time_.minute().into();\n        let seconds: f64 = time_.second().into();\n        let seconds: f64 = hours * HOUR + minutes * MINUTE + seconds;\n\n        ResponseWithCmd(\n            seconds + milliseconds,\n            cmd::time_of_day::new().with_parent(self.cmd()),\n        )\n    }\n\n    pub fn year(self) -\u003e ResponseWithCmd\u003ci32\u003e {\n        ResponseWithCmd(\n            self.0.date().year(),\n            cmd::year::new().with_parent(self.cmd()),\n        )\n    }\n\n    pub fn month(self) -\u003e ResponseWithCmd\u003cu8\u003e {\n        ResponseWithCmd(\n            self.0.date().month().into(),\n            cmd::month::new().with_parent(self.cmd()),\n        )\n    }\n\n    pub fn day(self) -\u003e ResponseWithCmd\u003cu8\u003e {\n        ResponseWithCmd(self.0.date().day(), cmd::day::new().with_parent(self.cmd()))\n    }\n\n    pub fn day_of_week(self) -\u003e ResponseWithCmd\u003cu8\u003e {\n        ResponseWithCmd(\n            self.0.date().weekday().number_from_monday(),\n            cmd::day_of_week::new().with_parent(self.cmd()),\n        )\n    }\n\n    pub fn day_of_year(self) -\u003e ResponseWithCmd\u003cu16\u003e {\n        ResponseWithCmd(\n            self.0.date().ordinal(),\n            cmd::day_of_year::new().with_parent(self.cmd()),\n        )\n    }\n\n    pub fn hours(self) -\u003e ResponseWithCmd\u003cu8\u003e {\n        ResponseWithCmd(\n            self.0.time().hour(),\n            cmd::hours::new().with_parent(self.cmd()),\n        )\n    }\n\n    pub fn minutes(self) -\u003e ResponseWithCmd\u003cu8\u003e {\n        ResponseWithCmd(\n            self.0.time().minute(),\n            cmd::minutes::new().with_parent(self.cmd()),\n        )\n    }\n\n    pub fn seconds(self) -\u003e ResponseWithCmd\u003cf64\u003e {\n        let time = self.0.time();\n        let second: f64 = time.second().into();\n\n        ResponseWithCmd(\n            second + get_milliseconds(\u0026time),\n            cmd::seconds::new().with_parent(self.cmd()),\n        )\n    }\n\n    pub fn to_iso8601(self) -\u003e ResponseWithCmd\u003cString\u003e {\n        let iso8601 = self.0.format(\u0026Iso8601::DEFAULT).unwrap();\n\n        ResponseWithCmd(iso8601, cmd::to_iso8601::new().with_parent(self.cmd()))\n    }\n\n    pub fn to_epoch_time(self) -\u003e ResponseWithCmd\u003cf64\u003e {\n        let milliseconds = get_milliseconds(\u0026self.0.time());\n        let current_time = self.0.unix_timestamp().to_string();\n        let current_time: f64 = current_time.parse().unwrap_or_default();\n\n        ResponseWithCmd(\n            current_time + milliseconds,\n            cmd::to_epoch_time::new().with_parent(self.cmd()),\n        )\n    }\n\n    fn create_datetime_command(\n        mut self,\n        offset_datetime: Option\u003cOffsetDateTime\u003e,\n        command: Option\u003cCommand\u003e,\n    ) -\u003e Self {\n        if let Some(command) = command {\n            self.1 = Some(command);\n        }\n\n        if let Some(offset_datetime) = offset_datetime {\n            self.0 = offset_datetime\n        }\n\n        self\n    }\n\n    pub fn cmd(self) -\u003e Command {\n        Command::from(self)\n    }\n\n    pub fn value(self) -\u003e Time {\n        Time::from(self)\n    }\n}\n\nimpl\u003c'de\u003e Deserialize\u003c'de\u003e for DateTime {\n    fn deserialize\u003cD\u003e(deserializer: D) -\u003e Result\u003cSelf, D::Error\u003e\n    where\n        D: Deserializer\u003c'de\u003e,\n    {\n        let time = Time::deserialize(deserializer)?;\n        let epoch_time = time.epoch_time.to_string();\n        let format = match format_description::parse(\"[offset_hour]:[offset_minute]\") {\n            Ok(fmt) =\u003e fmt,\n            Err(error) =\u003e {\n                return Err(de::Error::custom(error));\n            }\n        };\n        let offset = match UtcOffset::parse(\u0026time.timezone, \u0026format) {\n            Ok(offset) =\u003e offset,\n            Err(error) =\u003e {\n                return Err(de::Error::custom(error));\n            }\n        };\n        let (secs, msecs) = match epoch_time.split_once('.') {\n            Some(parts) =\u003e parts,\n            None =\u003e (epoch_time.as_str(), \"0\"),\n        };\n        let secs = match secs.parse::\u003ci128\u003e() {\n            Ok(secs) =\u003e match secs.checked_mul(NANOS_PER_SEC) {\n                Some(secs) =\u003e secs,\n                None =\u003e {\n                    return Err(de::Error::custom(\"seconds to nanosecond overflow\"));\n                }\n            },\n            Err(..) =\u003e {\n                return Err(de::Error::custom(\"invalid epoch time seconds\"));\n            }\n        };\n        // RethinkDB timestamps have millisecond precision so we need\n        // to convert the milliseconds to nanoseconds first\n        let msecs = match msecs.parse::\u003ci128\u003e() {\n            Ok(int) =\u003e {\n                let msecs = match msecs.len() {\n                    3 =\u003e int,\n                    2 =\u003e int * 10,\n                    1 =\u003e int * 100,\n                    _ =\u003e {\n                        return Err(de::Error::custom(\"invalid epoch milliseconds\"));\n                    }\n                };\n                match msecs.checked_mul(NANOS_PER_MSEC) {\n                    Some(msecs) =\u003e msecs,\n                    None =\u003e {\n                        return Err(de::Error::custom(\"millisecond to nanosecond overflow\"));\n                    }\n                }\n            }\n            Err(..) =\u003e {\n                return Err(de::Error::custom(\"invalid epoch time milliseconds\"));\n            }\n        };\n        let timestamp = match secs.checked_add(msecs) {\n            Some(timestamp) =\u003e timestamp,\n            None =\u003e {\n                return Err(de::Error::custom(\"timestamp addition overflow\"));\n            }\n        };\n        let dt = match OffsetDateTime::from_unix_timestamp_nanos(timestamp) {\n            Ok(date_time) =\u003e date_time.to_offset(offset),\n            Err(error) =\u003e {\n                return Err(de::Error::custom(error));\n            }\n        };\n        Ok(DateTime(dt, None))\n    }\n}\n\nimpl Serialize for DateTime {\n    fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    where\n        S: Serializer,\n    {\n        Time::from(self.to_owned()).serialize(serializer)\n    }\n}\n\nimpl Default for DateTime {\n    fn default() -\u003e Self {\n        let offset_datetime = OffsetDateTime::now_utc();\n\n        Self(offset_datetime, None)\n    }\n}\n\nimpl Debug for DateTime {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        f.debug_tuple(\"DateTime\").field(\u0026self.0).finish()\n    }\n}\n\nimpl Deref for DateTime {\n    type Target = OffsetDateTime;\n\n    fn deref(\u0026self) -\u003e \u0026Self::Target {\n        \u0026self.0\n    }\n}\n\nimpl PartialEq for DateTime {\n    fn eq(\u0026self, other: \u0026Self) -\u003e bool {\n        self.0.eq(\u0026other.0)\n    }\n}\n\nimpl PartialOrd for DateTime {\n    fn partial_cmp(\u0026self, other: \u0026Self) -\u003e Option\u003cstd::cmp::Ordering\u003e {\n        self.0.partial_cmp(\u0026other.0)\n    }\n}\n\nimpl Eq for DateTime {}\n\nimpl Ord for DateTime {\n    fn cmp(\u0026self, other: \u0026Self) -\u003e std::cmp::Ordering {\n        self.0.cmp(\u0026other.0)\n    }\n}\n\nimpl Hash for DateTime {\n    fn hash\u003cH: std::hash::Hasher\u003e(\u0026self, state: \u0026mut H) {\n        self.0.hash(state);\n    }\n}\n\nimpl From\u003cOffsetDateTime\u003e for DateTime {\n    fn from(dt: OffsetDateTime) -\u003e Self {\n        Self(dt, None)\n    }\n}\n\nimpl From\u003cDateTime\u003e for OffsetDateTime {\n    fn from(DateTime(dt, _): DateTime) -\u003e Self {\n        dt\n    }\n}\n\nimpl From\u003cDateTime\u003e for Command {\n    fn from(date_time: DateTime) -\u003e Self {\n        date_time.1.unwrap()\n    }\n}\n\nimpl From\u003cDateTime\u003e for Time {\n    fn from(date_time: DateTime) -\u003e Self {\n        Self::from(date_time.0)\n    }\n}\n\npub fn timezone_to_string(timezone: UtcOffset) -\u003e String {\n    if timezone.is_utc() {\n        String::from(\"Z\")\n    } else {\n        let format = format_description::parse(TIMEZONE_FORMAT).unwrap();\n        timezone.format(\u0026format).unwrap()\n    }\n}\n\nfn get_milliseconds(time: \u0026time::Time) -\u003e f64 {\n    let milliseconds: f64 = time.millisecond().into();\n\n    milliseconds / 1000.\n}\n","traces":[{"line":21,"address":[4020527,4020500,4020272],"length":1,"stats":{"Line":1},"fn_name":"now"},{"line":22,"address":[4020289],"length":1,"stats":{"Line":1},"fn_name":null},{"line":24,"address":[4020308,4020520],"length":1,"stats":{"Line":1},"fn_name":null},{"line":27,"address":[4404256,4404304,4403792,4404782],"length":1,"stats":{"Line":2},"fn_name":"time\u003creql_rust::arguments::Args\u003c(time::date::Date, time::time::Time, time::utc_offset::UtcOffset)\u003e\u003e"},{"line":28,"address":[4404336,4403809],"length":1,"stats":{"Line":2},"fn_name":null},{"line":30,"address":[4403921,4404704,4404447,4404178],"length":1,"stats":{"Line":4},"fn_name":null},{"line":31,"address":[4403973,4404499],"length":1,"stats":{"Line":2},"fn_name":null},{"line":32,"address":[4404583,4404693,4404057,4404167],"length":1,"stats":{"Line":4},"fn_name":null},{"line":33,"address":[4404010,4404536],"length":1,"stats":{"Line":2},"fn_name":null},{"line":34,"address":[4404023,4404549],"length":1,"stats":{"Line":2},"fn_name":null},{"line":40,"address":[4021008,4021038,4020544],"length":1,"stats":{"Line":1},"fn_name":"epoch_time"},{"line":41,"address":[4020698,4020574],"length":1,"stats":{"Line":1},"fn_name":null},{"line":43,"address":[4020917,4020675,4020969],"length":1,"stats":{"Line":3},"fn_name":null},{"line":44,"address":[4020794],"length":1,"stats":{"Line":1},"fn_name":null},{"line":45,"address":[4020831,4020911],"length":1,"stats":{"Line":2},"fn_name":null},{"line":49,"address":[4405801,4406782,4404832,4405840],"length":1,"stats":{"Line":2},"fn_name":"iso8601\u003creql_rust::arguments::Args\u003c(\u0026str, time::utc_offset::UtcOffset)\u003e\u003e"},{"line":50,"address":[4404849,4406008,4405873,4405027],"length":1,"stats":{"Line":2},"fn_name":null},{"line":51,"address":[4405179,4406160,4405007,4405988],"length":1,"stats":{"Line":4},"fn_name":null},{"line":52,"address":[4406245,4405264,4406180,4405199,4406363,4405382],"length":1,"stats":{"Line":4},"fn_name":null},{"line":54,"address":[4406552,4406348,4405571,4405367],"length":1,"stats":{"Line":4},"fn_name":null},{"line":57,"address":[4021056,4021649,4021696],"length":1,"stats":{"Line":1},"fn_name":"in_timezone"},{"line":58,"address":[4021113],"length":1,"stats":{"Line":1},"fn_name":null},{"line":60,"address":[4021262,4021603],"length":1,"stats":{"Line":2},"fn_name":null},{"line":61,"address":[4021277],"length":1,"stats":{"Line":1},"fn_name":null},{"line":62,"address":[4021306,4021639,4021412],"length":1,"stats":{"Line":2},"fn_name":null},{"line":66,"address":[4021728,4022131],"length":1,"stats":{"Line":1},"fn_name":"timezone"},{"line":68,"address":[4021750,4021851],"length":1,"stats":{"Line":2},"fn_name":null},{"line":69,"address":[4022121,4021904],"length":1,"stats":{"Line":1},"fn_name":null},{"line":73,"address":[4022923,4022176,4022864],"length":1,"stats":{"Line":1},"fn_name":"during"},{"line":79,"address":[4022252,4022370],"length":1,"stats":{"Line":2},"fn_name":null},{"line":82,"address":[4022425],"length":1,"stats":{"Line":1},"fn_name":null},{"line":83,"address":[4022436,4022854],"length":1,"stats":{"Line":1},"fn_name":null},{"line":87,"address":[4022960,4023453,4023500],"length":1,"stats":{"Line":1},"fn_name":"date"},{"line":88,"address":[4022982],"length":1,"stats":{"Line":1},"fn_name":null},{"line":90,"address":[4023112,4023407],"length":1,"stats":{"Line":2},"fn_name":null},{"line":91,"address":[4023127],"length":1,"stats":{"Line":1},"fn_name":null},{"line":92,"address":[4023164,4023214,4023443],"length":1,"stats":{"Line":2},"fn_name":null},{"line":96,"address":[4024230,4023536],"length":1,"stats":{"Line":1},"fn_name":"time_of_day"},{"line":97,"address":[4023558,4023661],"length":1,"stats":{"Line":2},"fn_name":null},{"line":98,"address":[4023687],"length":1,"stats":{"Line":1},"fn_name":null},{"line":99,"address":[4023715],"length":1,"stats":{"Line":1},"fn_name":null},{"line":100,"address":[4023786],"length":1,"stats":{"Line":1},"fn_name":null},{"line":101,"address":[4023857],"length":1,"stats":{"Line":1},"fn_name":null},{"line":102,"address":[4023954],"length":1,"stats":{"Line":1},"fn_name":null},{"line":105,"address":[4023987],"length":1,"stats":{"Line":1},"fn_name":null},{"line":106,"address":[4024005,4024220],"length":1,"stats":{"Line":1},"fn_name":null},{"line":110,"address":[4024272,4024633],"length":1,"stats":{"Line":1},"fn_name":"year"},{"line":112,"address":[4024294,4024395],"length":1,"stats":{"Line":2},"fn_name":null},{"line":113,"address":[4024623,4024418],"length":1,"stats":{"Line":1},"fn_name":null},{"line":117,"address":[4024672,4025051],"length":1,"stats":{"Line":1},"fn_name":"month"},{"line":119,"address":[4024694,4024795],"length":1,"stats":{"Line":2},"fn_name":null},{"line":120,"address":[4025041,4024836],"length":1,"stats":{"Line":1},"fn_name":null},{"line":124,"address":[4025465,4025104],"length":1,"stats":{"Line":1},"fn_name":"day"},{"line":125,"address":[4025227,4025126,4025455],"length":1,"stats":{"Line":2},"fn_name":null},{"line":128,"address":[4025887,4025504],"length":1,"stats":{"Line":1},"fn_name":"day_of_week"},{"line":130,"address":[4025627,4025526],"length":1,"stats":{"Line":2},"fn_name":null},{"line":131,"address":[4025877,4025672],"length":1,"stats":{"Line":1},"fn_name":null},{"line":135,"address":[4025936,4026300],"length":1,"stats":{"Line":1},"fn_name":"day_of_year"},{"line":137,"address":[4026059,4025958],"length":1,"stats":{"Line":2},"fn_name":null},{"line":138,"address":[4026083,4026290],"length":1,"stats":{"Line":1},"fn_name":null},{"line":142,"address":[4026743,4026352],"length":1,"stats":{"Line":1},"fn_name":"hours"},{"line":144,"address":[4026477,4026374],"length":1,"stats":{"Line":2},"fn_name":null},{"line":145,"address":[4026733,4026526],"length":1,"stats":{"Line":1},"fn_name":null},{"line":149,"address":[4026784,4027175],"length":1,"stats":{"Line":1},"fn_name":"minutes"},{"line":151,"address":[4026909,4026806],"length":1,"stats":{"Line":2},"fn_name":null},{"line":152,"address":[4026958,4027165],"length":1,"stats":{"Line":1},"fn_name":null},{"line":156,"address":[4027216,4027694],"length":1,"stats":{"Line":1},"fn_name":"seconds"},{"line":157,"address":[4027238,4027341],"length":1,"stats":{"Line":2},"fn_name":null},{"line":158,"address":[4027362],"length":1,"stats":{"Line":1},"fn_name":null},{"line":161,"address":[4027432],"length":1,"stats":{"Line":1},"fn_name":null},{"line":162,"address":[4027684,4027475],"length":1,"stats":{"Line":1},"fn_name":null},{"line":166,"address":[4027744,4028207],"length":1,"stats":{"Line":1},"fn_name":"to_iso8601"},{"line":167,"address":[4027766,4027867],"length":1,"stats":{"Line":2},"fn_name":null},{"line":169,"address":[4027891,4028197],"length":1,"stats":{"Line":1},"fn_name":null},{"line":172,"address":[4028924,4028256,4028900],"length":1,"stats":{"Line":1},"fn_name":"to_epoch_time"},{"line":173,"address":[4028278,4028381],"length":1,"stats":{"Line":2},"fn_name":null},{"line":174,"address":[4028440],"length":1,"stats":{"Line":1},"fn_name":null},{"line":175,"address":[4028521,4028597],"length":1,"stats":{"Line":2},"fn_name":null},{"line":178,"address":[4028646],"length":1,"stats":{"Line":1},"fn_name":null},{"line":179,"address":[4028890,4028664],"length":1,"stats":{"Line":1},"fn_name":null},{"line":183,"address":[4029514,4028960,4029541],"length":1,"stats":{"Line":1},"fn_name":"create_datetime_command"},{"line":188,"address":[4029277,4028992],"length":1,"stats":{"Line":2},"fn_name":null},{"line":189,"address":[4029125,4029196,4029251],"length":1,"stats":{"Line":2},"fn_name":null},{"line":192,"address":[4029308,4029169],"length":1,"stats":{"Line":2},"fn_name":null},{"line":193,"address":[4029331],"length":1,"stats":{"Line":1},"fn_name":null},{"line":196,"address":[4029403],"length":1,"stats":{"Line":1},"fn_name":null},{"line":199,"address":[4029552],"length":1,"stats":{"Line":1},"fn_name":"cmd"},{"line":200,"address":[4029568],"length":1,"stats":{"Line":1},"fn_name":null},{"line":203,"address":[4029616],"length":1,"stats":{"Line":1},"fn_name":"value"},{"line":204,"address":[4029632],"length":1,"stats":{"Line":1},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":215,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":216,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":217,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":218,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":221,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":222,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":223,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":224,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":227,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":228,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":229,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":231,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":232,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":233,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":234,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":235,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":238,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":239,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":244,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":245,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":246,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":247,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":248,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":249,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":250,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":251,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":254,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":255,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":256,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":257,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":261,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":262,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":265,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":266,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":267,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":268,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":271,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":272,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":273,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":274,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":277,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":286,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":291,"address":[4029680],"length":1,"stats":{"Line":1},"fn_name":"default"},{"line":292,"address":[4029696],"length":1,"stats":{"Line":1},"fn_name":null},{"line":294,"address":[4029711],"length":1,"stats":{"Line":1},"fn_name":null},{"line":299,"address":[4029792],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":300,"address":[4029811],"length":1,"stats":{"Line":0},"fn_name":null},{"line":307,"address":[4029904],"length":1,"stats":{"Line":0},"fn_name":"deref"},{"line":308,"address":[4029912],"length":1,"stats":{"Line":0},"fn_name":null},{"line":313,"address":[4029920],"length":1,"stats":{"Line":0},"fn_name":"eq"},{"line":314,"address":[4029934],"length":1,"stats":{"Line":0},"fn_name":null},{"line":319,"address":[4029984],"length":1,"stats":{"Line":1},"fn_name":"partial_cmp"},{"line":320,"address":[4029998],"length":1,"stats":{"Line":1},"fn_name":null},{"line":327,"address":[4030032],"length":1,"stats":{"Line":0},"fn_name":"cmp"},{"line":328,"address":[4030046],"length":1,"stats":{"Line":0},"fn_name":null},{"line":333,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":334,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":339,"address":[4030080],"length":1,"stats":{"Line":0},"fn_name":"from"},{"line":340,"address":[4030095],"length":1,"stats":{"Line":0},"fn_name":null},{"line":345,"address":[4751392,4751417],"length":1,"stats":{"Line":0},"fn_name":"from"},{"line":351,"address":[4059584],"length":1,"stats":{"Line":1},"fn_name":"from"},{"line":352,"address":[4059600],"length":1,"stats":{"Line":1},"fn_name":null},{"line":357,"address":[1766286,1766208],"length":1,"stats":{"Line":1},"fn_name":"from"},{"line":358,"address":[1766224],"length":1,"stats":{"Line":1},"fn_name":null},{"line":362,"address":[4030504,4030176],"length":1,"stats":{"Line":1},"fn_name":"timezone_to_string"},{"line":363,"address":[4030228],"length":1,"stats":{"Line":1},"fn_name":null},{"line":364,"address":[4030313],"length":1,"stats":{"Line":1},"fn_name":null},{"line":366,"address":[4030284,4030343],"length":1,"stats":{"Line":2},"fn_name":null},{"line":367,"address":[4030365,4030469],"length":1,"stats":{"Line":2},"fn_name":null},{"line":371,"address":[4030544],"length":1,"stats":{"Line":1},"fn_name":"get_milliseconds"},{"line":372,"address":[4030553],"length":1,"stats":{"Line":1},"fn_name":null},{"line":374,"address":[4030606],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":107,"coverable":164},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","types","group_stream.rs"],"content":"use std::fmt::Debug;\n\nuse serde::{de::DeserializeOwned, Deserialize, Serialize};\nuse serde_json::Value;\n\nuse super::ReqlType;\n\n#[derive(Debug, Default, Clone, Serialize, Eq, PartialEq, Ord, PartialOrd, Hash)]\npub struct GroupedStream\u003cG: DeserializeOwned + Serialize, V: DeserializeOwned + Serialize\u003e(\n    Vec\u003cGroupedItem\u003cG, V\u003e\u003e,\n);\n\n#[derive(Debug, Default, Clone, Serialize, Deserialize, Eq, PartialEq, Ord, PartialOrd, Hash)]\npub struct GroupedItem\u003cG, V\u003e {\n    pub group: G,\n    pub values: Vec\u003cV\u003e,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize, Eq, PartialEq)]\nstruct InnerGroup {\n    #[serde(rename = \"$reql_type$\")]\n    reql_type: ReqlType,\n    data: Vec\u003c[Value; 2]\u003e,\n}\n\nimpl\u003c'de, G, V\u003e Deserialize\u003c'de\u003e for GroupedStream\u003cG, V\u003e\nwhere\n    G: DeserializeOwned + Serialize,\n    V: DeserializeOwned + Serialize,\n{\n    fn deserialize\u003cD: serde::Deserializer\u003c'de\u003e\u003e(deserializer: D) -\u003e Result\u003cSelf, D::Error\u003e {\n        Deserialize::deserialize(deserializer).map(|item| {\n            let inner: InnerGroup = item;\n\n            let data: Vec\u003cGroupedItem\u003cG, V\u003e\u003e = inner\n                .data\n                .into_iter()\n                .map(|item| {\n                    let group: G = serde_json::from_value(item[0].clone()).unwrap();\n                    let values: Vec\u003cV\u003e = serde_json::from_value(item[1].clone()).unwrap();\n\n                    GroupedItem { group, values }\n                })\n                .collect();\n\n            GroupedStream(data)\n        })\n    }\n}\n\nimpl\u003cG, V\u003e GroupedStream\u003cG, V\u003e\nwhere\n    G: DeserializeOwned + Serialize,\n    V: DeserializeOwned + Serialize,\n{\n    pub fn collect(self) -\u003e Vec\u003cGroupedItem\u003cG, V\u003e\u003e {\n        self.0\n    }\n}\n\nimpl Default for InnerGroup {\n    fn default() -\u003e Self {\n        Self {\n            reql_type: ReqlType::GroupedData,\n            data: Default::default(),\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use serde::{Deserialize, Serialize};\n\n    use super::GroupedStream;\n\n    #[derive(Serialize, Deserialize, Debug)]\n    struct Posts {\n        id: u8,\n        title: String,\n        content: String,\n        user_id: u8,\n    }\n\n    #[test]\n    fn test_group_stream() {\n        let data = r#\"\n        {\n            \"$reql_type$\": \"GROUPED_DATA\",\n            \"data\": [\n                [\n                    1,\n                    [\n                        {\n                            \"content\": \"content 5\",\n                            \"id\": 5,\n                            \"title\":\"title 5\",\n                            \"user_id\": 1\n                        },\n                        {\n                            \"content\": \"content 3\",\n                            \"id\": 3,\n                            \"title\": \"title 3\",\n                            \"user_id\": 1\n                        },\n                        {\n                            \"content\": \"content 1\",\n                            \"id\": 1,\n                            \"title\": \"title 1\",\n                            \"user_id\": 1\n                        }\n                    ]\n                ],\n                [\n                    2,\n                    [\n                        {\n                            \"content\": \"content 4\",\n                            \"id\": 4,\n                            \"title\": \"title 4\",\n                            \"user_id\": 2\n                        },\n                        {\n                            \"content\": \"content 2\",\n                            \"id\": 2,\n                            \"title\": \"title 2\",\n                            \"user_id\": 2\n                        }\n                    ]\n                ]\n            ]\n        }\n        \"#;\n\n        let elememt: GroupedStream\u003cu8, Posts\u003e = serde_json::from_str(data).unwrap();\n        dbg!(elememt);\n    }\n}\n","traces":[{"line":29,"address":[2656128,2656192],"length":1,"stats":{"Line":2},"fn_name":"deserialize\u003cu8, reql_rust::types::group_stream::tests::Posts, \u0026mut serde_json::de::Deserializer\u003cserde_json::read::StrRead\u003e\u003e"},{"line":30,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":37,"address":[2657361,2657307,2656993,2656939],"length":1,"stats":{"Line":4},"fn_name":null},{"line":38,"address":[2657095,2657039,2657470,2657397],"length":1,"stats":{"Line":4},"fn_name":null},{"line":40,"address":[2657140,2657514],"length":1,"stats":{"Line":2},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[2656765,2656461],"length":1,"stats":{"Line":2},"fn_name":null},{"line":54,"address":[2657728],"length":1,"stats":{"Line":1},"fn_name":"collect\u003calloc::string::String, reql_rust::spec::Post\u003e"},{"line":55,"address":[2657731],"length":1,"stats":{"Line":1},"fn_name":null},{"line":74,"address":[5137840,5138534],"length":1,"stats":{"Line":3},"fn_name":"test_group_stream"},{"line":75,"address":[5137847],"length":1,"stats":{"Line":1},"fn_name":null},{"line":123,"address":[5137874],"length":1,"stats":{"Line":1},"fn_name":null},{"line":124,"address":[5137927],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":15,"coverable":18},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","types","mod.rs"],"content":"use std::borrow::Cow;\n\nuse serde::{Deserialize, Serialize};\nuse serde_json::Value;\nuse uuid::Uuid;\n\nuse crate::arguments::{Durability, ReadMode};\npub use crate::cmd::geojson::ReqlGeoJson;\npub use crate::cmd::line::Line;\npub use crate::cmd::point::Point;\npub use crate::cmd::polygon::Polygon;\npub use binary::Binary;\npub use datetime::DateTime;\npub use group_stream::{GroupedItem, GroupedStream};\npub use time_::Time;\n\npub(crate) use datetime::timezone_to_string;\n\npub use crate::Command;\n\nmod binary;\nmod datetime;\nmod group_stream;\nmod response_with_cmd;\nmod time_;\n\n#[derive(Debug, Clone, Copy, Serialize, Deserialize, PartialEq, PartialOrd, Eq, Ord)]\n#[non_exhaustive]\n#[serde(rename_all = \"SCREAMING_SNAKE_CASE\")]\npub enum ReqlType {\n    Geometry,\n    GroupedStream,\n    GroupedData,\n    Binary,\n    Time,\n}\n\n#[derive(Debug, Clone, Copy, Serialize, Deserialize, PartialEq, PartialOrd)]\npub enum GeoType {\n    LineString,\n    Point,\n    Polygon,\n}\n\n#[derive(Debug, Default, Clone, Deserialize, Serialize, PartialEq, PartialOrd)]\npub struct ServerInfoResponse {\n    /// the UUID of the server the client is connected to.\n    pub id: Uuid,\n    /// a boolean indicating whether the server is a\n    /// [RethinkDB proxy node](https://rethinkdb.com/docs/sharding-and-replication/#running-a-proxy-node).\n    pub proxy: bool,\n    /// the server name. If `proxy` is `true`, this field will not be returned.\n    pub name: Option\u003cString\u003e,\n}\n\n/// Structure of return data in `db` table\n#[derive(Debug, Default, Clone, Deserialize, Serialize, PartialEq, PartialOrd)]\n#[non_exhaustive]\npub struct DbResponse {\n    pub config_changes: Vec\u003cConfigChange\u003cConfigResponse\u003e\u003e,\n    pub dbs_created: Option\u003cusize\u003e,\n    pub dbs_dropped: Option\u003cusize\u003e,\n    pub tables_created: Option\u003cusize\u003e,\n    pub tables_dropped: Option\u003cusize\u003e,\n}\n\n/// Structure of return data in `db` table\n#[derive(Debug, Default, Clone, Deserialize, Serialize, PartialEq)]\n#[non_exhaustive]\npub struct MutationResponse {\n    pub inserted: usize,\n    pub replaced: usize,\n    pub unchanged: usize,\n    pub skipped: usize,\n    pub deleted: usize,\n    pub errors: usize,\n    pub first_error: Option\u003cString\u003e,\n    pub generated_keys: Option\u003cVec\u003cUuid\u003e\u003e,\n    pub warnings: Option\u003cVec\u003cString\u003e\u003e,\n    pub changes: Option\u003cVec\u003cConfigChange\u003cValue\u003e\u003e\u003e,\n}\n\n/// Structure of return data in `index` table\n#[derive(Debug, Clone, Deserialize, Serialize, Eq, PartialEq, Ord, PartialOrd, Hash)]\n#[non_exhaustive]\npub struct IndexResponse {\n    pub created: Option\u003cusize\u003e,\n    pub dropped: Option\u003cusize\u003e,\n    pub renamed: Option\u003cusize\u003e,\n}\n\n#[derive(Debug, Clone, Copy, Deserialize, Serialize, Eq, PartialEq, Ord, PartialOrd, Hash)]\npub struct SetWriteHookResponse {\n    pub created: Option\u003cusize\u003e,\n    pub deleted: Option\u003cusize\u003e,\n    pub replaced: Option\u003cusize\u003e,\n}\n\n/// Structure of return data in `index_status` table\n#[derive(Debug, Clone, Deserialize, Serialize)]\n#[non_exhaustive]\npub struct IndexStatusResponse {\n    pub geo: bool,\n    pub ready: bool,\n    pub multi: bool,\n    pub outdated: bool,\n    pub progress: Option\u003cf64\u003e,\n    pub index: Cow\u003c'static, str\u003e,\n    pub query: Cow\u003c'static, str\u003e,\n    pub function: Binary,\n}\n\n/// Structure of return data in `index_status` table\n#[derive(Debug, Clone, Deserialize, Serialize)]\n#[non_exhaustive]\npub struct GetWriteHookResponse {\n    pub function: Binary,\n    pub query: Cow\u003c'static, str\u003e,\n}\n\n#[derive(Debug, Clone, Deserialize, Serialize)]\n#[non_exhaustive]\npub struct UngroupItem\u003cG, V\u003e {\n    pub group: G,\n    pub reduction: Vec\u003cV\u003e,\n}\n\n#[derive(Debug, Clone, Deserialize, Serialize)]\npub struct SyncResponse {\n    pub synced: u8,\n}\n\n#[derive(Debug, Clone, Copy, Deserialize, Serialize)]\npub struct WaitResponse {\n    /// The value is an integer indicating the number of tables waited for.\n    /// It will always be `1` when `wait` is called on a table,\n    /// and the total number of tables when called on a database.\n    pub ready: u8,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, PartialOrd)]\npub struct JoinResponse\u003cL, R\u003e {\n    pub left: Option\u003cL\u003e,\n    pub right: Option\u003cR\u003e,\n}\n\n#[derive(Debug, Default, Clone, Serialize, Deserialize, PartialEq, PartialOrd)]\npub struct GrantResponse {\n    /// The granted field will always be 1,\n    pub granted: u8,\n    /// list will have one object, describing the new permissions values and\n    /// the old values they were changed from (which may be None).\n    pub permissions_changes: Vec\u003cConfigChange\u003cGrantChangeValue\u003e\u003e,\n}\n\n#[derive(Debug, Default, Clone, Serialize, Deserialize, PartialEq, PartialOrd)]\npub struct RebalanceResponse {\n    /// the number of tables rebalanced.\n    pub rebalanced: u8,\n    /// a list of new and old table status values.\n    /// Each element of the list will be an object with two fields:\n    /// - `old_val`: The table’s [status](crate::Command::status)\n    /// value before `rebalance` was executed.\n    /// - `new_val`: The table’s `status` value after `rebalance` was executed.\n    /// (This value will almost always indicate the table is unavailable.)\n    pub status_changes: Vec\u003cConfigChange\u003cStatusResponse\u003e\u003e,\n}\n\n#[derive(Debug, Default, Clone, Serialize, Deserialize, PartialEq, PartialOrd)]\npub struct ReconfigureResponse {\n    /// the number of tables reconfigured.\n    /// This will be `0` if `dry_run` is `true`.\n    pub reconfigured: u8,\n    /// a list of new and old table configuration values.\n    /// Each element of the list will be an object with two fields\n    /// - `old_val`: The table’s [config](crate::Command::config)\n    /// value before reconfigure was executed.\n    /// - `new_val`: The table’s `config` value after `reconfigure` was executed.\n    pub config_changes: Vec\u003cConfigChange\u003cConfigResponse\u003e\u003e,\n    /// a list of new and old table status values.\n    /// Each element of the list will be an object with two fields\n    /// - `old_val`: The table’s [status](crate::Command::status)\n    /// value before reconfigure was executed.\n    /// - `new_val`: The table’s `config` value after `reconfigure` was executed.\n    pub status_changes: Vec\u003cConfigChange\u003cStatusResponse\u003e\u003e,\n}\n\n#[derive(Debug, Default, Clone, Deserialize, Serialize, PartialEq, PartialOrd)]\npub struct ConfigChange\u003cT\u003e {\n    pub new_val: Option\u003cT\u003e,\n    pub old_val: Option\u003cT\u003e,\n}\n\n#[derive(Debug, Clone, Deserialize, Serialize, Eq, PartialEq, Ord, PartialOrd, Hash)]\npub struct ConfigResponse {\n    pub id: Cow\u003c'static, str\u003e,\n    pub name: Cow\u003c'static, str\u003e,\n\n    pub db: Option\u003cCow\u003c'static, str\u003e\u003e,\n    pub durability: Option\u003cDurability\u003e,\n    pub indexes: Option\u003cVec\u003cCow\u003c'static, str\u003e\u003e\u003e,\n    pub primary_key: Option\u003cCow\u003c'static, str\u003e\u003e,\n    pub shards: Option\u003cVec\u003cShardType\u003cCow\u003c'static, str\u003e\u003e\u003e\u003e,\n    pub write_acks: Option\u003cReadMode\u003e,\n    pub write_hook: Option\u003cCow\u003c'static, str\u003e\u003e,\n}\n\n#[derive(Debug, Clone, Deserialize, Serialize, Eq, PartialEq, Ord, PartialOrd, Hash)]\npub struct GrantChangeValue {\n    pub write: Option\u003cbool\u003e,\n    pub read: Option\u003cbool\u003e,\n    pub connect: Option\u003cbool\u003e,\n    pub config: Option\u003cbool\u003e,\n}\n\n#[derive(Debug, Clone, Deserialize, Serialize, Eq, PartialEq, Ord, PartialOrd, Hash)]\npub struct StatusResponse {\n    /// the UUID of the table.\n    pub id: Option\u003cCow\u003c'static, str\u003e\u003e,\n    /// the table’s name.\n    pub name: Option\u003cCow\u003c'static, str\u003e\u003e,\n    /// the database the table is in.\n    pub db: Option\u003cCow\u003c'static, str\u003e\u003e,\n    /// the subfields in this field indicate whether all shards of\n    /// the table are ready to accept the given type of query\n    pub status: Option\u003cStatusResponseStatus\u003e,\n    /// one entry for each shard in `table_config`\n    pub shards: Option\u003cVec\u003cShardType\u003cShardReplicasType\u003e\u003e\u003e,\n    pub raft_leader: Option\u003cCow\u003c'static, str\u003e\u003e,\n}\n\n#[derive(Debug, Clone, Deserialize, Serialize, Eq, PartialEq, Ord, PartialOrd, Hash)]\npub struct InfoResponse {\n    pub db: DbInfo,\n    pub doc_count_estimates: Vec\u003cusize\u003e,\n    pub id: Cow\u003c'static, str\u003e,\n    pub indexes: Vec\u003cCow\u003c'static, str\u003e\u003e,\n    pub name: Cow\u003c'static, str\u003e,\n    pub primary_key: Cow\u003c'static, str\u003e,\n    #[serde(rename = \"type\")]\n    pub typ: TypeOf,\n}\n\n#[derive(Debug, Clone, Deserialize, Serialize, Eq, PartialEq, Ord, PartialOrd, Hash)]\npub struct DbInfo {\n    id: Cow\u003c'static, str\u003e,\n    name: Cow\u003c'static, str\u003e,\n    #[serde(rename = \"type\")]\n    pub typ: TypeOf,\n}\n\n#[derive(Debug, Clone, Deserialize, Serialize, Eq, PartialEq, Ord, PartialOrd, Hash)]\npub struct StatusResponseStatus {\n    pub all_replicas_ready: Option\u003cbool\u003e,\n    pub ready_for_outdated_reads: Option\u003cbool\u003e,\n    pub ready_for_reads: Option\u003cbool\u003e,\n    pub ready_for_writes: Option\u003cbool\u003e,\n}\n\n#[derive(Debug, Clone, Deserialize, Serialize, PartialEq, PartialOrd)]\npub struct ClosestDocumentResponse\u003cT\u003e {\n    pub dist: f64,\n    pub doc: Option\u003cT\u003e,\n}\n\n#[derive(Debug, Clone, Deserialize, Serialize, Eq, PartialEq, Ord, PartialOrd, Hash)]\npub struct ShardType\u003cR\u003e {\n    pub primary_replica: Option\u003cCow\u003c'static, str\u003e\u003e,\n    pub replicas: Vec\u003cR\u003e,\n    pub nonvoting_replicas: Option\u003cVec\u003cCow\u003c'static, str\u003e\u003e\u003e,\n}\n\n#[derive(Debug, Clone, Deserialize, Serialize, Eq, PartialEq, Ord, PartialOrd, Hash)]\npub struct ShardReplicasType {\n    pub server: Cow\u003c'static, str\u003e,\n    pub state: Cow\u003c'static, str\u003e,\n}\n\n#[derive(Debug, Clone, Deserialize, Serialize, PartialEq, PartialOrd)]\npub struct GeoJson\u003cT: Serialize\u003e {\n    #[serde(rename = \"type\")]\n    pub typ: GeoType,\n    pub coordinates: T,\n}\n\nimpl\u003cT: Serialize + Clone\u003e GeoJson\u003cT\u003e {\n    pub fn new(typ: GeoType, coordinates: T) -\u003e Self {\n        Self { typ, coordinates }\n    }\n}\n\n#[derive(Debug, Clone, Deserialize, Serialize, PartialEq, PartialOrd, Eq, Ord, Hash)]\npub struct MatchResponse {\n    /// The matched string’s start\n    pub start: usize,\n    /// The matched string’s end\n    pub end: usize,\n    /// The matched string\n    pub str: Cow\u003c'static, str\u003e,\n    /// The capture groups defined with parentheses\n    pub groups: Vec\u003cMatchItem\u003e,\n}\n\n#[derive(Debug, Clone, Deserialize, Serialize, PartialEq, PartialOrd, Eq, Ord, Hash)]\npub struct MatchItem {\n    pub start: usize,\n    pub end: usize,\n    pub str: Cow\u003c'static, str\u003e,\n}\n\n/// Controls how change notifications are batched\n#[derive(Debug, Clone, Copy, Serialize, Deserialize, PartialEq, PartialOrd)]\n#[non_exhaustive]\n#[serde(untagged)]\npub enum Squash {\n    Bool(bool),\n    Float(f32),\n}\n\n#[derive(Debug, Clone, Copy, Serialize, Deserialize, Eq, PartialEq, Ord, PartialOrd, Hash)]\npub enum GeoSystem {\n    #[serde(rename = \"unit_sphere\")]\n    UnitSphere,\n    WGS84,\n}\n\n#[derive(Debug, Clone, Copy, Serialize, Deserialize, Eq, PartialEq, Ord, PartialOrd, Hash)]\n#[serde(rename_all = \"UPPERCASE\")]\npub enum TypeOf {\n    Array,\n    Bool,\n    Db,\n    Function,\n    GroupedData,\n    GroupedStream,\n    Maxval,\n    Minval,\n    Null,\n    Number,\n    Object,\n\n    #[serde(rename = \"PTYPE\u003cBINARY\u003e\")]\n    PtypeBinary,\n    #[serde(rename = \"PTYPE\u003cGEOMETRY\u003e\")]\n    PtypeGeometry,\n    #[serde(rename = \"PTYPE\u003cTIME\u003e\")]\n    PtypeTime,\n    #[serde(rename = \"SELECTION\u003cARRAY\u003e\")]\n    SelectionArray,\n    #[serde(rename = \"SELECTION\u003cOBJECT\u003e\")]\n    SelectionObject,\n    #[serde(rename = \"SELECTION\u003cSTREAM\u003e\")]\n    SelectionStream,\n\n    Stream,\n    String,\n    TableSlice,\n    Table,\n}\n","traces":[{"line":276,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":1},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","types","response_with_cmd.rs"],"content":"use crate::Command;\n\n#[derive(Debug, Clone)]\npub struct ResponseWithCmd\u003cT\u003e(pub T, pub Command);\n\nimpl\u003cT\u003e ResponseWithCmd\u003cT\u003e {\n    pub fn value(self) -\u003e T {\n        self.0\n    }\n\n    pub fn cmd(self) -\u003e Command {\n        self.1\n    }\n}\n","traces":[{"line":7,"address":[4773984,4773952,4773920,4773840,4773776,4773872,4773808],"length":1,"stats":{"Line":7},"fn_name":"value\u003cbool\u003e"},{"line":8,"address":[4774009,4773777,4773953,4773809,4773841,4773921,4773873],"length":1,"stats":{"Line":7},"fn_name":null},{"line":11,"address":[4774096,4774128,4774224,4774288,4774256,4774192,4774064],"length":1,"stats":{"Line":7},"fn_name":"cmd\u003cu8\u003e"},{"line":12,"address":[4774296,4774232,4774104,4774264,4774200,4774072,4774145],"length":1,"stats":{"Line":7},"fn_name":null}],"covered":4,"coverable":4},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","src","types","time_.rs"],"content":"use serde::{Deserialize, Serialize};\nuse time::{format_description, OffsetDateTime, UtcOffset};\n\nuse crate::{\n    constants::{NANOS_PER_MSEC, NANOS_PER_SEC},\n    ReqlDriverError, ReqlError, Result,\n};\n\nuse super::ReqlType;\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[non_exhaustive]\npub struct Time {\n    #[serde(rename = \"$reql_type$\")]\n    pub reql_type: ReqlType,\n    pub epoch_time: f64,\n    pub timezone: String,\n}\n\nimpl Time {\n    pub fn new(epoch_time: f64, timezone: String) -\u003e Self {\n        Self {\n            epoch_time,\n            timezone,\n            reql_type: ReqlType::Time,\n        }\n    }\n\n    pub fn is_valid(\u0026self) -\u003e bool {\n        self.to_offset_date_time().is_ok()\n    }\n\n    pub fn to_offset_date_time(\u0026self) -\u003e Result\u003cOffsetDateTime\u003e {\n        let epoch_time = self.epoch_time.to_string();\n        let format = match format_description::parse(\"[offset_hour]:[offset_minute]\") {\n            Ok(fmt) =\u003e fmt,\n            Err(error) =\u003e {\n                return Err(ReqlError::from(error));\n            }\n        };\n        let offset = match UtcOffset::parse(\u0026self.timezone, \u0026format) {\n            Ok(offset) =\u003e offset,\n            Err(error) =\u003e {\n                return Err(ReqlError::from(error));\n            }\n        };\n        let (secs, msecs) = match epoch_time.split_once('.') {\n            Some(parts) =\u003e parts,\n            None =\u003e (epoch_time.as_str(), \"0\"),\n        };\n        let secs = match secs.parse::\u003ci128\u003e() {\n            Ok(secs) =\u003e match secs.checked_mul(NANOS_PER_SEC) {\n                Some(secs) =\u003e secs,\n                None =\u003e {\n                    return Err(ReqlError::Driver(ReqlDriverError::Time(\n                        \"seconds to nanosecond overflow\".to_owned(),\n                    )));\n                }\n            },\n            Err(..) =\u003e {\n                return Err(ReqlError::Driver(ReqlDriverError::Time(\n                    \"invalid epoch time seconds\".to_owned(),\n                )));\n            }\n        };\n        // RethinkDB timestamps have millisecond precision so we need\n        // to convert the milliseconds to nanoseconds first\n        let msecs = match msecs.parse::\u003ci128\u003e() {\n            Ok(int) =\u003e {\n                let msecs = match msecs.len() {\n                    3 =\u003e int,\n                    2 =\u003e int * 10,\n                    1 =\u003e int * 100,\n                    _ =\u003e {\n                        return Err(ReqlError::Driver(ReqlDriverError::Time(\n                            \"invalid epoch milliseconds\".to_owned(),\n                        )));\n                    }\n                };\n                match msecs.checked_mul(NANOS_PER_MSEC) {\n                    Some(msecs) =\u003e msecs,\n                    None =\u003e {\n                        return Err(ReqlError::Driver(ReqlDriverError::Time(\n                            \"millisecond to nanosecond overflow\".to_owned(),\n                        )));\n                    }\n                }\n            }\n            Err(..) =\u003e {\n                return Err(ReqlError::Driver(ReqlDriverError::Time(\n                    \"invalid epoch time milliseconds\".to_owned(),\n                )));\n            }\n        };\n        let timestamp = match secs.checked_add(msecs) {\n            Some(timestamp) =\u003e timestamp,\n            None =\u003e {\n                return Err(ReqlError::Driver(ReqlDriverError::Time(\n                    \"timestamp addition overflow\".to_owned(),\n                )));\n            }\n        };\n\n        let dt = match OffsetDateTime::from_unix_timestamp_nanos(timestamp) {\n            Ok(date_time) =\u003e date_time.to_offset(offset),\n            Err(error) =\u003e {\n                return Err(ReqlError::from(error));\n            }\n        };\n\n        Ok(dt)\n    }\n}\n\nimpl Eq for Time {}\n\nimpl PartialEq for Time {\n    fn eq(\u0026self, other: \u0026Self) -\u003e bool {\n        let dt = self.to_offset_date_time().unwrap();\n        let dt2 = other.to_offset_date_time().unwrap();\n\n        dt.eq(\u0026dt2)\n    }\n}\n\nimpl PartialOrd for Time {\n    fn partial_cmp(\u0026self, other: \u0026Self) -\u003e Option\u003cstd::cmp::Ordering\u003e {\n        let dt = self.to_offset_date_time().unwrap();\n        let dt2 = other.to_offset_date_time().unwrap();\n\n        dt.partial_cmp(\u0026dt2)\n    }\n}\n\nimpl Ord for Time {\n    fn cmp(\u0026self, other: \u0026Self) -\u003e std::cmp::Ordering {\n        let dt = self.to_offset_date_time().unwrap();\n        let dt2 = other.to_offset_date_time().unwrap();\n\n        dt.cmp(\u0026dt2)\n    }\n}\n\nimpl From\u003cOffsetDateTime\u003e for Time {\n    fn from(dt: OffsetDateTime) -\u003e Self {\n        let offset = dt.offset();\n        let timezone = {\n            let (hours, minutes, _) = offset.as_hms();\n            format!(\n                \"{}{:02}:{:02}\",\n                if offset.is_negative() { '-' } else { '+' },\n                hours.abs(),\n                minutes.abs(),\n            )\n        };\n\n        let epoch_time = format!(\"{}.{:03}\", dt.unix_timestamp(), dt.millisecond())\n            .parse()\n            .unwrap();\n\n        Self::new(epoch_time, timezone)\n    }\n}\n","traces":[{"line":21,"address":[1766320],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":29,"address":[1766478,1766400],"length":1,"stats":{"Line":1},"fn_name":"is_valid"},{"line":30,"address":[1766412],"length":1,"stats":{"Line":1},"fn_name":null},{"line":33,"address":[1766528,1770539],"length":1,"stats":{"Line":1},"fn_name":"to_offset_date_time"},{"line":34,"address":[1766567],"length":1,"stats":{"Line":1},"fn_name":null},{"line":35,"address":[1766580,1766655],"length":1,"stats":{"Line":2},"fn_name":null},{"line":36,"address":[1766682],"length":1,"stats":{"Line":1},"fn_name":null},{"line":37,"address":[1766776],"length":1,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[1766824,1766930],"length":1,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[1766746,1767061],"length":1,"stats":{"Line":2},"fn_name":null},{"line":42,"address":[1767086],"length":1,"stats":{"Line":1},"fn_name":null},{"line":43,"address":[1767180],"length":1,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[1767244],"length":1,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[1767154,1767426,1767620],"length":1,"stats":{"Line":3},"fn_name":null},{"line":48,"address":[1767492],"length":1,"stats":{"Line":1},"fn_name":null},{"line":49,"address":[1767466,1767731],"length":1,"stats":{"Line":2},"fn_name":null},{"line":51,"address":[1767708,1767779],"length":1,"stats":{"Line":2},"fn_name":null},{"line":52,"address":[1767797,1768104],"length":1,"stats":{"Line":2},"fn_name":null},{"line":53,"address":[1768193],"length":1,"stats":{"Line":1},"fn_name":null},{"line":55,"address":[1770366],"length":1,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[1768147],"length":1,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[1767907],"length":1,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[1767872],"length":1,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[1768265],"length":1,"stats":{"Line":1},"fn_name":null},{"line":69,"address":[1768306],"length":1,"stats":{"Line":1},"fn_name":null},{"line":70,"address":[1768582,1768348],"length":1,"stats":{"Line":2},"fn_name":null},{"line":71,"address":[1768666],"length":1,"stats":{"Line":1},"fn_name":null},{"line":72,"address":[1769231,1768692],"length":1,"stats":{"Line":2},"fn_name":null},{"line":73,"address":[1769124,1768815],"length":1,"stats":{"Line":2},"fn_name":null},{"line":75,"address":[1768941],"length":1,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[1768626],"length":1,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[1769294,1769174],"length":1,"stats":{"Line":2},"fn_name":null},{"line":81,"address":[1769383],"length":1,"stats":{"Line":1},"fn_name":null},{"line":83,"address":[1770185],"length":1,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[1769337],"length":1,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[1768401],"length":1,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[1768366],"length":1,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[1769431],"length":1,"stats":{"Line":1},"fn_name":null},{"line":96,"address":[1769539],"length":1,"stats":{"Line":1},"fn_name":null},{"line":98,"address":[1770004],"length":1,"stats":{"Line":0},"fn_name":null},{"line":99,"address":[1769509],"length":1,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[1769587],"length":1,"stats":{"Line":1},"fn_name":null},{"line":105,"address":[1769624],"length":1,"stats":{"Line":1},"fn_name":null},{"line":106,"address":[1769737],"length":1,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[1769785],"length":1,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[1769913],"length":1,"stats":{"Line":1},"fn_name":null},{"line":118,"address":[1770576],"length":1,"stats":{"Line":1},"fn_name":"eq"},{"line":119,"address":[1770610],"length":1,"stats":{"Line":1},"fn_name":null},{"line":120,"address":[1770647],"length":1,"stats":{"Line":1},"fn_name":null},{"line":122,"address":[1770679],"length":1,"stats":{"Line":1},"fn_name":null},{"line":127,"address":[1770720],"length":1,"stats":{"Line":0},"fn_name":"partial_cmp"},{"line":128,"address":[1770754],"length":1,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[1770791],"length":1,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[1770823],"length":1,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[1770864],"length":1,"stats":{"Line":0},"fn_name":"cmp"},{"line":137,"address":[1770898],"length":1,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[1770935],"length":1,"stats":{"Line":0},"fn_name":null},{"line":140,"address":[1770967],"length":1,"stats":{"Line":0},"fn_name":null},{"line":145,"address":[1771008,1772295,1772399],"length":1,"stats":{"Line":1},"fn_name":"from"},{"line":146,"address":[1771039],"length":1,"stats":{"Line":1},"fn_name":null},{"line":148,"address":[1771126],"length":1,"stats":{"Line":1},"fn_name":null},{"line":149,"address":[1771383,1771435,1771487],"length":1,"stats":{"Line":3},"fn_name":null},{"line":151,"address":[1771279],"length":1,"stats":{"Line":1},"fn_name":null},{"line":152,"address":[1771420],"length":1,"stats":{"Line":1},"fn_name":null},{"line":153,"address":[1771472],"length":1,"stats":{"Line":1},"fn_name":null},{"line":157,"address":[1771739,1772226,1771820],"length":1,"stats":{"Line":3},"fn_name":null},{"line":161,"address":[1772320],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":41,"coverable":67},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","tests","make_query.rs"],"content":"use futures::stream::{select_all, TryStreamExt};\nuse reql_rust::arguments::ReadMode;\nuse reql_rust::cmd::run::RunOption;\nuse reql_rust::prelude::Converter;\nuse reql_rust::{args, r, Result};\n\n#[tokio::test]\nasync fn simple() -\u003e Result\u003c()\u003e {\n    let conn = r.connection().connect().await?;\n    let run_option = RunOption::default().read_mode(ReadMode::Outdated);\n    let response = r\n        .db(\"rethinkdb\")\n        .table(\"users\")\n        .make_query(args!(\u0026conn, run_option))\n        .try_next()\n        .await?;\n\n    assert!(response.is_some());\n\n    Ok(())\n}\n\n#[tokio::test]\nasync fn concurrency() -\u003e Result\u003c()\u003e {\n    let conn = r.connection().connect().await?;\n    let expected_messages: Vec\u003cString\u003e = (0..10_000)\n        .into_iter()\n        .map(|i| format!(\"message {}\", i))\n        .collect();\n\n    let mut streams = Vec::new();\n\n    for msg in expected_messages.iter() {\n        streams.push(r.expr(msg).make_query(\u0026conn));\n    }\n\n    let mut list = select_all(streams);\n    let mut response = Vec::new();\n\n    while let Some(msg) = list.try_next().await? {\n        let msg: String = msg.parse()?;\n        response.push(msg);\n    }\n\n    assert!(response == expected_messages);\n\n    Ok(())\n}\n","traces":[{"line":8,"address":[1796357,1795952,1796405,1795991],"length":1,"stats":{"Line":6},"fn_name":"simple"},{"line":9,"address":[1519581,1520232,1519498,1519956,1519442,1519732],"length":1,"stats":{"Line":4},"fn_name":null},{"line":10,"address":[1520222,1520493],"length":1,"stats":{"Line":2},"fn_name":null},{"line":11,"address":[1521486,1520624,1521285,1520845,1521095,1520548,1521026],"length":1,"stats":{"Line":6},"fn_name":null},{"line":14,"address":[1520667],"length":1,"stats":{"Line":1},"fn_name":null},{"line":16,"address":[1548774],"length":1,"stats":{"Line":1},"fn_name":null},{"line":18,"address":[1521648,1521700],"length":1,"stats":{"Line":1},"fn_name":null},{"line":20,"address":[1795983,1796368,1796088,1796028],"length":1,"stats":{"Line":5},"fn_name":null},{"line":24,"address":[1796448,1796901,1796487,1796853],"length":1,"stats":{"Line":6},"fn_name":"concurrency"},{"line":25,"address":[1522252,1522018,1522798,1522476,1522101,1521954],"length":1,"stats":{"Line":4},"fn_name":null},{"line":26,"address":[1522734,1523069],"length":1,"stats":{"Line":2},"fn_name":null},{"line":28,"address":[1525328,1525351],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":31,"address":[1523131],"length":1,"stats":{"Line":1},"fn_name":null},{"line":33,"address":[1523528,1523295,1523202,1523617],"length":1,"stats":{"Line":4},"fn_name":null},{"line":34,"address":[1523544],"length":1,"stats":{"Line":1},"fn_name":null},{"line":37,"address":[1523473],"length":1,"stats":{"Line":1},"fn_name":null},{"line":38,"address":[1523689,1523630],"length":1,"stats":{"Line":2},"fn_name":null},{"line":40,"address":[1523699,1525153,1522036,1525275,1524422,1523747,1524512,1524770],"length":1,"stats":{"Line":6},"fn_name":null},{"line":41,"address":[1524988,1524813,1524454],"length":1,"stats":{"Line":2},"fn_name":null},{"line":42,"address":[1524922],"length":1,"stats":{"Line":1},"fn_name":null},{"line":45,"address":[1524658,1524617,1524539],"length":1,"stats":{"Line":2},"fn_name":null},{"line":47,"address":[1524631],"length":1,"stats":{"Line":5},"fn_name":null}],"covered":22,"coverable":22},{"path":["/","home","themasterking","Documents","Work","EXYTECH","rethinkdb-for-rust","tests","run.rs"],"content":"use reql_rust::arguments::ReadMode;\nuse reql_rust::cmd::run::RunOption;\nuse reql_rust::{args, r, Result};\n\n#[tokio::test]\nasync fn test_run_ops() -\u003e Result\u003c()\u003e {\n    let conn = r.connection().connect().await?;\n    let run_option = RunOption::default().read_mode(ReadMode::Outdated);\n    let response = r\n        .db(\"rethinkdb\")\n        .table(\"users\")\n        .run(args!(\u0026conn, run_option))\n        .await?;\n\n    assert!(response.is_some());\n\n    Ok(())\n}\n","traces":[{"line":6,"address":[1329377,1329081,1329242,1329104,1329072,1329680,1329161],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":7,"address":[1329691,1329266,1329482,1329952,1329216,1329337],"length":1,"stats":{"Line":4},"fn_name":null},{"line":8,"address":[1330201,1329942],"length":1,"stats":{"Line":2},"fn_name":null},{"line":9,"address":[1330326,1331094,1330253,1330630,1330701,1330519,1330886],"length":1,"stats":{"Line":6},"fn_name":null},{"line":12,"address":[1330829,1330366,1330542,1330660,1329281],"length":1,"stats":{"Line":4},"fn_name":null},{"line":13,"address":[1331128,1330998],"length":1,"stats":{"Line":0},"fn_name":null},{"line":15,"address":[1330984,1331267,1331230],"length":1,"stats":{"Line":2},"fn_name":null},{"line":17,"address":[1331236],"length":1,"stats":{"Line":5},"fn_name":null}],"covered":7,"coverable":8}]};
    </script>
    <script crossorigin>/** @license React v16.13.1
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
'use strict';(function(d,r){"object"===typeof exports&&"undefined"!==typeof module?r(exports):"function"===typeof define&&define.amd?define(["exports"],r):(d=d||self,r(d.React={}))})(this,function(d){function r(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function w(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function da(){}function L(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function ea(a,b,c){var g,e={},fa=null,d=null;if(null!=b)for(g in void 0!==b.ref&&(d=b.ref),void 0!==b.key&&(fa=""+b.key),b)ha.call(b,g)&&!ia.hasOwnProperty(g)&&(e[g]=b[g]);var h=arguments.length-2;if(1===h)e.children=c;else if(1<h){for(var k=Array(h),f=0;f<h;f++)k[f]=arguments[f+2];e.children=k}if(a&&a.defaultProps)for(g in h=a.defaultProps,
h)void 0===e[g]&&(e[g]=h[g]);return{$$typeof:x,type:a,key:fa,ref:d,props:e,_owner:M.current}}function va(a,b){return{$$typeof:x,type:a.type,key:b,ref:a.ref,props:a.props,_owner:a._owner}}function N(a){return"object"===typeof a&&null!==a&&a.$$typeof===x}function wa(a){var b={"=":"=0",":":"=2"};return"$"+(""+a).replace(/[=:]/g,function(a){return b[a]})}function ja(a,b,c,g){if(C.length){var e=C.pop();e.result=a;e.keyPrefix=b;e.func=c;e.context=g;e.count=0;return e}return{result:a,keyPrefix:b,func:c,
context:g,count:0}}function ka(a){a.result=null;a.keyPrefix=null;a.func=null;a.context=null;a.count=0;10>C.length&&C.push(a)}function O(a,b,c,g){var e=typeof a;if("undefined"===e||"boolean"===e)a=null;var d=!1;if(null===a)d=!0;else switch(e){case "string":case "number":d=!0;break;case "object":switch(a.$$typeof){case x:case xa:d=!0}}if(d)return c(g,a,""===b?"."+P(a,0):b),1;d=0;b=""===b?".":b+":";if(Array.isArray(a))for(var f=0;f<a.length;f++){e=a[f];var h=b+P(e,f);d+=O(e,h,c,g)}else if(null===a||
"object"!==typeof a?h=null:(h=la&&a[la]||a["@@iterator"],h="function"===typeof h?h:null),"function"===typeof h)for(a=h.call(a),f=0;!(e=a.next()).done;)e=e.value,h=b+P(e,f++),d+=O(e,h,c,g);else if("object"===e)throw c=""+a,Error(r(31,"[object Object]"===c?"object with keys {"+Object.keys(a).join(", ")+"}":c,""));return d}function Q(a,b,c){return null==a?0:O(a,"",b,c)}function P(a,b){return"object"===typeof a&&null!==a&&null!=a.key?wa(a.key):b.toString(36)}function ya(a,b,c){a.func.call(a.context,b,
a.count++)}function za(a,b,c){var g=a.result,e=a.keyPrefix;a=a.func.call(a.context,b,a.count++);Array.isArray(a)?R(a,g,c,function(a){return a}):null!=a&&(N(a)&&(a=va(a,e+(!a.key||b&&b.key===a.key?"":(""+a.key).replace(ma,"$&/")+"/")+c)),g.push(a))}function R(a,b,c,g,e){var d="";null!=c&&(d=(""+c).replace(ma,"$&/")+"/");b=ja(b,d,g,e);Q(a,za,b);ka(b)}function t(){var a=na.current;if(null===a)throw Error(r(321));return a}function S(a,b){var c=a.length;a.push(b);a:for(;;){var g=c-1>>>1,e=a[g];if(void 0!==
e&&0<D(e,b))a[g]=b,a[c]=e,c=g;else break a}}function n(a){a=a[0];return void 0===a?null:a}function E(a){var b=a[0];if(void 0!==b){var c=a.pop();if(c!==b){a[0]=c;a:for(var g=0,e=a.length;g<e;){var d=2*(g+1)-1,f=a[d],h=d+1,k=a[h];if(void 0!==f&&0>D(f,c))void 0!==k&&0>D(k,f)?(a[g]=k,a[h]=c,g=h):(a[g]=f,a[d]=c,g=d);else if(void 0!==k&&0>D(k,c))a[g]=k,a[h]=c,g=h;else break a}}return b}return null}function D(a,b){var c=a.sortIndex-b.sortIndex;return 0!==c?c:a.id-b.id}function F(a){for(var b=n(u);null!==
b;){if(null===b.callback)E(u);else if(b.startTime<=a)E(u),b.sortIndex=b.expirationTime,S(p,b);else break;b=n(u)}}function T(a){y=!1;F(a);if(!v)if(null!==n(p))v=!0,z(U);else{var b=n(u);null!==b&&G(T,b.startTime-a)}}function U(a,b){v=!1;y&&(y=!1,V());H=!0;var c=m;try{F(b);for(l=n(p);null!==l&&(!(l.expirationTime>b)||a&&!W());){var g=l.callback;if(null!==g){l.callback=null;m=l.priorityLevel;var e=g(l.expirationTime<=b);b=q();"function"===typeof e?l.callback=e:l===n(p)&&E(p);F(b)}else E(p);l=n(p)}if(null!==
l)var d=!0;else{var f=n(u);null!==f&&G(T,f.startTime-b);d=!1}return d}finally{l=null,m=c,H=!1}}function oa(a){switch(a){case 1:return-1;case 2:return 250;case 5:return 1073741823;case 4:return 1E4;default:return 5E3}}var f="function"===typeof Symbol&&Symbol.for,x=f?Symbol.for("react.element"):60103,xa=f?Symbol.for("react.portal"):60106,Aa=f?Symbol.for("react.fragment"):60107,Ba=f?Symbol.for("react.strict_mode"):60108,Ca=f?Symbol.for("react.profiler"):60114,Da=f?Symbol.for("react.provider"):60109,
Ea=f?Symbol.for("react.context"):60110,Fa=f?Symbol.for("react.forward_ref"):60112,Ga=f?Symbol.for("react.suspense"):60113,Ha=f?Symbol.for("react.memo"):60115,Ia=f?Symbol.for("react.lazy"):60116,la="function"===typeof Symbol&&Symbol.iterator,pa=Object.getOwnPropertySymbols,Ja=Object.prototype.hasOwnProperty,Ka=Object.prototype.propertyIsEnumerable,I=function(){try{if(!Object.assign)return!1;var a=new String("abc");a[5]="de";if("5"===Object.getOwnPropertyNames(a)[0])return!1;var b={};for(a=0;10>a;a++)b["_"+
String.fromCharCode(a)]=a;if("0123456789"!==Object.getOwnPropertyNames(b).map(function(a){return b[a]}).join(""))return!1;var c={};"abcdefghijklmnopqrst".split("").forEach(function(a){c[a]=a});return"abcdefghijklmnopqrst"!==Object.keys(Object.assign({},c)).join("")?!1:!0}catch(g){return!1}}()?Object.assign:function(a,b){if(null===a||void 0===a)throw new TypeError("Object.assign cannot be called with null or undefined");var c=Object(a);for(var g,e=1;e<arguments.length;e++){var d=Object(arguments[e]);
for(var f in d)Ja.call(d,f)&&(c[f]=d[f]);if(pa){g=pa(d);for(var h=0;h<g.length;h++)Ka.call(d,g[h])&&(c[g[h]]=d[g[h]])}}return c},ca={isMounted:function(a){return!1},enqueueForceUpdate:function(a,b,c){},enqueueReplaceState:function(a,b,c,d){},enqueueSetState:function(a,b,c,d){}},ba={};w.prototype.isReactComponent={};w.prototype.setState=function(a,b){if("object"!==typeof a&&"function"!==typeof a&&null!=a)throw Error(r(85));this.updater.enqueueSetState(this,a,b,"setState")};w.prototype.forceUpdate=
function(a){this.updater.enqueueForceUpdate(this,a,"forceUpdate")};da.prototype=w.prototype;f=L.prototype=new da;f.constructor=L;I(f,w.prototype);f.isPureReactComponent=!0;var M={current:null},ha=Object.prototype.hasOwnProperty,ia={key:!0,ref:!0,__self:!0,__source:!0},ma=/\/+/g,C=[],na={current:null},X;if("undefined"===typeof window||"function"!==typeof MessageChannel){var A=null,qa=null,ra=function(){if(null!==A)try{var a=q();A(!0,a);A=null}catch(b){throw setTimeout(ra,0),b;}},La=Date.now();var q=
function(){return Date.now()-La};var z=function(a){null!==A?setTimeout(z,0,a):(A=a,setTimeout(ra,0))};var G=function(a,b){qa=setTimeout(a,b)};var V=function(){clearTimeout(qa)};var W=function(){return!1};f=X=function(){}}else{var Y=window.performance,sa=window.Date,Ma=window.setTimeout,Na=window.clearTimeout;"undefined"!==typeof console&&(f=window.cancelAnimationFrame,"function"!==typeof window.requestAnimationFrame&&console.error("This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"),
"function"!==typeof f&&console.error("This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"));if("object"===typeof Y&&"function"===typeof Y.now)q=function(){return Y.now()};else{var Oa=sa.now();q=function(){return sa.now()-Oa}}var J=!1,K=null,Z=-1,ta=5,ua=0;W=function(){return q()>=ua};f=function(){};X=function(a){0>a||125<a?console.error("forceFrameRate takes a positive int between 0 and 125, forcing framerates higher than 125 fps is not unsupported"):
ta=0<a?Math.floor(1E3/a):5};var B=new MessageChannel,aa=B.port2;B.port1.onmessage=function(){if(null!==K){var a=q();ua=a+ta;try{K(!0,a)?aa.postMessage(null):(J=!1,K=null)}catch(b){throw aa.postMessage(null),b;}}else J=!1};z=function(a){K=a;J||(J=!0,aa.postMessage(null))};G=function(a,b){Z=Ma(function(){a(q())},b)};V=function(){Na(Z);Z=-1}}var p=[],u=[],Pa=1,l=null,m=3,H=!1,v=!1,y=!1,Qa=0;B={ReactCurrentDispatcher:na,ReactCurrentOwner:M,IsSomeRendererActing:{current:!1},assign:I};I(B,{Scheduler:{__proto__:null,
unstable_ImmediatePriority:1,unstable_UserBlockingPriority:2,unstable_NormalPriority:3,unstable_IdlePriority:5,unstable_LowPriority:4,unstable_runWithPriority:function(a,b){switch(a){case 1:case 2:case 3:case 4:case 5:break;default:a=3}var c=m;m=a;try{return b()}finally{m=c}},unstable_next:function(a){switch(m){case 1:case 2:case 3:var b=3;break;default:b=m}var c=m;m=b;try{return a()}finally{m=c}},unstable_scheduleCallback:function(a,b,c){var d=q();if("object"===typeof c&&null!==c){var e=c.delay;
e="number"===typeof e&&0<e?d+e:d;c="number"===typeof c.timeout?c.timeout:oa(a)}else c=oa(a),e=d;c=e+c;a={id:Pa++,callback:b,priorityLevel:a,startTime:e,expirationTime:c,sortIndex:-1};e>d?(a.sortIndex=e,S(u,a),null===n(p)&&a===n(u)&&(y?V():y=!0,G(T,e-d))):(a.sortIndex=c,S(p,a),v||H||(v=!0,z(U)));return a},unstable_cancelCallback:function(a){a.callback=null},unstable_wrapCallback:function(a){var b=m;return function(){var c=m;m=b;try{return a.apply(this,arguments)}finally{m=c}}},unstable_getCurrentPriorityLevel:function(){return m},
unstable_shouldYield:function(){var a=q();F(a);var b=n(p);return b!==l&&null!==l&&null!==b&&null!==b.callback&&b.startTime<=a&&b.expirationTime<l.expirationTime||W()},unstable_requestPaint:f,unstable_continueExecution:function(){v||H||(v=!0,z(U))},unstable_pauseExecution:function(){},unstable_getFirstCallbackNode:function(){return n(p)},get unstable_now(){return q},get unstable_forceFrameRate(){return X},unstable_Profiling:null},SchedulerTracing:{__proto__:null,__interactionsRef:null,__subscriberRef:null,
unstable_clear:function(a){return a()},unstable_getCurrent:function(){return null},unstable_getThreadID:function(){return++Qa},unstable_trace:function(a,b,c){return c()},unstable_wrap:function(a){return a},unstable_subscribe:function(a){},unstable_unsubscribe:function(a){}}});d.Children={map:function(a,b,c){if(null==a)return a;var d=[];R(a,d,null,b,c);return d},forEach:function(a,b,c){if(null==a)return a;b=ja(null,null,b,c);Q(a,ya,b);ka(b)},count:function(a){return Q(a,function(){return null},null)},
toArray:function(a){var b=[];R(a,b,null,function(a){return a});return b},only:function(a){if(!N(a))throw Error(r(143));return a}};d.Component=w;d.Fragment=Aa;d.Profiler=Ca;d.PureComponent=L;d.StrictMode=Ba;d.Suspense=Ga;d.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=B;d.cloneElement=function(a,b,c){if(null===a||void 0===a)throw Error(r(267,a));var d=I({},a.props),e=a.key,f=a.ref,m=a._owner;if(null!=b){void 0!==b.ref&&(f=b.ref,m=M.current);void 0!==b.key&&(e=""+b.key);if(a.type&&a.type.defaultProps)var h=
a.type.defaultProps;for(k in b)ha.call(b,k)&&!ia.hasOwnProperty(k)&&(d[k]=void 0===b[k]&&void 0!==h?h[k]:b[k])}var k=arguments.length-2;if(1===k)d.children=c;else if(1<k){h=Array(k);for(var l=0;l<k;l++)h[l]=arguments[l+2];d.children=h}return{$$typeof:x,type:a.type,key:e,ref:f,props:d,_owner:m}};d.createContext=function(a,b){void 0===b&&(b=null);a={$$typeof:Ea,_calculateChangedBits:b,_currentValue:a,_currentValue2:a,_threadCount:0,Provider:null,Consumer:null};a.Provider={$$typeof:Da,_context:a};return a.Consumer=
a};d.createElement=ea;d.createFactory=function(a){var b=ea.bind(null,a);b.type=a;return b};d.createRef=function(){return{current:null}};d.forwardRef=function(a){return{$$typeof:Fa,render:a}};d.isValidElement=N;d.lazy=function(a){return{$$typeof:Ia,_ctor:a,_status:-1,_result:null}};d.memo=function(a,b){return{$$typeof:Ha,type:a,compare:void 0===b?null:b}};d.useCallback=function(a,b){return t().useCallback(a,b)};d.useContext=function(a,b){return t().useContext(a,b)};d.useDebugValue=function(a,b){};
d.useEffect=function(a,b){return t().useEffect(a,b)};d.useImperativeHandle=function(a,b,c){return t().useImperativeHandle(a,b,c)};d.useLayoutEffect=function(a,b){return t().useLayoutEffect(a,b)};d.useMemo=function(a,b){return t().useMemo(a,b)};d.useReducer=function(a,b,c){return t().useReducer(a,b,c)};d.useRef=function(a){return t().useRef(a)};d.useState=function(a){return t().useState(a)};d.version="16.13.1"});
</script>
    <script crossorigin>/** @license React v16.13.1
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/*
 Modernizr 3.0.0pre (Custom Build) | MIT
*/
'use strict';(function(I,ea){"object"===typeof exports&&"undefined"!==typeof module?ea(exports,require("react")):"function"===typeof define&&define.amd?define(["exports","react"],ea):(I=I||self,ea(I.ReactDOM={},I.React))})(this,function(I,ea){function k(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function ji(a,b,c,d,e,f,g,h,m){yb=!1;gc=null;ki.apply(li,arguments)}function mi(a,b,c,d,e,f,g,h,m){ji.apply(this,arguments);if(yb){if(yb){var n=gc;yb=!1;gc=null}else throw Error(k(198));hc||(hc=!0,pd=n)}}function lf(a,b,c){var d=a.type||"unknown-event";a.currentTarget=mf(c);mi(d,b,void 0,a);a.currentTarget=null}function nf(){if(ic)for(var a in cb){var b=cb[a],c=ic.indexOf(a);if(!(-1<c))throw Error(k(96,a));if(!jc[c]){if(!b.extractEvents)throw Error(k(97,a));jc[c]=b;c=b.eventTypes;for(var d in c){var e=
void 0;var f=c[d],g=b,h=d;if(qd.hasOwnProperty(h))throw Error(k(99,h));qd[h]=f;var m=f.phasedRegistrationNames;if(m){for(e in m)m.hasOwnProperty(e)&&of(m[e],g,h);e=!0}else f.registrationName?(of(f.registrationName,g,h),e=!0):e=!1;if(!e)throw Error(k(98,d,a));}}}}function of(a,b,c){if(db[a])throw Error(k(100,a));db[a]=b;rd[a]=b.eventTypes[c].dependencies}function pf(a){var b=!1,c;for(c in a)if(a.hasOwnProperty(c)){var d=a[c];if(!cb.hasOwnProperty(c)||cb[c]!==d){if(cb[c])throw Error(k(102,c));cb[c]=
d;b=!0}}b&&nf()}function qf(a){if(a=rf(a)){if("function"!==typeof sd)throw Error(k(280));var b=a.stateNode;b&&(b=td(b),sd(a.stateNode,a.type,b))}}function sf(a){eb?fb?fb.push(a):fb=[a]:eb=a}function tf(){if(eb){var a=eb,b=fb;fb=eb=null;qf(a);if(b)for(a=0;a<b.length;a++)qf(b[a])}}function ud(){if(null!==eb||null!==fb)vd(),tf()}function uf(a,b,c){if(wd)return a(b,c);wd=!0;try{return vf(a,b,c)}finally{wd=!1,ud()}}function ni(a){if(wf.call(xf,a))return!0;if(wf.call(yf,a))return!1;if(oi.test(a))return xf[a]=
!0;yf[a]=!0;return!1}function pi(a,b,c,d){if(null!==c&&0===c.type)return!1;switch(typeof b){case "function":case "symbol":return!0;case "boolean":if(d)return!1;if(null!==c)return!c.acceptsBooleans;a=a.toLowerCase().slice(0,5);return"data-"!==a&&"aria-"!==a;default:return!1}}function qi(a,b,c,d){if(null===b||"undefined"===typeof b||pi(a,b,c,d))return!0;if(d)return!1;if(null!==c)switch(c.type){case 3:return!b;case 4:return!1===b;case 5:return isNaN(b);case 6:return isNaN(b)||1>b}return!1}function L(a,
b,c,d,e,f){this.acceptsBooleans=2===b||3===b||4===b;this.attributeName=d;this.attributeNamespace=e;this.mustUseProperty=c;this.propertyName=a;this.type=b;this.sanitizeURL=f}function xd(a,b,c,d){var e=E.hasOwnProperty(b)?E[b]:null;var f=null!==e?0===e.type:d?!1:!(2<b.length)||"o"!==b[0]&&"O"!==b[0]||"n"!==b[1]&&"N"!==b[1]?!1:!0;f||(qi(b,c,e,d)&&(c=null),d||null===e?ni(b)&&(null===c?a.removeAttribute(b):a.setAttribute(b,""+c)):e.mustUseProperty?a[e.propertyName]=null===c?3===e.type?!1:"":c:(b=e.attributeName,
d=e.attributeNamespace,null===c?a.removeAttribute(b):(e=e.type,c=3===e||4===e&&!0===c?"":""+c,d?a.setAttributeNS(d,b,c):a.setAttribute(b,c))))}function zb(a){if(null===a||"object"!==typeof a)return null;a=zf&&a[zf]||a["@@iterator"];return"function"===typeof a?a:null}function ri(a){if(-1===a._status){a._status=0;var b=a._ctor;b=b();a._result=b;b.then(function(b){0===a._status&&(b=b.default,a._status=1,a._result=b)},function(b){0===a._status&&(a._status=2,a._result=b)})}}function na(a){if(null==a)return null;
if("function"===typeof a)return a.displayName||a.name||null;if("string"===typeof a)return a;switch(a){case Ma:return"Fragment";case gb:return"Portal";case kc:return"Profiler";case Af:return"StrictMode";case lc:return"Suspense";case yd:return"SuspenseList"}if("object"===typeof a)switch(a.$$typeof){case Bf:return"Context.Consumer";case Cf:return"Context.Provider";case zd:var b=a.render;b=b.displayName||b.name||"";return a.displayName||(""!==b?"ForwardRef("+b+")":"ForwardRef");case Ad:return na(a.type);
case Df:return na(a.render);case Ef:if(a=1===a._status?a._result:null)return na(a)}return null}function Bd(a){var b="";do{a:switch(a.tag){case 3:case 4:case 6:case 7:case 10:case 9:var c="";break a;default:var d=a._debugOwner,e=a._debugSource,f=na(a.type);c=null;d&&(c=na(d.type));d=f;f="";e?f=" (at "+e.fileName.replace(si,"")+":"+e.lineNumber+")":c&&(f=" (created by "+c+")");c="\n    in "+(d||"Unknown")+f}b+=c;a=a.return}while(a);return b}function va(a){switch(typeof a){case "boolean":case "number":case "object":case "string":case "undefined":return a;
default:return""}}function Ff(a){var b=a.type;return(a=a.nodeName)&&"input"===a.toLowerCase()&&("checkbox"===b||"radio"===b)}function ti(a){var b=Ff(a)?"checked":"value",c=Object.getOwnPropertyDescriptor(a.constructor.prototype,b),d=""+a[b];if(!a.hasOwnProperty(b)&&"undefined"!==typeof c&&"function"===typeof c.get&&"function"===typeof c.set){var e=c.get,f=c.set;Object.defineProperty(a,b,{configurable:!0,get:function(){return e.call(this)},set:function(a){d=""+a;f.call(this,a)}});Object.defineProperty(a,
b,{enumerable:c.enumerable});return{getValue:function(){return d},setValue:function(a){d=""+a},stopTracking:function(){a._valueTracker=null;delete a[b]}}}}function mc(a){a._valueTracker||(a._valueTracker=ti(a))}function Gf(a){if(!a)return!1;var b=a._valueTracker;if(!b)return!0;var c=b.getValue();var d="";a&&(d=Ff(a)?a.checked?"true":"false":a.value);a=d;return a!==c?(b.setValue(a),!0):!1}function Cd(a,b){var c=b.checked;return M({},b,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:null!=
c?c:a._wrapperState.initialChecked})}function Hf(a,b){var c=null==b.defaultValue?"":b.defaultValue,d=null!=b.checked?b.checked:b.defaultChecked;c=va(null!=b.value?b.value:c);a._wrapperState={initialChecked:d,initialValue:c,controlled:"checkbox"===b.type||"radio"===b.type?null!=b.checked:null!=b.value}}function If(a,b){b=b.checked;null!=b&&xd(a,"checked",b,!1)}function Dd(a,b){If(a,b);var c=va(b.value),d=b.type;if(null!=c)if("number"===d){if(0===c&&""===a.value||a.value!=c)a.value=""+c}else a.value!==
""+c&&(a.value=""+c);else if("submit"===d||"reset"===d){a.removeAttribute("value");return}b.hasOwnProperty("value")?Ed(a,b.type,c):b.hasOwnProperty("defaultValue")&&Ed(a,b.type,va(b.defaultValue));null==b.checked&&null!=b.defaultChecked&&(a.defaultChecked=!!b.defaultChecked)}function Jf(a,b,c){if(b.hasOwnProperty("value")||b.hasOwnProperty("defaultValue")){var d=b.type;if(!("submit"!==d&&"reset"!==d||void 0!==b.value&&null!==b.value))return;b=""+a._wrapperState.initialValue;c||b===a.value||(a.value=
b);a.defaultValue=b}c=a.name;""!==c&&(a.name="");a.defaultChecked=!!a._wrapperState.initialChecked;""!==c&&(a.name=c)}function Ed(a,b,c){if("number"!==b||a.ownerDocument.activeElement!==a)null==c?a.defaultValue=""+a._wrapperState.initialValue:a.defaultValue!==""+c&&(a.defaultValue=""+c)}function ui(a){var b="";ea.Children.forEach(a,function(a){null!=a&&(b+=a)});return b}function Fd(a,b){a=M({children:void 0},b);if(b=ui(b.children))a.children=b;return a}function hb(a,b,c,d){a=a.options;if(b){b={};
for(var e=0;e<c.length;e++)b["$"+c[e]]=!0;for(c=0;c<a.length;c++)e=b.hasOwnProperty("$"+a[c].value),a[c].selected!==e&&(a[c].selected=e),e&&d&&(a[c].defaultSelected=!0)}else{c=""+va(c);b=null;for(e=0;e<a.length;e++){if(a[e].value===c){a[e].selected=!0;d&&(a[e].defaultSelected=!0);return}null!==b||a[e].disabled||(b=a[e])}null!==b&&(b.selected=!0)}}function Gd(a,b){if(null!=b.dangerouslySetInnerHTML)throw Error(k(91));return M({},b,{value:void 0,defaultValue:void 0,children:""+a._wrapperState.initialValue})}
function Kf(a,b){var c=b.value;if(null==c){c=b.children;b=b.defaultValue;if(null!=c){if(null!=b)throw Error(k(92));if(Array.isArray(c)){if(!(1>=c.length))throw Error(k(93));c=c[0]}b=c}null==b&&(b="");c=b}a._wrapperState={initialValue:va(c)}}function Lf(a,b){var c=va(b.value),d=va(b.defaultValue);null!=c&&(c=""+c,c!==a.value&&(a.value=c),null==b.defaultValue&&a.defaultValue!==c&&(a.defaultValue=c));null!=d&&(a.defaultValue=""+d)}function Mf(a,b){b=a.textContent;b===a._wrapperState.initialValue&&""!==
b&&null!==b&&(a.value=b)}function Nf(a){switch(a){case "svg":return"http://www.w3.org/2000/svg";case "math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function Hd(a,b){return null==a||"http://www.w3.org/1999/xhtml"===a?Nf(b):"http://www.w3.org/2000/svg"===a&&"foreignObject"===b?"http://www.w3.org/1999/xhtml":a}function nc(a,b){var c={};c[a.toLowerCase()]=b.toLowerCase();c["Webkit"+a]="webkit"+b;c["Moz"+a]="moz"+b;return c}function oc(a){if(Id[a])return Id[a];
if(!ib[a])return a;var b=ib[a],c;for(c in b)if(b.hasOwnProperty(c)&&c in Of)return Id[a]=b[c];return a}function Jd(a){var b=Pf.get(a);void 0===b&&(b=new Map,Pf.set(a,b));return b}function Na(a){var b=a,c=a;if(a.alternate)for(;b.return;)b=b.return;else{a=b;do b=a,0!==(b.effectTag&1026)&&(c=b.return),a=b.return;while(a)}return 3===b.tag?c:null}function Qf(a){if(13===a.tag){var b=a.memoizedState;null===b&&(a=a.alternate,null!==a&&(b=a.memoizedState));if(null!==b)return b.dehydrated}return null}function Rf(a){if(Na(a)!==
a)throw Error(k(188));}function vi(a){var b=a.alternate;if(!b){b=Na(a);if(null===b)throw Error(k(188));return b!==a?null:a}for(var c=a,d=b;;){var e=c.return;if(null===e)break;var f=e.alternate;if(null===f){d=e.return;if(null!==d){c=d;continue}break}if(e.child===f.child){for(f=e.child;f;){if(f===c)return Rf(e),a;if(f===d)return Rf(e),b;f=f.sibling}throw Error(k(188));}if(c.return!==d.return)c=e,d=f;else{for(var g=!1,h=e.child;h;){if(h===c){g=!0;c=e;d=f;break}if(h===d){g=!0;d=e;c=f;break}h=h.sibling}if(!g){for(h=
f.child;h;){if(h===c){g=!0;c=f;d=e;break}if(h===d){g=!0;d=f;c=e;break}h=h.sibling}if(!g)throw Error(k(189));}}if(c.alternate!==d)throw Error(k(190));}if(3!==c.tag)throw Error(k(188));return c.stateNode.current===c?a:b}function Sf(a){a=vi(a);if(!a)return null;for(var b=a;;){if(5===b.tag||6===b.tag)return b;if(b.child)b.child.return=b,b=b.child;else{if(b===a)break;for(;!b.sibling;){if(!b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}}return null}function jb(a,b){if(null==
b)throw Error(k(30));if(null==a)return b;if(Array.isArray(a)){if(Array.isArray(b))return a.push.apply(a,b),a;a.push(b);return a}return Array.isArray(b)?[a].concat(b):[a,b]}function Kd(a,b,c){Array.isArray(a)?a.forEach(b,c):a&&b.call(c,a)}function pc(a){null!==a&&(Ab=jb(Ab,a));a=Ab;Ab=null;if(a){Kd(a,wi);if(Ab)throw Error(k(95));if(hc)throw a=pd,hc=!1,pd=null,a;}}function Ld(a){a=a.target||a.srcElement||window;a.correspondingUseElement&&(a=a.correspondingUseElement);return 3===a.nodeType?a.parentNode:
a}function Tf(a){if(!wa)return!1;a="on"+a;var b=a in document;b||(b=document.createElement("div"),b.setAttribute(a,"return;"),b="function"===typeof b[a]);return b}function Uf(a){a.topLevelType=null;a.nativeEvent=null;a.targetInst=null;a.ancestors.length=0;10>qc.length&&qc.push(a)}function Vf(a,b,c,d){if(qc.length){var e=qc.pop();e.topLevelType=a;e.eventSystemFlags=d;e.nativeEvent=b;e.targetInst=c;return e}return{topLevelType:a,eventSystemFlags:d,nativeEvent:b,targetInst:c,ancestors:[]}}function Wf(a){var b=
a.targetInst,c=b;do{if(!c){a.ancestors.push(c);break}var d=c;if(3===d.tag)d=d.stateNode.containerInfo;else{for(;d.return;)d=d.return;d=3!==d.tag?null:d.stateNode.containerInfo}if(!d)break;b=c.tag;5!==b&&6!==b||a.ancestors.push(c);c=Bb(d)}while(c);for(c=0;c<a.ancestors.length;c++){b=a.ancestors[c];var e=Ld(a.nativeEvent);d=a.topLevelType;var f=a.nativeEvent,g=a.eventSystemFlags;0===c&&(g|=64);for(var h=null,m=0;m<jc.length;m++){var n=jc[m];n&&(n=n.extractEvents(d,b,f,e,g))&&(h=jb(h,n))}pc(h)}}function Md(a,
b,c){if(!c.has(a)){switch(a){case "scroll":Cb(b,"scroll",!0);break;case "focus":case "blur":Cb(b,"focus",!0);Cb(b,"blur",!0);c.set("blur",null);c.set("focus",null);break;case "cancel":case "close":Tf(a)&&Cb(b,a,!0);break;case "invalid":case "submit":case "reset":break;default:-1===Db.indexOf(a)&&w(a,b)}c.set(a,null)}}function xi(a,b){var c=Jd(b);Nd.forEach(function(a){Md(a,b,c)});yi.forEach(function(a){Md(a,b,c)})}function Od(a,b,c,d,e){return{blockedOn:a,topLevelType:b,eventSystemFlags:c|32,nativeEvent:e,
container:d}}function Xf(a,b){switch(a){case "focus":case "blur":xa=null;break;case "dragenter":case "dragleave":ya=null;break;case "mouseover":case "mouseout":za=null;break;case "pointerover":case "pointerout":Eb.delete(b.pointerId);break;case "gotpointercapture":case "lostpointercapture":Fb.delete(b.pointerId)}}function Gb(a,b,c,d,e,f){if(null===a||a.nativeEvent!==f)return a=Od(b,c,d,e,f),null!==b&&(b=Hb(b),null!==b&&Yf(b)),a;a.eventSystemFlags|=d;return a}function zi(a,b,c,d,e){switch(b){case "focus":return xa=
Gb(xa,a,b,c,d,e),!0;case "dragenter":return ya=Gb(ya,a,b,c,d,e),!0;case "mouseover":return za=Gb(za,a,b,c,d,e),!0;case "pointerover":var f=e.pointerId;Eb.set(f,Gb(Eb.get(f)||null,a,b,c,d,e));return!0;case "gotpointercapture":return f=e.pointerId,Fb.set(f,Gb(Fb.get(f)||null,a,b,c,d,e)),!0}return!1}function Ai(a){var b=Bb(a.target);if(null!==b){var c=Na(b);if(null!==c)if(b=c.tag,13===b){if(b=Qf(c),null!==b){a.blockedOn=b;Pd(a.priority,function(){Bi(c)});return}}else if(3===b&&c.stateNode.hydrate){a.blockedOn=
3===c.tag?c.stateNode.containerInfo:null;return}}a.blockedOn=null}function rc(a){if(null!==a.blockedOn)return!1;var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);if(null!==b){var c=Hb(b);null!==c&&Yf(c);a.blockedOn=b;return!1}return!0}function Zf(a,b,c){rc(a)&&c.delete(b)}function Ci(){for(Rd=!1;0<fa.length;){var a=fa[0];if(null!==a.blockedOn){a=Hb(a.blockedOn);null!==a&&Di(a);break}var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);null!==b?a.blockedOn=b:fa.shift()}null!==
xa&&rc(xa)&&(xa=null);null!==ya&&rc(ya)&&(ya=null);null!==za&&rc(za)&&(za=null);Eb.forEach(Zf);Fb.forEach(Zf)}function Ib(a,b){a.blockedOn===b&&(a.blockedOn=null,Rd||(Rd=!0,$f(ag,Ci)))}function bg(a){if(0<fa.length){Ib(fa[0],a);for(var b=1;b<fa.length;b++){var c=fa[b];c.blockedOn===a&&(c.blockedOn=null)}}null!==xa&&Ib(xa,a);null!==ya&&Ib(ya,a);null!==za&&Ib(za,a);b=function(b){return Ib(b,a)};Eb.forEach(b);Fb.forEach(b);for(b=0;b<Jb.length;b++)c=Jb[b],c.blockedOn===a&&(c.blockedOn=null);for(;0<Jb.length&&
(b=Jb[0],null===b.blockedOn);)Ai(b),null===b.blockedOn&&Jb.shift()}function Sd(a,b){for(var c=0;c<a.length;c+=2){var d=a[c],e=a[c+1],f="on"+(e[0].toUpperCase()+e.slice(1));f={phasedRegistrationNames:{bubbled:f,captured:f+"Capture"},dependencies:[d],eventPriority:b};Td.set(d,b);cg.set(d,f);dg[e]=f}}function w(a,b){Cb(b,a,!1)}function Cb(a,b,c){var d=Td.get(b);switch(void 0===d?2:d){case 0:d=Ei.bind(null,b,1,a);break;case 1:d=Fi.bind(null,b,1,a);break;default:d=sc.bind(null,b,1,a)}c?a.addEventListener(b,
d,!0):a.addEventListener(b,d,!1)}function Ei(a,b,c,d){Oa||vd();var e=sc,f=Oa;Oa=!0;try{eg(e,a,b,c,d)}finally{(Oa=f)||ud()}}function Fi(a,b,c,d){Gi(Hi,sc.bind(null,a,b,c,d))}function sc(a,b,c,d){if(tc)if(0<fa.length&&-1<Nd.indexOf(a))a=Od(null,a,b,c,d),fa.push(a);else{var e=Qd(a,b,c,d);if(null===e)Xf(a,d);else if(-1<Nd.indexOf(a))a=Od(e,a,b,c,d),fa.push(a);else if(!zi(e,a,b,c,d)){Xf(a,d);a=Vf(a,d,null,b);try{uf(Wf,a)}finally{Uf(a)}}}}function Qd(a,b,c,d){c=Ld(d);c=Bb(c);if(null!==c){var e=Na(c);if(null===
e)c=null;else{var f=e.tag;if(13===f){c=Qf(e);if(null!==c)return c;c=null}else if(3===f){if(e.stateNode.hydrate)return 3===e.tag?e.stateNode.containerInfo:null;c=null}else e!==c&&(c=null)}}a=Vf(a,d,c,b);try{uf(Wf,a)}finally{Uf(a)}return null}function fg(a,b,c){return null==b||"boolean"===typeof b||""===b?"":c||"number"!==typeof b||0===b||Kb.hasOwnProperty(a)&&Kb[a]?(""+b).trim():b+"px"}function gg(a,b){a=a.style;for(var c in b)if(b.hasOwnProperty(c)){var d=0===c.indexOf("--"),e=fg(c,b[c],d);"float"===
c&&(c="cssFloat");d?a.setProperty(c,e):a[c]=e}}function Ud(a,b){if(b){if(Ii[a]&&(null!=b.children||null!=b.dangerouslySetInnerHTML))throw Error(k(137,a,""));if(null!=b.dangerouslySetInnerHTML){if(null!=b.children)throw Error(k(60));if(!("object"===typeof b.dangerouslySetInnerHTML&&"__html"in b.dangerouslySetInnerHTML))throw Error(k(61));}if(null!=b.style&&"object"!==typeof b.style)throw Error(k(62,""));}}function Vd(a,b){if(-1===a.indexOf("-"))return"string"===typeof b.is;switch(a){case "annotation-xml":case "color-profile":case "font-face":case "font-face-src":case "font-face-uri":case "font-face-format":case "font-face-name":case "missing-glyph":return!1;
default:return!0}}function oa(a,b){a=9===a.nodeType||11===a.nodeType?a:a.ownerDocument;var c=Jd(a);b=rd[b];for(var d=0;d<b.length;d++)Md(b[d],a,c)}function uc(){}function Wd(a){a=a||("undefined"!==typeof document?document:void 0);if("undefined"===typeof a)return null;try{return a.activeElement||a.body}catch(b){return a.body}}function hg(a){for(;a&&a.firstChild;)a=a.firstChild;return a}function ig(a,b){var c=hg(a);a=0;for(var d;c;){if(3===c.nodeType){d=a+c.textContent.length;if(a<=b&&d>=b)return{node:c,
offset:b-a};a=d}a:{for(;c;){if(c.nextSibling){c=c.nextSibling;break a}c=c.parentNode}c=void 0}c=hg(c)}}function jg(a,b){return a&&b?a===b?!0:a&&3===a.nodeType?!1:b&&3===b.nodeType?jg(a,b.parentNode):"contains"in a?a.contains(b):a.compareDocumentPosition?!!(a.compareDocumentPosition(b)&16):!1:!1}function kg(){for(var a=window,b=Wd();b instanceof a.HTMLIFrameElement;){try{var c="string"===typeof b.contentWindow.location.href}catch(d){c=!1}if(c)a=b.contentWindow;else break;b=Wd(a.document)}return b}
function Xd(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return b&&("input"===b&&("text"===a.type||"search"===a.type||"tel"===a.type||"url"===a.type||"password"===a.type)||"textarea"===b||"true"===a.contentEditable)}function lg(a,b){switch(a){case "button":case "input":case "select":case "textarea":return!!b.autoFocus}return!1}function Yd(a,b){return"textarea"===a||"option"===a||"noscript"===a||"string"===typeof b.children||"number"===typeof b.children||"object"===typeof b.dangerouslySetInnerHTML&&
null!==b.dangerouslySetInnerHTML&&null!=b.dangerouslySetInnerHTML.__html}function kb(a){for(;null!=a;a=a.nextSibling){var b=a.nodeType;if(1===b||3===b)break}return a}function mg(a){a=a.previousSibling;for(var b=0;a;){if(8===a.nodeType){var c=a.data;if(c===ng||c===Zd||c===$d){if(0===b)return a;b--}else c===og&&b++}a=a.previousSibling}return null}function Bb(a){var b=a[Aa];if(b)return b;for(var c=a.parentNode;c;){if(b=c[Lb]||c[Aa]){c=b.alternate;if(null!==b.child||null!==c&&null!==c.child)for(a=mg(a);null!==
a;){if(c=a[Aa])return c;a=mg(a)}return b}a=c;c=a.parentNode}return null}function Hb(a){a=a[Aa]||a[Lb];return!a||5!==a.tag&&6!==a.tag&&13!==a.tag&&3!==a.tag?null:a}function Pa(a){if(5===a.tag||6===a.tag)return a.stateNode;throw Error(k(33));}function ae(a){return a[vc]||null}function pa(a){do a=a.return;while(a&&5!==a.tag);return a?a:null}function pg(a,b){var c=a.stateNode;if(!c)return null;var d=td(c);if(!d)return null;c=d[b];a:switch(b){case "onClick":case "onClickCapture":case "onDoubleClick":case "onDoubleClickCapture":case "onMouseDown":case "onMouseDownCapture":case "onMouseMove":case "onMouseMoveCapture":case "onMouseUp":case "onMouseUpCapture":case "onMouseEnter":(d=
!d.disabled)||(a=a.type,d=!("button"===a||"input"===a||"select"===a||"textarea"===a));a=!d;break a;default:a=!1}if(a)return null;if(c&&"function"!==typeof c)throw Error(k(231,b,typeof c));return c}function qg(a,b,c){if(b=pg(a,c.dispatchConfig.phasedRegistrationNames[b]))c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a)}function Ji(a){if(a&&a.dispatchConfig.phasedRegistrationNames){for(var b=a._targetInst,c=[];b;)c.push(b),b=pa(b);for(b=c.length;0<b--;)qg(c[b],
"captured",a);for(b=0;b<c.length;b++)qg(c[b],"bubbled",a)}}function be(a,b,c){a&&c&&c.dispatchConfig.registrationName&&(b=pg(a,c.dispatchConfig.registrationName))&&(c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a))}function Ki(a){a&&a.dispatchConfig.registrationName&&be(a._targetInst,null,a)}function lb(a){Kd(a,Ji)}function rg(){if(wc)return wc;var a,b=ce,c=b.length,d,e="value"in Ba?Ba.value:Ba.textContent,f=e.length;for(a=0;a<c&&b[a]===e[a];a++);var g=
c-a;for(d=1;d<=g&&b[c-d]===e[f-d];d++);return wc=e.slice(a,1<d?1-d:void 0)}function xc(){return!0}function yc(){return!1}function R(a,b,c,d){this.dispatchConfig=a;this._targetInst=b;this.nativeEvent=c;a=this.constructor.Interface;for(var e in a)a.hasOwnProperty(e)&&((b=a[e])?this[e]=b(c):"target"===e?this.target=d:this[e]=c[e]);this.isDefaultPrevented=(null!=c.defaultPrevented?c.defaultPrevented:!1===c.returnValue)?xc:yc;this.isPropagationStopped=yc;return this}function Li(a,b,c,d){if(this.eventPool.length){var e=
this.eventPool.pop();this.call(e,a,b,c,d);return e}return new this(a,b,c,d)}function Mi(a){if(!(a instanceof this))throw Error(k(279));a.destructor();10>this.eventPool.length&&this.eventPool.push(a)}function sg(a){a.eventPool=[];a.getPooled=Li;a.release=Mi}function tg(a,b){switch(a){case "keyup":return-1!==Ni.indexOf(b.keyCode);case "keydown":return 229!==b.keyCode;case "keypress":case "mousedown":case "blur":return!0;default:return!1}}function ug(a){a=a.detail;return"object"===typeof a&&"data"in
a?a.data:null}function Oi(a,b){switch(a){case "compositionend":return ug(b);case "keypress":if(32!==b.which)return null;vg=!0;return wg;case "textInput":return a=b.data,a===wg&&vg?null:a;default:return null}}function Pi(a,b){if(mb)return"compositionend"===a||!de&&tg(a,b)?(a=rg(),wc=ce=Ba=null,mb=!1,a):null;switch(a){case "paste":return null;case "keypress":if(!(b.ctrlKey||b.altKey||b.metaKey)||b.ctrlKey&&b.altKey){if(b.char&&1<b.char.length)return b.char;if(b.which)return String.fromCharCode(b.which)}return null;
case "compositionend":return xg&&"ko"!==b.locale?null:b.data;default:return null}}function yg(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return"input"===b?!!Qi[a.type]:"textarea"===b?!0:!1}function zg(a,b,c){a=R.getPooled(Ag.change,a,b,c);a.type="change";sf(c);lb(a);return a}function Ri(a){pc(a)}function zc(a){var b=Pa(a);if(Gf(b))return a}function Si(a,b){if("change"===a)return b}function Bg(){Mb&&(Mb.detachEvent("onpropertychange",Cg),Nb=Mb=null)}function Cg(a){if("value"===a.propertyName&&
zc(Nb))if(a=zg(Nb,a,Ld(a)),Oa)pc(a);else{Oa=!0;try{ee(Ri,a)}finally{Oa=!1,ud()}}}function Ti(a,b,c){"focus"===a?(Bg(),Mb=b,Nb=c,Mb.attachEvent("onpropertychange",Cg)):"blur"===a&&Bg()}function Ui(a,b){if("selectionchange"===a||"keyup"===a||"keydown"===a)return zc(Nb)}function Vi(a,b){if("click"===a)return zc(b)}function Wi(a,b){if("input"===a||"change"===a)return zc(b)}function Xi(a){var b=this.nativeEvent;return b.getModifierState?b.getModifierState(a):(a=Yi[a])?!!b[a]:!1}function fe(a){return Xi}
function Zi(a,b){return a===b&&(0!==a||1/a===1/b)||a!==a&&b!==b}function Ob(a,b){if(Qa(a,b))return!0;if("object"!==typeof a||null===a||"object"!==typeof b||null===b)return!1;var c=Object.keys(a),d=Object.keys(b);if(c.length!==d.length)return!1;for(d=0;d<c.length;d++)if(!$i.call(b,c[d])||!Qa(a[c[d]],b[c[d]]))return!1;return!0}function Dg(a,b){var c=b.window===b?b.document:9===b.nodeType?b:b.ownerDocument;if(ge||null==nb||nb!==Wd(c))return null;c=nb;"selectionStart"in c&&Xd(c)?c={start:c.selectionStart,
end:c.selectionEnd}:(c=(c.ownerDocument&&c.ownerDocument.defaultView||window).getSelection(),c={anchorNode:c.anchorNode,anchorOffset:c.anchorOffset,focusNode:c.focusNode,focusOffset:c.focusOffset});return Pb&&Ob(Pb,c)?null:(Pb=c,a=R.getPooled(Eg.select,he,a,b),a.type="select",a.target=nb,lb(a),a)}function Ac(a){var b=a.keyCode;"charCode"in a?(a=a.charCode,0===a&&13===b&&(a=13)):a=b;10===a&&(a=13);return 32<=a||13===a?a:0}function q(a,b){0>ob||(a.current=ie[ob],ie[ob]=null,ob--)}function y(a,b,c){ob++;
ie[ob]=a.current;a.current=b}function pb(a,b){var c=a.type.contextTypes;if(!c)return Ca;var d=a.stateNode;if(d&&d.__reactInternalMemoizedUnmaskedChildContext===b)return d.__reactInternalMemoizedMaskedChildContext;var e={},f;for(f in c)e[f]=b[f];d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=b,a.__reactInternalMemoizedMaskedChildContext=e);return e}function N(a){a=a.childContextTypes;return null!==a&&void 0!==a}function Fg(a,b,c){if(B.current!==Ca)throw Error(k(168));y(B,b);y(G,c)}
function Gg(a,b,c){var d=a.stateNode;a=b.childContextTypes;if("function"!==typeof d.getChildContext)return c;d=d.getChildContext();for(var e in d)if(!(e in a))throw Error(k(108,na(b)||"Unknown",e));return M({},c,{},d)}function Bc(a){a=(a=a.stateNode)&&a.__reactInternalMemoizedMergedChildContext||Ca;Ra=B.current;y(B,a);y(G,G.current);return!0}function Hg(a,b,c){var d=a.stateNode;if(!d)throw Error(k(169));c?(a=Gg(a,b,Ra),d.__reactInternalMemoizedMergedChildContext=a,q(G),q(B),y(B,a)):q(G);y(G,c)}function Cc(){switch(aj()){case Dc:return 99;
case Ig:return 98;case Jg:return 97;case Kg:return 96;case Lg:return 95;default:throw Error(k(332));}}function Mg(a){switch(a){case 99:return Dc;case 98:return Ig;case 97:return Jg;case 96:return Kg;case 95:return Lg;default:throw Error(k(332));}}function Da(a,b){a=Mg(a);return bj(a,b)}function Ng(a,b,c){a=Mg(a);return je(a,b,c)}function Og(a){null===qa?(qa=[a],Ec=je(Dc,Pg)):qa.push(a);return Qg}function ha(){if(null!==Ec){var a=Ec;Ec=null;Rg(a)}Pg()}function Pg(){if(!ke&&null!==qa){ke=!0;var a=0;
try{var b=qa;Da(99,function(){for(;a<b.length;a++){var c=b[a];do c=c(!0);while(null!==c)}});qa=null}catch(c){throw null!==qa&&(qa=qa.slice(a+1)),je(Dc,ha),c;}finally{ke=!1}}}function Fc(a,b,c){c/=10;return 1073741821-(((1073741821-a+b/10)/c|0)+1)*c}function aa(a,b){if(a&&a.defaultProps){b=M({},b);a=a.defaultProps;for(var c in a)void 0===b[c]&&(b[c]=a[c])}return b}function le(){Gc=qb=Hc=null}function me(a){var b=Ic.current;q(Ic);a.type._context._currentValue=b}function Sg(a,b){for(;null!==a;){var c=
a.alternate;if(a.childExpirationTime<b)a.childExpirationTime=b,null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);else if(null!==c&&c.childExpirationTime<b)c.childExpirationTime=b;else break;a=a.return}}function rb(a,b){Hc=a;Gc=qb=null;a=a.dependencies;null!==a&&null!==a.firstContext&&(a.expirationTime>=b&&(ia=!0),a.firstContext=null)}function W(a,b){if(Gc!==a&&!1!==b&&0!==b){if("number"!==typeof b||1073741823===b)Gc=a,b=1073741823;b={context:a,observedBits:b,next:null};if(null===qb){if(null===
Hc)throw Error(k(308));qb=b;Hc.dependencies={expirationTime:0,firstContext:b,responders:null}}else qb=qb.next=b}return a._currentValue}function ne(a){a.updateQueue={baseState:a.memoizedState,baseQueue:null,shared:{pending:null},effects:null}}function oe(a,b){a=a.updateQueue;b.updateQueue===a&&(b.updateQueue={baseState:a.baseState,baseQueue:a.baseQueue,shared:a.shared,effects:a.effects})}function Ea(a,b){a={expirationTime:a,suspenseConfig:b,tag:Tg,payload:null,callback:null,next:null};return a.next=
a}function Fa(a,b){a=a.updateQueue;if(null!==a){a=a.shared;var c=a.pending;null===c?b.next=b:(b.next=c.next,c.next=b);a.pending=b}}function Ug(a,b){var c=a.alternate;null!==c&&oe(c,a);a=a.updateQueue;c=a.baseQueue;null===c?(a.baseQueue=b.next=b,b.next=b):(b.next=c.next,c.next=b)}function Qb(a,b,c,d){var e=a.updateQueue;Ga=!1;var f=e.baseQueue,g=e.shared.pending;if(null!==g){if(null!==f){var h=f.next;f.next=g.next;g.next=h}f=g;e.shared.pending=null;h=a.alternate;null!==h&&(h=h.updateQueue,null!==h&&
(h.baseQueue=g))}if(null!==f){h=f.next;var m=e.baseState,n=0,k=null,ba=null,l=null;if(null!==h){var p=h;do{g=p.expirationTime;if(g<d){var t={expirationTime:p.expirationTime,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null};null===l?(ba=l=t,k=m):l=l.next=t;g>n&&(n=g)}else{null!==l&&(l=l.next={expirationTime:1073741823,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null});Vg(g,p.suspenseConfig);a:{var q=a,r=p;g=b;t=c;switch(r.tag){case 1:q=
r.payload;if("function"===typeof q){m=q.call(t,m,g);break a}m=q;break a;case 3:q.effectTag=q.effectTag&-4097|64;case Tg:q=r.payload;g="function"===typeof q?q.call(t,m,g):q;if(null===g||void 0===g)break a;m=M({},m,g);break a;case Jc:Ga=!0}}null!==p.callback&&(a.effectTag|=32,g=e.effects,null===g?e.effects=[p]:g.push(p))}p=p.next;if(null===p||p===h)if(g=e.shared.pending,null===g)break;else p=f.next=g.next,g.next=h,e.baseQueue=f=g,e.shared.pending=null}while(1)}null===l?k=m:l.next=ba;e.baseState=k;e.baseQueue=
l;Kc(n);a.expirationTime=n;a.memoizedState=m}}function Wg(a,b,c){a=b.effects;b.effects=null;if(null!==a)for(b=0;b<a.length;b++){var d=a[b],e=d.callback;if(null!==e){d.callback=null;d=e;e=c;if("function"!==typeof d)throw Error(k(191,d));d.call(e)}}}function Lc(a,b,c,d){b=a.memoizedState;c=c(d,b);c=null===c||void 0===c?b:M({},b,c);a.memoizedState=c;0===a.expirationTime&&(a.updateQueue.baseState=c)}function Xg(a,b,c,d,e,f,g){a=a.stateNode;return"function"===typeof a.shouldComponentUpdate?a.shouldComponentUpdate(d,
f,g):b.prototype&&b.prototype.isPureReactComponent?!Ob(c,d)||!Ob(e,f):!0}function Yg(a,b,c){var d=!1,e=Ca;var f=b.contextType;"object"===typeof f&&null!==f?f=W(f):(e=N(b)?Ra:B.current,d=b.contextTypes,f=(d=null!==d&&void 0!==d)?pb(a,e):Ca);b=new b(c,f);a.memoizedState=null!==b.state&&void 0!==b.state?b.state:null;b.updater=Mc;a.stateNode=b;b._reactInternalFiber=a;d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=e,a.__reactInternalMemoizedMaskedChildContext=f);return b}function Zg(a,
b,c,d){a=b.state;"function"===typeof b.componentWillReceiveProps&&b.componentWillReceiveProps(c,d);"function"===typeof b.UNSAFE_componentWillReceiveProps&&b.UNSAFE_componentWillReceiveProps(c,d);b.state!==a&&Mc.enqueueReplaceState(b,b.state,null)}function pe(a,b,c,d){var e=a.stateNode;e.props=c;e.state=a.memoizedState;e.refs=$g;ne(a);var f=b.contextType;"object"===typeof f&&null!==f?e.context=W(f):(f=N(b)?Ra:B.current,e.context=pb(a,f));Qb(a,c,e,d);e.state=a.memoizedState;f=b.getDerivedStateFromProps;
"function"===typeof f&&(Lc(a,b,f,c),e.state=a.memoizedState);"function"===typeof b.getDerivedStateFromProps||"function"===typeof e.getSnapshotBeforeUpdate||"function"!==typeof e.UNSAFE_componentWillMount&&"function"!==typeof e.componentWillMount||(b=e.state,"function"===typeof e.componentWillMount&&e.componentWillMount(),"function"===typeof e.UNSAFE_componentWillMount&&e.UNSAFE_componentWillMount(),b!==e.state&&Mc.enqueueReplaceState(e,e.state,null),Qb(a,c,e,d),e.state=a.memoizedState);"function"===
typeof e.componentDidMount&&(a.effectTag|=4)}function Rb(a,b,c){a=c.ref;if(null!==a&&"function"!==typeof a&&"object"!==typeof a){if(c._owner){c=c._owner;if(c){if(1!==c.tag)throw Error(k(309));var d=c.stateNode}if(!d)throw Error(k(147,a));var e=""+a;if(null!==b&&null!==b.ref&&"function"===typeof b.ref&&b.ref._stringRef===e)return b.ref;b=function(a){var b=d.refs;b===$g&&(b=d.refs={});null===a?delete b[e]:b[e]=a};b._stringRef=e;return b}if("string"!==typeof a)throw Error(k(284));if(!c._owner)throw Error(k(290,
a));}return a}function Nc(a,b){if("textarea"!==a.type)throw Error(k(31,"[object Object]"===Object.prototype.toString.call(b)?"object with keys {"+Object.keys(b).join(", ")+"}":b,""));}function ah(a){function b(b,c){if(a){var d=b.lastEffect;null!==d?(d.nextEffect=c,b.lastEffect=c):b.firstEffect=b.lastEffect=c;c.nextEffect=null;c.effectTag=8}}function c(c,d){if(!a)return null;for(;null!==d;)b(c,d),d=d.sibling;return null}function d(a,b){for(a=new Map;null!==b;)null!==b.key?a.set(b.key,b):a.set(b.index,
b),b=b.sibling;return a}function e(a,b){a=Sa(a,b);a.index=0;a.sibling=null;return a}function f(b,c,d){b.index=d;if(!a)return c;d=b.alternate;if(null!==d)return d=d.index,d<c?(b.effectTag=2,c):d;b.effectTag=2;return c}function g(b){a&&null===b.alternate&&(b.effectTag=2);return b}function h(a,b,c,d){if(null===b||6!==b.tag)return b=qe(c,a.mode,d),b.return=a,b;b=e(b,c);b.return=a;return b}function m(a,b,c,d){if(null!==b&&b.elementType===c.type)return d=e(b,c.props),d.ref=Rb(a,b,c),d.return=a,d;d=Oc(c.type,
c.key,c.props,null,a.mode,d);d.ref=Rb(a,b,c);d.return=a;return d}function n(a,b,c,d){if(null===b||4!==b.tag||b.stateNode.containerInfo!==c.containerInfo||b.stateNode.implementation!==c.implementation)return b=re(c,a.mode,d),b.return=a,b;b=e(b,c.children||[]);b.return=a;return b}function l(a,b,c,d,f){if(null===b||7!==b.tag)return b=Ha(c,a.mode,d,f),b.return=a,b;b=e(b,c);b.return=a;return b}function ba(a,b,c){if("string"===typeof b||"number"===typeof b)return b=qe(""+b,a.mode,c),b.return=a,b;if("object"===
typeof b&&null!==b){switch(b.$$typeof){case Pc:return c=Oc(b.type,b.key,b.props,null,a.mode,c),c.ref=Rb(a,null,b),c.return=a,c;case gb:return b=re(b,a.mode,c),b.return=a,b}if(Qc(b)||zb(b))return b=Ha(b,a.mode,c,null),b.return=a,b;Nc(a,b)}return null}function p(a,b,c,d){var e=null!==b?b.key:null;if("string"===typeof c||"number"===typeof c)return null!==e?null:h(a,b,""+c,d);if("object"===typeof c&&null!==c){switch(c.$$typeof){case Pc:return c.key===e?c.type===Ma?l(a,b,c.props.children,d,e):m(a,b,c,
d):null;case gb:return c.key===e?n(a,b,c,d):null}if(Qc(c)||zb(c))return null!==e?null:l(a,b,c,d,null);Nc(a,c)}return null}function t(a,b,c,d,e){if("string"===typeof d||"number"===typeof d)return a=a.get(c)||null,h(b,a,""+d,e);if("object"===typeof d&&null!==d){switch(d.$$typeof){case Pc:return a=a.get(null===d.key?c:d.key)||null,d.type===Ma?l(b,a,d.props.children,e,d.key):m(b,a,d,e);case gb:return a=a.get(null===d.key?c:d.key)||null,n(b,a,d,e)}if(Qc(d)||zb(d))return a=a.get(c)||null,l(b,a,d,e,null);
Nc(b,d)}return null}function q(e,g,h,m){for(var n=null,k=null,l=g,r=g=0,C=null;null!==l&&r<h.length;r++){l.index>r?(C=l,l=null):C=l.sibling;var O=p(e,l,h[r],m);if(null===O){null===l&&(l=C);break}a&&l&&null===O.alternate&&b(e,l);g=f(O,g,r);null===k?n=O:k.sibling=O;k=O;l=C}if(r===h.length)return c(e,l),n;if(null===l){for(;r<h.length;r++)l=ba(e,h[r],m),null!==l&&(g=f(l,g,r),null===k?n=l:k.sibling=l,k=l);return n}for(l=d(e,l);r<h.length;r++)C=t(l,e,r,h[r],m),null!==C&&(a&&null!==C.alternate&&l.delete(null===
C.key?r:C.key),g=f(C,g,r),null===k?n=C:k.sibling=C,k=C);a&&l.forEach(function(a){return b(e,a)});return n}function w(e,g,h,n){var m=zb(h);if("function"!==typeof m)throw Error(k(150));h=m.call(h);if(null==h)throw Error(k(151));for(var l=m=null,r=g,C=g=0,O=null,v=h.next();null!==r&&!v.done;C++,v=h.next()){r.index>C?(O=r,r=null):O=r.sibling;var q=p(e,r,v.value,n);if(null===q){null===r&&(r=O);break}a&&r&&null===q.alternate&&b(e,r);g=f(q,g,C);null===l?m=q:l.sibling=q;l=q;r=O}if(v.done)return c(e,r),m;
if(null===r){for(;!v.done;C++,v=h.next())v=ba(e,v.value,n),null!==v&&(g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);return m}for(r=d(e,r);!v.done;C++,v=h.next())v=t(r,e,C,v.value,n),null!==v&&(a&&null!==v.alternate&&r.delete(null===v.key?C:v.key),g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);a&&r.forEach(function(a){return b(e,a)});return m}return function(a,d,f,h){var m="object"===typeof f&&null!==f&&f.type===Ma&&null===f.key;m&&(f=f.props.children);var n="object"===typeof f&&null!==f;if(n)switch(f.$$typeof){case Pc:a:{n=
f.key;for(m=d;null!==m;){if(m.key===n){switch(m.tag){case 7:if(f.type===Ma){c(a,m.sibling);d=e(m,f.props.children);d.return=a;a=d;break a}break;default:if(m.elementType===f.type){c(a,m.sibling);d=e(m,f.props);d.ref=Rb(a,m,f);d.return=a;a=d;break a}}c(a,m);break}else b(a,m);m=m.sibling}f.type===Ma?(d=Ha(f.props.children,a.mode,h,f.key),d.return=a,a=d):(h=Oc(f.type,f.key,f.props,null,a.mode,h),h.ref=Rb(a,d,f),h.return=a,a=h)}return g(a);case gb:a:{for(m=f.key;null!==d;){if(d.key===m)if(4===d.tag&&d.stateNode.containerInfo===
f.containerInfo&&d.stateNode.implementation===f.implementation){c(a,d.sibling);d=e(d,f.children||[]);d.return=a;a=d;break a}else{c(a,d);break}else b(a,d);d=d.sibling}d=re(f,a.mode,h);d.return=a;a=d}return g(a)}if("string"===typeof f||"number"===typeof f)return f=""+f,null!==d&&6===d.tag?(c(a,d.sibling),d=e(d,f),d.return=a,a=d):(c(a,d),d=qe(f,a.mode,h),d.return=a,a=d),g(a);if(Qc(f))return q(a,d,f,h);if(zb(f))return w(a,d,f,h);n&&Nc(a,f);if("undefined"===typeof f&&!m)switch(a.tag){case 1:case 0:throw a=
a.type,Error(k(152,a.displayName||a.name||"Component"));}return c(a,d)}}function Ta(a){if(a===Sb)throw Error(k(174));return a}function se(a,b){y(Tb,b);y(Ub,a);y(ja,Sb);a=b.nodeType;switch(a){case 9:case 11:b=(b=b.documentElement)?b.namespaceURI:Hd(null,"");break;default:a=8===a?b.parentNode:b,b=a.namespaceURI||null,a=a.tagName,b=Hd(b,a)}q(ja);y(ja,b)}function tb(a){q(ja);q(Ub);q(Tb)}function bh(a){Ta(Tb.current);var b=Ta(ja.current);var c=Hd(b,a.type);b!==c&&(y(Ub,a),y(ja,c))}function te(a){Ub.current===
a&&(q(ja),q(Ub))}function Rc(a){for(var b=a;null!==b;){if(13===b.tag){var c=b.memoizedState;if(null!==c&&(c=c.dehydrated,null===c||c.data===$d||c.data===Zd))return b}else if(19===b.tag&&void 0!==b.memoizedProps.revealOrder){if(0!==(b.effectTag&64))return b}else if(null!==b.child){b.child.return=b;b=b.child;continue}if(b===a)break;for(;null===b.sibling;){if(null===b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}return null}function ue(a,b){return{responder:a,props:b}}
function S(){throw Error(k(321));}function ve(a,b){if(null===b)return!1;for(var c=0;c<b.length&&c<a.length;c++)if(!Qa(a[c],b[c]))return!1;return!0}function we(a,b,c,d,e,f){Ia=f;z=b;b.memoizedState=null;b.updateQueue=null;b.expirationTime=0;Sc.current=null===a||null===a.memoizedState?dj:ej;a=c(d,e);if(b.expirationTime===Ia){f=0;do{b.expirationTime=0;if(!(25>f))throw Error(k(301));f+=1;J=K=null;b.updateQueue=null;Sc.current=fj;a=c(d,e)}while(b.expirationTime===Ia)}Sc.current=Tc;b=null!==K&&null!==K.next;
Ia=0;J=K=z=null;Uc=!1;if(b)throw Error(k(300));return a}function ub(){var a={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};null===J?z.memoizedState=J=a:J=J.next=a;return J}function vb(){if(null===K){var a=z.alternate;a=null!==a?a.memoizedState:null}else a=K.next;var b=null===J?z.memoizedState:J.next;if(null!==b)J=b,K=a;else{if(null===a)throw Error(k(310));K=a;a={memoizedState:K.memoizedState,baseState:K.baseState,baseQueue:K.baseQueue,queue:K.queue,next:null};null===J?z.memoizedState=
J=a:J=J.next=a}return J}function Ua(a,b){return"function"===typeof b?b(a):b}function Vc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=K,e=d.baseQueue,f=c.pending;if(null!==f){if(null!==e){var g=e.next;e.next=f.next;f.next=g}d.baseQueue=e=f;c.pending=null}if(null!==e){e=e.next;d=d.baseState;var h=g=f=null,m=e;do{var n=m.expirationTime;if(n<Ia){var l={expirationTime:m.expirationTime,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,
next:null};null===h?(g=h=l,f=d):h=h.next=l;n>z.expirationTime&&(z.expirationTime=n,Kc(n))}else null!==h&&(h=h.next={expirationTime:1073741823,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,next:null}),Vg(n,m.suspenseConfig),d=m.eagerReducer===a?m.eagerState:a(d,m.action);m=m.next}while(null!==m&&m!==e);null===h?f=d:h.next=g;Qa(d,b.memoizedState)||(ia=!0);b.memoizedState=d;b.baseState=f;b.baseQueue=h;c.lastRenderedState=d}return[b.memoizedState,
c.dispatch]}function Wc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=c.dispatch,e=c.pending,f=b.memoizedState;if(null!==e){c.pending=null;var g=e=e.next;do f=a(f,g.action),g=g.next;while(g!==e);Qa(f,b.memoizedState)||(ia=!0);b.memoizedState=f;null===b.baseQueue&&(b.baseState=f);c.lastRenderedState=f}return[f,d]}function xe(a){var b=ub();"function"===typeof a&&(a=a());b.memoizedState=b.baseState=a;a=b.queue={pending:null,dispatch:null,lastRenderedReducer:Ua,
lastRenderedState:a};a=a.dispatch=ch.bind(null,z,a);return[b.memoizedState,a]}function ye(a,b,c,d){a={tag:a,create:b,destroy:c,deps:d,next:null};b=z.updateQueue;null===b?(b={lastEffect:null},z.updateQueue=b,b.lastEffect=a.next=a):(c=b.lastEffect,null===c?b.lastEffect=a.next=a:(d=c.next,c.next=a,a.next=d,b.lastEffect=a));return a}function dh(a){return vb().memoizedState}function ze(a,b,c,d){var e=ub();z.effectTag|=a;e.memoizedState=ye(1|b,c,void 0,void 0===d?null:d)}function Ae(a,b,c,d){var e=vb();
d=void 0===d?null:d;var f=void 0;if(null!==K){var g=K.memoizedState;f=g.destroy;if(null!==d&&ve(d,g.deps)){ye(b,c,f,d);return}}z.effectTag|=a;e.memoizedState=ye(1|b,c,f,d)}function eh(a,b){return ze(516,4,a,b)}function Xc(a,b){return Ae(516,4,a,b)}function fh(a,b){return Ae(4,2,a,b)}function gh(a,b){if("function"===typeof b)return a=a(),b(a),function(){b(null)};if(null!==b&&void 0!==b)return a=a(),b.current=a,function(){b.current=null}}function hh(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;
return Ae(4,2,gh.bind(null,b,a),c)}function Be(a,b){}function ih(a,b){ub().memoizedState=[a,void 0===b?null:b];return a}function Yc(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];c.memoizedState=[a,b];return a}function jh(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];a=a();c.memoizedState=[a,b];return a}function Ce(a,b,c){var d=Cc();Da(98>d?98:d,function(){a(!0)});Da(97<d?97:d,function(){var d=
X.suspense;X.suspense=void 0===b?null:b;try{a(!1),c()}finally{X.suspense=d}})}function ch(a,b,c){var d=ka(),e=Vb.suspense;d=Va(d,a,e);e={expirationTime:d,suspenseConfig:e,action:c,eagerReducer:null,eagerState:null,next:null};var f=b.pending;null===f?e.next=e:(e.next=f.next,f.next=e);b.pending=e;f=a.alternate;if(a===z||null!==f&&f===z)Uc=!0,e.expirationTime=Ia,z.expirationTime=Ia;else{if(0===a.expirationTime&&(null===f||0===f.expirationTime)&&(f=b.lastRenderedReducer,null!==f))try{var g=b.lastRenderedState,
h=f(g,c);e.eagerReducer=f;e.eagerState=h;if(Qa(h,g))return}catch(m){}finally{}Ja(a,d)}}function kh(a,b){var c=la(5,null,null,0);c.elementType="DELETED";c.type="DELETED";c.stateNode=b;c.return=a;c.effectTag=8;null!==a.lastEffect?(a.lastEffect.nextEffect=c,a.lastEffect=c):a.firstEffect=a.lastEffect=c}function lh(a,b){switch(a.tag){case 5:var c=a.type;b=1!==b.nodeType||c.toLowerCase()!==b.nodeName.toLowerCase()?null:b;return null!==b?(a.stateNode=b,!0):!1;case 6:return b=""===a.pendingProps||3!==b.nodeType?
null:b,null!==b?(a.stateNode=b,!0):!1;case 13:return!1;default:return!1}}function De(a){if(Wa){var b=Ka;if(b){var c=b;if(!lh(a,b)){b=kb(c.nextSibling);if(!b||!lh(a,b)){a.effectTag=a.effectTag&-1025|2;Wa=!1;ra=a;return}kh(ra,c)}ra=a;Ka=kb(b.firstChild)}else a.effectTag=a.effectTag&-1025|2,Wa=!1,ra=a}}function mh(a){for(a=a.return;null!==a&&5!==a.tag&&3!==a.tag&&13!==a.tag;)a=a.return;ra=a}function Zc(a){if(a!==ra)return!1;if(!Wa)return mh(a),Wa=!0,!1;var b=a.type;if(5!==a.tag||"head"!==b&&"body"!==
b&&!Yd(b,a.memoizedProps))for(b=Ka;b;)kh(a,b),b=kb(b.nextSibling);mh(a);if(13===a.tag){a=a.memoizedState;a=null!==a?a.dehydrated:null;if(!a)throw Error(k(317));a:{a=a.nextSibling;for(b=0;a;){if(8===a.nodeType){var c=a.data;if(c===og){if(0===b){Ka=kb(a.nextSibling);break a}b--}else c!==ng&&c!==Zd&&c!==$d||b++}a=a.nextSibling}Ka=null}}else Ka=ra?kb(a.stateNode.nextSibling):null;return!0}function Ee(){Ka=ra=null;Wa=!1}function T(a,b,c,d){b.child=null===a?Fe(b,null,c,d):wb(b,a.child,c,d)}function nh(a,
b,c,d,e){c=c.render;var f=b.ref;rb(b,e);d=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,d,e);return b.child}function oh(a,b,c,d,e,f){if(null===a){var g=c.type;if("function"===typeof g&&!Ge(g)&&void 0===g.defaultProps&&null===c.compare&&void 0===c.defaultProps)return b.tag=15,b.type=g,ph(a,b,g,d,e,f);a=Oc(c.type,null,d,null,b.mode,f);a.ref=b.ref;a.return=b;return b.child=a}g=a.child;if(e<
f&&(e=g.memoizedProps,c=c.compare,c=null!==c?c:Ob,c(e,d)&&a.ref===b.ref))return sa(a,b,f);b.effectTag|=1;a=Sa(g,d);a.ref=b.ref;a.return=b;return b.child=a}function ph(a,b,c,d,e,f){return null!==a&&Ob(a.memoizedProps,d)&&a.ref===b.ref&&(ia=!1,e<f)?(b.expirationTime=a.expirationTime,sa(a,b,f)):He(a,b,c,d,f)}function qh(a,b){var c=b.ref;if(null===a&&null!==c||null!==a&&a.ref!==c)b.effectTag|=128}function He(a,b,c,d,e){var f=N(c)?Ra:B.current;f=pb(b,f);rb(b,e);c=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=
a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,c,e);return b.child}function rh(a,b,c,d,e){if(N(c)){var f=!0;Bc(b)}else f=!1;rb(b,e);if(null===b.stateNode)null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),Yg(b,c,d),pe(b,c,d,e),d=!0;else if(null===a){var g=b.stateNode,h=b.memoizedProps;g.props=h;var m=g.context,n=c.contextType;"object"===typeof n&&null!==n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n));var l=c.getDerivedStateFromProps,k="function"===
typeof l||"function"===typeof g.getSnapshotBeforeUpdate;k||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n);Ga=!1;var p=b.memoizedState;g.state=p;Qb(b,d,g,e);m=b.memoizedState;h!==d||p!==m||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),m=b.memoizedState),(h=Ga||Xg(b,c,h,d,p,m,n))?(k||"function"!==typeof g.UNSAFE_componentWillMount&&"function"!==typeof g.componentWillMount||("function"===typeof g.componentWillMount&&
g.componentWillMount(),"function"===typeof g.UNSAFE_componentWillMount&&g.UNSAFE_componentWillMount()),"function"===typeof g.componentDidMount&&(b.effectTag|=4)):("function"===typeof g.componentDidMount&&(b.effectTag|=4),b.memoizedProps=d,b.memoizedState=m),g.props=d,g.state=m,g.context=n,d=h):("function"===typeof g.componentDidMount&&(b.effectTag|=4),d=!1)}else g=b.stateNode,oe(a,b),h=b.memoizedProps,g.props=b.type===b.elementType?h:aa(b.type,h),m=g.context,n=c.contextType,"object"===typeof n&&null!==
n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n)),l=c.getDerivedStateFromProps,(k="function"===typeof l||"function"===typeof g.getSnapshotBeforeUpdate)||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n),Ga=!1,m=b.memoizedState,g.state=m,Qb(b,d,g,e),p=b.memoizedState,h!==d||m!==p||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),p=b.memoizedState),(l=Ga||Xg(b,c,h,d,m,p,n))?(k||"function"!==typeof g.UNSAFE_componentWillUpdate&&
"function"!==typeof g.componentWillUpdate||("function"===typeof g.componentWillUpdate&&g.componentWillUpdate(d,p,n),"function"===typeof g.UNSAFE_componentWillUpdate&&g.UNSAFE_componentWillUpdate(d,p,n)),"function"===typeof g.componentDidUpdate&&(b.effectTag|=4),"function"===typeof g.getSnapshotBeforeUpdate&&(b.effectTag|=256)):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===
a.memoizedState||(b.effectTag|=256),b.memoizedProps=d,b.memoizedState=p),g.props=d,g.state=p,g.context=n,d=l):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=256),d=!1);return Ie(a,b,c,d,f,e)}function Ie(a,b,c,d,e,f){qh(a,b);var g=0!==(b.effectTag&64);if(!d&&!g)return e&&Hg(b,c,!1),sa(a,b,f);d=b.stateNode;gj.current=b;var h=g&&"function"!==typeof c.getDerivedStateFromError?
null:d.render();b.effectTag|=1;null!==a&&g?(b.child=wb(b,a.child,null,f),b.child=wb(b,null,h,f)):T(a,b,h,f);b.memoizedState=d.state;e&&Hg(b,c,!0);return b.child}function sh(a){var b=a.stateNode;b.pendingContext?Fg(a,b.pendingContext,b.pendingContext!==b.context):b.context&&Fg(a,b.context,!1);se(a,b.containerInfo)}function th(a,b,c){var d=b.mode,e=b.pendingProps,f=D.current,g=!1,h;(h=0!==(b.effectTag&64))||(h=0!==(f&2)&&(null===a||null!==a.memoizedState));h?(g=!0,b.effectTag&=-65):null!==a&&null===
a.memoizedState||void 0===e.fallback||!0===e.unstable_avoidThisFallback||(f|=1);y(D,f&1);if(null===a){void 0!==e.fallback&&De(b);if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;b.memoizedState=Je;b.child=e;return c}d=e.children;b.memoizedState=null;return b.child=Fe(b,null,d,c)}if(null!==a.memoizedState){a=a.child;d=a.sibling;if(g){e=e.fallback;
c=Sa(a,a.pendingProps);c.return=b;if(0===(b.mode&2)&&(g=null!==b.memoizedState?b.child.child:b.child,g!==a.child))for(c.child=g;null!==g;)g.return=c,g=g.sibling;d=Sa(d,e);d.return=b;c.sibling=d;c.childExpirationTime=0;b.memoizedState=Je;b.child=c;return d}c=wb(b,a.child,e.children,c);b.memoizedState=null;return b.child=c}a=a.child;if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;e.child=a;null!==a&&(a.return=e);if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==
a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;c.effectTag|=2;e.childExpirationTime=0;b.memoizedState=Je;b.child=e;return c}b.memoizedState=null;return b.child=wb(b,a,e.children,c)}function uh(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);Sg(a.return,b)}function Ke(a,b,c,d,e,f){var g=a.memoizedState;null===g?a.memoizedState={isBackwards:b,rendering:null,renderingStartTime:0,last:d,tail:c,tailExpiration:0,tailMode:e,
lastEffect:f}:(g.isBackwards=b,g.rendering=null,g.renderingStartTime=0,g.last=d,g.tail=c,g.tailExpiration=0,g.tailMode=e,g.lastEffect=f)}function vh(a,b,c){var d=b.pendingProps,e=d.revealOrder,f=d.tail;T(a,b,d.children,c);d=D.current;if(0!==(d&2))d=d&1|2,b.effectTag|=64;else{if(null!==a&&0!==(a.effectTag&64))a:for(a=b.child;null!==a;){if(13===a.tag)null!==a.memoizedState&&uh(a,c);else if(19===a.tag)uh(a,c);else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===b)break a;for(;null===a.sibling;){if(null===
a.return||a.return===b)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}d&=1}y(D,d);if(0===(b.mode&2))b.memoizedState=null;else switch(e){case "forwards":c=b.child;for(e=null;null!==c;)a=c.alternate,null!==a&&null===Rc(a)&&(e=c),c=c.sibling;c=e;null===c?(e=b.child,b.child=null):(e=c.sibling,c.sibling=null);Ke(b,!1,e,c,f,b.lastEffect);break;case "backwards":c=null;e=b.child;for(b.child=null;null!==e;){a=e.alternate;if(null!==a&&null===Rc(a)){b.child=e;break}a=e.sibling;e.sibling=c;c=e;e=a}Ke(b,
!0,c,null,f,b.lastEffect);break;case "together":Ke(b,!1,null,null,void 0,b.lastEffect);break;default:b.memoizedState=null}return b.child}function sa(a,b,c){null!==a&&(b.dependencies=a.dependencies);var d=b.expirationTime;0!==d&&Kc(d);if(b.childExpirationTime<c)return null;if(null!==a&&b.child!==a.child)throw Error(k(153));if(null!==b.child){a=b.child;c=Sa(a,a.pendingProps);b.child=c;for(c.return=b;null!==a.sibling;)a=a.sibling,c=c.sibling=Sa(a,a.pendingProps),c.return=b;c.sibling=null}return b.child}
function $c(a,b){switch(a.tailMode){case "hidden":b=a.tail;for(var c=null;null!==b;)null!==b.alternate&&(c=b),b=b.sibling;null===c?a.tail=null:c.sibling=null;break;case "collapsed":c=a.tail;for(var d=null;null!==c;)null!==c.alternate&&(d=c),c=c.sibling;null===d?b||null===a.tail?a.tail=null:a.tail.sibling=null:d.sibling=null}}function hj(a,b,c){var d=b.pendingProps;switch(b.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return null;case 1:return N(b.type)&&(q(G),q(B)),
null;case 3:return tb(),q(G),q(B),c=b.stateNode,c.pendingContext&&(c.context=c.pendingContext,c.pendingContext=null),null!==a&&null!==a.child||!Zc(b)||(b.effectTag|=4),wh(b),null;case 5:te(b);c=Ta(Tb.current);var e=b.type;if(null!==a&&null!=b.stateNode)ij(a,b,e,d,c),a.ref!==b.ref&&(b.effectTag|=128);else{if(!d){if(null===b.stateNode)throw Error(k(166));return null}a=Ta(ja.current);if(Zc(b)){d=b.stateNode;e=b.type;var f=b.memoizedProps;d[Aa]=b;d[vc]=f;switch(e){case "iframe":case "object":case "embed":w("load",
d);break;case "video":case "audio":for(a=0;a<Db.length;a++)w(Db[a],d);break;case "source":w("error",d);break;case "img":case "image":case "link":w("error",d);w("load",d);break;case "form":w("reset",d);w("submit",d);break;case "details":w("toggle",d);break;case "input":Hf(d,f);w("invalid",d);oa(c,"onChange");break;case "select":d._wrapperState={wasMultiple:!!f.multiple};w("invalid",d);oa(c,"onChange");break;case "textarea":Kf(d,f),w("invalid",d),oa(c,"onChange")}Ud(e,f);a=null;for(var g in f)if(f.hasOwnProperty(g)){var h=
f[g];"children"===g?"string"===typeof h?d.textContent!==h&&(a=["children",h]):"number"===typeof h&&d.textContent!==""+h&&(a=["children",""+h]):db.hasOwnProperty(g)&&null!=h&&oa(c,g)}switch(e){case "input":mc(d);Jf(d,f,!0);break;case "textarea":mc(d);Mf(d);break;case "select":case "option":break;default:"function"===typeof f.onClick&&(d.onclick=uc)}c=a;b.updateQueue=c;null!==c&&(b.effectTag|=4)}else{g=9===c.nodeType?c:c.ownerDocument;"http://www.w3.org/1999/xhtml"===a&&(a=Nf(e));"http://www.w3.org/1999/xhtml"===
a?"script"===e?(a=g.createElement("div"),a.innerHTML="<script>\x3c/script>",a=a.removeChild(a.firstChild)):"string"===typeof d.is?a=g.createElement(e,{is:d.is}):(a=g.createElement(e),"select"===e&&(g=a,d.multiple?g.multiple=!0:d.size&&(g.size=d.size))):a=g.createElementNS(a,e);a[Aa]=b;a[vc]=d;jj(a,b,!1,!1);b.stateNode=a;g=Vd(e,d);switch(e){case "iframe":case "object":case "embed":w("load",a);h=d;break;case "video":case "audio":for(h=0;h<Db.length;h++)w(Db[h],a);h=d;break;case "source":w("error",a);
h=d;break;case "img":case "image":case "link":w("error",a);w("load",a);h=d;break;case "form":w("reset",a);w("submit",a);h=d;break;case "details":w("toggle",a);h=d;break;case "input":Hf(a,d);h=Cd(a,d);w("invalid",a);oa(c,"onChange");break;case "option":h=Fd(a,d);break;case "select":a._wrapperState={wasMultiple:!!d.multiple};h=M({},d,{value:void 0});w("invalid",a);oa(c,"onChange");break;case "textarea":Kf(a,d);h=Gd(a,d);w("invalid",a);oa(c,"onChange");break;default:h=d}Ud(e,h);var m=h;for(f in m)if(m.hasOwnProperty(f)){var n=
m[f];"style"===f?gg(a,n):"dangerouslySetInnerHTML"===f?(n=n?n.__html:void 0,null!=n&&xh(a,n)):"children"===f?"string"===typeof n?("textarea"!==e||""!==n)&&Wb(a,n):"number"===typeof n&&Wb(a,""+n):"suppressContentEditableWarning"!==f&&"suppressHydrationWarning"!==f&&"autoFocus"!==f&&(db.hasOwnProperty(f)?null!=n&&oa(c,f):null!=n&&xd(a,f,n,g))}switch(e){case "input":mc(a);Jf(a,d,!1);break;case "textarea":mc(a);Mf(a);break;case "option":null!=d.value&&a.setAttribute("value",""+va(d.value));break;case "select":a.multiple=
!!d.multiple;c=d.value;null!=c?hb(a,!!d.multiple,c,!1):null!=d.defaultValue&&hb(a,!!d.multiple,d.defaultValue,!0);break;default:"function"===typeof h.onClick&&(a.onclick=uc)}lg(e,d)&&(b.effectTag|=4)}null!==b.ref&&(b.effectTag|=128)}return null;case 6:if(a&&null!=b.stateNode)kj(a,b,a.memoizedProps,d);else{if("string"!==typeof d&&null===b.stateNode)throw Error(k(166));c=Ta(Tb.current);Ta(ja.current);Zc(b)?(c=b.stateNode,d=b.memoizedProps,c[Aa]=b,c.nodeValue!==d&&(b.effectTag|=4)):(c=(9===c.nodeType?
c:c.ownerDocument).createTextNode(d),c[Aa]=b,b.stateNode=c)}return null;case 13:q(D);d=b.memoizedState;if(0!==(b.effectTag&64))return b.expirationTime=c,b;c=null!==d;d=!1;null===a?void 0!==b.memoizedProps.fallback&&Zc(b):(e=a.memoizedState,d=null!==e,c||null===e||(e=a.child.sibling,null!==e&&(f=b.firstEffect,null!==f?(b.firstEffect=e,e.nextEffect=f):(b.firstEffect=b.lastEffect=e,e.nextEffect=null),e.effectTag=8)));if(c&&!d&&0!==(b.mode&2))if(null===a&&!0!==b.memoizedProps.unstable_avoidThisFallback||
0!==(D.current&1))F===Xa&&(F=ad);else{if(F===Xa||F===ad)F=bd;0!==Xb&&null!==U&&(Ya(U,P),yh(U,Xb))}if(c||d)b.effectTag|=4;return null;case 4:return tb(),wh(b),null;case 10:return me(b),null;case 17:return N(b.type)&&(q(G),q(B)),null;case 19:q(D);d=b.memoizedState;if(null===d)return null;e=0!==(b.effectTag&64);f=d.rendering;if(null===f)if(e)$c(d,!1);else{if(F!==Xa||null!==a&&0!==(a.effectTag&64))for(f=b.child;null!==f;){a=Rc(f);if(null!==a){b.effectTag|=64;$c(d,!1);e=a.updateQueue;null!==e&&(b.updateQueue=
e,b.effectTag|=4);null===d.lastEffect&&(b.firstEffect=null);b.lastEffect=d.lastEffect;for(d=b.child;null!==d;)e=d,f=c,e.effectTag&=2,e.nextEffect=null,e.firstEffect=null,e.lastEffect=null,a=e.alternate,null===a?(e.childExpirationTime=0,e.expirationTime=f,e.child=null,e.memoizedProps=null,e.memoizedState=null,e.updateQueue=null,e.dependencies=null):(e.childExpirationTime=a.childExpirationTime,e.expirationTime=a.expirationTime,e.child=a.child,e.memoizedProps=a.memoizedProps,e.memoizedState=a.memoizedState,
e.updateQueue=a.updateQueue,f=a.dependencies,e.dependencies=null===f?null:{expirationTime:f.expirationTime,firstContext:f.firstContext,responders:f.responders}),d=d.sibling;y(D,D.current&1|2);return b.child}f=f.sibling}}else{if(!e)if(a=Rc(f),null!==a){if(b.effectTag|=64,e=!0,c=a.updateQueue,null!==c&&(b.updateQueue=c,b.effectTag|=4),$c(d,!0),null===d.tail&&"hidden"===d.tailMode&&!f.alternate)return b=b.lastEffect=d.lastEffect,null!==b&&(b.nextEffect=null),null}else 2*Y()-d.renderingStartTime>d.tailExpiration&&
1<c&&(b.effectTag|=64,e=!0,$c(d,!1),b.expirationTime=b.childExpirationTime=c-1);d.isBackwards?(f.sibling=b.child,b.child=f):(c=d.last,null!==c?c.sibling=f:b.child=f,d.last=f)}return null!==d.tail?(0===d.tailExpiration&&(d.tailExpiration=Y()+500),c=d.tail,d.rendering=c,d.tail=c.sibling,d.lastEffect=b.lastEffect,d.renderingStartTime=Y(),c.sibling=null,b=D.current,y(D,e?b&1|2:b&1),c):null}throw Error(k(156,b.tag));}function lj(a,b){switch(a.tag){case 1:return N(a.type)&&(q(G),q(B)),b=a.effectTag,b&4096?
(a.effectTag=b&-4097|64,a):null;case 3:tb();q(G);q(B);b=a.effectTag;if(0!==(b&64))throw Error(k(285));a.effectTag=b&-4097|64;return a;case 5:return te(a),null;case 13:return q(D),b=a.effectTag,b&4096?(a.effectTag=b&-4097|64,a):null;case 19:return q(D),null;case 4:return tb(),null;case 10:return me(a),null;default:return null}}function Le(a,b){return{value:a,source:b,stack:Bd(b)}}function Me(a,b){var c=b.source,d=b.stack;null===d&&null!==c&&(d=Bd(c));null!==c&&na(c.type);b=b.value;null!==a&&1===a.tag&&
na(a.type);try{console.error(b)}catch(e){setTimeout(function(){throw e;})}}function mj(a,b){try{b.props=a.memoizedProps,b.state=a.memoizedState,b.componentWillUnmount()}catch(c){Za(a,c)}}function zh(a){var b=a.ref;if(null!==b)if("function"===typeof b)try{b(null)}catch(c){Za(a,c)}else b.current=null}function nj(a,b){switch(b.tag){case 0:case 11:case 15:case 22:return;case 1:if(b.effectTag&256&&null!==a){var c=a.memoizedProps,d=a.memoizedState;a=b.stateNode;b=a.getSnapshotBeforeUpdate(b.elementType===
b.type?c:aa(b.type,c),d);a.__reactInternalSnapshotBeforeUpdate=b}return;case 3:case 5:case 6:case 4:case 17:return}throw Error(k(163));}function Ah(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.destroy;c.destroy=void 0;void 0!==d&&d()}c=c.next}while(c!==b)}}function Bh(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.create;c.destroy=d()}c=c.next}while(c!==b)}}function oj(a,b,c,d){switch(c.tag){case 0:case 11:case 15:case 22:Bh(3,
c);return;case 1:a=c.stateNode;c.effectTag&4&&(null===b?a.componentDidMount():(d=c.elementType===c.type?b.memoizedProps:aa(c.type,b.memoizedProps),a.componentDidUpdate(d,b.memoizedState,a.__reactInternalSnapshotBeforeUpdate)));b=c.updateQueue;null!==b&&Wg(c,b,a);return;case 3:b=c.updateQueue;if(null!==b){a=null;if(null!==c.child)switch(c.child.tag){case 5:a=c.child.stateNode;break;case 1:a=c.child.stateNode}Wg(c,b,a)}return;case 5:a=c.stateNode;null===b&&c.effectTag&4&&lg(c.type,c.memoizedProps)&&
a.focus();return;case 6:return;case 4:return;case 12:return;case 13:null===c.memoizedState&&(c=c.alternate,null!==c&&(c=c.memoizedState,null!==c&&(c=c.dehydrated,null!==c&&bg(c))));return;case 19:case 17:case 20:case 21:return}throw Error(k(163));}function Ch(a,b,c){"function"===typeof Ne&&Ne(b);switch(b.tag){case 0:case 11:case 14:case 15:case 22:a=b.updateQueue;if(null!==a&&(a=a.lastEffect,null!==a)){var d=a.next;Da(97<c?97:c,function(){var a=d;do{var c=a.destroy;if(void 0!==c){var g=b;try{c()}catch(h){Za(g,
h)}}a=a.next}while(a!==d)})}break;case 1:zh(b);c=b.stateNode;"function"===typeof c.componentWillUnmount&&mj(b,c);break;case 5:zh(b);break;case 4:Dh(a,b,c)}}function Eh(a){var b=a.alternate;a.return=null;a.child=null;a.memoizedState=null;a.updateQueue=null;a.dependencies=null;a.alternate=null;a.firstEffect=null;a.lastEffect=null;a.pendingProps=null;a.memoizedProps=null;a.stateNode=null;null!==b&&Eh(b)}function Fh(a){return 5===a.tag||3===a.tag||4===a.tag}function Gh(a){a:{for(var b=a.return;null!==
b;){if(Fh(b)){var c=b;break a}b=b.return}throw Error(k(160));}b=c.stateNode;switch(c.tag){case 5:var d=!1;break;case 3:b=b.containerInfo;d=!0;break;case 4:b=b.containerInfo;d=!0;break;default:throw Error(k(161));}c.effectTag&16&&(Wb(b,""),c.effectTag&=-17);a:b:for(c=a;;){for(;null===c.sibling;){if(null===c.return||Fh(c.return)){c=null;break a}c=c.return}c.sibling.return=c.return;for(c=c.sibling;5!==c.tag&&6!==c.tag&&18!==c.tag;){if(c.effectTag&2)continue b;if(null===c.child||4===c.tag)continue b;
else c.child.return=c,c=c.child}if(!(c.effectTag&2)){c=c.stateNode;break a}}d?Oe(a,c,b):Pe(a,c,b)}function Oe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?8===c.nodeType?c.parentNode.insertBefore(a,b):c.insertBefore(a,b):(8===c.nodeType?(b=c.parentNode,b.insertBefore(a,c)):(b=c,b.appendChild(a)),c=c._reactRootContainer,null!==c&&void 0!==c||null!==b.onclick||(b.onclick=uc));else if(4!==d&&(a=a.child,null!==a))for(Oe(a,b,c),a=a.sibling;null!==a;)Oe(a,b,c),a=a.sibling}
function Pe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?c.insertBefore(a,b):c.appendChild(a);else if(4!==d&&(a=a.child,null!==a))for(Pe(a,b,c),a=a.sibling;null!==a;)Pe(a,b,c),a=a.sibling}function Dh(a,b,c){for(var d=b,e=!1,f,g;;){if(!e){e=d.return;a:for(;;){if(null===e)throw Error(k(160));f=e.stateNode;switch(e.tag){case 5:g=!1;break a;case 3:f=f.containerInfo;g=!0;break a;case 4:f=f.containerInfo;g=!0;break a}e=e.return}e=!0}if(5===d.tag||6===d.tag){a:for(var h=
a,m=d,n=c,l=m;;)if(Ch(h,l,n),null!==l.child&&4!==l.tag)l.child.return=l,l=l.child;else{if(l===m)break a;for(;null===l.sibling;){if(null===l.return||l.return===m)break a;l=l.return}l.sibling.return=l.return;l=l.sibling}g?(h=f,m=d.stateNode,8===h.nodeType?h.parentNode.removeChild(m):h.removeChild(m)):f.removeChild(d.stateNode)}else if(4===d.tag){if(null!==d.child){f=d.stateNode.containerInfo;g=!0;d.child.return=d;d=d.child;continue}}else if(Ch(a,d,c),null!==d.child){d.child.return=d;d=d.child;continue}if(d===
b)break;for(;null===d.sibling;){if(null===d.return||d.return===b)return;d=d.return;4===d.tag&&(e=!1)}d.sibling.return=d.return;d=d.sibling}}function Qe(a,b){switch(b.tag){case 0:case 11:case 14:case 15:case 22:Ah(3,b);return;case 1:return;case 5:var c=b.stateNode;if(null!=c){var d=b.memoizedProps,e=null!==a?a.memoizedProps:d;a=b.type;var f=b.updateQueue;b.updateQueue=null;if(null!==f){c[vc]=d;"input"===a&&"radio"===d.type&&null!=d.name&&If(c,d);Vd(a,e);b=Vd(a,d);for(e=0;e<f.length;e+=2){var g=f[e],
h=f[e+1];"style"===g?gg(c,h):"dangerouslySetInnerHTML"===g?xh(c,h):"children"===g?Wb(c,h):xd(c,g,h,b)}switch(a){case "input":Dd(c,d);break;case "textarea":Lf(c,d);break;case "select":b=c._wrapperState.wasMultiple,c._wrapperState.wasMultiple=!!d.multiple,a=d.value,null!=a?hb(c,!!d.multiple,a,!1):b!==!!d.multiple&&(null!=d.defaultValue?hb(c,!!d.multiple,d.defaultValue,!0):hb(c,!!d.multiple,d.multiple?[]:"",!1))}}}return;case 6:if(null===b.stateNode)throw Error(k(162));b.stateNode.nodeValue=b.memoizedProps;
return;case 3:b=b.stateNode;b.hydrate&&(b.hydrate=!1,bg(b.containerInfo));return;case 12:return;case 13:c=b;null===b.memoizedState?d=!1:(d=!0,c=b.child,Re=Y());if(null!==c)a:for(a=c;;){if(5===a.tag)f=a.stateNode,d?(f=f.style,"function"===typeof f.setProperty?f.setProperty("display","none","important"):f.display="none"):(f=a.stateNode,e=a.memoizedProps.style,e=void 0!==e&&null!==e&&e.hasOwnProperty("display")?e.display:null,f.style.display=fg("display",e));else if(6===a.tag)a.stateNode.nodeValue=d?
"":a.memoizedProps;else if(13===a.tag&&null!==a.memoizedState&&null===a.memoizedState.dehydrated){f=a.child.sibling;f.return=a;a=f;continue}else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===c)break;for(;null===a.sibling;){if(null===a.return||a.return===c)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}Hh(b);return;case 19:Hh(b);return;case 17:return}throw Error(k(163));}function Hh(a){var b=a.updateQueue;if(null!==b){a.updateQueue=null;var c=a.stateNode;null===c&&(c=a.stateNode=
new pj);b.forEach(function(b){var d=qj.bind(null,a,b);c.has(b)||(c.add(b),b.then(d,d))})}}function Ih(a,b,c){c=Ea(c,null);c.tag=3;c.payload={element:null};var d=b.value;c.callback=function(){cd||(cd=!0,Se=d);Me(a,b)};return c}function Jh(a,b,c){c=Ea(c,null);c.tag=3;var d=a.type.getDerivedStateFromError;if("function"===typeof d){var e=b.value;c.payload=function(){Me(a,b);return d(e)}}var f=a.stateNode;null!==f&&"function"===typeof f.componentDidCatch&&(c.callback=function(){"function"!==typeof d&&
(null===La?La=new Set([this]):La.add(this),Me(a,b));var c=b.stack;this.componentDidCatch(b.value,{componentStack:null!==c?c:""})});return c}function ka(){return(p&(ca|ma))!==H?1073741821-(Y()/10|0):0!==dd?dd:dd=1073741821-(Y()/10|0)}function Va(a,b,c){b=b.mode;if(0===(b&2))return 1073741823;var d=Cc();if(0===(b&4))return 99===d?1073741823:1073741822;if((p&ca)!==H)return P;if(null!==c)a=Fc(a,c.timeoutMs|0||5E3,250);else switch(d){case 99:a=1073741823;break;case 98:a=Fc(a,150,100);break;case 97:case 96:a=
Fc(a,5E3,250);break;case 95:a=2;break;default:throw Error(k(326));}null!==U&&a===P&&--a;return a}function ed(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);var d=a.return,e=null;if(null===d&&3===a.tag)e=a.stateNode;else for(;null!==d;){c=d.alternate;d.childExpirationTime<b&&(d.childExpirationTime=b);null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);if(null===d.return&&3===d.tag){e=d.stateNode;break}d=d.return}null!==e&&
(U===e&&(Kc(b),F===bd&&Ya(e,P)),yh(e,b));return e}function fd(a){var b=a.lastExpiredTime;if(0!==b)return b;b=a.firstPendingTime;if(!Kh(a,b))return b;var c=a.lastPingedTime;a=a.nextKnownPendingLevel;a=c>a?c:a;return 2>=a&&b!==a?0:a}function V(a){if(0!==a.lastExpiredTime)a.callbackExpirationTime=1073741823,a.callbackPriority=99,a.callbackNode=Og(Te.bind(null,a));else{var b=fd(a),c=a.callbackNode;if(0===b)null!==c&&(a.callbackNode=null,a.callbackExpirationTime=0,a.callbackPriority=90);else{var d=ka();
1073741823===b?d=99:1===b||2===b?d=95:(d=10*(1073741821-b)-10*(1073741821-d),d=0>=d?99:250>=d?98:5250>=d?97:95);if(null!==c){var e=a.callbackPriority;if(a.callbackExpirationTime===b&&e>=d)return;c!==Qg&&Rg(c)}a.callbackExpirationTime=b;a.callbackPriority=d;b=1073741823===b?Og(Te.bind(null,a)):Ng(d,Lh.bind(null,a),{timeout:10*(1073741821-b)-Y()});a.callbackNode=b}}}function Lh(a,b){dd=0;if(b)return b=ka(),Ue(a,b),V(a),null;var c=fd(a);if(0!==c){b=a.callbackNode;if((p&(ca|ma))!==H)throw Error(k(327));
xb();a===U&&c===P||$a(a,c);if(null!==t){var d=p;p|=ca;var e=Mh();do try{rj();break}catch(h){Nh(a,h)}while(1);le();p=d;gd.current=e;if(F===hd)throw b=id,$a(a,c),Ya(a,c),V(a),b;if(null===t)switch(e=a.finishedWork=a.current.alternate,a.finishedExpirationTime=c,d=F,U=null,d){case Xa:case hd:throw Error(k(345));case Oh:Ue(a,2<c?2:c);break;case ad:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(1073741823===ta&&(e=Re+Ph-Y(),10<e)){if(jd){var f=a.lastPingedTime;if(0===f||f>=c){a.lastPingedTime=
c;$a(a,c);break}}f=fd(a);if(0!==f&&f!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}a.timeoutHandle=We(ab.bind(null,a),e);break}ab(a);break;case bd:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(jd&&(e=a.lastPingedTime,0===e||e>=c)){a.lastPingedTime=c;$a(a,c);break}e=fd(a);if(0!==e&&e!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}1073741823!==Yb?d=10*(1073741821-Yb)-Y():1073741823===ta?d=0:(d=10*(1073741821-ta)-5E3,e=Y(),c=10*(1073741821-c)-e,d=e-d,0>d&&(d=0),d=
(120>d?120:480>d?480:1080>d?1080:1920>d?1920:3E3>d?3E3:4320>d?4320:1960*sj(d/1960))-d,c<d&&(d=c));if(10<d){a.timeoutHandle=We(ab.bind(null,a),d);break}ab(a);break;case Xe:if(1073741823!==ta&&null!==kd){f=ta;var g=kd;d=g.busyMinDurationMs|0;0>=d?d=0:(e=g.busyDelayMs|0,f=Y()-(10*(1073741821-f)-(g.timeoutMs|0||5E3)),d=f<=e?0:e+d-f);if(10<d){Ya(a,c);a.timeoutHandle=We(ab.bind(null,a),d);break}}ab(a);break;default:throw Error(k(329));}V(a);if(a.callbackNode===b)return Lh.bind(null,a)}}return null}function Te(a){var b=
a.lastExpiredTime;b=0!==b?b:1073741823;if((p&(ca|ma))!==H)throw Error(k(327));xb();a===U&&b===P||$a(a,b);if(null!==t){var c=p;p|=ca;var d=Mh();do try{tj();break}catch(e){Nh(a,e)}while(1);le();p=c;gd.current=d;if(F===hd)throw c=id,$a(a,b),Ya(a,b),V(a),c;if(null!==t)throw Error(k(261));a.finishedWork=a.current.alternate;a.finishedExpirationTime=b;U=null;ab(a);V(a)}return null}function uj(){if(null!==bb){var a=bb;bb=null;a.forEach(function(a,c){Ue(c,a);V(c)});ha()}}function Qh(a,b){var c=p;p|=1;try{return a(b)}finally{p=
c,p===H&&ha()}}function Rh(a,b){var c=p;p&=-2;p|=Ye;try{return a(b)}finally{p=c,p===H&&ha()}}function $a(a,b){a.finishedWork=null;a.finishedExpirationTime=0;var c=a.timeoutHandle;-1!==c&&(a.timeoutHandle=-1,vj(c));if(null!==t)for(c=t.return;null!==c;){var d=c;switch(d.tag){case 1:d=d.type.childContextTypes;null!==d&&void 0!==d&&(q(G),q(B));break;case 3:tb();q(G);q(B);break;case 5:te(d);break;case 4:tb();break;case 13:q(D);break;case 19:q(D);break;case 10:me(d)}c=c.return}U=a;t=Sa(a.current,null);
P=b;F=Xa;id=null;Yb=ta=1073741823;kd=null;Xb=0;jd=!1}function Nh(a,b){do{try{le();Sc.current=Tc;if(Uc)for(var c=z.memoizedState;null!==c;){var d=c.queue;null!==d&&(d.pending=null);c=c.next}Ia=0;J=K=z=null;Uc=!1;if(null===t||null===t.return)return F=hd,id=b,t=null;a:{var e=a,f=t.return,g=t,h=b;b=P;g.effectTag|=2048;g.firstEffect=g.lastEffect=null;if(null!==h&&"object"===typeof h&&"function"===typeof h.then){var m=h;if(0===(g.mode&2)){var n=g.alternate;n?(g.updateQueue=n.updateQueue,g.memoizedState=
n.memoizedState,g.expirationTime=n.expirationTime):(g.updateQueue=null,g.memoizedState=null)}var l=0!==(D.current&1),k=f;do{var p;if(p=13===k.tag){var q=k.memoizedState;if(null!==q)p=null!==q.dehydrated?!0:!1;else{var w=k.memoizedProps;p=void 0===w.fallback?!1:!0!==w.unstable_avoidThisFallback?!0:l?!1:!0}}if(p){var y=k.updateQueue;if(null===y){var r=new Set;r.add(m);k.updateQueue=r}else y.add(m);if(0===(k.mode&2)){k.effectTag|=64;g.effectTag&=-2981;if(1===g.tag)if(null===g.alternate)g.tag=17;else{var O=
Ea(1073741823,null);O.tag=Jc;Fa(g,O)}g.expirationTime=1073741823;break a}h=void 0;g=b;var v=e.pingCache;null===v?(v=e.pingCache=new wj,h=new Set,v.set(m,h)):(h=v.get(m),void 0===h&&(h=new Set,v.set(m,h)));if(!h.has(g)){h.add(g);var x=xj.bind(null,e,m,g);m.then(x,x)}k.effectTag|=4096;k.expirationTime=b;break a}k=k.return}while(null!==k);h=Error((na(g.type)||"A React component")+" suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display."+
Bd(g))}F!==Xe&&(F=Oh);h=Le(h,g);k=f;do{switch(k.tag){case 3:m=h;k.effectTag|=4096;k.expirationTime=b;var A=Ih(k,m,b);Ug(k,A);break a;case 1:m=h;var u=k.type,B=k.stateNode;if(0===(k.effectTag&64)&&("function"===typeof u.getDerivedStateFromError||null!==B&&"function"===typeof B.componentDidCatch&&(null===La||!La.has(B)))){k.effectTag|=4096;k.expirationTime=b;var H=Jh(k,m,b);Ug(k,H);break a}}k=k.return}while(null!==k)}t=Sh(t)}catch(cj){b=cj;continue}break}while(1)}function Mh(a){a=gd.current;gd.current=
Tc;return null===a?Tc:a}function Vg(a,b){a<ta&&2<a&&(ta=a);null!==b&&a<Yb&&2<a&&(Yb=a,kd=b)}function Kc(a){a>Xb&&(Xb=a)}function tj(){for(;null!==t;)t=Th(t)}function rj(){for(;null!==t&&!yj();)t=Th(t)}function Th(a){var b=zj(a.alternate,a,P);a.memoizedProps=a.pendingProps;null===b&&(b=Sh(a));Uh.current=null;return b}function Sh(a){t=a;do{var b=t.alternate;a=t.return;if(0===(t.effectTag&2048)){b=hj(b,t,P);if(1===P||1!==t.childExpirationTime){for(var c=0,d=t.child;null!==d;){var e=d.expirationTime,
f=d.childExpirationTime;e>c&&(c=e);f>c&&(c=f);d=d.sibling}t.childExpirationTime=c}if(null!==b)return b;null!==a&&0===(a.effectTag&2048)&&(null===a.firstEffect&&(a.firstEffect=t.firstEffect),null!==t.lastEffect&&(null!==a.lastEffect&&(a.lastEffect.nextEffect=t.firstEffect),a.lastEffect=t.lastEffect),1<t.effectTag&&(null!==a.lastEffect?a.lastEffect.nextEffect=t:a.firstEffect=t,a.lastEffect=t))}else{b=lj(t);if(null!==b)return b.effectTag&=2047,b;null!==a&&(a.firstEffect=a.lastEffect=null,a.effectTag|=
2048)}b=t.sibling;if(null!==b)return b;t=a}while(null!==t);F===Xa&&(F=Xe);return null}function Ve(a){var b=a.expirationTime;a=a.childExpirationTime;return b>a?b:a}function ab(a){var b=Cc();Da(99,Aj.bind(null,a,b));return null}function Aj(a,b){do xb();while(null!==Zb);if((p&(ca|ma))!==H)throw Error(k(327));var c=a.finishedWork,d=a.finishedExpirationTime;if(null===c)return null;a.finishedWork=null;a.finishedExpirationTime=0;if(c===a.current)throw Error(k(177));a.callbackNode=null;a.callbackExpirationTime=
0;a.callbackPriority=90;a.nextKnownPendingLevel=0;var e=Ve(c);a.firstPendingTime=e;d<=a.lastSuspendedTime?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:d<=a.firstSuspendedTime&&(a.firstSuspendedTime=d-1);d<=a.lastPingedTime&&(a.lastPingedTime=0);d<=a.lastExpiredTime&&(a.lastExpiredTime=0);a===U&&(t=U=null,P=0);1<c.effectTag?null!==c.lastEffect?(c.lastEffect.nextEffect=c,e=c.firstEffect):e=c:e=c.firstEffect;if(null!==e){var f=p;p|=ma;Uh.current=null;Ze=tc;var g=kg();if(Xd(g)){if("selectionStart"in
g)var h={start:g.selectionStart,end:g.selectionEnd};else a:{h=(h=g.ownerDocument)&&h.defaultView||window;var m=h.getSelection&&h.getSelection();if(m&&0!==m.rangeCount){h=m.anchorNode;var n=m.anchorOffset,q=m.focusNode;m=m.focusOffset;try{h.nodeType,q.nodeType}catch(sb){h=null;break a}var ba=0,w=-1,y=-1,B=0,D=0,r=g,z=null;b:for(;;){for(var v;;){r!==h||0!==n&&3!==r.nodeType||(w=ba+n);r!==q||0!==m&&3!==r.nodeType||(y=ba+m);3===r.nodeType&&(ba+=r.nodeValue.length);if(null===(v=r.firstChild))break;z=r;
r=v}for(;;){if(r===g)break b;z===h&&++B===n&&(w=ba);z===q&&++D===m&&(y=ba);if(null!==(v=r.nextSibling))break;r=z;z=r.parentNode}r=v}h=-1===w||-1===y?null:{start:w,end:y}}else h=null}h=h||{start:0,end:0}}else h=null;$e={activeElementDetached:null,focusedElem:g,selectionRange:h};tc=!1;l=e;do try{Bj()}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=e;do try{for(g=a,h=b;null!==l;){var x=l.effectTag;x&16&&Wb(l.stateNode,"");if(x&128){var A=l.alternate;if(null!==A){var u=
A.ref;null!==u&&("function"===typeof u?u(null):u.current=null)}}switch(x&1038){case 2:Gh(l);l.effectTag&=-3;break;case 6:Gh(l);l.effectTag&=-3;Qe(l.alternate,l);break;case 1024:l.effectTag&=-1025;break;case 1028:l.effectTag&=-1025;Qe(l.alternate,l);break;case 4:Qe(l.alternate,l);break;case 8:n=l,Dh(g,n,h),Eh(n)}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);u=$e;A=kg();x=u.focusedElem;h=u.selectionRange;if(A!==x&&x&&x.ownerDocument&&jg(x.ownerDocument.documentElement,
x)){null!==h&&Xd(x)&&(A=h.start,u=h.end,void 0===u&&(u=A),"selectionStart"in x?(x.selectionStart=A,x.selectionEnd=Math.min(u,x.value.length)):(u=(A=x.ownerDocument||document)&&A.defaultView||window,u.getSelection&&(u=u.getSelection(),n=x.textContent.length,g=Math.min(h.start,n),h=void 0===h.end?g:Math.min(h.end,n),!u.extend&&g>h&&(n=h,h=g,g=n),n=ig(x,g),q=ig(x,h),n&&q&&(1!==u.rangeCount||u.anchorNode!==n.node||u.anchorOffset!==n.offset||u.focusNode!==q.node||u.focusOffset!==q.offset)&&(A=A.createRange(),
A.setStart(n.node,n.offset),u.removeAllRanges(),g>h?(u.addRange(A),u.extend(q.node,q.offset)):(A.setEnd(q.node,q.offset),u.addRange(A))))));A=[];for(u=x;u=u.parentNode;)1===u.nodeType&&A.push({element:u,left:u.scrollLeft,top:u.scrollTop});"function"===typeof x.focus&&x.focus();for(x=0;x<A.length;x++)u=A[x],u.element.scrollLeft=u.left,u.element.scrollTop=u.top}tc=!!Ze;$e=Ze=null;a.current=c;l=e;do try{for(x=a;null!==l;){var F=l.effectTag;F&36&&oj(x,l.alternate,l);if(F&128){A=void 0;var E=l.ref;if(null!==
E){var G=l.stateNode;switch(l.tag){case 5:A=G;break;default:A=G}"function"===typeof E?E(A):E.current=A}}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=null;Cj();p=f}else a.current=c;if(ld)ld=!1,Zb=a,$b=b;else for(l=e;null!==l;)b=l.nextEffect,l.nextEffect=null,l=b;b=a.firstPendingTime;0===b&&(La=null);1073741823===b?a===af?ac++:(ac=0,af=a):ac=0;"function"===typeof bf&&bf(c.stateNode,d);V(a);if(cd)throw cd=!1,a=Se,Se=null,a;if((p&Ye)!==H)return null;
ha();return null}function Bj(){for(;null!==l;){var a=l.effectTag;0!==(a&256)&&nj(l.alternate,l);0===(a&512)||ld||(ld=!0,Ng(97,function(){xb();return null}));l=l.nextEffect}}function xb(){if(90!==$b){var a=97<$b?97:$b;$b=90;return Da(a,Dj)}}function Dj(){if(null===Zb)return!1;var a=Zb;Zb=null;if((p&(ca|ma))!==H)throw Error(k(331));var b=p;p|=ma;for(a=a.current.firstEffect;null!==a;){try{var c=a;if(0!==(c.effectTag&512))switch(c.tag){case 0:case 11:case 15:case 22:Ah(5,c),Bh(5,c)}}catch(d){if(null===
a)throw Error(k(330));Za(a,d)}c=a.nextEffect;a.nextEffect=null;a=c}p=b;ha();return!0}function Vh(a,b,c){b=Le(c,b);b=Ih(a,b,1073741823);Fa(a,b);a=ed(a,1073741823);null!==a&&V(a)}function Za(a,b){if(3===a.tag)Vh(a,a,b);else for(var c=a.return;null!==c;){if(3===c.tag){Vh(c,a,b);break}else if(1===c.tag){var d=c.stateNode;if("function"===typeof c.type.getDerivedStateFromError||"function"===typeof d.componentDidCatch&&(null===La||!La.has(d))){a=Le(b,a);a=Jh(c,a,1073741823);Fa(c,a);c=ed(c,1073741823);null!==
c&&V(c);break}}c=c.return}}function xj(a,b,c){var d=a.pingCache;null!==d&&d.delete(b);U===a&&P===c?F===bd||F===ad&&1073741823===ta&&Y()-Re<Ph?$a(a,P):jd=!0:Kh(a,c)&&(b=a.lastPingedTime,0!==b&&b<c||(a.lastPingedTime=c,V(a)))}function qj(a,b){var c=a.stateNode;null!==c&&c.delete(b);b=0;0===b&&(b=ka(),b=Va(b,a,null));a=ed(a,b);null!==a&&V(a)}function Ej(a){if("undefined"===typeof __REACT_DEVTOOLS_GLOBAL_HOOK__)return!1;var b=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(b.isDisabled||!b.supportsFiber)return!0;try{var c=
b.inject(a);bf=function(a,e){try{b.onCommitFiberRoot(c,a,void 0,64===(a.current.effectTag&64))}catch(f){}};Ne=function(a){try{b.onCommitFiberUnmount(c,a)}catch(e){}}}catch(d){}return!0}function Fj(a,b,c,d){this.tag=a;this.key=c;this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null;this.index=0;this.ref=null;this.pendingProps=b;this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null;this.mode=d;this.effectTag=0;this.lastEffect=this.firstEffect=this.nextEffect=
null;this.childExpirationTime=this.expirationTime=0;this.alternate=null}function Ge(a){a=a.prototype;return!(!a||!a.isReactComponent)}function Gj(a){if("function"===typeof a)return Ge(a)?1:0;if(void 0!==a&&null!==a){a=a.$$typeof;if(a===zd)return 11;if(a===Ad)return 14}return 2}function Sa(a,b){var c=a.alternate;null===c?(c=la(a.tag,b,a.key,a.mode),c.elementType=a.elementType,c.type=a.type,c.stateNode=a.stateNode,c.alternate=a,a.alternate=c):(c.pendingProps=b,c.effectTag=0,c.nextEffect=null,c.firstEffect=
null,c.lastEffect=null);c.childExpirationTime=a.childExpirationTime;c.expirationTime=a.expirationTime;c.child=a.child;c.memoizedProps=a.memoizedProps;c.memoizedState=a.memoizedState;c.updateQueue=a.updateQueue;b=a.dependencies;c.dependencies=null===b?null:{expirationTime:b.expirationTime,firstContext:b.firstContext,responders:b.responders};c.sibling=a.sibling;c.index=a.index;c.ref=a.ref;return c}function Oc(a,b,c,d,e,f){var g=2;d=a;if("function"===typeof a)Ge(a)&&(g=1);else if("string"===typeof a)g=
5;else a:switch(a){case Ma:return Ha(c.children,e,f,b);case Hj:g=8;e|=7;break;case Af:g=8;e|=1;break;case kc:return a=la(12,c,b,e|8),a.elementType=kc,a.type=kc,a.expirationTime=f,a;case lc:return a=la(13,c,b,e),a.type=lc,a.elementType=lc,a.expirationTime=f,a;case yd:return a=la(19,c,b,e),a.elementType=yd,a.expirationTime=f,a;default:if("object"===typeof a&&null!==a)switch(a.$$typeof){case Cf:g=10;break a;case Bf:g=9;break a;case zd:g=11;break a;case Ad:g=14;break a;case Ef:g=16;d=null;break a;case Df:g=
22;break a}throw Error(k(130,null==a?a:typeof a,""));}b=la(g,c,b,e);b.elementType=a;b.type=d;b.expirationTime=f;return b}function Ha(a,b,c,d){a=la(7,a,d,b);a.expirationTime=c;return a}function qe(a,b,c){a=la(6,a,null,b);a.expirationTime=c;return a}function re(a,b,c){b=la(4,null!==a.children?a.children:[],a.key,b);b.expirationTime=c;b.stateNode={containerInfo:a.containerInfo,pendingChildren:null,implementation:a.implementation};return b}function Ij(a,b,c){this.tag=b;this.current=null;this.containerInfo=
a;this.pingCache=this.pendingChildren=null;this.finishedExpirationTime=0;this.finishedWork=null;this.timeoutHandle=-1;this.pendingContext=this.context=null;this.hydrate=c;this.callbackNode=null;this.callbackPriority=90;this.lastExpiredTime=this.lastPingedTime=this.nextKnownPendingLevel=this.lastSuspendedTime=this.firstSuspendedTime=this.firstPendingTime=0}function Kh(a,b){var c=a.firstSuspendedTime;a=a.lastSuspendedTime;return 0!==c&&c>=b&&a<=b}function Ya(a,b){var c=a.firstSuspendedTime,d=a.lastSuspendedTime;
c<b&&(a.firstSuspendedTime=b);if(d>b||0===c)a.lastSuspendedTime=b;b<=a.lastPingedTime&&(a.lastPingedTime=0);b<=a.lastExpiredTime&&(a.lastExpiredTime=0)}function yh(a,b){b>a.firstPendingTime&&(a.firstPendingTime=b);var c=a.firstSuspendedTime;0!==c&&(b>=c?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:b>=a.lastSuspendedTime&&(a.lastSuspendedTime=b+1),b>a.nextKnownPendingLevel&&(a.nextKnownPendingLevel=b))}function Ue(a,b){var c=a.lastExpiredTime;if(0===c||c>b)a.lastExpiredTime=b}
function md(a,b,c,d){var e=b.current,f=ka(),g=Vb.suspense;f=Va(f,e,g);a:if(c){c=c._reactInternalFiber;b:{if(Na(c)!==c||1!==c.tag)throw Error(k(170));var h=c;do{switch(h.tag){case 3:h=h.stateNode.context;break b;case 1:if(N(h.type)){h=h.stateNode.__reactInternalMemoizedMergedChildContext;break b}}h=h.return}while(null!==h);throw Error(k(171));}if(1===c.tag){var m=c.type;if(N(m)){c=Gg(c,m,h);break a}}c=h}else c=Ca;null===b.context?b.context=c:b.pendingContext=c;b=Ea(f,g);b.payload={element:a};d=void 0===
d?null:d;null!==d&&(b.callback=d);Fa(e,b);Ja(e,f);return f}function cf(a){a=a.current;if(!a.child)return null;switch(a.child.tag){case 5:return a.child.stateNode;default:return a.child.stateNode}}function Wh(a,b){a=a.memoizedState;null!==a&&null!==a.dehydrated&&a.retryTime<b&&(a.retryTime=b)}function df(a,b){Wh(a,b);(a=a.alternate)&&Wh(a,b)}function ef(a,b,c){c=null!=c&&!0===c.hydrate;var d=new Ij(a,b,c),e=la(3,null,null,2===b?7:1===b?3:0);d.current=e;e.stateNode=d;ne(e);a[Lb]=d.current;c&&0!==b&&
xi(a,9===a.nodeType?a:a.ownerDocument);this._internalRoot=d}function bc(a){return!(!a||1!==a.nodeType&&9!==a.nodeType&&11!==a.nodeType&&(8!==a.nodeType||" react-mount-point-unstable "!==a.nodeValue))}function Jj(a,b){b||(b=a?9===a.nodeType?a.documentElement:a.firstChild:null,b=!(!b||1!==b.nodeType||!b.hasAttribute("data-reactroot")));if(!b)for(var c;c=a.lastChild;)a.removeChild(c);return new ef(a,0,b?{hydrate:!0}:void 0)}function nd(a,b,c,d,e){var f=c._reactRootContainer;if(f){var g=f._internalRoot;
if("function"===typeof e){var h=e;e=function(){var a=cf(g);h.call(a)}}md(b,g,a,e)}else{f=c._reactRootContainer=Jj(c,d);g=f._internalRoot;if("function"===typeof e){var m=e;e=function(){var a=cf(g);m.call(a)}}Rh(function(){md(b,g,a,e)})}return cf(g)}function Kj(a,b,c){var d=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return{$$typeof:gb,key:null==d?null:""+d,children:a,containerInfo:b,implementation:c}}function Xh(a,b){var c=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null;
if(!bc(b))throw Error(k(200));return Kj(a,b,null,c)}if(!ea)throw Error(k(227));var ki=function(a,b,c,d,e,f,g,h,m){var n=Array.prototype.slice.call(arguments,3);try{b.apply(c,n)}catch(C){this.onError(C)}},yb=!1,gc=null,hc=!1,pd=null,li={onError:function(a){yb=!0;gc=a}},td=null,rf=null,mf=null,ic=null,cb={},jc=[],qd={},db={},rd={},wa=!("undefined"===typeof window||"undefined"===typeof window.document||"undefined"===typeof window.document.createElement),M=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.assign,
sd=null,eb=null,fb=null,ee=function(a,b){return a(b)},eg=function(a,b,c,d,e){return a(b,c,d,e)},vd=function(){},vf=ee,Oa=!1,wd=!1,Z=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.Scheduler,Lj=Z.unstable_cancelCallback,ff=Z.unstable_now,$f=Z.unstable_scheduleCallback,Mj=Z.unstable_shouldYield,Yh=Z.unstable_requestPaint,Pd=Z.unstable_runWithPriority,Nj=Z.unstable_getCurrentPriorityLevel,Oj=Z.unstable_ImmediatePriority,Zh=Z.unstable_UserBlockingPriority,ag=Z.unstable_NormalPriority,Pj=Z.unstable_LowPriority,
Qj=Z.unstable_IdlePriority,oi=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,wf=Object.prototype.hasOwnProperty,yf={},xf={},E={};"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a){E[a]=
new L(a,0,!1,a,null,!1)});[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach(function(a){var b=a[0];E[b]=new L(b,1,!1,a[1],null,!1)});["contentEditable","draggable","spellCheck","value"].forEach(function(a){E[a]=new L(a,2,!1,a.toLowerCase(),null,!1)});["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach(function(a){E[a]=new L(a,2,!1,a,null,!1)});"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a){E[a]=
new L(a,3,!1,a.toLowerCase(),null,!1)});["checked","multiple","muted","selected"].forEach(function(a){E[a]=new L(a,3,!0,a,null,!1)});["capture","download"].forEach(function(a){E[a]=new L(a,4,!1,a,null,!1)});["cols","rows","size","span"].forEach(function(a){E[a]=new L(a,6,!1,a,null,!1)});["rowSpan","start"].forEach(function(a){E[a]=new L(a,5,!1,a.toLowerCase(),null,!1)});var gf=/[\-:]([a-z])/g,hf=function(a){return a[1].toUpperCase()};"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a){var b=
a.replace(gf,hf);E[b]=new L(b,1,!1,a,null,!1)});"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/1999/xlink",!1)});["xml:base","xml:lang","xml:space"].forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/XML/1998/namespace",!1)});["tabIndex","crossOrigin"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!1)});E.xlinkHref=new L("xlinkHref",1,
!1,"xlink:href","http://www.w3.org/1999/xlink",!0);["src","href","action","formAction"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!0)});var da=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;da.hasOwnProperty("ReactCurrentDispatcher")||(da.ReactCurrentDispatcher={current:null});da.hasOwnProperty("ReactCurrentBatchConfig")||(da.ReactCurrentBatchConfig={suspense:null});var si=/^(.*)[\\\/]/,Q="function"===typeof Symbol&&Symbol.for,Pc=Q?Symbol.for("react.element"):60103,gb=Q?Symbol.for("react.portal"):
60106,Ma=Q?Symbol.for("react.fragment"):60107,Af=Q?Symbol.for("react.strict_mode"):60108,kc=Q?Symbol.for("react.profiler"):60114,Cf=Q?Symbol.for("react.provider"):60109,Bf=Q?Symbol.for("react.context"):60110,Hj=Q?Symbol.for("react.concurrent_mode"):60111,zd=Q?Symbol.for("react.forward_ref"):60112,lc=Q?Symbol.for("react.suspense"):60113,yd=Q?Symbol.for("react.suspense_list"):60120,Ad=Q?Symbol.for("react.memo"):60115,Ef=Q?Symbol.for("react.lazy"):60116,Df=Q?Symbol.for("react.block"):60121,zf="function"===
typeof Symbol&&Symbol.iterator,od,xh=function(a){return"undefined"!==typeof MSApp&&MSApp.execUnsafeLocalFunction?function(b,c,d,e){MSApp.execUnsafeLocalFunction(function(){return a(b,c,d,e)})}:a}(function(a,b){if("http://www.w3.org/2000/svg"!==a.namespaceURI||"innerHTML"in a)a.innerHTML=b;else{od=od||document.createElement("div");od.innerHTML="<svg>"+b.valueOf().toString()+"</svg>";for(b=od.firstChild;a.firstChild;)a.removeChild(a.firstChild);for(;b.firstChild;)a.appendChild(b.firstChild)}}),Wb=function(a,
b){if(b){var c=a.firstChild;if(c&&c===a.lastChild&&3===c.nodeType){c.nodeValue=b;return}}a.textContent=b},ib={animationend:nc("Animation","AnimationEnd"),animationiteration:nc("Animation","AnimationIteration"),animationstart:nc("Animation","AnimationStart"),transitionend:nc("Transition","TransitionEnd")},Id={},Of={};wa&&(Of=document.createElement("div").style,"AnimationEvent"in window||(delete ib.animationend.animation,delete ib.animationiteration.animation,delete ib.animationstart.animation),"TransitionEvent"in
window||delete ib.transitionend.transition);var $h=oc("animationend"),ai=oc("animationiteration"),bi=oc("animationstart"),ci=oc("transitionend"),Db="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),Pf=new ("function"===typeof WeakMap?WeakMap:Map),Ab=null,wi=function(a){if(a){var b=a._dispatchListeners,c=a._dispatchInstances;
if(Array.isArray(b))for(var d=0;d<b.length&&!a.isPropagationStopped();d++)lf(a,b[d],c[d]);else b&&lf(a,b,c);a._dispatchListeners=null;a._dispatchInstances=null;a.isPersistent()||a.constructor.release(a)}},qc=[],Rd=!1,fa=[],xa=null,ya=null,za=null,Eb=new Map,Fb=new Map,Jb=[],Nd="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput close cancel copy cut paste click change contextmenu reset submit".split(" "),
yi="focus blur dragenter dragleave mouseover mouseout pointerover pointerout gotpointercapture lostpointercapture".split(" "),dg={},cg=new Map,Td=new Map,Rj=["abort","abort",$h,"animationEnd",ai,"animationIteration",bi,"animationStart","canplay","canPlay","canplaythrough","canPlayThrough","durationchange","durationChange","emptied","emptied","encrypted","encrypted","ended","ended","error","error","gotpointercapture","gotPointerCapture","load","load","loadeddata","loadedData","loadedmetadata","loadedMetadata",
"loadstart","loadStart","lostpointercapture","lostPointerCapture","playing","playing","progress","progress","seeking","seeking","stalled","stalled","suspend","suspend","timeupdate","timeUpdate",ci,"transitionEnd","waiting","waiting"];Sd("blur blur cancel cancel click click close close contextmenu contextMenu copy copy cut cut auxclick auxClick dblclick doubleClick dragend dragEnd dragstart dragStart drop drop focus focus input input invalid invalid keydown keyDown keypress keyPress keyup keyUp mousedown mouseDown mouseup mouseUp paste paste pause pause play play pointercancel pointerCancel pointerdown pointerDown pointerup pointerUp ratechange rateChange reset reset seeked seeked submit submit touchcancel touchCancel touchend touchEnd touchstart touchStart volumechange volumeChange".split(" "),
0);Sd("drag drag dragenter dragEnter dragexit dragExit dragleave dragLeave dragover dragOver mousemove mouseMove mouseout mouseOut mouseover mouseOver pointermove pointerMove pointerout pointerOut pointerover pointerOver scroll scroll toggle toggle touchmove touchMove wheel wheel".split(" "),1);Sd(Rj,2);(function(a,b){for(var c=0;c<a.length;c++)Td.set(a[c],b)})("change selectionchange textInput compositionstart compositionend compositionupdate".split(" "),0);var Hi=Zh,Gi=Pd,tc=!0,Kb={animationIterationCount:!0,
borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,
strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},Sj=["Webkit","ms","Moz","O"];Object.keys(Kb).forEach(function(a){Sj.forEach(function(b){b=b+a.charAt(0).toUpperCase()+a.substring(1);Kb[b]=Kb[a]})});var Ii=M({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0}),ng="$",og="/$",$d="$?",Zd="$!",Ze=null,$e=null,We="function"===typeof setTimeout?setTimeout:void 0,vj="function"===
typeof clearTimeout?clearTimeout:void 0,jf=Math.random().toString(36).slice(2),Aa="__reactInternalInstance$"+jf,vc="__reactEventHandlers$"+jf,Lb="__reactContainere$"+jf,Ba=null,ce=null,wc=null;M(R.prototype,{preventDefault:function(){this.defaultPrevented=!0;var a=this.nativeEvent;a&&(a.preventDefault?a.preventDefault():"unknown"!==typeof a.returnValue&&(a.returnValue=!1),this.isDefaultPrevented=xc)},stopPropagation:function(){var a=this.nativeEvent;a&&(a.stopPropagation?a.stopPropagation():"unknown"!==
typeof a.cancelBubble&&(a.cancelBubble=!0),this.isPropagationStopped=xc)},persist:function(){this.isPersistent=xc},isPersistent:yc,destructor:function(){var a=this.constructor.Interface,b;for(b in a)this[b]=null;this.nativeEvent=this._targetInst=this.dispatchConfig=null;this.isPropagationStopped=this.isDefaultPrevented=yc;this._dispatchInstances=this._dispatchListeners=null}});R.Interface={type:null,target:null,currentTarget:function(){return null},eventPhase:null,bubbles:null,cancelable:null,timeStamp:function(a){return a.timeStamp||
Date.now()},defaultPrevented:null,isTrusted:null};R.extend=function(a){function b(){return c.apply(this,arguments)}var c=this,d=function(){};d.prototype=c.prototype;d=new d;M(d,b.prototype);b.prototype=d;b.prototype.constructor=b;b.Interface=M({},c.Interface,a);b.extend=c.extend;sg(b);return b};sg(R);var Tj=R.extend({data:null}),Uj=R.extend({data:null}),Ni=[9,13,27,32],de=wa&&"CompositionEvent"in window,cc=null;wa&&"documentMode"in document&&(cc=document.documentMode);var Vj=wa&&"TextEvent"in window&&
!cc,xg=wa&&(!de||cc&&8<cc&&11>=cc),wg=String.fromCharCode(32),ua={beforeInput:{phasedRegistrationNames:{bubbled:"onBeforeInput",captured:"onBeforeInputCapture"},dependencies:["compositionend","keypress","textInput","paste"]},compositionEnd:{phasedRegistrationNames:{bubbled:"onCompositionEnd",captured:"onCompositionEndCapture"},dependencies:"blur compositionend keydown keypress keyup mousedown".split(" ")},compositionStart:{phasedRegistrationNames:{bubbled:"onCompositionStart",captured:"onCompositionStartCapture"},
dependencies:"blur compositionstart keydown keypress keyup mousedown".split(" ")},compositionUpdate:{phasedRegistrationNames:{bubbled:"onCompositionUpdate",captured:"onCompositionUpdateCapture"},dependencies:"blur compositionupdate keydown keypress keyup mousedown".split(" ")}},vg=!1,mb=!1,Wj={eventTypes:ua,extractEvents:function(a,b,c,d,e){var f;if(de)b:{switch(a){case "compositionstart":var g=ua.compositionStart;break b;case "compositionend":g=ua.compositionEnd;break b;case "compositionupdate":g=
ua.compositionUpdate;break b}g=void 0}else mb?tg(a,c)&&(g=ua.compositionEnd):"keydown"===a&&229===c.keyCode&&(g=ua.compositionStart);g?(xg&&"ko"!==c.locale&&(mb||g!==ua.compositionStart?g===ua.compositionEnd&&mb&&(f=rg()):(Ba=d,ce="value"in Ba?Ba.value:Ba.textContent,mb=!0)),e=Tj.getPooled(g,b,c,d),f?e.data=f:(f=ug(c),null!==f&&(e.data=f)),lb(e),f=e):f=null;(a=Vj?Oi(a,c):Pi(a,c))?(b=Uj.getPooled(ua.beforeInput,b,c,d),b.data=a,lb(b)):b=null;return null===f?b:null===b?f:[f,b]}},Qi={color:!0,date:!0,
datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0},Ag={change:{phasedRegistrationNames:{bubbled:"onChange",captured:"onChangeCapture"},dependencies:"blur change click focus input keydown keyup selectionchange".split(" ")}},Mb=null,Nb=null,kf=!1;wa&&(kf=Tf("input")&&(!document.documentMode||9<document.documentMode));var Xj={eventTypes:Ag,_isInputEventSupported:kf,extractEvents:function(a,b,c,d,e){e=b?Pa(b):window;var f=
e.nodeName&&e.nodeName.toLowerCase();if("select"===f||"input"===f&&"file"===e.type)var g=Si;else if(yg(e))if(kf)g=Wi;else{g=Ui;var h=Ti}else(f=e.nodeName)&&"input"===f.toLowerCase()&&("checkbox"===e.type||"radio"===e.type)&&(g=Vi);if(g&&(g=g(a,b)))return zg(g,c,d);h&&h(a,e,b);"blur"===a&&(a=e._wrapperState)&&a.controlled&&"number"===e.type&&Ed(e,"number",e.value)}},dc=R.extend({view:null,detail:null}),Yi={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"},di=0,ei=0,fi=!1,gi=!1,ec=dc.extend({screenX:null,
screenY:null,clientX:null,clientY:null,pageX:null,pageY:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,getModifierState:fe,button:null,buttons:null,relatedTarget:function(a){return a.relatedTarget||(a.fromElement===a.srcElement?a.toElement:a.fromElement)},movementX:function(a){if("movementX"in a)return a.movementX;var b=di;di=a.screenX;return fi?"mousemove"===a.type?a.screenX-b:0:(fi=!0,0)},movementY:function(a){if("movementY"in a)return a.movementY;var b=ei;ei=a.screenY;return gi?"mousemove"===
a.type?a.screenY-b:0:(gi=!0,0)}}),hi=ec.extend({pointerId:null,width:null,height:null,pressure:null,tangentialPressure:null,tiltX:null,tiltY:null,twist:null,pointerType:null,isPrimary:null}),fc={mouseEnter:{registrationName:"onMouseEnter",dependencies:["mouseout","mouseover"]},mouseLeave:{registrationName:"onMouseLeave",dependencies:["mouseout","mouseover"]},pointerEnter:{registrationName:"onPointerEnter",dependencies:["pointerout","pointerover"]},pointerLeave:{registrationName:"onPointerLeave",dependencies:["pointerout",
"pointerover"]}},Yj={eventTypes:fc,extractEvents:function(a,b,c,d,e){var f="mouseover"===a||"pointerover"===a,g="mouseout"===a||"pointerout"===a;if(f&&0===(e&32)&&(c.relatedTarget||c.fromElement)||!g&&!f)return null;f=d.window===d?d:(f=d.ownerDocument)?f.defaultView||f.parentWindow:window;if(g){if(g=b,b=(b=c.relatedTarget||c.toElement)?Bb(b):null,null!==b){var h=Na(b);if(b!==h||5!==b.tag&&6!==b.tag)b=null}}else g=null;if(g===b)return null;if("mouseout"===a||"mouseover"===a){var m=ec;var n=fc.mouseLeave;
var l=fc.mouseEnter;var k="mouse"}else if("pointerout"===a||"pointerover"===a)m=hi,n=fc.pointerLeave,l=fc.pointerEnter,k="pointer";a=null==g?f:Pa(g);f=null==b?f:Pa(b);n=m.getPooled(n,g,c,d);n.type=k+"leave";n.target=a;n.relatedTarget=f;c=m.getPooled(l,b,c,d);c.type=k+"enter";c.target=f;c.relatedTarget=a;d=g;k=b;if(d&&k)a:{m=d;l=k;g=0;for(a=m;a;a=pa(a))g++;a=0;for(b=l;b;b=pa(b))a++;for(;0<g-a;)m=pa(m),g--;for(;0<a-g;)l=pa(l),a--;for(;g--;){if(m===l||m===l.alternate)break a;m=pa(m);l=pa(l)}m=null}else m=
null;l=m;for(m=[];d&&d!==l;){g=d.alternate;if(null!==g&&g===l)break;m.push(d);d=pa(d)}for(d=[];k&&k!==l;){g=k.alternate;if(null!==g&&g===l)break;d.push(k);k=pa(k)}for(k=0;k<m.length;k++)be(m[k],"bubbled",n);for(k=d.length;0<k--;)be(d[k],"captured",c);return 0===(e&64)?[n]:[n,c]}},Qa="function"===typeof Object.is?Object.is:Zi,$i=Object.prototype.hasOwnProperty,Zj=wa&&"documentMode"in document&&11>=document.documentMode,Eg={select:{phasedRegistrationNames:{bubbled:"onSelect",captured:"onSelectCapture"},
dependencies:"blur contextmenu dragend focus keydown keyup mousedown mouseup selectionchange".split(" ")}},nb=null,he=null,Pb=null,ge=!1,ak={eventTypes:Eg,extractEvents:function(a,b,c,d,e,f){e=f||(d.window===d?d.document:9===d.nodeType?d:d.ownerDocument);if(!(f=!e)){a:{e=Jd(e);f=rd.onSelect;for(var g=0;g<f.length;g++)if(!e.has(f[g])){e=!1;break a}e=!0}f=!e}if(f)return null;e=b?Pa(b):window;switch(a){case "focus":if(yg(e)||"true"===e.contentEditable)nb=e,he=b,Pb=null;break;case "blur":Pb=he=nb=null;
break;case "mousedown":ge=!0;break;case "contextmenu":case "mouseup":case "dragend":return ge=!1,Dg(c,d);case "selectionchange":if(Zj)break;case "keydown":case "keyup":return Dg(c,d)}return null}},bk=R.extend({animationName:null,elapsedTime:null,pseudoElement:null}),ck=R.extend({clipboardData:function(a){return"clipboardData"in a?a.clipboardData:window.clipboardData}}),dk=dc.extend({relatedTarget:null}),ek={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",
Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},fk={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",
224:"Meta"},gk=dc.extend({key:function(a){if(a.key){var b=ek[a.key]||a.key;if("Unidentified"!==b)return b}return"keypress"===a.type?(a=Ac(a),13===a?"Enter":String.fromCharCode(a)):"keydown"===a.type||"keyup"===a.type?fk[a.keyCode]||"Unidentified":""},location:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,repeat:null,locale:null,getModifierState:fe,charCode:function(a){return"keypress"===a.type?Ac(a):0},keyCode:function(a){return"keydown"===a.type||"keyup"===a.type?a.keyCode:0},which:function(a){return"keypress"===
a.type?Ac(a):"keydown"===a.type||"keyup"===a.type?a.keyCode:0}}),hk=ec.extend({dataTransfer:null}),ik=dc.extend({touches:null,targetTouches:null,changedTouches:null,altKey:null,metaKey:null,ctrlKey:null,shiftKey:null,getModifierState:fe}),jk=R.extend({propertyName:null,elapsedTime:null,pseudoElement:null}),kk=ec.extend({deltaX:function(a){return"deltaX"in a?a.deltaX:"wheelDeltaX"in a?-a.wheelDeltaX:0},deltaY:function(a){return"deltaY"in a?a.deltaY:"wheelDeltaY"in a?-a.wheelDeltaY:"wheelDelta"in a?
-a.wheelDelta:0},deltaZ:null,deltaMode:null}),lk={eventTypes:dg,extractEvents:function(a,b,c,d,e){e=cg.get(a);if(!e)return null;switch(a){case "keypress":if(0===Ac(c))return null;case "keydown":case "keyup":a=gk;break;case "blur":case "focus":a=dk;break;case "click":if(2===c.button)return null;case "auxclick":case "dblclick":case "mousedown":case "mousemove":case "mouseup":case "mouseout":case "mouseover":case "contextmenu":a=ec;break;case "drag":case "dragend":case "dragenter":case "dragexit":case "dragleave":case "dragover":case "dragstart":case "drop":a=
hk;break;case "touchcancel":case "touchend":case "touchmove":case "touchstart":a=ik;break;case $h:case ai:case bi:a=bk;break;case ci:a=jk;break;case "scroll":a=dc;break;case "wheel":a=kk;break;case "copy":case "cut":case "paste":a=ck;break;case "gotpointercapture":case "lostpointercapture":case "pointercancel":case "pointerdown":case "pointermove":case "pointerout":case "pointerover":case "pointerup":a=hi;break;default:a=R}b=a.getPooled(e,b,c,d);lb(b);return b}};(function(a){if(ic)throw Error(k(101));
ic=Array.prototype.slice.call(a);nf()})("ResponderEventPlugin SimpleEventPlugin EnterLeaveEventPlugin ChangeEventPlugin SelectEventPlugin BeforeInputEventPlugin".split(" "));(function(a,b,c){td=a;rf=b;mf=c})(ae,Hb,Pa);pf({SimpleEventPlugin:lk,EnterLeaveEventPlugin:Yj,ChangeEventPlugin:Xj,SelectEventPlugin:ak,BeforeInputEventPlugin:Wj});var ie=[],ob=-1,Ca={},B={current:Ca},G={current:!1},Ra=Ca,bj=Pd,je=$f,Rg=Lj,aj=Nj,Dc=Oj,Ig=Zh,Jg=ag,Kg=Pj,Lg=Qj,Qg={},yj=Mj,Cj=void 0!==Yh?Yh:function(){},qa=null,
Ec=null,ke=!1,ii=ff(),Y=1E4>ii?ff:function(){return ff()-ii},Ic={current:null},Hc=null,qb=null,Gc=null,Tg=0,Jc=2,Ga=!1,Vb=da.ReactCurrentBatchConfig,$g=(new ea.Component).refs,Mc={isMounted:function(a){return(a=a._reactInternalFiber)?Na(a)===a:!1},enqueueSetState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;d=Va(d,a,e);e=Ea(d,e);e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueReplaceState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;
d=Va(d,a,e);e=Ea(d,e);e.tag=1;e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueForceUpdate:function(a,b){a=a._reactInternalFiber;var c=ka(),d=Vb.suspense;c=Va(c,a,d);d=Ea(c,d);d.tag=Jc;void 0!==b&&null!==b&&(d.callback=b);Fa(a,d);Ja(a,c)}},Qc=Array.isArray,wb=ah(!0),Fe=ah(!1),Sb={},ja={current:Sb},Ub={current:Sb},Tb={current:Sb},D={current:0},Sc=da.ReactCurrentDispatcher,X=da.ReactCurrentBatchConfig,Ia=0,z=null,K=null,J=null,Uc=!1,Tc={readContext:W,useCallback:S,useContext:S,
useEffect:S,useImperativeHandle:S,useLayoutEffect:S,useMemo:S,useReducer:S,useRef:S,useState:S,useDebugValue:S,useResponder:S,useDeferredValue:S,useTransition:S},dj={readContext:W,useCallback:ih,useContext:W,useEffect:eh,useImperativeHandle:function(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;return ze(4,2,gh.bind(null,b,a),c)},useLayoutEffect:function(a,b){return ze(4,2,a,b)},useMemo:function(a,b){var c=ub();b=void 0===b?null:b;a=a();c.memoizedState=[a,b];return a},useReducer:function(a,b,c){var d=
ub();b=void 0!==c?c(b):b;d.memoizedState=d.baseState=b;a=d.queue={pending:null,dispatch:null,lastRenderedReducer:a,lastRenderedState:b};a=a.dispatch=ch.bind(null,z,a);return[d.memoizedState,a]},useRef:function(a){var b=ub();a={current:a};return b.memoizedState=a},useState:xe,useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=xe(a),d=c[0],e=c[1];eh(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=
xe(!1),c=b[0];b=b[1];return[ih(Ce.bind(null,b,a),[b,a]),c]}},ej={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Vc,useRef:dh,useState:function(a){return Vc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Vc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Vc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,
b,a),[b,a]),c]}},fj={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Wc,useRef:dh,useState:function(a){return Wc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Wc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Wc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,b,a),[b,a]),c]}},ra=null,Ka=null,Wa=
!1,gj=da.ReactCurrentOwner,ia=!1,Je={dehydrated:null,retryTime:0};var jj=function(a,b,c,d){for(c=b.child;null!==c;){if(5===c.tag||6===c.tag)a.appendChild(c.stateNode);else if(4!==c.tag&&null!==c.child){c.child.return=c;c=c.child;continue}if(c===b)break;for(;null===c.sibling;){if(null===c.return||c.return===b)return;c=c.return}c.sibling.return=c.return;c=c.sibling}};var wh=function(a){};var ij=function(a,b,c,d,e){var f=a.memoizedProps;if(f!==d){var g=b.stateNode;Ta(ja.current);a=null;switch(c){case "input":f=
Cd(g,f);d=Cd(g,d);a=[];break;case "option":f=Fd(g,f);d=Fd(g,d);a=[];break;case "select":f=M({},f,{value:void 0});d=M({},d,{value:void 0});a=[];break;case "textarea":f=Gd(g,f);d=Gd(g,d);a=[];break;default:"function"!==typeof f.onClick&&"function"===typeof d.onClick&&(g.onclick=uc)}Ud(c,d);var h,m;c=null;for(h in f)if(!d.hasOwnProperty(h)&&f.hasOwnProperty(h)&&null!=f[h])if("style"===h)for(m in g=f[h],g)g.hasOwnProperty(m)&&(c||(c={}),c[m]="");else"dangerouslySetInnerHTML"!==h&&"children"!==h&&"suppressContentEditableWarning"!==
h&&"suppressHydrationWarning"!==h&&"autoFocus"!==h&&(db.hasOwnProperty(h)?a||(a=[]):(a=a||[]).push(h,null));for(h in d){var k=d[h];g=null!=f?f[h]:void 0;if(d.hasOwnProperty(h)&&k!==g&&(null!=k||null!=g))if("style"===h)if(g){for(m in g)!g.hasOwnProperty(m)||k&&k.hasOwnProperty(m)||(c||(c={}),c[m]="");for(m in k)k.hasOwnProperty(m)&&g[m]!==k[m]&&(c||(c={}),c[m]=k[m])}else c||(a||(a=[]),a.push(h,c)),c=k;else"dangerouslySetInnerHTML"===h?(k=k?k.__html:void 0,g=g?g.__html:void 0,null!=k&&g!==k&&(a=a||
[]).push(h,k)):"children"===h?g===k||"string"!==typeof k&&"number"!==typeof k||(a=a||[]).push(h,""+k):"suppressContentEditableWarning"!==h&&"suppressHydrationWarning"!==h&&(db.hasOwnProperty(h)?(null!=k&&oa(e,h),a||g===k||(a=[])):(a=a||[]).push(h,k))}c&&(a=a||[]).push("style",c);e=a;if(b.updateQueue=e)b.effectTag|=4}};var kj=function(a,b,c,d){c!==d&&(b.effectTag|=4)};var pj="function"===typeof WeakSet?WeakSet:Set,wj="function"===typeof WeakMap?WeakMap:Map,sj=Math.ceil,gd=da.ReactCurrentDispatcher,
Uh=da.ReactCurrentOwner,H=0,Ye=8,ca=16,ma=32,Xa=0,hd=1,Oh=2,ad=3,bd=4,Xe=5,p=H,U=null,t=null,P=0,F=Xa,id=null,ta=1073741823,Yb=1073741823,kd=null,Xb=0,jd=!1,Re=0,Ph=500,l=null,cd=!1,Se=null,La=null,ld=!1,Zb=null,$b=90,bb=null,ac=0,af=null,dd=0,Ja=function(a,b){if(50<ac)throw ac=0,af=null,Error(k(185));a=ed(a,b);if(null!==a){var c=Cc();1073741823===b?(p&Ye)!==H&&(p&(ca|ma))===H?Te(a):(V(a),p===H&&ha()):V(a);(p&4)===H||98!==c&&99!==c||(null===bb?bb=new Map([[a,b]]):(c=bb.get(a),(void 0===c||c>b)&&bb.set(a,
b)))}};var zj=function(a,b,c){var d=b.expirationTime;if(null!==a){var e=b.pendingProps;if(a.memoizedProps!==e||G.current)ia=!0;else{if(d<c){ia=!1;switch(b.tag){case 3:sh(b);Ee();break;case 5:bh(b);if(b.mode&4&&1!==c&&e.hidden)return b.expirationTime=b.childExpirationTime=1,null;break;case 1:N(b.type)&&Bc(b);break;case 4:se(b,b.stateNode.containerInfo);break;case 10:d=b.memoizedProps.value;e=b.type._context;y(Ic,e._currentValue);e._currentValue=d;break;case 13:if(null!==b.memoizedState){d=b.child.childExpirationTime;
if(0!==d&&d>=c)return th(a,b,c);y(D,D.current&1);b=sa(a,b,c);return null!==b?b.sibling:null}y(D,D.current&1);break;case 19:d=b.childExpirationTime>=c;if(0!==(a.effectTag&64)){if(d)return vh(a,b,c);b.effectTag|=64}e=b.memoizedState;null!==e&&(e.rendering=null,e.tail=null);y(D,D.current);if(!d)return null}return sa(a,b,c)}ia=!1}}else ia=!1;b.expirationTime=0;switch(b.tag){case 2:d=b.type;null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;e=pb(b,B.current);rb(b,c);e=we(null,
b,d,a,e,c);b.effectTag|=1;if("object"===typeof e&&null!==e&&"function"===typeof e.render&&void 0===e.$$typeof){b.tag=1;b.memoizedState=null;b.updateQueue=null;if(N(d)){var f=!0;Bc(b)}else f=!1;b.memoizedState=null!==e.state&&void 0!==e.state?e.state:null;ne(b);var g=d.getDerivedStateFromProps;"function"===typeof g&&Lc(b,d,g,a);e.updater=Mc;b.stateNode=e;e._reactInternalFiber=b;pe(b,d,a,c);b=Ie(null,b,d,!0,f,c)}else b.tag=0,T(null,b,e,c),b=b.child;return b;case 16:a:{e=b.elementType;null!==a&&(a.alternate=
null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;ri(e);if(1!==e._status)throw e._result;e=e._result;b.type=e;f=b.tag=Gj(e);a=aa(e,a);switch(f){case 0:b=He(null,b,e,a,c);break a;case 1:b=rh(null,b,e,a,c);break a;case 11:b=nh(null,b,e,a,c);break a;case 14:b=oh(null,b,e,aa(e.type,a),d,c);break a}throw Error(k(306,e,""));}return b;case 0:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),He(a,b,d,e,c);case 1:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),rh(a,b,d,e,c);
case 3:sh(b);d=b.updateQueue;if(null===a||null===d)throw Error(k(282));d=b.pendingProps;e=b.memoizedState;e=null!==e?e.element:null;oe(a,b);Qb(b,d,null,c);d=b.memoizedState.element;if(d===e)Ee(),b=sa(a,b,c);else{if(e=b.stateNode.hydrate)Ka=kb(b.stateNode.containerInfo.firstChild),ra=b,e=Wa=!0;if(e)for(c=Fe(b,null,d,c),b.child=c;c;)c.effectTag=c.effectTag&-3|1024,c=c.sibling;else T(a,b,d,c),Ee();b=b.child}return b;case 5:return bh(b),null===a&&De(b),d=b.type,e=b.pendingProps,f=null!==a?a.memoizedProps:
null,g=e.children,Yd(d,e)?g=null:null!==f&&Yd(d,f)&&(b.effectTag|=16),qh(a,b),b.mode&4&&1!==c&&e.hidden?(b.expirationTime=b.childExpirationTime=1,b=null):(T(a,b,g,c),b=b.child),b;case 6:return null===a&&De(b),null;case 13:return th(a,b,c);case 4:return se(b,b.stateNode.containerInfo),d=b.pendingProps,null===a?b.child=wb(b,null,d,c):T(a,b,d,c),b.child;case 11:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),nh(a,b,d,e,c);case 7:return T(a,b,b.pendingProps,c),b.child;case 8:return T(a,
b,b.pendingProps.children,c),b.child;case 12:return T(a,b,b.pendingProps.children,c),b.child;case 10:a:{d=b.type._context;e=b.pendingProps;g=b.memoizedProps;f=e.value;var h=b.type._context;y(Ic,h._currentValue);h._currentValue=f;if(null!==g)if(h=g.value,f=Qa(h,f)?0:("function"===typeof d._calculateChangedBits?d._calculateChangedBits(h,f):1073741823)|0,0===f){if(g.children===e.children&&!G.current){b=sa(a,b,c);break a}}else for(h=b.child,null!==h&&(h.return=b);null!==h;){var m=h.dependencies;if(null!==
m){g=h.child;for(var l=m.firstContext;null!==l;){if(l.context===d&&0!==(l.observedBits&f)){1===h.tag&&(l=Ea(c,null),l.tag=Jc,Fa(h,l));h.expirationTime<c&&(h.expirationTime=c);l=h.alternate;null!==l&&l.expirationTime<c&&(l.expirationTime=c);Sg(h.return,c);m.expirationTime<c&&(m.expirationTime=c);break}l=l.next}}else g=10===h.tag?h.type===b.type?null:h.child:h.child;if(null!==g)g.return=h;else for(g=h;null!==g;){if(g===b){g=null;break}h=g.sibling;if(null!==h){h.return=g.return;g=h;break}g=g.return}h=
g}T(a,b,e.children,c);b=b.child}return b;case 9:return e=b.type,f=b.pendingProps,d=f.children,rb(b,c),e=W(e,f.unstable_observedBits),d=d(e),b.effectTag|=1,T(a,b,d,c),b.child;case 14:return e=b.type,f=aa(e,b.pendingProps),f=aa(e.type,f),oh(a,b,e,f,d,c);case 15:return ph(a,b,b.type,b.pendingProps,d,c);case 17:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),b.tag=1,N(d)?(a=!0,Bc(b)):a=!1,rb(b,c),Yg(b,d,e),pe(b,d,e,c),Ie(null,
b,d,!0,a,c);case 19:return vh(a,b,c)}throw Error(k(156,b.tag));};var bf=null,Ne=null,la=function(a,b,c,d){return new Fj(a,b,c,d)};ef.prototype.render=function(a){md(a,this._internalRoot,null,null)};ef.prototype.unmount=function(){var a=this._internalRoot,b=a.containerInfo;md(null,a,null,function(){b[Lb]=null})};var Di=function(a){if(13===a.tag){var b=Fc(ka(),150,100);Ja(a,b);df(a,b)}};var Yf=function(a){13===a.tag&&(Ja(a,3),df(a,3))};var Bi=function(a){if(13===a.tag){var b=ka();b=Va(b,a,null);Ja(a,
b);df(a,b)}};sd=function(a,b,c){switch(b){case "input":Dd(a,c);b=c.name;if("radio"===c.type&&null!=b){for(c=a;c.parentNode;)c=c.parentNode;c=c.querySelectorAll("input[name="+JSON.stringify(""+b)+'][type="radio"]');for(b=0;b<c.length;b++){var d=c[b];if(d!==a&&d.form===a.form){var e=ae(d);if(!e)throw Error(k(90));Gf(d);Dd(d,e)}}}break;case "textarea":Lf(a,c);break;case "select":b=c.value,null!=b&&hb(a,!!c.multiple,b,!1)}};(function(a,b,c,d){ee=a;eg=b;vd=c;vf=d})(Qh,function(a,b,c,d,e){var f=p;p|=4;
try{return Da(98,a.bind(null,b,c,d,e))}finally{p=f,p===H&&ha()}},function(){(p&(1|ca|ma))===H&&(uj(),xb())},function(a,b){var c=p;p|=2;try{return a(b)}finally{p=c,p===H&&ha()}});var mk={Events:[Hb,Pa,ae,pf,qd,lb,function(a){Kd(a,Ki)},sf,tf,sc,pc,xb,{current:!1}]};(function(a){var b=a.findFiberByHostInstance;return Ej(M({},a,{overrideHookState:null,overrideProps:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:da.ReactCurrentDispatcher,findHostInstanceByFiber:function(a){a=Sf(a);
return null===a?null:a.stateNode},findFiberByHostInstance:function(a){return b?b(a):null},findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null}))})({findFiberByHostInstance:Bb,bundleType:0,version:"16.13.1",rendererPackageName:"react-dom"});I.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=mk;I.createPortal=Xh;I.findDOMNode=function(a){if(null==a)return null;if(1===a.nodeType)return a;var b=a._reactInternalFiber;if(void 0===
b){if("function"===typeof a.render)throw Error(k(188));throw Error(k(268,Object.keys(a)));}a=Sf(b);a=null===a?null:a.stateNode;return a};I.flushSync=function(a,b){if((p&(ca|ma))!==H)throw Error(k(187));var c=p;p|=1;try{return Da(99,a.bind(null,b))}finally{p=c,ha()}};I.hydrate=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!0,c)};I.render=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!1,c)};I.unmountComponentAtNode=function(a){if(!bc(a))throw Error(k(40));return a._reactRootContainer?
(Rh(function(){nd(null,null,a,!1,function(){a._reactRootContainer=null;a[Lb]=null})}),!0):!1};I.unstable_batchedUpdates=Qh;I.unstable_createPortal=function(a,b){return Xh(a,b,2<arguments.length&&void 0!==arguments[2]?arguments[2]:null)};I.unstable_renderSubtreeIntoContainer=function(a,b,c,d){if(!bc(c))throw Error(k(200));if(null==a||void 0===a._reactInternalFiber)throw Error(k(38));return nd(a,b,c,!1,d)};I.version="16.13.1"});
</script>
    <script>const e = React.createElement;

function pathToString(path) {
  if (path[0] === '/') {
    return '/' + path.slice(1).join('/');
  } else {
    return path.join('/');
  }
}

function findCommonPath(files) {
  if (!files || !files.length) {
    return [];
  }

  function isPrefix(arr, prefix) {
    if (arr.length < prefix.length) {
      return false;
    }
    for (let i = prefix.length - 1; i >= 0; --i) {
      if (arr[i] !== prefix[i]) {
        return false;
      }
    }
    return true;
  }

  let commonPath = files[0].path.slice(0, -1);
  while (commonPath.length) {
    if (files.every(file => isPrefix(file.path, commonPath))) {
      break;
    }
    commonPath.pop();
  }
  return commonPath;
}

function findFolders(files) {
  if (!files || !files.length) {
    return [];
  }

  let folders = files.filter(file => file.path.length > 1).map(file => file.path[0]);
  folders = [...new Set(folders)]; // unique
  folders.sort();

  folders = folders.map(folder => {
    let filesInFolder = files
      .filter(file => file.path[0] === folder)
      .map(file => ({
        ...file,
        path: file.path.slice(1),
        parent: [...file.parent, file.path[0]],
      }));

    const children = findFolders(filesInFolder); // recursion

    return {
      is_folder: true,
      path: [folder],
      parent: files[0].parent,
      children,
      covered: children.reduce((sum, file) => sum + file.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.coverable, 0),
      prevRun: {
        covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
        coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
      }
    };
  });

  return [
    ...folders,
    ...files.filter(file => file.path.length === 1),
  ];
}

class App extends React.Component {
  constructor(...args) {
    super(...args);

    this.state = {
      current: [],
    };
  }

  componentDidMount() {
    this.updateStateFromLocation();
    window.addEventListener("hashchange", () => this.updateStateFromLocation(), false);
  }

  updateStateFromLocation() {
    if (window.location.hash.length > 1) {
      const current = window.location.hash.substr(1).split('/');
      this.setState({current});
    } else {
      this.setState({current: []});
    }
  }

  getCurrentPath() {
    let file = this.props.root;
    let path = [file];
    for (let p of this.state.current) {
      file = file.children.find(file => file.path[0] === p);
      if (!file) {
        return path;
      }
      path.push(file);
    }
    return path;
  }

  render() {
    const path = this.getCurrentPath();
    const file = path[path.length - 1];

    let w = null;
    if (file.is_folder) {
      w = e(FilesList, {
        folder: file,
        onSelectFile: this.selectFile.bind(this),
        onBack: path.length > 1 ? this.back.bind(this) : null,
      });
    } else {
      w = e(DisplayFile, {
        file,
        onBack: this.back.bind(this),
      });
    }

    return e('div', {className: 'app'}, w);
  }

  selectFile(file) {
    this.setState(({current}) => {
      return {current: [...current, file.path[0]]};
    }, () => this.updateHash());
  }

  back(file) {
    this.setState(({current}) => {
      return {current: current.slice(0, current.length - 1)};
    }, () => this.updateHash());
  }

  updateHash() {
    if (!this.state.current || !this.state.current.length) {
      window.location = '#';
    } else {
      window.location = '#' + this.state.current.join('/');
    }
  }
}

function FilesList({folder, onSelectFile, onBack}) {
  let files = folder.children;
  return e('div', {className: 'display-folder'},
    e(FileHeader, {file: folder, onBack}),
    e('table', {className: 'files-list'},
      e('thead', {className: 'files-list__head'},
        e('tr', null,
          e('th', null, "Path"),
          e('th', null, "Coverage")
        )
      ),
      e('tbody', {className: 'files-list__body'},
        files.map(file => e(File, {file, onClick: onSelectFile}))
      )
    )
  );
}

function File({file, onClick}) {
  const coverage = file.coverable ? file.covered / file.coverable * 100 : -1;
  const coverageDelta = file.prevRun &&
    (file.covered / file.coverable * 100 - file.prevRun.covered / file.prevRun.coverable * 100);

  return e('tr', {
      className: 'files-list__file'
        + (coverage >= 0 && coverage < 50 ? ' files-list__file_low': '')
        + (coverage >= 50 && coverage < 80 ? ' files-list__file_medium': '')
        + (coverage >= 80 ? ' files-list__file_high': '')
        + (file.is_folder ? ' files-list__file_folder': ''),
      onClick: () => onClick(file),
    },
    e('td', null, pathToString(file.path)),
    e('td', null,
      file.covered + ' / ' + file.coverable +
      (coverage >= 0 ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e('span', {title: 'Change from the previous run'},
        (coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : ''))
    )
  );
}

function DisplayFile({file, onBack}) {
  return e('div', {className: 'display-file'},
    e(FileHeader, {file, onBack}),
    e(FileContent, {file})
  );
}

function FileHeader({file, onBack}) {
  const coverage = file.covered / file.coverable * 100;
  const coverageDelta = file.prevRun && (coverage - file.prevRun.covered / file.prevRun.coverable * 100);

  return e('div', {className: 'file-header'},
    onBack ? e('a', {className: 'file-header__back', onClick: onBack}, 'Back') : null,
    e('div', {className: 'file-header__name'}, pathToString([...file.parent, ...file.path])),
    e('div', {className: 'file-header__stat'},
      'Covered: ' + file.covered + ' of ' + file.coverable +
      (file.coverable ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e('span', {title: 'Change from the previous run'},
        (coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : ''))
    )
  );
}

function FileContent({file}) {
  return e('div', {className: 'file-content'},
    file.content.split(/\r?\n/).map((line, index) => {
      const trace = file.traces.find(trace => trace.line === index + 1);
      const covered = trace && trace.stats.Line;
      const uncovered = trace && !trace.stats.Line;
      return e('pre', {
          className: 'code-line'
            + (covered ? ' code-line_covered' : '')
            + (uncovered ? ' code-line_uncovered' : ''),
          title: trace ? JSON.stringify(trace.stats, null, 2) : null,
        }, line);
    })
  );
}

(function(){
  const commonPath = findCommonPath(data.files);
  const prevFilesMap = new Map();

  previousData && previousData.files.forEach((file) => {
    const path = file.path.slice(commonPath.length).join('/');
    prevFilesMap.set(path, file);
  });

  const files = data.files.map((file) => {
    const path = file.path.slice(commonPath.length);
    const { covered = 0, coverable = 0 } = prevFilesMap.get(path.join('/')) || {};
    return {
      ...file,
      path,
      parent: commonPath,
      prevRun: { covered, coverable },
    };
  });

  const children = findFolders(files);

  const root = {
    is_folder: true,
    children,
    path: commonPath,
    parent: [],
    covered: children.reduce((sum, file) => sum + file.covered, 0),
    coverable: children.reduce((sum, file) => sum + file.coverable, 0),
    prevRun: {
      covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
    }
  };

  ReactDOM.render(e(App, {root, prevFilesMap}), document.getElementById('root'));
}());
</script>
</body>
</html>